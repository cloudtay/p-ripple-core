{
  "$schema": "https://raw.githubusercontent.com/schemastore/schemastore/master/src/schemas/json/sarif-2.1.0-rtm.5.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "IU",
          "fullName": "Qodana",
          "version": "241.17890.1",
          "rules": [],
          "taxa": [
            {
              "id": "JVM 语言",
              "name": "JVM 语言"
            },
            {
              "id": "PHP",
              "name": "PHP"
            },
            {
              "id": "PHP/PHPDoc",
              "name": "PHPDoc",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java",
              "name": "Java"
            },
            {
              "id": "Java/国际化",
              "name": "国际化",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/性能",
              "name": "性能",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/代码样式问题",
              "name": "代码样式问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/声明冗余",
              "name": "声明冗余",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/错误处理",
              "name": "错误处理",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/代码样式",
              "name": "代码样式",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/常规",
              "name": "常规",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/类结构",
              "name": "类结构",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/序列化问题",
              "name": "序列化问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/导入",
              "name": "导入",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "MySQL",
              "name": "MySQL"
            },
            {
              "id": "PHP/命名约定",
              "name": "命名约定",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/线程问题",
              "name": "线程问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数值问题",
              "name": "数值问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/控制流问题",
              "name": "控制流问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/代码异味",
              "name": "代码异味",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/PHPDoc/代码样式",
              "name": "代码样式",
              "relationships": [
                {
                  "target": {
                    "id": "PHP/PHPDoc",
                    "index": 2,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/控制流",
              "name": "控制流",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/初始化",
              "name": "初始化",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Sass_SCSS",
              "name": "Sass/SCSS"
            },
            {
              "id": "HTML",
              "name": "HTML"
            },
            {
              "id": "JavaScript 和 TypeScript",
              "name": "JavaScript 和 TypeScript"
            },
            {
              "id": "JavaScript 和 TypeScript/未使用的符号",
              "name": "未使用的符号",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/Flow 类型检查器",
              "name": "Flow 类型检查器",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/安全性",
              "name": "安全性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PostCSS",
              "name": "PostCSS"
            },
            {
              "id": "JavaScript 和 TypeScript/按位运算问题",
              "name": "按位运算问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/常规",
              "name": "常规",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/未定义的符号",
              "name": "未定义的符号",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Reactive Streams",
              "name": "Reactive Streams"
            },
            {
              "id": "Reactive Streams/通用",
              "name": "通用",
              "relationships": [
                {
                  "target": {
                    "id": "Reactive Streams",
                    "index": 34,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/打包问题",
              "name": "打包问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/详细或冗余的代码结构",
              "name": "详细或冗余的代码结构",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "常规",
              "name": "常规"
            },
            {
              "id": "FreeMarker",
              "name": "FreeMarker"
            },
            {
              "id": "JVM 语言/日志记录",
              "name": "日志记录",
              "relationships": [
                {
                  "target": {
                    "id": "JVM 语言",
                    "index": 0,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "EditorConfig",
              "name": "EditorConfig"
            },
            {
              "id": "JavaScript 和 TypeScript/有效性问题",
              "name": "有效性问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/代码成熟度",
              "name": "代码成熟度",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
              "name": "可能引起混淆的代码结构",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "SQL",
              "name": "SQL"
            },
            {
              "id": "PHP/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/Try 语句问题",
              "name": "Try 语句问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数据流",
              "name": "数据流",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/类型兼容性",
              "name": "类型兼容性",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Velocity",
              "name": "Velocity"
            },
            {
              "id": "Java/Java 语言级迁移帮助",
              "name": "Java 语言级迁移帮助",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "CSS",
              "name": "CSS"
            },
            {
              "id": "CSS/无效元素",
              "name": "无效元素",
              "relationships": [
                {
                  "target": {
                    "id": "CSS",
                    "index": 52,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/Composer",
              "name": "Composer",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
              "name": "可能不合需要的代码结构",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/完成",
              "name": "完成",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/记录",
              "name": "记录",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/模块化问题",
              "name": "模块化问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Javadoc",
              "name": "Javadoc",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名约定",
              "name": "命名约定",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名约定/类",
              "name": "类",
              "relationships": [
                {
                  "target": {
                    "id": "Java/命名约定",
                    "index": 60,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Kubernetes",
              "name": "Kubernetes"
            },
            {
              "id": "Java/抽象问题",
              "name": "抽象问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "属性文件",
              "name": "属性文件"
            },
            {
              "id": "Java/赋值问题",
              "name": "赋值问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助",
              "name": "Java 语言级别迁移帮助",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 9",
              "name": "Java 9",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/特性",
              "name": "特性",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/JUnit",
              "name": "JUnit",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/未使用的符号",
              "name": "未使用的符号",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Dockerfile",
              "name": "Dockerfile"
            },
            {
              "id": "Java/可移植性",
              "name": "可移植性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/赋值问题",
              "name": "赋值问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/可见性",
              "name": "可见性",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "正则表达式",
              "name": "正则表达式"
            },
            {
              "id": "Java/并发注解问题",
              "name": "并发注解问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "CSS/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "CSS",
                    "index": 52,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/TypeScript",
              "name": "TypeScript",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Lombok",
              "name": "Lombok",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Lombok/冗余修饰符",
              "name": "冗余修饰符",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Lombok",
                    "index": 79,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "DotEnv",
              "name": "DotEnv"
            },
            {
              "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
              "name": "ES2015 迁移协助",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/命名约定/方法",
              "name": "方法",
              "relationships": [
                {
                  "target": {
                    "id": "Java/命名约定",
                    "index": 60,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/DOM 问题",
              "name": "DOM 问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/可能的 bug",
              "name": "可能的 bug",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "校对",
              "name": "校对"
            },
            {
              "id": "PHP/Annotation",
              "name": "Annotation",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "XML",
              "name": "XML"
            },
            {
              "id": "Java/克隆问题",
              "name": "克隆问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "清单",
              "name": "清单"
            },
            {
              "id": "Markdown",
              "name": "Markdown"
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 5",
              "name": "Java 5",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 8",
              "name": "Java 8",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JVM 语言/测试框架",
              "name": "测试框架",
              "relationships": [
                {
                  "target": {
                    "id": "JVM 语言",
                    "index": 0,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/类指标",
              "name": "类指标",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/封装",
              "name": "封装",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/控制流问题",
              "name": "控制流问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/测试框架",
              "name": "测试框架",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/反射访问",
              "name": "反射访问",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/PHPUnit",
              "name": "PHPUnit",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "代码覆盖率",
              "name": "代码覆盖率"
            },
            {
              "id": "JavaScript 和 TypeScript/代码质量工具",
              "name": "代码质量工具",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 15",
              "name": "Java 15",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/方法指标",
              "name": "方法指标",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Blade 文件",
              "name": "Blade 文件"
            },
            {
              "id": "Java/资源管理",
              "name": "资源管理",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/switch 语句问题",
              "name": "switch 语句问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 14",
              "name": "Java 14",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/数值问题/转换",
              "name": "转换",
              "relationships": [
                {
                  "target": {
                    "id": "Java/数值问题",
                    "index": 18,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/JavaBeans 问题",
              "name": "JavaBeans 问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/函数指标",
              "name": "函数指标",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/代码样式问题",
              "name": "代码样式问题",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/依赖性问题",
              "name": "依赖性问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级问题",
              "name": "Java 语言级问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JSON 和 JSON5",
              "name": "JSON 和 JSON5"
            },
            {
              "id": "PHP/正则表达式",
              "name": "正则表达式",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/继承问题",
              "name": "继承问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "安全性",
              "name": "安全性"
            },
            {
              "id": "JavaScript and TypeScript",
              "name": "JavaScript and TypeScript"
            },
            {
              "id": "JavaScript and TypeScript/安全性",
              "name": "安全性",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript and TypeScript",
                    "index": 119,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/PHP 严格标准",
              "name": "PHP 严格标准",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Reactive Streams/Reactor",
              "name": "Reactor",
              "relationships": [
                {
                  "target": {
                    "id": "Reactive Streams",
                    "index": 34,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Oracle",
              "name": "Oracle"
            },
            {
              "id": "国际化",
              "name": "国际化"
            },
            {
              "id": "Vue",
              "name": "Vue"
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 10",
              "name": "Java 10",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 7",
              "name": "Java 7",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/编译器问题",
              "name": "编译器问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "版本控制",
              "name": "版本控制"
            },
            {
              "id": "MongoJS",
              "name": "MongoJS"
            },
            {
              "id": "Java/内存",
              "name": "内存",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/单元测试",
              "name": "单元测试",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/Code style",
              "name": "Code style",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/Code style/PSR-12",
              "name": "PSR-12",
              "relationships": [
                {
                  "target": {
                    "id": "PHP/Code style",
                    "index": 133,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/Database",
              "name": "Database",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Docker-compose",
              "name": "Docker-compose"
            },
            {
              "id": "结构搜索",
              "name": "结构搜索"
            },
            {
              "id": "YAML",
              "name": "YAML"
            },
            {
              "id": "Java/性能/嵌入式",
              "name": "嵌入式",
              "relationships": [
                {
                  "target": {
                    "id": "Java/性能",
                    "index": 5,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/Import 和依赖项",
              "name": "Import 和依赖项",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/可能的 bug/为 null 性问题",
              "name": "为 null 性问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java/可能的 bug",
                    "index": 10,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "RELAX NG",
              "name": "RELAX NG"
            },
            {
              "id": "Laravel Idea",
              "name": "Laravel Idea"
            },
            {
              "id": "PHP/错误处理",
              "name": "错误处理",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 11",
              "name": "Java 11",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PostgreSQL",
              "name": "PostgreSQL"
            },
            {
              "id": "SQL Server",
              "name": "SQL Server"
            },
            {
              "id": "JavaScript 和 TypeScript/Async 代码和 promise",
              "name": "Async 代码和 promise",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/命名约定",
              "name": "命名约定",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Qodana",
              "name": "Qodana"
            },
            {
              "id": "PHP/Symfony",
              "name": "Symfony",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/质量工具",
              "name": "质量工具",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 16",
              "name": "Java 16",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Shell 脚本",
              "name": "Shell 脚本"
            },
            {
              "id": "JavaScript 和 TypeScript/数据流",
              "name": "数据流",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "JavaScript 和 TypeScript/React",
              "name": "React",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Lombok/冗余定义",
              "name": "冗余定义",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Lombok",
                    "index": 79,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "CSS/代码样式问题",
              "name": "代码样式问题",
              "relationships": [
                {
                  "target": {
                    "id": "CSS",
                    "index": 52,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/Java 语言级别迁移帮助/Java 21",
              "name": "Java 21",
              "relationships": [
                {
                  "target": {
                    "id": "Java/Java 语言级别迁移帮助",
                    "index": 66,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Less",
              "name": "Less"
            },
            {
              "id": "Reactive Streams/Mutiny",
              "name": "Mutiny",
              "relationships": [
                {
                  "target": {
                    "id": "Reactive Streams",
                    "index": 34,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/按位运算问题",
              "name": "按位运算问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "协议缓冲区",
              "name": "协议缓冲区"
            },
            {
              "id": "JavaScript 和 TypeScript/Node.js",
              "name": "Node.js",
              "relationships": [
                {
                  "target": {
                    "id": "JavaScript 和 TypeScript",
                    "index": 26,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "Java/toString() 问题",
              "name": "toString() 问题",
              "relationships": [
                {
                  "target": {
                    "id": "Java",
                    "index": 3,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "PHP/可替换赋值",
              "name": "可替换赋值",
              "relationships": [
                {
                  "target": {
                    "id": "PHP",
                    "index": 1,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            },
            {
              "id": "CSS/代码质量工具",
              "name": "代码质量工具",
              "relationships": [
                {
                  "target": {
                    "id": "CSS",
                    "index": 52,
                    "toolComponent": {
                      "name": "IU"
                    }
                  },
                  "kinds": [
                    "superset"
                  ]
                }
              ]
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        },
        "extensions": [
          {
            "name": "com.intellij.java",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "OverrideOnly",
                "shortDescription": {
                  "text": "方法只能重写"
                },
                "fullDescription": {
                  "text": "报告对使用 '@ApiStatus.OverrideOnly' 标记的 API 方法的调用。 '@ApiStatus.OverrideOnly' 注解表示该方法是 SPI（服务提供程序接口）的一部分。 声明库的客户端应实现或重写此类方法，而不是直接调用。 使用此注解标记类或接口与使用它标记每个方法相同。",
                  "markdown": "报告对使用 `@ApiStatus.OverrideOnly` 标记的 API 方法的调用。\n\n\n`@ApiStatus.OverrideOnly` 注解表示该方法是 SPI（服务提供程序接口）的一部分。\n声明库的客户端应实现或重写此类方法，而不是直接调用。\n使用此注解标记类或接口与使用它标记每个方法相同。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverrideOnly",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSuspiciousStringMethod",
                "shortDescription": {
                  "text": "调用可疑的 'String' 方法"
                },
                "fullDescription": {
                  "text": "报告对以下各项的调用： 'equals()' 'equalsIgnoreCase()' 'compareTo()' 'compareToIgnoreCase()' 和 'trim()' （发生在 'String' 对象上）。 国际化字符串的比较可能应改用 'java.text.Collator'。 'String.trim()' 只会移除 0x00 和 0x20 之间的控制字符。 Java 11 中引入的 'String.strip()' 方法对 Unicode 的感知更好，可以作为替代。",
                  "markdown": "报告对以下各项的调用：\n\n* `equals()`\n* `equalsIgnoreCase()`\n* `compareTo()`\n* `compareToIgnoreCase()` 和\n* `trim()`\n\n\n（发生在 `String` 对象上）。\n国际化字符串的比较可能应改用 `java.text.Collator`。\n`String.trim()` 只会移除 0x00 和 0x20 之间的控制字符。\nJava 11 中引入的 `String.strip()` 方法对 Unicode 的感知更好，可以作为替代。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSuspiciousStringMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KeySetIterationMayUseEntrySet",
                "shortDescription": {
                  "text": "可以优化对 'keySet()' 的迭代"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Map' 实例的 'keySet()' 的迭代，其中迭代的键用于从映射中检索值。 替换为 'entrySet()' 或 'values()' 的迭代时，此类迭代可能会更有效（如果实际上没有使用键）。 同理，如果在 lambda 中检索值，则 'keySet().forEach(key -> ...)' 可以替换为 'forEach((key, value) -> ...)'。 示例： 'for (Object key : map.keySet()) {\n   Object val = map.get(key);\n  }' 在应用快速修复后： 'for (Object val : map.values()) {}'",
                  "markdown": "报告对 `java.util.Map` 实例的 `keySet()` 的迭代，其中迭代的键用于从映射中检索值。\n\n\n替换为 `entrySet()` 或 `values()` 的迭代时，此类迭代可能会更有效（如果实际上没有使用键）。\n\n\n同理，如果在 lambda 中检索值，则 `keySet().forEach(key -> ...)` 可以替换为 `forEach((key, value) -> ...)`。\n\n**示例：**\n\n\n      for (Object key : map.keySet()) {\n       Object val = map.get(key);\n      }\n\n在应用快速修复后：\n\n\n      for (Object val : map.values()) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KeySetIterationMayUseEntrySet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryQualifierForThis",
                "shortDescription": {
                  "text": "'this' 或 'super' 的限定符不必要"
                },
                "fullDescription": {
                  "text": "报告不必要的 'this' 或 'super' 限定。 在 'this' 或 'super' 上使用限定符来消除代码引用的歧义可能很容易通过自动重构变得不必要，为了清楚起见应该删除。 示例： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      Bar.super.foo();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      super.foo();\n    }\n  }'",
                  "markdown": "报告不必要的 `this` 或 `super` 限定。\n\n\n在 `this` 或 `super` 上使用限定符来消除代码引用的歧义可能很容易通过自动重构变得不必要，为了清楚起见应该删除。\n\n**示例：**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          Bar.super.foo();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryQualifierForThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedReturnValue",
                "shortDescription": {
                  "text": "方法可以为 'void'"
                },
                "fullDescription": {
                  "text": "报告调用时从不使用其返回值的方法。 此类方法的返回类型可以设置为 'void'。 不会报告使用 Error Prone 或 AssertJ 的 '@CanIgnoreReturnValue' 注解进行注解的方法。 该快速修复会更新方法签名，并移除方法中的 'return' 语句。 示例： '// 可见性设置为 Protected 或 Public 时报告\n  protected String myToUpperCase(String s) {\n    return s.toUpperCase();\n  }\n\n  // 简单的 setter，根据设置进行报告\n  public String setStr(String str) {\n    myStr = str;\n    return myStr;\n  }\n\n  void test() {\n    setStr(\"value\");          // 未使用返回值\n    myToUpperCase(\"result\");  // 未使用返回值\n  }' 对这两种方法应用该快速修复后： 'protected void myToUpperCase(String s) {\n      // 完全移除了 'return'\n      // 因为 's.toUpperCase()' 没有任何副作用\n    }\n\n    public void setStr(String str) {\n      myStr = str;\n      // 移除了 'return'\n    }\n  ...' 注意：由于性能原因，在编辑器中高亮显示时可能不会报告某些方法。 要查看所有结果，请通过代码 | 检查代码或代码 | 分析代码 | 按名称运行检查来运行检查> 使用忽略可链接方法选项可以忽略可链接调用中未使用的返回值。 使用报告方法最大可见性选项可以控制要报告的方法的最大可见性。",
                  "markdown": "报告调用时从不使用其返回值的方法。 此类方法的返回类型可以设置为 `void`。\n\n不会报告使用 Error Prone 或 AssertJ 的 `@CanIgnoreReturnValue` 注解进行注解的方法。\n该快速修复会更新方法签名，并移除方法中的 `return` 语句。\n\n**示例：**\n\n\n      // 可见性设置为 Protected 或 Public 时报告\n      protected String myToUpperCase(String s) {\n        return s.toUpperCase();\n      }\n\n      // 简单的 setter，根据设置进行报告\n      public String setStr(String str) {\n        myStr = str;\n        return myStr;\n      }\n\n      void test() {\n        setStr(\"value\");          // 未使用返回值\n        myToUpperCase(\"result\");  // 未使用返回值\n      }\n\n对这两种方法应用该快速修复后：\n\n\n        protected void myToUpperCase(String s) {\n          // 完全移除了 'return'\n          // 因为 's.toUpperCase()' 没有任何副作用\n        }\n\n        public void setStr(String str) {\n          myStr = str;\n          // 移除了 'return'\n        }\n      ...\n\n\n**注意** ：由于性能原因，在编辑器中高亮显示时可能不会报告某些方法。\n要查看所有结果，请通过**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**来运行检查\\>\n\n使用**忽略可链接方法**选项可以忽略可链接调用中未使用的返回值。\n\n使用**报告方法最大可见性**选项可以控制要报告的方法的最大可见性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedReturnValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UncheckedExceptionClass",
                "shortDescription": {
                  "text": "未检查的 'Exception' 类"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.RuntimeException' 的子类。 某些编码标准要求检查所有用户定义的异常类。 示例： 'class EnigmaException extends RuntimeException {} // 警告：未检查的异常类 'EnigmaException''",
                  "markdown": "报告 `java.lang.RuntimeException` 的子类。\n\n某些编码标准要求检查所有用户定义的异常类。\n\n**示例：**\n\n\n      class EnigmaException extends RuntimeException {} // 警告：未检查的异常类 'EnigmaException'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UncheckedExceptionClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SizeReplaceableByIsEmpty",
                "shortDescription": {
                  "text": "'size() == 0' 可被替换为 'isEmpty()'"
                },
                "fullDescription": {
                  "text": "报告 '0' 文字可以替换为对 '.isEmpty()' 的调用的 '.size()' 或 '.length()' 比较。 示例： 'boolean emptyList = list.size() == 0;' 在应用快速修复后： 'boolean emptyList = list.isEmpty();' 使用忽略类表可以添加不应为之替换任何 '.size()' 或 '.length()' 比较的类。 使用忽略将替换为 ''!isEmpty()'' 的表达式选项可以忽略任何将替换为 '!isEmpty()' 的表达式。",
                  "markdown": "报告 `0` 文字可以替换为对 `.isEmpty()` 的调用的 `.size()` 或 `.length()` 比较。\n\n**示例：**\n\n\n      boolean emptyList = list.size() == 0;\n\n在应用快速修复后：\n\n\n      boolean emptyList = list.isEmpty();\n      \n\n使用**忽略类** 表可以添加不应为之替换任何 `.size()` 或 `.length()` 比较的类。\n\n使用**忽略将替换为 `'!isEmpty()'` 的表达式** 选项可以忽略任何将替换为 `!isEmpty()` 的表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SizeReplaceableByIsEmpty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsupportedChronoFieldUnitCall",
                "shortDescription": {
                  "text": "使用不受支持的 'java.time.temporal.ChronoUnit' 和 'java.time.temporal.ChronoField' 调用方法"
                },
                "fullDescription": {
                  "text": "报告以不支持的 'java.time.temporal.ChronoField' 或 'java.time.temporal.ChronoUnit' 枚举常量作为实参的 'java.time' 方法调用（'get()'、'getLong()'、 'with()'、'plus()'、'minus()'）。 此类调用将在运行时抛出 'UnsupportedTemporalTypeException'。 示例： 'LocalTime localTime = LocalTime.now();\nint year = localTime.get(ChronoField.YEAR);' 2023.2 最新变化",
                  "markdown": "报告以不支持的 `java.time.temporal.ChronoField` 或 `java.time.temporal.ChronoUnit` 枚举常量作为实参的 `java.time` 方法调用（`get()`、`getLong()`、 `with()`、`plus()`、`minus()`）。 此类调用将在运行时抛出 `UnsupportedTemporalTypeException`。\n\n示例：\n\n\n    LocalTime localTime = LocalTime.now();\n    int year = localTime.get(ChronoField.YEAR);\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsupportedChronoFieldUnitCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumberEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'equals()' 进行数字比较"
                },
                "fullDescription": {
                  "text": "报告使用 == 或 != 而不是 'equals()' 来测试 'Number' 相等性的代码。 使用自动装箱时很容易犯这样的错误：即不比较两个基元，而是比较包装器类型的两个实例，例如使用 'Integer' 而不是 'int'。 示例： 'void foo(Integer a, Integer b) {\n    final boolean bool = a == b;\n  }' 如果已知 'a' 为非 null，则可以安全地应用“不安全”的快速修复，并获得类似于如下所示的结果： 'void foo(Integer a, Integer b) {\n    final boolean bool = a.equals(b);\n  }'",
                  "markdown": "报告使用 **==** 或 **!=** 而不是 `equals()` 来测试 `Number` 相等性的代码。\n\n\n使用自动装箱时很容易犯这样的错误：即不比较两个基元，而是比较包装器类型的两个实例，例如使用 `Integer` 而不是 `int`。\n\n**示例：**\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a == b;\n      }\n\n如果已知 `a` 为非 null，则可以安全地应用\"不安全\"的快速修复，并获得类似于如下所示的结果：\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a.equals(b);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumberEquality",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithOnlyPrivateConstructors",
                "shortDescription": {
                  "text": "仅包含 'private' 构造函数的类应被声明为 'final'"
                },
                "fullDescription": {
                  "text": "报告仅包含 'private' 构造函数的类。 只有 'private' 构造函数的类不能在文件外扩展，应声明为 'final'。",
                  "markdown": "报告仅包含 `private` 构造函数的类。\n\n只有 `private` 构造函数的类不能在文件外扩展，应声明为 `final`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithOnlyPrivateConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorNotSerializable",
                "shortDescription": {
                  "text": "'Comparator' 类未被声明为 'Serializable'"
                },
                "fullDescription": {
                  "text": "报告实现 'java.lang.Comparator' 但不实现 'java.io.Serializable' 的类。 如果使用不可序列化的比较器来构建 'java.util.TreeMap' 或 'java.util.TreeSet' 之类的有序集合，那么该集合也将不可序列化。 这可能会导致意外且难以诊断的错误。 'java.lang.Comparator' 的子类通常无状态，因此只需将它们标记为可序列化，即可轻松避免此类问题。 示例： 'class Foo implements Comparator { // 警告\n      @Override\n      public int compare(Object o1, Object o2) {\n          /* ... */\n      }\n  }' 在应用快速修复后： 'class Foo implements Comparator, Serializable { // 此处无警告\n      @Override\n      public int compare(Object o1, Object o2) {\n          /* ... */\n      }\n  }'",
                  "markdown": "报告实现 `java.lang.Comparator` 但不实现 `java.io.Serializable` 的类。\n\n\n如果使用不可序列化的比较器来构建 `java.util.TreeMap` 或 `java.util.TreeSet` 之类的有序集合，那么该集合也将不可序列化。 这可能会导致意外且难以诊断的错误。\n\n\n`java.lang.Comparator` 的子类通常无状态，因此只需将它们标记为可序列化，即可轻松避免此类问题。\n\n**示例：**\n\n\n      class Foo implements Comparator { // 警告\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n\n在应用快速修复后：\n\n\n      class Foo implements Comparator, Serializable { // 此处无警告\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorNotSerializable",
                    "cweIds": [
                      502
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UNUSED_IMPORT",
                "shortDescription": {
                  "text": "未使用的 import"
                },
                "fullDescription": {
                  "text": "报告冗余的 'import' 语句。 如果不使用源文件中导入的类和软件包，则不必使用常规 'import' 语句。 这同样适用于源文件中未使用但已导入的 'static' 字段和方法。 示例： 'import java.util.ArrayList;\n  public class Example {\n    public static void main(String[] args) {\n      System.out.println(\"Hello World!\");\n    }\n  }' 在应用快速修复后： 'public class Example {\n    public static void main(String[] args) {\n      System.out.println(\"Hello World!\");\n    }\n  }'",
                  "markdown": "报告冗余的 `import` 语句。\n\n如果不使用源文件中导入的类和软件包，则不必使用常规 `import` 语句。\n这同样适用于源文件中未使用但已导入的 `static` 字段和方法。\n\n**示例：**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UNUSED_IMPORT",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 14,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldAccessedSynchronizedAndUnsynchronized",
                "shortDescription": {
                  "text": "同时在 'synchronized' 和未同步上下文中访问字段"
                },
                "fullDescription": {
                  "text": "报告在 'synchronized' 和非 'synchronized' 上下文中访问的非 final 字段。 'volatile' 字段以及构造函数和初始值设定项中的访问将被此检查忽略。 此类“部分同步的”访问通常是编码疏忽所致，可能导致意外的不一致数据结构。 示例： 'public class Program {\n    Console console; // 警告：在同步和非同步上下文中都访问字段 'console'\n\n    public synchronized void execute() {\n      console.print(\"running\");\n    }\n\n    public void check() {\n      console.check();\n    }\n  }'\n 使用该选项可以指定简单的 getter 和 setter 是否也算作访问。",
                  "markdown": "报告在 `synchronized` 和非 `synchronized` 上下文中访问的非 final 字段。 `volatile` 字段以及构造函数和初始值设定项中的访问将被此检查忽略。\n\n\n此类\"部分同步的\"访问通常是编码疏忽所致，可能导致意外的不一致数据结构。\n\n**示例：**\n\n\n      public class Program {\n        Console console; // 警告：在同步和非同步上下文中都访问字段 'console'\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\n使用该选项可以指定简单的 getter 和 setter 是否也算作访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldAccessedSynchronizedAndUnsynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RemoveLiteralUnderscores",
                "shortDescription": {
                  "text": "数字文字中的下划线"
                },
                "fullDescription": {
                  "text": "报告带下划线的数值文字，并建议通过快速修复将其移除。 如果您需要降低语言级别，这可能会有用。 该快速修复会移除数值文字中的下划线。 例如，'1_000_000' 将转换为 '1000000'。 带下划线的数值文字在 Java 7 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。 2020.2 最新变化",
                  "markdown": "报告带下划线的数值文字，并建议通过快速修复将其移除。 如果您需要降低语言级别，这可能会有用。\n\n该快速修复会移除数值文字中的下划线。 例如，`1_000_000` 将转换为 `1000000`。\n\n\n*带下划线的数值文字*在 Java 7 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RemoveLiteralUnderscores",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedEqualityExpression",
                "shortDescription": {
                  "text": "否定相等表达式"
                },
                "fullDescription": {
                  "text": "报告被前缀表达式否定的等式表达式。 可以使用 '!=' 运算符简化此类表达式。 示例： '!(i == 1)' 在应用快速修复后： 'i != 1'",
                  "markdown": "报告被前缀表达式否定的等式表达式。\n\n可以使用 `!=` 运算符简化此类表达式。\n\n示例：\n\n\n      !(i == 1)\n\n在应用快速修复后：\n\n\n      i != 1\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedEqualityExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MathRandomCastToInt",
                "shortDescription": {
                  "text": "'Math.random()' 转换为 'int'"
                },
                "fullDescription": {
                  "text": "报告对立即转换为 'int' 的 'Math.random()' 的调用。 将 '0.0'（包括）和 '1.0'（不包括）之间的 'double' 转换为 'int' 将始终舍入为零。 在将该值转换为 'int' 前，应先将其乘以某个因子，以获取介于零（包括）和乘法因子（不包括）之间的值。 另一种可能的解决办法是使用 'java.util.Random' 的 'nextInt()' 方法。 示例： 'int r = (int)Math.random() * 10;' 在应用快速修复后： 'int r = (int)(Math.random() * 10);'",
                  "markdown": "报告对立即转换为 `int` 的 `Math.random()` 的调用。\n\n将 `0.0`（包括）和 `1.0`（不包括）之间的 `double` 转换为 `int` 将始终舍入为零。 在将该值转换为 `int` 前，应先将其乘以某个因子，以获取介于零（包括）和乘法因子（不包括）之间的值。\n另一种可能的解决办法是使用 `java.util.Random` 的 `nextInt()` 方法。\n\n**示例：**\n\n      int r = (int)Math.random() * 10;\n\n在应用快速修复后：\n\n      int r = (int)(Math.random() * 10);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MathRandomCastToInt",
                    "cweIds": [
                      330,
                      681
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleBraceInitialization",
                "shortDescription": {
                  "text": "双大括号初始化"
                },
                "fullDescription": {
                  "text": "报告双大括号初始化。 双大括号初始化在非 static 上下文中使用时可能会导致内存泄漏，因为它创建了一个将引用周围对象的匿名类。 与常规初始化相比，双大括号初始化的性能更差，因为它需要加载一个额外的类。 如果 'equals()' 方法不接受子类作为形参，还可能导致 'equals()' 比较失败。 此外，在 Java 9 以前的版本中，双大括号初始化不能与 Diamond 运算符结合使用，因为它与匿名类不兼容。 示例： 'List<Integer> list = new ArrayList<>() {{\n    add(1);\n    add(2);\n  }};' 在应用快速修复后： 'List<Integer> list = new ArrayList<>();\n  list.add(1);\n  list.add(2);'",
                  "markdown": "报告[双大括号初始化](https://www.c2.com/cgi/wiki?DoubleBraceInitialization)。\n\n双大括号初始化在非 static 上下文中使用时可能会导致内存泄漏，因为它创建了一个将引用周围对象的匿名类。\n\n与常规初始化相比，双大括号初始化的性能更差，因为它需要加载一个额外的类。\n\n如果 `equals()` 方法不接受子类作为形参，还可能导致 `equals()` 比较失败。\n\n此外，在 Java 9 以前的版本中，双大括号初始化不能与 Diamond 运算符结合使用，因为它与匿名类不兼容。\n\n**示例：**\n\n\n      List<Integer> list = new ArrayList<>() {{\n        add(1);\n        add(2);\n      }};\n\n在应用快速修复后：\n\n\n      List<Integer> list = new ArrayList<>();\n      list.add(1);\n      list.add(2);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DoubleBraceInitialization",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInLoops",
                "shortDescription": {
                  "text": "字符串串联在循环中"
                },
                "fullDescription": {
                  "text": "报告循环中的 String 串联。 由于每个 String 串联都会复制整个字符串，因此通常最好将其替换为对 'StringBuilder.append()' 或 'StringBuffer.append()' 的显式调用。 示例： 'String str = \"\";\n  for(int i=0; i<10; i++) {\n    str += i;\n  }' 在应用快速修复后： 'String str = \"\";\n  StringBuilder strBuilder = new StringBuilder(str);\n  for(int i = 0; i<10; i++) {\n    strBuilder.append(i);\n  }\n  str = strBuilder.toString();' 有时，通过该快速修复可将 'String' 变量转换为 'StringBuilder' 或引入新的 'StringBuilder'。 原始代码专门处理 'null' 值时应小心，因为替换可能会改变语义。 如果可能为 'null'，建议进行 null 安全修正，生成必要的 null 检查。 此外，也不能保证自动替换总是性能更好。",
                  "markdown": "报告循环中的 String 串联。\n\n\n由于每个 String 串联都会复制整个字符串，因此通常最好将其替换为对 `StringBuilder.append()` 或 `StringBuffer.append()` 的显式调用。\n\n**示例：**\n\n\n      String str = \"\";\n      for(int i=0; i<10; i++) {\n        str += i;\n      }\n\n在应用快速修复后：\n\n\n      String str = \"\";\n      StringBuilder strBuilder = new StringBuilder(str);\n      for(int i = 0; i<10; i++) {\n        strBuilder.append(i);\n      }\n      str = strBuilder.toString();\n\n\n有时，通过该快速修复可将 `String` 变量转换为 `StringBuilder` 或引入新的 `StringBuilder`。 原始代码专门处理 `null` 值时应小心，因为替换可能会改变语义。 如果可能为 `null`，建议进行 null 安全修正，生成必要的 null 检查。 此外，也不能保证自动替换总是性能更好。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneableClassInSecureContext",
                "shortDescription": {
                  "text": "安全上下文中的可克隆类"
                },
                "fullDescription": {
                  "text": "报告可能被克隆的类。 如果一个类支持 'Cloneable' 接口，并且它的 'clone()' 方法没有定义为立即抛出错误，则该类可以被克隆。 在用于安全使用的代码中，可克隆类可能是危险的。 示例： 'class SecureBean implements Cloneable {}' 在应用快速修复后： 'class SecureBean {}' 当类扩展现有的可克隆类或实现可克隆接口时，应用该快速修复后，代码可能如下所示： 'class SecureBean extends ParentBean {\n    @Override\n    protected SecureBean clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }\n}'",
                  "markdown": "报告可能被克隆的类。\n\n\n如果一个类支持 `Cloneable` 接口，并且它的 `clone()` 方法没有定义为立即抛出错误，则该类可以被克隆。 在用于安全使用的代码中，可克隆类可能是危险的。\n\n**示例：**\n`class SecureBean implements Cloneable {}`\n\n在应用快速修复后：\n`class SecureBean {}`\n\n\n当类扩展现有的可克隆类或实现可克隆接口时，应用该快速修复后，代码可能如下所示：\n\n    class SecureBean extends ParentBean {\n        @Override\n        protected SecureBean clone() throws CloneNotSupportedException {\n            throw new CloneNotSupportedException();\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneableClassInSecureContext",
                    "cweIds": [
                      498
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentTextBlockIndent",
                "shortDescription": {
                  "text": "文本块中的空格缩进不一致"
                },
                "fullDescription": {
                  "text": "报告同时使用空格和制表符缩进的文本块。 由于空格和制表符会被文本块处理同等对待，此类情况会产生意外的结果。 在下面的示例中，空格和制表符被分别呈现为 '·' 和 '␉'，在编辑器中，一个制表符相当于 4 个空格。 示例： 'String colors = \"\"\"\n········red\n␉   ␉   green\n········blue\"\"\";' 打印此类字符串后，结果为： '······red\ngreen\n······blue' 在编译器从每一行的开头移除相同数量的空格或制表符后，某些行将保留前导空格。 2021.1 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告同时使用空格和制表符缩进的文本块。 由于空格和制表符会被文本块处理同等对待，此类情况会产生意外的结果。\n\n在下面的示例中，空格和制表符被分别呈现为 `·` 和 `␉`，在编辑器中，一个制表符相当于 4 个空格。\n\n**示例：**\n\n\n    String colors = \"\"\"\n    ········red\n    ␉   ␉   green\n    ········blue\"\"\";\n\n打印此类字符串后，结果为：\n\n\n    ······red\n    green\n    ······blue\n\n在编译器从每一行的开头移除相同数量的空格或制表符后，某些行将保留前导空格。\n\n2021.1 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentTextBlockIndent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertionCanBeIf",
                "shortDescription": {
                  "text": "断言可被替换为 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告 'assert' 语句并建议将它们替换为抛出 'java.lang.AssertionError' 的 'if' 语句。 示例： 'assert param != null;' 在应用快速修复后： 'if (param == null) throw new AssertionError();' 此检查取决于 Java 功能 '断言'，该功能自 Java 4 起可用。",
                  "markdown": "报告 `assert` 语句并建议将它们替换为抛出 `java.lang.AssertionError` 的 `if` 语句。\n\n示例：\n\n\n      assert param != null;\n\n在应用快速修复后：\n\n\n      if (param == null) throw new AssertionError();\n\n此检查取决于 Java 功能 '断言'，该功能自 Java 4 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AssertionCanBeIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleNegation",
                "shortDescription": {
                  "text": "双重否定"
                },
                "fullDescription": {
                  "text": "报告可以简化的双重否定。 示例： 'if (!!functionCall()) {}' 在应用快速修复后： 'if (functionCall()) {}' 示例： 'if (!(a != b)) {}' 在应用快速修复后： 'if (a == b) {}'",
                  "markdown": "报告可以简化的双重否定。\n\n示例：\n\n\n      if (!!functionCall()) {}\n\n在应用快速修复后：\n\n\n      if (functionCall()) {}\n\n示例：\n\n\n      if (!(a != b)) {}\n\n在应用快速修复后：\n\n\n      if (a == b) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleNegation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageWithTooFewClasses",
                "shortDescription": {
                  "text": "软件包具有过少类"
                },
                "fullDescription": {
                  "text": "报告包含少于指定最小值的类的软件包。 不报告包含子软件包的软件包。 过小的软件包可能表明设计零散。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最小类数字段可指定软件包中允许的最小类数。",
                  "markdown": "报告包含少于指定最小值的类的软件包。\n\n不报告包含子软件包的软件包。 过小的软件包可能表明设计零散。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最小类数**字段可指定软件包中允许的最小类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageWithTooFewClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 36,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceOnLiteralHasNoEffect",
                "shortDescription": {
                  "text": "替换操作不起任何作用"
                },
                "fullDescription": {
                  "text": "报告对 'String' 方法 'replace()'、'replaceAll()' 或 'replaceFirst()' 的无效调用。 当限定符和搜索字符串均为编译时常量，且在限定符中找不到搜索字符串时，可以保证此类调用无效。 这是冗余代码，可能表示存在错误。 示例： '// 替换不起任何作用\n  \"hello\".replace(\"$value$\", value);' 2022.1 最新变化",
                  "markdown": "报告对 `String` 方法 `replace()`、`replaceAll()` 或 `replaceFirst()` 的无效调用。 当限定符和搜索字符串均为编译时常量，且在限定符中找不到搜索字符串时，可以保证此类调用无效。 这是冗余代码，可能表示存在错误。\n\n**示例：**\n\n\n      // 替换不起任何作用\n      \"hello\".replace(\"$value$\", value);\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceOnLiteralHasNoEffect",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleClassImport",
                "shortDescription": {
                  "text": "单个类导入"
                },
                "fullDescription": {
                  "text": "报告导入单个类（而不是整个软件包）的 'import' 语句。 某些编码标准禁止此类 'import' 语句。 您可以将 IntelliJ IDEA 配置为使用优化 import 命令检测和修正此类语句。 转到设置 | 编辑器 | 代码样式 | Java | 导入，并清除使用单个类导入复选框。 因此，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告导入单个类（而不是整个软件包）的 `import` 语句。\n\n某些编码标准禁止此类 `import` 语句。\n\n\n您可以将 IntelliJ IDEA 配置为使用**优化 import** 命令检测和修正此类语句。 转到[设置 \\| 编辑器 \\| 代码样式 \\| Java \\| 导入](settings://preferences.sourceCode.Java?Use%20single%20class%20import)，并清除**使用单个类导入**复选框。 因此，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleClassImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 14,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadOddness",
                "shortDescription": {
                  "text": "可疑的奇数检查"
                },
                "fullDescription": {
                  "text": "报告以下形式的奇偶校验：'x % 2 == 1'。 当与负奇数一起使用时，此类检查将会失败。 请考虑改用 'x % 2 != 0' 或 '(x & 1) == 1'。",
                  "markdown": "报告以下形式的奇偶校验：`x % 2 == 1`。 当与负奇数一起使用时，此类检查将会失败。 请考虑改用 `x % 2 != 0` 或 `(x & 1) == 1`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BadOddness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingConditionDisagreesWithLogLevelStatement",
                "shortDescription": {
                  "text": "日志条件与日志记录调用不匹配"
                },
                "fullDescription": {
                  "text": "报告与包含的日志记录调用的日志级别不匹配的 'if' 语句的 is log enabled for 条件。 示例： 'if (LOG.isTraceEnabled()) {\n    // 已记录调试级别，但已检查跟踪级别\n    LOG.debug(\"some log message\");\n  }' 此检查能够理解 java.util.logging、Log4j、Log4j2、Apache Commons Logging 和 SLF4J 日志记录框架。",
                  "markdown": "报告与包含的日志记录调用的日志级别不匹配的 `if` 语句的 *is log enabled for* 条件。\n\n\n示例：\n\n\n      if (LOG.isTraceEnabled()) {\n        // 已记录调试级别，但已检查跟踪级别\n        LOG.debug(\"some log message\");\n      }\n\n此检查能够理解 *java.util.logging* 、*Log4j* 、*Log4j2* 、*Apache Commons Logging* 和 *SLF4J* 日志记录框架。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingConditionDisagreesWithLogLevelStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 40,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemOutErr",
                "shortDescription": {
                  "text": "使用 'System.out' 或 'System.err'"
                },
                "fullDescription": {
                  "text": "报告 'System.out' 或 'System.err' 的用法。 此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。",
                  "markdown": "报告 `System.out` 或 `System.err` 的用法。\n\n此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfSystemOutOrSystemErr",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckedExceptionClass",
                "shortDescription": {
                  "text": "已检查的异常类"
                },
                "fullDescription": {
                  "text": "报告已检查的异常类（即，非 'java.lang.RuntimeException' 子类的 'java.lang.Exception' 的子类）。 某些编码标准禁止已检查的用户定义的异常类。 示例： 'class IllegalMoveException extends Exception {}'",
                  "markdown": "报告已检查的异常类（即，非 `java.lang.RuntimeException` 子类的 `java.lang.Exception` 的子类）。\n\n某些编码标准禁止已检查的用户定义的异常类。\n\n**示例：**\n\n\n      class IllegalMoveException extends Exception {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckedExceptionClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableStoresNonSerializable",
                "shortDescription": {
                  "text": "'Serializable' 对象隐式存储非 'Serializable' 对象"
                },
                "fullDescription": {
                  "text": "报告任何对 'Serializable' lambda、局部类和匿名类外部的非 'Serializable' 局部变量的引用。 从匿名类引用局部变量时，它的值存储在该类的隐式字段中。 对于局部类和 lambda 也是如此。 如果变量类型为非 'Serializable'，序列化将失败。 示例： 'interface A extends Serializable {\n      abstract void foo();\n  }\n  class B {}\n  class C {\n      void foo() {\n          B b = new B();\n          A a = new A() {\n              @Override\n              public void foo() {\n                  System.out.println(b); // 警告\n              }\n          };\n      }\n  }'",
                  "markdown": "报告任何对 `Serializable` lambda、局部类和匿名类外部的非 `Serializable` 局部变量的引用。\n\n\n从匿名类引用局部变量时，它的值存储在该类的隐式字段中。 对于局部类和 lambda 也是如此。 如果变量类型为非 `Serializable`，序列化将失败。\n\n**示例：**\n\n\n      interface A extends Serializable {\n          abstract void foo();\n      }\n      class B {}\n      class C {\n          void foo() {\n              B b = new B();\n              A a = new A() {\n                  @Override\n                  public void foo() {\n                      System.out.println(b); // 警告\n                  }\n              };\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableStoresNonSerializable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InsertLiteralUnderscores",
                "shortDescription": {
                  "text": "不可读的数字文字"
                },
                "fullDescription": {
                  "text": "报告不带下划线的长数值文字并建议添加它们。 下划线使此类文字更易于阅读。 示例： '1000000' 在应用快速修复后： '1_000_000' 仅当项目或模块的语言级别为 7 级或更高级别时，此检查才会报告。 2020.2 最新变化",
                  "markdown": "报告不带下划线的长数值文字并建议添加它们。 下划线使此类文字更易于阅读。\n\n示例：\n\n\n      1000000\n\n在应用快速修复后：\n\n\n      1_000_000\n\n仅当项目或模块的语言级别为 7 级或更高级别时，此检查才会报告。\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "InsertLiteralUnderscores",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatement",
                "shortDescription": {
                  "text": "'break' 语句"
                },
                "fullDescription": {
                  "text": "报告在 'switch' 语句分支结尾以外的位置使用的 'break' 语句。 'break' 语句导致重构复杂化，可能令人困惑。 示例： 'void foo(List<String> strs) {\n  for (String str : strs) {\n    if (str.contains(\"stop\")) break;\n    handleStr(str);\n  }\n}'",
                  "markdown": "报告在 `switch` 语句分支结尾以外的位置使用的 `break` 语句。\n\n`break` 语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n    void foo(List<String> strs) {\n      for (String str : strs) {\n        if (str.contains(\"stop\")) break;\n        handleStr(str);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCExecuteWithNonConstantString",
                "shortDescription": {
                  "text": "'Statement.execute()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对 'java.sql.Statement.execute()' 或其任何变体的调用，这些变体会将动态构造的字符串作为要执行的查询。 构造的 SQL 语句是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'ResultSet execute(Statement statement, String name) throws SQLException {\n    return statement.executeQuery(\"select * from \" + name); // 报告警告\n  }' 使用检查选项可以将任何 'static' 'final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'private static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";'",
                  "markdown": "报告对 `java.sql.Statement.execute()` 或其任何变体的调用，这些变体会将动态构造的字符串作为要执行的查询。\n\n构造的 SQL 语句是安全漏洞的常见来源。\n默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      ResultSet execute(Statement statement, String name) throws SQLException {\n        return statement.executeQuery(\"select * from \" + name); // 报告警告\n      }\n\n\n使用检查选项可以将任何 `static` `final` 字段视为常量。\n请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      private static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCExecuteWithNonConstantString",
                    "cweIds": [
                      89,
                      564
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantValueVariableUse",
                "shortDescription": {
                  "text": "使用已知值为常量的变量"
                },
                "fullDescription": {
                  "text": "报告已知为常量的变量的所有用法。 如果（读取）使用的变量被 'if'、'while' 或 'for' 语句包围，且存在该变量与常量相比较的 '==' 条件时，就会发生这种情况。 在这种情况下，使用的已知为常量的变量可以替换为实际常量。 示例： 'private static void foo(double number) {\n        if (number == 1.0) {\n            f(number);\n        }\n    }\n    private static void f(double number) {}' 在应用快速修复后： 'private static void foo(double number) {\n        if (number == 1.0) {\n            f(1.0);\n        }\n    }\n    private static void f(double number) {}'",
                  "markdown": "报告已知为常量的变量的所有用法。\n\n如果（读取）使用的变量被 `if`、`while` 或 `for` 语句包围，且存在该变量与常量相比较的 `==` 条件时，就会发生这种情况。\n在这种情况下，使用的已知为常量的变量可以替换为实际常量。\n\n示例：\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(number);\n            }\n        }\n        private static void f(double number) {}\n\n在应用快速修复后：\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(1.0);\n            }\n        }\n        private static void f(double number) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantValueVariableUse",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewStringBufferWithCharArgument",
                "shortDescription": {
                  "text": "StringBuilder 构造函数调用具有 'char' 实参"
                },
                "fullDescription": {
                  "text": "报告对 'char' 作为实参的 'StringBuffer' 和 'StringBuilder' 构造函数的调用。 在本例中，'char' 无提示地转换为整数，并解读为缓冲区的初始容量。 示例： 'new StringBuilder('(').append(\"1\").append(')');' 在应用快速修复后： 'new StringBuilder(\"(\").append(\"1\").append(')');'",
                  "markdown": "报告对 `char` 作为实参的 `StringBuffer` 和 `StringBuilder` 构造函数的调用。 在本例中，`char` 无提示地转换为整数，并解读为缓冲区的初始容量。\n\n**示例：**\n\n\n      new StringBuilder('(').append(\"1\").append(')');\n\n在应用快速修复后：\n\n\n      new StringBuilder(\"(\").append(\"1\").append(')');\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewStringBufferWithCharArgument",
                    "cweIds": [
                      628,
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ResultOfObjectAllocationIgnored",
                "shortDescription": {
                  "text": "对象分配的结果已忽略"
                },
                "fullDescription": {
                  "text": "报告其中分配的对象被忽略，并且既不分配给变量，也不以其他方式使用的对象分配。 此类分配表达式虽然在 Java 中合法，但通常要么是无意为之，要么表明存在非常奇怪的对象初始化策略。 使用这些选项可列出此检查应忽略其分配的类。",
                  "markdown": "报告其中分配的对象被忽略，并且既不分配给变量，也不以其他方式使用的对象分配。\n\n\n此类分配表达式虽然在 Java 中合法，但通常要么是无意为之，要么表明存在非常奇怪的对象初始化策略。\n\n\n使用这些选项可列出此检查应忽略其分配的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ResultOfObjectAllocationIgnored",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassGetClass",
                "shortDescription": {
                  "text": "'Class.getClass()' 调用可疑"
                },
                "fullDescription": {
                  "text": "报告在 'java.lang.Class' 实例上调用的 'getClass()' 方法。 这通常是一个错误，因为结果总是等同于 'Class.class'。 如果是错误，那么最好移除 'getClass()' 调用并直接使用限定符。 如果行为是故意的，最好显式编写 'Class.class' 以避免混淆。 示例： 'void test(Class<?> clazz) {\n    String name = clazz.getClass().getName();\n  }' 在应用可能的快速修复之一后： 'void test(Class<?> clazz) {\n    String name = clazz.getName();\n  }' 2018.2 最新变化",
                  "markdown": "报告在 `java.lang.Class` 实例上调用的 `getClass()` 方法。\n\n这通常是一个错误，因为结果总是等同于 `Class.class`。\n如果是错误，那么最好移除 `getClass()` 调用并直接使用限定符。\n如果行为是故意的，最好显式编写 `Class.class` 以避免混淆。\n\n示例：\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getClass().getName();\n      }\n\n在应用可能的快速修复之一后：\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getName();\n      }\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassGetClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLibrary",
                "shortDescription": {
                  "text": "未使用的库"
                },
                "fullDescription": {
                  "text": "报告附加到指定检查范围但未直接在代码中使用的库。",
                  "markdown": "报告附加到指定检查范围但未直接在代码中使用的库。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLibrary",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObsoleteCollection",
                "shortDescription": {
                  "text": "使用废弃的集合类型"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Vector'、'java.util.Hashtable' 和 'java.util.Stack' 的用法。 这些类的用法通常可以分别替换为 'java.util.ArrayList'、'java.util.HashMap' 和 'java.util.ArrayDeque' 的用法。 虽然仍受支持，但以前的类已被 JDK1.2 集合类废弃，在新开发中或许不宜使用。 使用在需要的位置忽略废弃的集合类型选项可以忽略任何将废弃的集合用作方法实参或分配给需要废弃类型的变量的情况。 启用此选项可能会消耗大量处理器资源。",
                  "markdown": "报告 `java.util.Vector`、`java.util.Hashtable` 和 `java.util.Stack` 的用法。\n\n这些类的用法通常可以分别替换为 `java.util.ArrayList`、`java.util.HashMap` 和 `java.util.ArrayDeque` 的用法。\n虽然仍受支持，但以前的类已被 JDK1.2 集合类废弃，在新开发中或许不宜使用。\n\n\n使用**在需要的位置忽略废弃的集合类型**选项可以忽略任何将废弃的集合用作方法实参或分配给需要废弃类型的变量的情况。\n启用此选项可能会消耗大量处理器资源。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteCollectionType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForEachWithRecordPatternCanBeUsed",
                "shortDescription": {
                  "text": "可以使用带有记录模式的增强 'for'"
                },
                "fullDescription": {
                  "text": "报告局部变量声明和访问器，以记录增强型 'for' 语句（这些语句通常更紧凑）中可被替换为模式变量的组件。 示例： 'record Record(Integer x, String y) {\n}\n\npublic static void test(List<Record> records) {\n    for (Record record : records) {\n        System.out.println(record.y());\n        Integer x = record.x;\n        System.out.println(x);\n    }\n}' 可以替换为： 'record Record(Integer x, String y) {\n}\n\npublic static void test(List<Record> records) {\n    for (Record(Integer x, String y) : records) {\n        System.out.println(y);\n        System.out.println(x);\n    }\n}' 使用嵌套深度限制选项指定要报告的最大嵌套析构模式数 使用要析构的记录组件的最大数量选项指定要在析构模式中使用的记录可以包含的组件的最大数量 使用未使用的记录组件的最大数量选项指定 'for' 语句中未使用的组件的最大数量 2023.1 最新变化 此检查取决于 Java 功能 '在 for-each 循环中记录模式'，该功能自 Java X 起可用。",
                  "markdown": "报告局部变量声明和访问器，以记录增强型 'for' 语句（这些语句通常更紧凑）中可被替换为模式变量的组件。\n\n**示例：**\n\n\n    record Record(Integer x, String y) {\n    }\n\n    public static void test(List<Record> records) {\n        for (Record record : records) {\n            System.out.println(record.y());\n            Integer x = record.x;\n            System.out.println(x);\n        }\n    }\n\n可以替换为：\n\n\n    record Record(Integer x, String y) {\n    }\n\n    public static void test(List<Record> records) {\n        for (Record(Integer x, String y) : records) {\n            System.out.println(y);\n            System.out.println(x);\n        }\n    }\n\n* 使用**嵌套深度限制**选项指定要报告的最大嵌套析构模式数\n* 使用**要析构的记录组件的最大数量**选项指定要在析构模式中使用的记录可以包含的组件的最大数量\n* 使用**未使用的记录组件的最大数量** 选项指定 `for` 语句中未使用的组件的最大数量\n\n2023.1 最新变化\n\n此检查取决于 Java 功能 '在 for-each 循环中记录模式'，该功能自 Java X 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForEachWithRecordPatternCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 51,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedStringBuilderQueryUpdate",
                "shortDescription": {
                  "text": "'StringBuilder' 的查询和更新不匹配"
                },
                "fullDescription": {
                  "text": "报告其内容已读取但未写入，或已写入但未读取的 'StringBuilder'、'StringBuffer' 或 'StringJoiner' 对象。 此类不一致读写毫无意义，可能表明死码、代码不完整或错误。 示例： 'public void m1() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"a\");\n  }'",
                  "markdown": "报告其内容已读取但未写入，或已写入但未读取的 `StringBuilder`、`StringBuffer` 或 `StringJoiner` 对象。\n\n此类不一致读写毫无意义，可能表明死码、代码不完整或错误。\n\n**示例：**\n\n\n      public void m1() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"a\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedQueryAndUpdateOfStringBuilder",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalizeNotProtected",
                "shortDescription": {
                  "text": "'finalize()' 应为 protected，不应为 public"
                },
                "fullDescription": {
                  "text": "报告被声明为 'public' 的 'Object.finalize()' 方法的任何实现。 根据 'Object.finalize()' 的约定，只有垃圾回收器调用此方法。 将此方法设为 public 可能令人困惑，因为这意味着该方法可以从其他代码中使用。 可以通过快速修复将该方法设为 'protected'，以防止它被其他类调用。 示例： 'class X {\n    public void finalize() {\n      /* ... */\n    }\n  }' 在应用快速修复后： 'class X {\n    protected void finalize() {\n      /* ... */\n    }\n  }'",
                  "markdown": "报告被声明为 `public` 的 `Object.finalize()` 方法的任何实现。\n\n\n根据 `Object.finalize()` 的约定，只有垃圾回收器调用此方法。 将此方法设为 public 可能令人困惑，因为这意味着该方法可以从其他代码中使用。\n\n\n可以通过快速修复将该方法设为 `protected`，以防止它被其他类调用。\n\n**示例：**\n\n\n      class X {\n        public void finalize() {\n          /* ... */\n        }\n      }\n\n在应用快速修复后：\n\n\n      class X {\n        protected void finalize() {\n          /* ... */\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeNotProtected",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/完成",
                      "index": 56,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LogStatementGuardedByLogCondition",
                "shortDescription": {
                  "text": "日志调用不受日志条件保护"
                },
                "fullDescription": {
                  "text": "报告带有未被保护条件包围的非常量实参的日志记录调用。 对日志记录调用的实参的评估可能开销巨大。 当日志记录语句使用的级别禁用日志记录时，使用临界子句包围日志记录调用可避免这种开销。 这对于最不严重的日志记录调用级别（跟踪、调试、最精细）特别有用，因为这些调用在生产环境中最常被禁用。 示例： 'public class Principal {\n    void bad(Object object) {\n      if (true) {\n        LOG.debug(\"log log log \" + expensiveCalculation(object));\n      }\n      LOG.debug(\"some more logging \" + expensiveCalculation(1));\n    }\n\n    void good(Object) {\n      if (LOG.isDebug()) {\n        LOG.debug(\"value: \" + expensiveCalculation(object));\n      }\n    }\n  }' 配置检查： 使用记录器类名字段可以指定使用的记录器类名。 使用该表可以指定此检查应警告的日志记录方法，以及相应的日志条件文本。 使用标记所有不受保护的日志调用选项可让检查标记所有不受保护的日志调用，而不仅仅是那些具有非常量实参的调用。",
                  "markdown": "报告带有未被保护条件包围的非常量实参的日志记录调用。 对日志记录调用的实参的评估可能开销巨大。 当日志记录语句使用的级别禁用日志记录时，使用临界子句包围日志记录调用可避免这种开销。 这对于最不严重的日志记录调用级别（跟踪、调试、最精细）特别有用，因为这些调用在生产环境中最常被禁用。\n\n**示例：**\n\n\n      public class Principal {\n        void bad(Object object) {\n          if (true) {\n            LOG.debug(\"log log log \" + expensiveCalculation(object));\n          }\n          LOG.debug(\"some more logging \" + expensiveCalculation(1));\n        }\n\n        void good(Object) {\n          if (LOG.isDebug()) {\n            LOG.debug(\"value: \" + expensiveCalculation(object));\n          }\n        }\n      }\n\n\n配置检查：\n\n* 使用**记录器类名**字段可以指定使用的记录器类名。\n*\n  使用该表可以指定此检查应警告的日志记录方法，以及相应的日志条件文本。\n\n* 使用**标记所有不受保护的日志调用**选项可让检查标记所有不受保护的日志调用，而不仅仅是那些具有非常量实参的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LogStatementGuardedByLogCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 57,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ModuleWithTooManyClasses",
                "shortDescription": {
                  "text": "类过多的模块"
                },
                "fullDescription": {
                  "text": "报告包含的类太多的模块。 模块过大可能表明缺乏设计清晰度。 Java、Kotlin 和 Groovy 类均计算在内。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最大类数字段可指定模块可以拥有的最大类数。",
                  "markdown": "报告包含的类太多的模块。 模块过大可能表明缺乏设计清晰度。 Java、Kotlin 和 Groovy 类均计算在内。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最大类数**字段可指定模块可以拥有的最大类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ModuleWithTooManyClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteLoopStatement",
                "shortDescription": {
                  "text": "无限循环语句"
                },
                "fullDescription": {
                  "text": "报告只能通过抛出异常退出的 'for'、'while' 或 'do' 语句。 虽然此类语句可能是正确的，但它们经常由编码错误导致。 示例： 'for (;;) {\n  }' 使用 放置在 Thread.run 中时忽略 选项忽略 'Thread.run' 中的无限循环语句。 它可能对守护线程有用。 示例： 'new Thread(() -> {\n    while (true) {\n    }\n  }).start();'",
                  "markdown": "报告只能通过抛出异常退出的 `for`、`while` 或 `do` 语句。 虽然此类语句可能是正确的，但它们经常由编码错误导致。\n\n示例：\n\n\n      for (;;) {\n      }\n\n\n使用 **放置在 Thread.run 中时忽略** 选项忽略 `Thread.run` 中的无限循环语句。\n它可能对守护线程有用。\n\n示例：\n\n\n      new Thread(() -> {\n        while (true) {\n        }\n      }).start();\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteLoopStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocHtmlLint",
                "shortDescription": {
                  "text": "Javadoc中的HTML问题(DocLint)"
                },
                "fullDescription": {
                  "text": "报告自 Java 8 以来 DocLint 报告的 Javadoc 注释中的相同 HTML 问题。 该检查发现以下问题： 自闭合、未闭合、未知、放错位置或空的标记 未知或错误的特性 放错位置的文本 示例： '/**\n * 未知标记：List<String>\n * 未闭合标记：error</b>\n * 放错位置的文本或标记：<ul><li>one</li>, <li>two</li></ul>\n * 错误或空的特性：<a href=\"\"></a>\n * 自闭合标记：<br/>\n * …\n */\nvoid sample(){ }'",
                  "markdown": "报告自 Java 8 以来 DocLint 报告的 Javadoc 注释中的相同 HTML 问题。\n\n该检查发现以下问题：\n\n* 自闭合、未闭合、未知、放错位置或空的标记\n* 未知或错误的特性\n* 放错位置的文本\n\n示例：\n\n\n    /**\n     * 未知标记：List<String>\n     * 未闭合标记：error</b>\n     * 放错位置的文本或标记：<ul><li>one</li>, <li>two</li></ul>\n     * 错误或空的特性：<a href=\"\"></a>\n     * 自闭合标记：<br/>\n     * ...\n     */\n    void sample(){ }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JavadocHtmlLint",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassUnconnectedToPackage",
                "shortDescription": {
                  "text": "独立于其软件包的类"
                },
                "fullDescription": {
                  "text": "报告如下类：不依赖于其软件包中的任何其他类，也不是其软件包中任何其他类的依赖项。 这种类表明临时或不连贯的打包策略，并且通常可以有利地移动。 不报告作为其软件包中唯一类的类。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告如下类：不依赖于其软件包中的任何其他类，也不是其软件包中任何其他类的依赖项。 这种类表明临时或不连贯的打包策略，并且通常可以有利地移动。 不报告作为其软件包中唯一类的类。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassUnconnectedToPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 36,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionNameDoesntEndWithException",
                "shortDescription": {
                  "text": "异常类名不以 'Exception' 结尾"
                },
                "fullDescription": {
                  "text": "报告名称不以 'Exception' 结束的异常类。 示例：'class NotStartedEx extends Exception {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告名称不以 `Exception` 结束的异常类。\n\n**示例** ：`class NotStartedEx extends Exception {}`\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExceptionClassNameDoesntEndWithException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 61,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalStaticVariableUsedInClassInitialization",
                "shortDescription": {
                  "text": "在类初始化期间使用非 final static 字段"
                },
                "fullDescription": {
                  "text": "报告在类初始化期间使用 'final' 'static' 变量的情况。 在此类情况下，代码语义可能会依赖于类的创建顺序。 此外，此类情况可能会导致在变量初始化之前使用变量，并且通常会导致困难和令人困惑的错误。 示例： 'class Foo {\n    public static int bar = 0;\n\n    static {\n      System.out.println(bar);\n    }\n  }'",
                  "markdown": "报告在类初始化期间使用 `final` `static` 变量的情况。\n\n在此类情况下，代码语义可能会依赖于类的创建顺序。 此外，此类情况可能会导致在变量初始化之前使用变量，并且通常会导致困难和令人困惑的错误。\n\n**示例：**\n\n\n      class Foo {\n        public static int bar = 0;\n\n        static {\n          System.out.println(bar);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalStaticVariableUsedInClassInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadStopSuspendResume",
                "shortDescription": {
                  "text": "调用 'Thread.stop()'、'suspend()' 或 'resume()'"
                },
                "fullDescription": {
                  "text": "报告对 'Thread.stop()'、'Thread.suspend()' 和 'Thread.resume()' 的调用。 这些调用本质上容易导致数据损坏和死锁，强烈建议不要使用。 最好使用合作取消代替 'stop'，使用中断代替直接调用 'suspend' 和 'resume'。",
                  "markdown": "报告对 `Thread.stop()`、`Thread.suspend()` 和 `Thread.resume()` 的调用。\n\n\n这些调用本质上容易导致数据损坏和死锁，强烈建议不要使用。\n最好使用合作取消代替 `stop`，使用中断代替直接调用 `suspend` 和 `resume`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadStopSuspendOrResumeManager",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryTemporaryOnConversionFromString",
                "shortDescription": {
                  "text": "从 'String' 转换时有不必要的临时对象"
                },
                "fullDescription": {
                  "text": "报告从 'String' 转换为基元类型时创建的不必要的临时对象。 示例： 'new Integer(\"3\").intValue()' 在应用快速修复后： 'Integer.valueOf(\"3\")'",
                  "markdown": "报告从 `String` 转换为基元类型时创建的不必要的临时对象。\n\n**示例：**\n\n\n      new Integer(\"3\").intValue()\n\n在应用快速修复后：\n\n\n      Integer.valueOf(\"3\")\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryTemporaryOnConversionFromString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfConcreteClass",
                "shortDescription": {
                  "text": "具体类的使用"
                },
                "fullDescription": {
                  "text": "报告使用具体类而非接口的情况。 此类声明可能代表抽象失败，并可能使测试更加困难。 此检查不会报告其类来自系统或第三方库的声明。 'equals()' 方法实现中不会报告转换、instanceof 和局部变量。 此外，'clone()' 方法实现中不会报告转换。 示例： 'interface Entity {}\n  class EntityImpl implements Entity {}\n\n  void processObject(Object obj) {\n    // 警告：具体类的 instanceof\n    if (obj instanceof EntityImpl) {\n      // 警告：转换为具体类，\n      // 而不是接口\n      processEntity((EntityImpl)obj);\n    }\n  }\n  // 警告：具体类的形参\n  void processEntity(EntityImpl obj) {\n  }' 使用忽略抽象类类型选项可以忽略对抽象类的转换。 使用后续选项可控制报告问题的上下文。",
                  "markdown": "报告使用具体类而非接口的情况。 此类声明可能代表抽象失败，并可能使测试更加困难。\n\n\n此检查不会报告其类来自系统或第三方库的声明。\n`equals()` 方法实现中不会报告转换、instanceof 和局部变量。\n此外，`clone()` 方法实现中不会报告转换。\n\n示例：\n\n\n      interface Entity {}\n      class EntityImpl implements Entity {}\n\n      void processObject(Object obj) {\n        // 警告：具体类的 instanceof\n        if (obj instanceof EntityImpl) {\n          // 警告：转换为具体类，\n          // 而不是接口\n          processEntity((EntityImpl)obj);\n        }\n      }\n      // 警告：具体类的形参\n      void processEntity(EntityImpl obj) {\n      }\n\n\n使用**忽略抽象类类型**选项可以忽略对抽象类的转换。\n\n使用后续选项可控制报告问题的上下文。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLabeledSwitchRuleCodeBlock",
                "shortDescription": {
                  "text": "标记的 switch 规则具有冗余代码块"
                },
                "fullDescription": {
                  "text": "报告带有冗余代码块的 'switch' 语句或 'switch' 表达式的标记规则。 示例： 'String s = switch (n) {\n    case 1 -> { yield Integer.toString(n); }\n    default -> \"default\";\n  };' 在应用快速修复后： 'String s = switch (n) {\n    case 1 -> Integer.toString(n);\n    default -> \"default\";\n  };' 2019.1 最新变化 此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。",
                  "markdown": "报告带有冗余代码块的 `switch` 语句或 `switch` 表达式的标记规则。\n\n示例：\n\n\n      String s = switch (n) {\n        case 1 -> { yield Integer.toString(n); }\n        default -> \"default\";\n      };\n\n在应用快速修复后：\n\n\n      String s = switch (n) {\n        case 1 -> Integer.toString(n);\n        default -> \"default\";\n      };\n\n2019.1 最新变化\n\n此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantLabeledSwitchRuleCodeBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IOStreamConstructor",
                "shortDescription": {
                  "text": "可以使用 'Files' 方法构建 'InputStream' 和 'OutputStream'"
                },
                "fullDescription": {
                  "text": "报告可被分别替换为 'Files.newInputStream()' 或 'Files.newOutputStream()' 调用的 'new FileInputStream()' 或 'new FileOutputStream()' 表达式。 使用 'Files' 方法创建的流通常比使用流构造函数创建的流更有效。 示例： 'InputStream is = new BufferedInputStream(new FileInputStream(file));' 在应用快速修复后： 'InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));' 如果语言级别为 10 或更高，则此检查不会显示警告，但快速修复仍然可用。 仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。 2022.1 最新变化",
                  "markdown": "报告可被分别替换为 `Files.newInputStream()` 或 `Files.newOutputStream()` 调用的 `new FileInputStream()` 或 `new FileOutputStream()` 表达式。   \n使用 `Files` 方法创建的流通常比使用流构造函数创建的流更有效。\n\n示例：\n\n\n      InputStream is = new BufferedInputStream(new FileInputStream(file));\n\n在应用快速修复后：\n\n\n      InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));\n\n如果语言级别为 10 或更高，则此检查不会显示警告，但快速修复仍然可用。\n\n仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IOStreamConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToForLoopParameter",
                "shortDescription": {
                  "text": "赋值给 'for' 循环形参"
                },
                "fullDescription": {
                  "text": "报告对循环体内 'for' 循环形参的赋值或修改。 虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量引起。 该快速修复会添加新变量的声明。 示例： 'for (String s : list) {\n    // 警告：s 在循环内被更改\n    s = s.trim();\n    System.out.println(\"String: \" + s);\n  }' 在应用快速修复后： 'for (String s : list) {\n    String trimmed = s.trim();\n    System.out.println(\"String: \" + trimmed);\n  }' 不报告没有 update 语句的基本 'for' 循环中的赋值。 在此类情况下，赋值很可能是预期的，不能轻易移动到 'for' 循环的更新部分。 示例： 'for (int i = 0; i < list.size(); ) {\n    if (element.equals(list.get(i))) {\n      list.remove(i);\n    } else {\n      // 因为没有 update 语句\n      // 所以不报告 for 循环形参的修改\n      i++;\n    }\n  }' 使用检查增强型 'for' 循环形参选项可指定是否还应报告增强的 'for' 循环形参的修改。",
                  "markdown": "报告对循环体内 `for` 循环形参的赋值或修改。\n\n虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量引起。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      for (String s : list) {\n        // 警告：s 在循环内被更改\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      }\n\n在应用快速修复后：\n\n\n      for (String s : list) {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      }\n\n不报告没有 update 语句的基本 `for` 循环中的赋值。\n在此类情况下，赋值很可能是预期的，不能轻易移动到 `for` 循环的更新部分。\n\n**示例：**\n\n\n      for (int i = 0; i < list.size(); ) {\n        if (element.equals(list.get(i))) {\n          list.remove(i);\n        } else {\n          // 因为没有 update 语句\n          // 所以不报告 for 循环形参的修改\n          i++;\n        }\n      }\n\n使用**检查增强型 'for' 循环形参** 选项可指定是否还应报告增强的 `for` 循环形参的修改。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToForLoopParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9CollectionFactory",
                "shortDescription": {
                  "text": "不可变集合创建可被替换为集合工厂调用"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Collections' 不可修改的集合调用，这些调用可以转换为更新的集合工厂方法。 例如，这些可以替换为在 Java 9 中引入的 'List.of()' 或 'Set.of()' 或在 Java 10 中引入的 'List.copyOf()'。 请注意，与 'java.util.Collections' 方法相比，Java 9 集合工厂方法： 不接受 'null' 值。 需要唯一的集合元素和映射键。 不要接受 'null' 实参来查询返回集合的 'List.contains()' 或 'Map.get()' 等方法。 当这些情况被违反时，会抛出异常。 这可以在迁移后更改代码的语义。 示例： 'List<Integer> even = Collections.unmodifiableList(\n    Arrays.asList(2, 4, 6, 8, 10, 2));\n  List<Integer> evenCopy = Collections.unmodifiableList(\n    new ArrayList<>(list1));' 在应用快速修复后： 'List<Integer> even = List.of(2, 4, 6, 8, 10, 2);\n  List<Integer> evenCopy = List.copyOf(list);' 使用当内容为非常量时不发出警告选项可以仅在提供的实参是编译时常量的情况下报告。 这减少了行为改变的机会，因为并不总是可以静态检查原始元素是否唯一且为非 'null'。 使用建议 'Map.ofEntries' 选项可建议使用 'Map.ofEntries()' 替换超过 10 个条目的不可修改的映射。 2017.2 最新变化 此检查取决于 Java 功能 '集合工厂方法'，该功能自 Java 9 起可用。",
                  "markdown": "报告 `java.util.Collections` 不可修改的集合调用，这些调用可以转换为更新的集合工厂方法。 例如，这些可以替换为在 Java 9 中引入的 `List.of()` 或 `Set.of()` 或在 Java 10 中引入的 `List.copyOf()`。\n\n请注意，与 `java.util.Collections` 方法相比，Java 9 集合工厂方法：\n\n* 不接受 `null` 值。\n* 需要唯一的集合元素和映射键。\n* 不要接受 `null` 实参来查询返回集合的 `List.contains()` 或 `Map.get()` 等方法。\n\n当这些情况被违反时，会抛出异常。\n这可以在迁移后更改代码的语义。\n\n示例：\n\n\n      List<Integer> even = Collections.unmodifiableList(\n        Arrays.asList(2, 4, 6, 8, 10, 2));\n      List<Integer> evenCopy = Collections.unmodifiableList(\n        new ArrayList<>(list1));\n\n在应用快速修复后：\n\n\n      List<Integer> even = List.of(2, 4, 6, 8, 10, 2);\n      List<Integer> evenCopy = List.copyOf(list);\n\n\n使用**当内容为非常量时不发出警告** 选项可以仅在提供的实参是编译时常量的情况下报告。\n这减少了行为改变的机会，因为并不总是可以静态检查原始元素是否唯一且为非 `null`。\n\n\n使用**建议 'Map.ofEntries'** 选项可建议使用 `Map.ofEntries()` 替换超过 10 个条目的不可修改的映射。\n\n2017.2 最新变化\n\n此检查取决于 Java 功能 '集合工厂方法'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Java9CollectionFactory",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 9",
                      "index": 67,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MetaAnnotationWithoutRuntimeRetention",
                "shortDescription": {
                  "text": "不含 '@Retention(RUNTIME)' 注解的测试注解"
                },
                "fullDescription": {
                  "text": "报告 JUnit 5 应当使用的包含 'SOURCE' 或 'CLASS' 保留策略的注解。 此类注解在运行时不可用，很可能应当修正其保留策略，才能通过反射进行访问。 请注意，如果未指定保留策略，则使用默认保留策略 'CLASS'。 示例： '@Testable\n  public @interface UnitTest {}' 在应用快速修复后： '@Retention(RetentionPolicy.RUNTIME)\n  @Testable\n  public @interface UnitTest {}'",
                  "markdown": "报告 JUnit 5 应当使用的包含 `SOURCE` 或 `CLASS` 保留策略的注解。 此类注解在运行时不可用，很可能应当修正其保留策略，才能通过反射进行访问。\n\n请注意，如果未指定保留策略，则使用默认保留策略 `CLASS`。\n\n**示例：**\n\n\n      @Testable\n      public @interface UnitTest {}\n\n在应用快速修复后：\n\n\n      @Retention(RetentionPolicy.RUNTIME)\n      @Testable\n      public @interface UnitTest {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MetaAnnotationWithoutRuntimeRetention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JUnit",
                      "index": 69,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryContinue",
                "shortDescription": {
                  "text": "不必要的 'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告循环中最后能够到达的 'continue' 语句。 这些 'continue' 语句是不必要的语句，可以安全移除。 示例： 'for (String element: elements) {\n    System.out.println();\n    continue;\n  }' 在应用快速修复后： 'for (String element: elements) {\n    System.out.println();\n  }' 该检查不分析 JSP 文件。 使用在具有 'else' 分支的 'if' 语句的 then 分支中忽略选项可以忽略位于完整 'if'-'else' 语句的 'then' 分支中的 'continue'语句。 示例： 'for (String element: elements) {\n    if(element.isEmpty()) {\n      continue;\n    } else {\n      //...\n    }\n  }'",
                  "markdown": "报告循环中最后能够到达的 `continue` 语句。 这些 `continue` 语句是不必要的语句，可以安全移除。\n\n示例：\n\n\n      for (String element: elements) {\n        System.out.println();\n        continue;\n      }\n\n在应用快速修复后：\n\n\n      for (String element: elements) {\n        System.out.println();\n      }\n\n该检查不分析 JSP 文件。\n\n\n使用**在具有 'else' 分支的 'if' 语句的 then 分支中忽略** 选项可以忽略位于完整 `if`-`else` 语句的 `then` 分支中的 `continue`语句。\n\n示例：\n\n\n      for (String element: elements) {\n        if(element.isEmpty()) {\n          continue;\n        } else {\n          //...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryContinue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CStyleArrayDeclaration",
                "shortDescription": {
                  "text": "C 样式数组声明"
                },
                "fullDescription": {
                  "text": "报告以 C 样式语法编写的数组声明，其中数组中括号放置在变量名称之后或方法形参列表之后。 大多数代码样式更喜欢 Java 样式的数组声明，其中数组中括号放置在类型名称之后。 示例： 'public String process(String value[])[] {\n    return value;\n  }' 在应用快速修复后： 'public String[] process(String[] value) {\n    return value;\n  }' 配置检查： 使用 忽略变量中的C样式声明 选项仅报告方法返回类型的 C 样式数组声明。",
                  "markdown": "报告以 C 样式语法编写的数组声明，其中数组中括号放置在变量名称之后或方法形参列表之后。 大多数代码样式更喜欢 Java 样式的数组声明，其中数组中括号放置在类型名称之后。\n\n**示例：**\n\n\n      public String process(String value[])[] {\n        return value;\n      }\n\n在应用快速修复后：\n\n\n      public String[] process(String[] value) {\n        return value;\n      }\n\n配置检查：\n\n\n使用 **忽略变量中的C样式声明** 选项仅报告方法返回类型的 C 样式数组声明。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CStyleArrayDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemExit",
                "shortDescription": {
                  "text": "调用 'System.exit()' 或相关方法"
                },
                "fullDescription": {
                  "text": "报告对 'System.exit()'、'Runtime.exit()' 和 'Runtime.halt()' 的调用。 调用 'System.exit()' 或 'Runtime.exit()' 会调用关闭挂钩并终止当前运行的 Java 虚拟机。 调用 'Runtime.halt()' 会强行终止 JVM，而不会导致启动关闭挂钩。 这些方法中的每一种都应极其谨慎地使用。 对这些方法的调用使得调用代码对于大多数应用程序服务器来说不可移植。 使用该选项可以忽略主方法中的调用。",
                  "markdown": "报告对 `System.exit()`、`Runtime.exit()` 和 `Runtime.halt()` 的调用。\n\n\n调用 `System.exit()` 或 `Runtime.exit()` 会调用关闭挂钩并终止当前运行的 Java 虚拟机。 调用 `Runtime.halt()` 会强行终止 JVM，而不会导致启动关闭挂钩。\n这些方法中的每一种都应极其谨慎地使用。 对这些方法的调用使得调用代码对于大多数应用程序服务器来说不可移植。\n\n\n使用该选项可以忽略主方法中的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeclareCollectionAsInterface",
                "shortDescription": {
                  "text": "按类 (而不是接口) 声明的集合"
                },
                "fullDescription": {
                  "text": "报告使用集合类作为类型而不是使用相应接口进行的 'Collection' 变量的声明。 如果削弱变量类型会导致编译错误，则不发出警告。 示例： '// 警告：使用了具体集合类 ArrayList。\n  int getTotalLength(ArrayList<String> list) {\n    return list.stream().mapToInt(String::length).sum();\n  }\n\n  // 无警告，因为 trimToSize() 方法\n  // 在 List 接口中不可用\n  void addData(ArrayList<String> data) {\n    data.add(\"Hello\");\n    data.add(\"World\");\n    data.trimToSize();\n  }' 建议通过快速修复使用相应集合接口（例如 'Collection'、'Set' 或 'List'）。",
                  "markdown": "报告使用集合类作为类型而不是使用相应接口进行的 `Collection` 变量的声明。 如果削弱变量类型会导致编译错误，则不发出警告。\n\n示例：\n\n\n      // 警告：使用了具体集合类 ArrayList。\n      int getTotalLength(ArrayList<String> list) {\n        return list.stream().mapToInt(String::length).sum();\n      }\n\n      // 无警告，因为 trimToSize() 方法\n      // 在 List 接口中不可用\n      void addData(ArrayList<String> data) {\n        data.add(\"Hello\");\n        data.add(\"World\");\n        data.trimToSize();\n      }\n\n建议通过快速修复使用相应集合接口（例如 `Collection`、`Set` 或 `List`）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionDeclaredAsConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialStringConcatenation",
                "shortDescription": {
                  "text": "与空字符串串联"
                },
                "fullDescription": {
                  "text": "报告字符串串联中的空字符串操作数。 与空字符串的串联可以用于将非 'String' 对象或基元转换为 'String'，但使用 'String.valueOf()' 方法调用会更清晰。 建议通过快速修复来简化串联。 示例： 'void foo(int x, int y) {\n    String s = \"\" + x + \" ; \" + y;\n  }' 在应用快速修复后： 'void foo(int x, int y) {\n    String s = x + \" ; \" + y;\n  }' 使用仅报告无需其他更改即可移除空字符串的情况选项可以忽略移除空字符串需要添加另一个操作数的 'String.valueOf()' 转换的情况。",
                  "markdown": "报告字符串串联中的空字符串操作数。 与空字符串的串联可以用于将非 `String` 对象或基元转换为 `String`，但使用 `String.valueOf()` 方法调用会更清晰。\n\n\n建议通过快速修复来简化串联。\n\n**示例：**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\n在应用快速修复后：\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n\n\n使用**仅报告无需其他更改即可移除空字符串的情况** 选项可以忽略移除空字符串需要添加另一个操作数的 `String.valueOf()` 转换的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConcatenationWithEmptyString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousInvocationHandlerImplementation",
                "shortDescription": {
                  "text": "可疑的 'InvocationHandler' 实现"
                },
                "fullDescription": {
                  "text": "报告不代理 'hashCode()'、'equals()' 和 'toString()' 等标准 'Object' 方法的 'InvocationHandler' 的实现。 未能处理这些方法可能会在代理实例上调用它们时导致意外问题。 示例： 'InvocationHandler myHandler = (proxy, method, params) -> {\n    System.out.println(\"Hello World!\");\n    return null;\n  };\n  Runnable myProxy = (Runnable) Proxy.newProxyInstance(\n    Thread.currentThread().getContextClassLoader(),\n    new Class[] {Runnable.class}, myHandler\n  );' 此代码段的宗旨是仅代理 'Runnable.run()' 方法。 但是，也会代理对 'hashCode()' 等任何 'Object' 方法的调用。 这可能导致 'NullPointerException' 等问题，例如在将 'myProxy' 添加到 'HashSet' 时。 2020.2 最新变化",
                  "markdown": "报告不代理 `hashCode()`、`equals()` 和 `toString()` 等标准 `Object` 方法的 `InvocationHandler` 的实现。\n\n未能处理这些方法可能会在代理实例上调用它们时导致意外问题。\n\n**示例：**\n\n\n      InvocationHandler myHandler = (proxy, method, params) -> {\n        System.out.println(\"Hello World!\");\n        return null;\n      };\n      Runnable myProxy = (Runnable) Proxy.newProxyInstance(\n        Thread.currentThread().getContextClassLoader(),\n        new Class[] {Runnable.class}, myHandler\n      );\n\n\n此代码段的宗旨是仅代理 `Runnable.run()` 方法。\n但是，也会代理对 `hashCode()` 等任何 `Object` 方法的调用。\n这可能导致 `NullPointerException` 等问题，例如在将 `myProxy` 添加到 `HashSet` 时。\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousInvocationHandlerImplementation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnreachableCode",
                "shortDescription": {
                  "text": "不可到达的代码"
                },
                "fullDescription": {
                  "text": "根据数据流分析报告从未到达的代码。 可能是前一个始终为 true 或始终为 false 的条件、无法到达的循环主体或 catch 部分的结果。 通常（尽管并非总是）无法到达的代码是先前警告的结果，因此请检查形成“为 null 性和数据流问题”、“常量值”或“空容器上的冗余操作”的检查警告，以更好地了解原因。 示例： 'void finishApplication() {\n    System.exit(0);\n    System.out.println(\"Application is terminated\"); // 不可到达的代码\n  }' 请注意，此检查依赖于方法契约推断。 特别是，如果您调用总是引发异常的 static 或 final 方法，那么将推断出“总是失败”契约，并且方法调用之后的代码将被视为不可到达。 示例： 'void run() {\n    performAction();\n    System.out.println(\"Action is performed\"); // 不可到达的代码\n  }\n  \n  static void performAction() {\n    throw new AssertionError();\n  }' 如果使用任何类型的代码后处理，这可能会导致误报，例如，如果注解处理器稍后用有用的内容替换了方法体。 To avoid false-positive warnings, one may suppress the automatic contract inference with explicit '@org.jetbrains.annotations.Contract' annotation from 'org.jetbrains:annotations' package: 'void run() {\n    performAction();\n    System.out.println(\"Action is performed\"); // 不再有警告\n  }\n\n  @Contract(\"-> _\") // 实现将被替换\n  static void performAction() {\n    throw new AssertionError();\n  }' 2024.1 最新变化",
                  "markdown": "根据数据流分析报告从未到达的代码。 可能是前一个始终为 true 或始终为 false 的条件、无法到达的循环主体或 catch 部分的结果。 通常（尽管并非总是）无法到达的代码是先前警告的结果，因此请检查形成\"为 null 性和数据流问题\"、\"常量值\"或\"空容器上的冗余操作\"的检查警告，以更好地了解原因。\n\n示例：\n\n\n      void finishApplication() {\n        System.exit(0);\n        System.out.println(\"Application is terminated\"); // 不可到达的代码\n      }\n\n\n请注意，此检查依赖于方法契约推断。 特别是，如果您调用总是引发异常的 static 或 final 方法，那么将推断出\"总是失败\"契约，并且方法调用之后的代码将被视为不可到达。 示例：\n\n\n      void run() {\n        performAction();\n        System.out.println(\"Action is performed\"); // 不可到达的代码\n      }\n      \n      static void performAction() {\n        throw new AssertionError();\n      }\n\n\n如果使用任何类型的代码后处理，这可能会导致误报，例如，如果注解处理器稍后用有用的内容替换了方法体。 To avoid false-positive warnings, one may suppress the automatic\ncontract inference with explicit `@org.jetbrains.annotations.Contract` annotation from\n`org.jetbrains:annotations` package:\n\n\n      void run() {\n        performAction();\n        System.out.println(\"Action is performed\"); // 不再有警告\n      }\n\n      @Contract(\"-> _\") // 实现将被替换\n      static void performAction() {\n        throw new AssertionError();\n      }\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnreachableCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlTagCanBeJavadocTag",
                "shortDescription": {
                  "text": "'<code>...</code>' 可被替换为 '{@code ...}'"
                },
                "fullDescription": {
                  "text": "报告 '<code>' 标记在 Javadoc 注释中的用法。 从 Java 5 起，这些标记可以替换为 '{@code ...}' 结构。 这允许在注释中使用尖括号 '<' 和 '>' 而不是 HTML 字符实体。 示例： '/**\n   * @return empty <code>ArrayList&lt;Integer&gt;</code>\n   */\n  List<Integer> getList(){ ... }' 在应用快速修复后： '/**\n   * @return empty {@code ArrayList<Integer>}\n   */\n  List<Integer> getList(){ ... }'",
                  "markdown": "报告 `<code>` 标记在 Javadoc 注释中的用法。 从 Java 5 起，这些标记可以替换为 `{@code ...}` 结构。 这允许在注释中使用尖括号 `<` 和 `>` 而不是 HTML 字符实体。\n\n**示例：**\n\n\n      /**\n       * @return empty <code>ArrayList&lt;Integer&gt;</code>\n       */\n      List<Integer> getList(){ ... }\n\n在应用快速修复后：\n\n\n      /**\n       * @return empty {@code ArrayList<Integer>}\n       */\n      List<Integer> getList(){ ... }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlTagCanBeJavadocTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassEscapesItsScope",
                "shortDescription": {
                  "text": "类暴露在其可见性作用域之外"
                },
                "fullDescription": {
                  "text": "当字段或方法签名中的类的可见性不如使用它的成员的可见性时，报告该类的用法。 虽然此类成员是合法的 Java，但不能在它们引用的类类型的可见性作用域之外使用。 示例： 'public class Parent {\n    public Child getChild() {\n      return new Child();\n    }\n\n    private class Child {}\n  }' 此外，在 Java 9 和更高版本中，模块可以通过不导出它们的软件包来向其他模块隐藏它的某些类。 不过，如果属于导出的 API 的成员在其签名中引用了非导出类，则不能在模块外部使用此类成员。 配置检查： 使用报告在模块 API 中公开的非导出类(Java 9+) 选项可以报告公开非导出类的模块 API 成员。 请注意，对于此选项，项目或模块的语言级别必须为 9 或更高。 使用报告在公开 API 中公开的不可访问类选项可以报告公开可见性作用域较小的类的 public 成员。 使用报告在 package-local API 中公开的 private 类选项可以报告公开 'private' 类的 package-local 成员。",
                  "markdown": "当字段或方法签名中的类的可见性不如使用它的成员的可见性时，报告该类的用法。 虽然此类成员是合法的 Java，但不能在它们引用的类类型的可见性作用域之外使用。\n\n**示例：**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\n此外，在 Java 9 和更高版本中，模块可以通过不导出它们的软件包来向其他模块隐藏它的某些类。\n不过，如果属于导出的 API 的成员在其签名中引用了非导出类，则不能在模块外部使用此类成员。\n\n配置检查：\n\n* 使用**报告在模块 API 中公开的非导出类(Java 9+)** 选项可以报告公开非导出类的模块 API 成员。  \n  请注意，对于此选项，项目或模块的语言级别必须为 9 或更高。\n* 使用**报告在公开 API 中公开的不可访问类**选项可以报告公开可见性作用域较小的类的 public 成员。\n* 使用**报告在 package-local API 中公开的 private 类** 选项可以报告公开 `private` 类的 package-local 成员。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassEscapesDefinedScope",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'equals()' 中引用了非 final 字段"
                },
                "fullDescription": {
                  "text": "报告访问非 'final' 变量的 'equals()' 的实现。 此类访问可能导致 'equals()' 在该对象生命周期的不同时刻返回不同的结果，进而可能在使用标准集合类时导致问题。 示例： 'public class Person {\n    private String lastName;\n\n    @Override\n    public boolean equals(Object obj) {\n      ...\n      Person other = (Person) obj;\n      if (lastName == null) {\n        if (!lastName.equals(other.lastName)) {\n        return false;\n      ...\n      }\n    }\n  }'",
                  "markdown": "报告访问非 `final` 变量的 `equals()` 的实现。 此类访问可能导致 `equals()` 在该对象生命周期的不同时刻返回不同的结果，进而可能在使用标准集合类时导致问题。\n\n**示例：**\n\n\n      public class Person {\n        private String lastName;\n\n        @Override\n        public boolean equals(Object obj) {\n          ...\n          Person other = (Person) obj;\n          if (lastName == null) {\n            if (!lastName.equals(other.lastName)) {\n            return false;\n          ...\n          }\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldReferenceInEquals",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedAssignment",
                "shortDescription": {
                  "text": "嵌套赋值"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他表达式中的赋值表达式。 此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。 示例： 'String userName;\n  // 警告：使用了对 'userName' 赋值的结果\n  String message = \"Hello \" + (userName = \"Alice\") + \"!\"\n  System.out.println(message);\n  System.out.println(\"Goodbye \" + userName);'",
                  "markdown": "报告嵌套在其他表达式中的赋值表达式。\n\n此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。\n\n**示例：**\n\n\n      String userName;\n      // 警告：使用了对 'userName' 赋值的结果\n      String message = \"Hello \" + (userName = \"Alice\") + \"!\"\n      System.out.println(message);\n      System.out.println(\"Goodbye \" + userName);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoUnboxing",
                "shortDescription": {
                  "text": "自动拆箱"
                },
                "fullDescription": {
                  "text": "报告受拆箱转换（自动将对象解开为基元值）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。 示例： 'int x = new Integer(42);' 该快速修复会将转换设为显式： 'int x = new Integer(42).intValue();' 自动拆箱在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告受拆箱转换（自动将对象解开为基元值）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。\n\n**示例：**\n\n    int x = new Integer(42);\n\n该快速修复会将转换设为显式：\n\n    int x = new Integer(42).intValue();\n\n\n*自动拆箱*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AutoUnboxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldInImmutable",
                "shortDescription": {
                  "text": "'@Immutable' 类中有非 final 字段"
                },
                "fullDescription": {
                  "text": "报告包含 '@Immutable' 注解的类中的任何非 final 字段。 这违反了 '@Immutable' 注解的约定。 示例： 'import javax.annotation.concurrent.Immutable;\n  @Immutable\n  class Foo {\n    String bar = \"foo\";\n  }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告包含 `@Immutable` 注解的类中的任何非 final 字段。 这违反了 `@Immutable` 注解的约定。\n\n示例：\n\n\n      import javax.annotation.concurrent.Immutable;\n      @Immutable\n      class Foo {\n        String bar = \"foo\";\n      }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldInImmutable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 76,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInMessageFormatCall",
                "shortDescription": {
                  "text": "字符串串联作为 'MessageFormat.format()' 调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作对 'MessageFormat.format()' 的调用实参的非常量字符串串联。 虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中包含 '{' 等特殊字符时，甚至可能导致异常。 此外，有时这可能是在本应键入 ',' 时键入了 '+' 而错误串联字符串格式实参所致。 示例： 'String formatGreeting(String userName, int balance) {\n    return MessageFormat.format(\"Hello, \" + userName + \"! Your balance is {0}.\", balance);\n  }' 这里的 'userName' 解读为格式字符串的一部分，这可能导致 'IllegalArgumentException'（例如，如果 'userName' 为 '\"{\"'）。 此调用或许应当替换为 'MessageFormat.format(\"Hello, {0}! Your balance is {1}.\", userName, balance)'。",
                  "markdown": "报告用作对 `MessageFormat.format()` 的调用实参的非常量字符串串联。\n\n\n虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中包含 `{` 等特殊字符时，甚至可能导致异常。\n\n\n此外，有时这可能是在本应键入 `,` 时键入了 `+` 而错误串联字符串格式实参所致。\n\n**示例：**\n\n\n      String formatGreeting(String userName, int balance) {\n        return MessageFormat.format(\"Hello, \" + userName + \"! Your balance is {0}.\", balance);\n      }\n\n\n这里的 `userName` 解读为格式字符串的一部分，这可能导致 `IllegalArgumentException`（例如，如果 `userName` 为 `\"{\"`）。\n此调用或许应当替换为 `MessageFormat.format(\"Hello, {0}! Your balance is {1}.\", userName, balance)`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInMessageFormatCall",
                    "cweIds": [
                      116,
                      134
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToStringConcatCanBeReplacedByOperator",
                "shortDescription": {
                  "text": "对 'String.concat()' 的调用可被替换为 '+'"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.String.concat()' 的调用。 如果在带有常量实参的常量上调用该方法，可以将此类调用替换为 '+' 运算符，以提高清晰度和性能。 示例： 'String foo(String name) {\n    return name.concat(\"foo\");\n  }' 在应用快速修复后： 'String foo(String name) {\n    return name + \"foo\";\n  }'",
                  "markdown": "报告对 `java.lang.String.concat()` 的调用。\n\n\n如果在带有常量实参的常量上调用该方法，可以将此类调用替换为 `+` 运算符，以提高清晰度和性能。\n\n**示例：**\n\n\n      String foo(String name) {\n        return name.concat(\"foo\");\n      }\n\n在应用快速修复后：\n\n\n      String foo(String name) {\n        return name + \"foo\";\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToStringConcatCanBeReplacedByOperator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardcodedFileSeparators",
                "shortDescription": {
                  "text": "硬编码文件分隔符"
                },
                "fullDescription": {
                  "text": "报告字符串或字符文字中的正斜杠 ('/') 或反斜杠 ('\\')。 这些字符通常用作文件分隔符，如果它们被硬编码，则可移植性可能会受到影响。 该检查不会报告转义序列内的反斜杠和紧跟在 '<' 字符之后或紧接在 '>' 字符之前的正斜杠，因为它们通常表示 XML 或 HTML 标记而不是文件名。 表示 'java.util.TimeZone' ID 的字符串、作为有效正则表达式的字符串或与 IANA 注册的 MIME 媒体类型等效的字符串也不会被报告。 示例： 'new File(\"C:\\\\Users\\\\Name\");' 使用该选项可将 'example/*' 包含在已识别的媒体类型集中。 通常，在示例之外（例如在 'Content-Type' 标头中）使用 'example/*' MIME 媒体类型是错误的。",
                  "markdown": "报告字符串或字符文字中的正斜杠 (`/`) 或反斜杠 (`\\`)。 这些字符通常用作文件分隔符，如果它们被硬编码，则可移植性可能会受到影响。\n\n\n该检查不会报告转义序列内的反斜杠和紧跟在 '\\<' 字符之后或紧接在 '\\>' 字符之前的正斜杠，因为它们通常表示 XML 或 HTML 标记而不是文件名。\n表示 `java.util.TimeZone` ID 的字符串、作为有效正则表达式的字符串或与 IANA 注册的 MIME 媒体类型等效的字符串也不会被报告。\n\n**示例：**\n\n\n      new File(\"C:\\\\Users\\\\Name\");\n\n\n使用该选项可将 `example/*` 包含在已识别的媒体类型集中。\n通常，在示例之外（例如在 `Content-Type` 标头中）使用 `example/*` MIME 媒体类型是错误的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardcodedFileSeparator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingFloatingPointLiteral",
                "shortDescription": {
                  "text": "引起混淆的浮点文字"
                },
                "fullDescription": {
                  "text": "报告任何没有小数点的浮点数、小数点前的数字或小数点后的数字。 此类文字可能令人困惑，并且违反多种编码标准。 示例： 'double d = .03;' 在应用快速修复后： 'double d = 0.03;' 使用忽略科学记数法中的浮点文字选项可以忽略科学记数法中的浮点数。",
                  "markdown": "报告任何没有小数点的浮点数、小数点前的数字或小数点后的数字。\n\n此类文字可能令人困惑，并且违反多种编码标准。\n\n**示例：**\n\n    double d = .03;\n\n在应用快速修复后：\n\n    double d = 0.03;\n\n\n使用**忽略科学记数法中的浮点文字**选项可以忽略科学记数法中的浮点数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingFloatingPointLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocReference",
                "shortDescription": {
                  "text": "声明在Javadoc引用中有问题"
                },
                "fullDescription": {
                  "text": "报告 Javadoc 注释中未解析的引用。 在以下示例中，由于缺少 'someParam' 形参，将高亮显示该形参： 'class A {\n    /**\n     * @param someParam description\n     **/\n    void foo() {\n    }\n}' 禁用报告无法访问的符号选项，可忽略引用缺少的方法形参、类、字段和方法的标记。",
                  "markdown": "报告 Javadoc 注释中未解析的引用。\n\n在以下示例中，由于缺少 `someParam` 形参，将高亮显示该形参：\n\n\n    class A {\n        /**\n         * @param someParam description\n         **/\n        void foo() {\n        }\n    }\n\n\n禁用**报告无法访问的符号**选项，可忽略引用缺少的方法形参、类、字段和方法的标记。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingPlaceholderCountMatchesArgumentCount",
                "shortDescription": {
                  "text": "占位符数量与日志调用中的实参数量不匹配"
                },
                "fullDescription": {
                  "text": "报告 SLF4J、Log4j2 和 akka.event.LoggingAdapter 日志记录调用，例如 'logger.info(\"{}: {}\", key)'，其中记录器消息中 '{}' 占位符的数量与日志调用的其他实参的数量不匹配。 使用检查选项可以指定 SLF4J 使用哪个实现。 如果选择自动检查，则在类路径中搜索 'org.apache.logging.slf4j.Log4jLogger'。 如果找到此文件或选择是，将不为 SLFJ4 API 报告带有异常类型的最后一个形参具有占位符的情况。 例如： '//如果选中“是”选项，则不会报告此情况\nlog.error(\"For id {}: {}\", \"1\", new RuntimeException());' 在这种情况下，将使用 'toString()' 打印 'new RuntimeException()'（不会打印其堆栈跟踪）： 'For id 1: java.lang.RuntimeException' 否则，它将高亮显示，因为未使用最后一个占位符： 'For id 1: {}\njava.lang.RuntimeException: null' 否选项可用于在占位符用于异常时始终高亮显示此类情况，即使 'org.apache.logging.slf4j.Log4jLogger' 用作后端也是如此。 此选项仅适用于SLF4J。",
                  "markdown": "报告 SLF4J、Log4j2 和 akka.event.LoggingAdapter 日志记录调用，例如 `logger.info(\"{}: {}\", key)`，其中记录器消息中 `{}` 占位符的数量与日志调用的其他实参的数量不匹配。\n\n\n使用检查选项可以指定 SLF4J 使用哪个实现。\n如果选择**自动检查** ，则在类路径中搜索 `org.apache.logging.slf4j.Log4jLogger`。\n如果找到此文件或选择**是** ，将不为 SLFJ4 API 报告带有异常类型的最后一个形参具有占位符的情况。  \n\n例如：\n\n\n    //如果选中\"是\"选项，则不会报告此情况\n    log.error(\"For id {}: {}\", \"1\", new RuntimeException());\n\n在这种情况下，将使用 'toString()' 打印 'new RuntimeException()'（不会打印其堆栈跟踪）：\n\n\n    For id 1: java.lang.RuntimeException\n\n否则，它将高亮显示，因为未使用最后一个占位符：\n\n\n    For id 1: {}\n    java.lang.RuntimeException: null\n\n**否** 选项可用于在占位符用于异常时始终高亮显示此类情况，即使 `org.apache.logging.slf4j.Log4jLogger` 用作后端也是如此。  \n此选项仅适用于SLF4J。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingPlaceholderCountMatchesArgumentCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 40,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitArrayToString",
                "shortDescription": {
                  "text": "调用数组上的 'toString()'"
                },
                "fullDescription": {
                  "text": "报告 'String' 连接中使用的数组，或作为形参传递给 'java.io.PrintStream' 方法的数组，如 'System.out.println()'。 通常使用数组的内容，而不是使用数组对象本身。 示例： 'void print(Object[] objects) {\n    System.out.println(objects);\n  }' 在应用快速修复后： 'void print(Object[] objects) {\n    System.out.println(Arrays.toString(objects));\n  }'",
                  "markdown": "报告 `String` 连接中使用的数组，或作为形参传递给 `java.io.PrintStream` 方法的数组，如 `System.out.println()`。\n\n\n通常使用数组的内容，而不是使用数组对象本身。\n\n**示例：**\n\n\n      void print(Object[] objects) {\n        System.out.println(objects);\n      }\n\n在应用快速修复后：\n\n\n      void print(Object[] objects) {\n        System.out.println(Arrays.toString(objects));\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitArrayToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReuseOfLocalVariable",
                "shortDescription": {
                  "text": "局部变量的重用"
                },
                "fullDescription": {
                  "text": "报告使用与其原始用途无关的新值覆盖其值而进行“重用”的局部变量。 此类局部变量重用可能令人困惑，因为局部变量的预期语义可能随每种用法而异。 如果由于代码更改，视为被覆盖的值实际看似处于活动状态，它也可能容易出现错误。 保持变量生命周期尽可能短不失为一种好做法，不要为了简洁而重用局部变量。 示例： 'void x() {\n        String s = \"one\";\n        System.out.println(\"s = \" + s);\n        s = \"two\"; //重用局部变量 's'\n        System.out.println(\"s = \" + s);\n    }'",
                  "markdown": "报告使用与其原始用途无关的新值覆盖其值而进行\"重用\"的局部变量。\n\n此类局部变量重用可能令人困惑，因为局部变量的预期语义可能随每种用法而异。 如果由于代码更改，视为被覆盖的值实际看似处于活动状态，它也可能容易出现错误。 保持变量生命周期尽可能短不失为一种好做法，不要为了简洁而重用局部变量。\n\n示例：\n\n\n        void x() {\n            String s = \"one\";\n            System.out.println(\"s = \" + s);\n            s = \"two\"; //重用局部变量 's'\n            System.out.println(\"s = \" + s);\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReuseOfLocalVariable",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanMethodNameMustStartWithQuestion",
                "shortDescription": {
                  "text": "布尔方法名称必须以疑问词开头"
                },
                "fullDescription": {
                  "text": "报告名称不以疑问词开头的布尔方法。 此检查将忽略重写库方法的布尔方法。 示例： 'boolean empty(List<String> list) {\n  return list.isEmpty();\n}' 只能在编辑器中使用重命名此类方法的快速修复。 配置检查： 使用布尔方法名称前缀列表可指定布尔方法名称开头可以接受的疑问词。 使用忽略具有 'java.lang.Boolean' 返回类型的方法选项，可忽略返回类型为 'java.lang.Boolean' 的方法。 使用忽略 @&interface 中的布尔方法选项，可忽略注解返回类型 ('@interface') 的布尔方法。 使用忽略重写/实现 super 方法的方法选项，可忽略具有 super 方法的方法。",
                  "markdown": "报告名称不以疑问词开头的布尔方法。\n\n此检查将忽略重写库方法的布尔方法。\n\n**示例：**\n\n    boolean empty(List<String> list) {\n      return list.isEmpty();\n    }\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n配置检查：\n\n* 使用**布尔方法名称前缀**列表可指定布尔方法名称开头可以接受的疑问词。\n* 使用**忽略具有 'java.lang.Boolean' 返回类型的方法** 选项，可忽略返回类型为 `java.lang.Boolean` 的方法。\n* 使用**忽略 @\\&interface 中的布尔方法** 选项，可忽略注解返回类型 (`@interface`) 的布尔方法。\n* 使用**忽略重写/实现 super 方法的方法**选项，可忽略具有 super 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanMethodNameMustStartWithQuestion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnLocalVariableOrMethodParameter",
                "shortDescription": {
                  "text": "在局部变量或方法形参上同步"
                },
                "fullDescription": {
                  "text": "报告局部变量或形参的同步。 使用此类同步时，很难保证正确的运算。 可以改进此类代码，例如，通过使用 synchronized 包装器类控制访问或通过在字段上进行同步。 示例： 'void bar() {\n    final Object lock = new Object();\n    synchronized (lock) { }\n  }'",
                  "markdown": "报告局部变量或形参的同步。\n\n\n使用此类同步时，很难保证正确的运算。\n可以改进此类代码，例如，通过使用 synchronized 包装器类控制访问或通过在字段上进行同步。\n\n**示例：**\n\n\n      void bar() {\n        final Object lock = new Object();\n        synchronized (lock) { }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnLocalVariableOrMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalMethod",
                "shortDescription": {
                  "text": "不能重写方法"
                },
                "fullDescription": {
                  "text": "报告被声明为 'final' 的方法。 此类方法不能被重写，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 'final' 方法。",
                  "markdown": "报告被声明为 `final` 的方法。 此类方法不能被重写，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 `final` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedConditionalExpression",
                "shortDescription": {
                  "text": "否定条件表达式"
                },
                "fullDescription": {
                  "text": "报告使用前缀表达式否定的条件表达式，因为此类结构可能令人困惑。 可以通过修正将外部否定同时传播到两个分支。 示例： '!(i == 1 ? a : b)' 在应用快速修复后： 'i == 1 ? !a : !b'",
                  "markdown": "报告使用前缀表达式否定的条件表达式，因为此类结构可能令人困惑。\n\n可以通过修正将外部否定同时传播到两个分支。\n\n示例：\n\n\n      !(i == 1 ? a : b)\n\n在应用快速修复后：\n\n\n      i == 1 ? !a : !b\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousSystemArraycopy",
                "shortDescription": {
                  "text": "可疑的 'System.arraycopy()' 调用"
                },
                "fullDescription": {
                  "text": "报告对 'System.arraycopy()' 的可疑调用。 此类调用在以下情况下可疑： 源或目标非数组类型 源和目标的类型不同 复制的块长度大于 'src.length - srcPos' 复制的块长度大于 'dest.length - destPos' 当源和目标为同一个数组时，范围始终相交 示例： 'void foo() {\n    int[] src = new int[] { 1, 2, 3, 4 };\n    System.arraycopy(src, 0, src, 1, 2); // 警告：复制到具有相交范围的同一数组\n  }'",
                  "markdown": "报告对 `System.arraycopy()` 的可疑调用。\n\n此类调用在以下情况下可疑：\n\n* 源或目标非数组类型\n* 源和目标的类型不同\n* 复制的块长度大于 `src.length - srcPos`\n* 复制的块长度大于 `dest.length - destPos`\n* 当源和目标为同一个数组时，范围始终相交\n\n**示例：**\n\n\n      void foo() {\n        int[] src = new int[] { 1, 2, 3, 4 };\n        System.arraycopy(src, 0, src, 1, 2); // 警告：复制到具有相交范围的同一数组\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousSystemArraycopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbsoluteAlignmentInUserInterface",
                "shortDescription": {
                  "text": "AWT/Swing 代码中的绝对对齐"
                },
                "fullDescription": {
                  "text": "报告 AWT 和 Swing 中的绝对对齐常量的用法。 国际化应用程序使用相对对齐，因为它遵循区域设置组件的方向设置。 示例： 'JPanel panel = new JPanel(new BorderLayout(2, 2));\n  JLabel label = new JLabel(\"Hello World\");\n  panel.add(label, BorderLayout.NORTH);' 在应用快速修复后： 'JPanel panel = new JPanel(new BorderLayout(2, 2));\n  JLabel label = new JLabel(\"Hello World\");\n  panel.add(label, BorderLayout.PAGE_START);'",
                  "markdown": "报告 AWT 和 Swing 中的绝对对齐常量的用法。 国际化应用程序使用相对对齐，因为它遵循区域设置组件的方向设置。\n\n**示例：**\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.NORTH);\n\n在应用快速修复后：\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.PAGE_START);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbsoluteAlignmentInUserInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLambdaParameterType",
                "shortDescription": {
                  "text": "冗余 lambda 形参类型"
                },
                "fullDescription": {
                  "text": "报告由于可以从上下文中推断而冗余的 lambda 形参类型。 示例： 'Map<String, Integer> map = ...\n  map.forEach((String s, Integer i) -> log.info(s + \"=\" + i));' 该快速修复会从 lambda 中移除这些形参类型。 'Map<String, Integer> map = ...\n  map.forEach((s, i) -> log.info(s + \"=\" + i));'",
                  "markdown": "报告由于可以从上下文中推断而冗余的 lambda 形参类型。\n\n**示例：**\n\n\n      Map<String, Integer> map = ...\n      map.forEach((String s, Integer i) -> log.info(s + \"=\" + i));\n\n该快速修复会从 lambda 中移除这些形参类型。\n\n\n      Map<String, Integer> map = ...\n      map.forEach((s, i) -> log.info(s + \"=\" + i));\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantLambdaParameterType",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpression",
                "shortDescription": {
                  "text": "条件表达式"
                },
                "fullDescription": {
                  "text": "报告三元条件运算符的用法并建议将它们转换为 'if'/'else' 语句。 一些代码标准禁止使用条件运算符。 示例： 'Object result = (condition) ? foo() : bar();' 在应用快速修复后： 'Object result;\n  if (condition) {\n    comp = foo();\n  }\n  else {\n    comp = bar();\n  }' 配置检查： 使用 对简单赋值和返回值忽略 选项忽略简单的赋值和返回并允许以下结构： 'String s = (foo == null) ? \"\" : foo.toString();' 在不可能用 if 语句自动替换的上下文中（例如，当条件表达式用作 'super()' 构造函数调用），使用 忽略无法使用 if 语句的位置 选项来忽略条件表达式。",
                  "markdown": "报告三元条件运算符的用法并建议将它们转换为 `if`/`else` 语句。\n\n一些代码标准禁止使用条件运算符。\n\n示例：\n\n\n      Object result = (condition) ? foo() : bar();\n\n在应用快速修复后：\n\n\n      Object result;\n      if (condition) {\n        comp = foo();\n      }\n      else {\n        comp = bar();\n      }\n\n配置检查：\n\n使用 **对简单赋值和返回值忽略** 选项忽略简单的赋值和返回并允许以下结构：\n\n\n      String s = (foo == null) ? \"\" : foo.toString();\n\n\n在不可能用 if 语句自动替换的上下文中（例如，当条件表达式用作 `super()` 构造函数调用），使用 **忽略无法使用 if 语句的位置** 选项来忽略条件表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousReturnByteInputStream",
                "shortDescription": {
                  "text": "从 'InputStream.read()' 返回的可疑字节"
                },
                "fullDescription": {
                  "text": "报告从实现 'InputStream.read()' 方法的方法返回的 'byte' 类型的表达式。 这很可疑，因为 'InputStream.read()' 应返回范围从 '0' 到 '255' 的值，而字节类型的表达式包含从 '-128' 到 '127' 的值。 该快速修复会通过应用位掩码 '0xFF' 将表达式转换为无符号 'byte'。 示例： 'class MyInputStream extends InputStream {\n  int pos = 0;\n  byte[] data;\n\n  MyInputStream(byte[] input) {\n    data = input;\n  }\n\n  @Override\n  public int read() {\n    if (pos == data.length) {\n      return -1;\n    }\n    return data[pos++]; // 问题\n  }\n}' 应用快速修复后： 'class MyInputStream extends InputStream {\n  int pos = 0;\n  byte[] data;\n\n  MyInputStream(byte[] input) {\n    data = input;\n  }\n\n  @Override\n  public int read() {\n    if (pos == data.length) {\n      return -1;\n    }\n    return data[pos++] & 0xFF;\n  }\n}' 2023.2 最新变化",
                  "markdown": "报告从实现 `InputStream.read()` 方法的方法返回的 `byte` 类型的表达式。\n\n\n这很可疑，因为 `InputStream.read()` 应返回范围从 `0` 到 `255` 的值，而字节类型的表达式包含从 `-128` 到 `127` 的值。\n该快速修复会通过应用位掩码 `0xFF` 将表达式转换为无符号 `byte`。\n\n**示例：**\n\n\n    class MyInputStream extends InputStream {\n      int pos = 0;\n      byte[] data;\n\n      MyInputStream(byte[] input) {\n        data = input;\n      }\n\n      @Override\n      public int read() {\n        if (pos == data.length) {\n          return -1;\n        }\n        return data[pos++]; // 问题\n      }\n    }\n\n应用快速修复后：\n\n\n    class MyInputStream extends InputStream {\n      int pos = 0;\n      byte[] data;\n\n      MyInputStream(byte[] input) {\n        data = input;\n      }\n\n      @Override\n      public int read() {\n        if (pos == data.length) {\n          return -1;\n        }\n        return data[pos++] & 0xFF;\n      }\n    }\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousReturnByteInputStream",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfClone",
                "shortDescription": {
                  "text": "使用 'clone()' 或 'Cloneable'"
                },
                "fullDescription": {
                  "text": "报告 'clone()' 方法的实现、对它的调用，以及 'java.lang.Cloneable' 接口的使用。 某些编码标准禁止使用 'clone()'，建议改用复制构造函数或 'static' 工厂方法。 该检查会忽略在数组上对 'clone()' 的调用，因为这是一种正确而又紧凑的数组复制方式。 示例： 'class Copy implements Cloneable /*警告*/ {\n\n    public Copy clone() /*警告*/ {\n      try {\n        return (Copy) super.clone(); // 警告\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }'",
                  "markdown": "报告 `clone()` 方法的实现、对它的调用，以及 `java.lang.Cloneable` 接口的使用。\n\n某些编码标准禁止使用 `clone()`，建议改用复制构造函数或 `static` 工厂方法。\n\n该检查会忽略在数组上对 `clone()` 的调用，因为这是一种正确而又紧凑的数组复制方式。\n\n**示例：**\n\n\n      class Copy implements Cloneable /*警告*/ {\n\n        public Copy clone() /*警告*/ {\n          try {\n            return (Copy) super.clone(); // 警告\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 89,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingFinalNewline",
                "shortDescription": {
                  "text": "缺少最终新行"
                },
                "fullDescription": {
                  "text": "如果清单文件未按照 JAR 文件规范的要求以最后的换行符结尾，则报告。",
                  "markdown": "如果清单文件未按照 JAR 文件规范的要求以最后的换行符结尾，则报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MissingFinalNewline",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "清单",
                      "index": 90,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedTryStatement",
                "shortDescription": {
                  "text": "嵌套 'try' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'try' 语句。 嵌套的 'try' 语句可能会导致代码不清晰，并且可能会合并它们的 'catch' 和 'finally' 部分。",
                  "markdown": "报告嵌套的 `try` 语句。\n\n嵌套的 `try` 语句可能会导致代码不清晰，并且可能会合并它们的 `catch` 和 `finally` 部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedTryStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonStaticFinalLogger",
                "shortDescription": {
                  "text": "非常量记录器"
                },
                "fullDescription": {
                  "text": "报告未被声明为 'static' 和/或 'final' 的记录器字段。 确保每个类记录器都是有效的常量并绑定到该类可以简化为应用程序提供统一日志记录实现的任务。 提供了一个快速修复来将记录器修饰符更改为 'static final'。 示例： 'public class Significant {\n    private Logger LOG = Logger.getLogger(Critical.class);\n  }' 在应用快速修复后： 'public class Significant {\n    private static final Logger LOG = Logger.getLogger(Critical.class);\n  }' 配置检查： 使用记录器类名表可以指定记录器类名。 该检查将报告不是 'static' 和 'final' 并且类型等同于指定类名之一的字段。",
                  "markdown": "报告未被声明为 `static` 和/或 `final` 的记录器字段。 确保每个类记录器都是有效的常量并绑定到该类可以简化为应用程序提供统一日志记录实现的任务。\n\n提供了一个快速修复来将记录器修饰符更改为 `static final`。\n\n**示例：**\n\n\n      public class Significant {\n        private Logger LOG = Logger.getLogger(Critical.class);\n      }\n\n在应用快速修复后：\n\n\n      public class Significant {\n        private static final Logger LOG = Logger.getLogger(Critical.class);\n      }\n\n\n配置检查：\n\n* 使用**记录器类名** 表可以指定记录器类名。 该检查将报告不是 `static` 和 `final` 并且类型等同于指定类名之一的字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantLogger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 57,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpressionWithIdenticalBranches",
                "shortDescription": {
                  "text": "具有相同分支的条件表达式"
                },
                "fullDescription": {
                  "text": "报告包含相同 'then' 和 'else' 分支的条件表达式。 此类表达式几乎肯定表明有错误。 该检查提供了一种折叠条件表达式的修正。 示例： 'int y = x == 10 ? 4 : 4;' 在应用快速修复后： 'int y = 4;'",
                  "markdown": "报告包含相同 `then` 和 `else` 分支的条件表达式。\n\n此类表达式几乎肯定表明有错误。 该检查提供了一种折叠条件表达式的修正。\n\n示例：\n\n\n      int y = x == 10 ? 4 : 4;\n\n在应用快速修复后：\n\n\n      int y = 4;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionWithIdenticalBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OnlyOneElementUsed",
                "shortDescription": {
                  "text": "仅使用了一个元素"
                },
                "fullDescription": {
                  "text": "报告其中有且只有一个元素在创建时被查询的列表、数组和字符串。 此类表达式可能会在重构之后出现，并且通常可被替换为访问的元素。 示例： 'System.out.println(new int[] {1,2,3,4,5}[2]);' 在应用快速修复后： 'System.out.println(3);' 2022.3 最新变化",
                  "markdown": "报告其中有且只有一个元素在创建时被查询的列表、数组和字符串。 此类表达式可能会在重构之后出现，并且通常可被替换为访问的元素。\n\n示例：\n\n\n      System.out.println(new int[] {1,2,3,4,5}[2]);\n\n在应用快速修复后：\n\n\n      System.out.println(3);\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OnlyOneElementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBoxing",
                "shortDescription": {
                  "text": "不必要的装箱"
                },
                "fullDescription": {
                  "text": "报告显式装箱，即将基元值包装到对象中。 对于 Java 5 和更高版本，显式手动装箱不必要，并且可以安全移除。 示例： 'Integer i = new Integer(1);' → 'Integer i = Integer.valueOf(1);' 'int i = Integer.valueOf(1);' → 'int i = 1;' 使用仅报告真正多余的装箱表达式选项，可仅报告真正多余的装箱，其中的装箱值立即隐式或显式地拆箱。 在本例中，可以移除整个装箱-拆箱步骤。 该检查不报告简单的显式装箱。 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告显式装箱，即将基元值包装到对象中。\n\n对于 Java 5 和更高版本，显式手动装箱不必要，并且可以安全移除。\n\n**示例：**\n\n* `Integer i = new Integer(1);` → `Integer i = Integer.valueOf(1);`\n* `int i = Integer.valueOf(1);` → `int i = 1;`\n\n\n使用**仅报告真正多余的装箱表达式**选项，可仅报告真正多余的装箱，其中的装箱值立即隐式或显式地拆箱。\n在本例中，可以移除整个装箱-拆箱步骤。 该检查不报告简单的显式装箱。\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryBoxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionThrown",
                "shortDescription": {
                  "text": "已抛出禁止异常"
                },
                "fullDescription": {
                  "text": "报告抛出不适当异常的 'throw' 语句。 例如，异常可能因为过于通用而不适当，例如 'java.lang.Exception' 或 'java.io.IOException'。 示例： 'void setup(Mode mode) {\n      if (mode == null)\n          throw new RuntimeException(\"Problem during setup\"); // 警告：抛出了禁止的异常 'RuntimeException'\n      ...\n  }' 使用被禁止的异常列表可指定应报告哪些异常。",
                  "markdown": "报告抛出不适当异常的 `throw` 语句。 例如，异常可能因为过于通用而不适当，例如 `java.lang.Exception` 或 `java.io.IOException`。\n\n**示例：**\n\n\n      void setup(Mode mode) {\n          if (mode == null)\n              throw new RuntimeException(\"Problem during setup\"); // 警告：抛出了禁止的异常 'RuntimeException'\n          ...\n      }\n\n使用**被禁止的异常**列表可指定应报告哪些异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Anonymous2MethodRef",
                "shortDescription": {
                  "text": "匿名类型可被替换为方法引用"
                },
                "fullDescription": {
                  "text": "报告可以替换为方法引用的匿名类。 请注意，如果将匿名类转换为未绑定的方法引用，则 Java 运行时可以在后续调用期间重用相同的方法引用对象。 另一方面，使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 'HashMap' 键时。 示例： 'Runnable r = new Runnable() {\n    @Override\n    public void run() {\n      System.out.println();\n    }\n  };' 在应用快速修复后： 'Runnable r = System.out::println;' 使用在接口未使用 @FunctionalInterface 注解时报告选项可为未使用 '@FunctionalInterface' 注解的接口启用此检查。 此检查取决于 Java 功能 '方法引用'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为方法引用的匿名类。\n\n\n请注意，如果将匿名类转换为未绑定的方法引用，则 Java 运行时可以在后续调用期间重用相同的方法引用对象。 另一方面，使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 `HashMap` 键时。\n\n**示例：**\n\n\n      Runnable r = new Runnable() {\n        @Override\n        public void run() {\n          System.out.println();\n        }\n      };\n\n在应用快速修复后：\n\n\n      Runnable r = System.out::println;\n\n使用**在接口未使用 @FunctionalInterface 注解时报告** 选项可为未使用 `@FunctionalInterface` 注解的接口启用此检查。\n\n此检查取决于 Java 功能 '方法引用'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Anonymous2MethodRef",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicMethodNotExposedInInterface",
                "shortDescription": {
                  "text": "'public' 方法在接口中未公开"
                },
                "fullDescription": {
                  "text": "报告未在接口中公开的类中的 'public' 方法。 通过接口公开所有 'public' 方法对于维护松散耦合非常重要，某些基于组件的编程风格可能需要这样做。 示例： 'interface Person {\n  String getName();\n}\n\nclass PersonImpl implements Person {\n  private String name;\n\n  // 正常：方法在接口中公开\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  // 警告：方法为 public\n  // 但未在接口中公开\n  public void setName() {\n    this.name = name;\n  }\n}' 使用有注解时忽略列表可指定特殊注解。 此检查将忽略使用其中一种注解进行注解的方法。 使用如果包含类未实现非库接口，则忽略选项可以忽略未实现项目中任何接口的类中的方法。",
                  "markdown": "报告未在接口中公开的类中的 `public` 方法。\n\n通过接口公开所有 `public` 方法对于维护松散耦合非常重要，某些基于组件的编程风格可能需要这样做。\n\n示例：\n\n\n    interface Person {\n      String getName();\n    }\n\n    class PersonImpl implements Person {\n      private String name;\n\n      // 正常：方法在接口中公开\n      @Override\n      public String getName() {\n        return name;\n      }\n\n      // 警告：方法为 public\n      // 但未在接口中公开\n      public void setName() {\n        this.name = name;\n      }\n    }\n\n\n使用**有注解时忽略**列表可指定特殊注解。 此检查将忽略使用其中一种注解进行注解的方法。\n\n\n使用**如果包含类未实现非库接口，则忽略**选项可以忽略未实现项目中任何接口的类中的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicMethodNotExposedInInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableHasSerialVersionUIDField",
                "shortDescription": {
                  "text": "不带 'serialVersionUID' 的可序列化类"
                },
                "fullDescription": {
                  "text": "报告实现 'Serializable' 且不声明 'serialVersionUID' 字段的类。 如果没有 'serialVersionUID' 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。 示例： 'class Main implements Serializable {\n  }' 在应用快速修复后： 'class Main implements Serializable {\n      private static final long serialVersionUID = -1446398935944895849L;\n  }' 当使用 JDK 14 或更高版本的语言级别时，该快速修复还将添加 'java.io.Serial' 注解。 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告实现 `Serializable` 且不声明 `serialVersionUID` 字段的类。\n\n\n如果没有 `serialVersionUID` 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。\n\n**示例：**\n\n\n      class Main implements Serializable {\n      }\n\n在应用快速修复后：\n\n\n      class Main implements Serializable {\n          private static final long serialVersionUID = -1446398935944895849L;\n      }\n\n当使用 JDK 14 或更高版本的语言级别时，该快速修复还将添加 `java.io.Serial` 注解。\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "serial",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestCaseWithNoTestMethods",
                "shortDescription": {
                  "text": "没有测试的测试类"
                },
                "fullDescription": {
                  "text": "报告没有任何测试方法的非 'abstract' 测试用例。 此类测试用例通常表示未完成的代码，或者可能是应当移除的重构剩余代码。 示例： 'public class CrucialTest {\n    @Before\n    public void setUp() {\n      System.out.println(\"setting up\");\n    }\n  }' 使用忽略具有带测试方法的超类的测试用例选项可忽略具有带测试方法的超类的测试用例。",
                  "markdown": "报告没有任何测试方法的非 `abstract` 测试用例。 此类测试用例通常表示未完成的代码，或者可能是应当移除的重构剩余代码。\n\n示例：\n\n\n      public class CrucialTest {\n        @Before\n        public void setUp() {\n          System.out.println(\"setting up\");\n        }\n      }\n\n\n使用**忽略具有带测试方法的超类的测试用例**选项可忽略具有带测试方法的超类的测试用例。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestCaseWithNoTests",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedArrayReadWrite",
                "shortDescription": {
                  "text": "数组的读取和写入不匹配"
                },
                "fullDescription": {
                  "text": "报告其内容已读取但未更新或已更新但未读取的数组。 此类不一致读写毫无意义，可能表明死码、代码不完整或错误。 示例： 'final int[] bar = new int[3];\n  bar[2] = 3;'",
                  "markdown": "报告其内容已读取但未更新或已更新但未读取的数组。 此类不一致读写毫无意义，可能表明死码、代码不完整或错误。\n\n**示例：**\n\n\n      final int[] bar = new int[3];\n      bar[2] = 3;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedReadAndWriteOfArray",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedStaticUsage",
                "shortDescription": {
                  "text": "不必要的限定静态访问"
                },
                "fullDescription": {
                  "text": "报告不必要地使用类名限定的 static 成员的用法。 当 static 成员在周围类或周围类的超类中可用时，不需要对类进行限定。 此类限定可以安全移除。 示例： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      Foo.foo();\n      System.out.println(Foo.x);\n    }\n\n    static void baz() { Foo.foo(); }\n  }' 在应用快速修复后： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      foo();\n      System.out.println(x);\n    }\n\n    static void baz() { foo(); }\n  }' 使用检查选项可以切换以下各项的报告： static 字段访问： 'void bar() { System.out.println(Foo.x); }' 对 static 方法的调用： 'void bar() { Foo.foo(); }' 此外，您可以将检查配置为仅报告 static 上下文中的 static 成员用法。 在这种情况下，只会报告 'static void baz() { Foo.foo(); }'。",
                  "markdown": "报告不必要地使用类名限定的 static 成员的用法。\n\n\n当 static 成员在周围类或周围类的超类中可用时，不需要对类进行限定。 此类限定可以安全移除。\n\n**示例：**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\n\n使用检查选项可以切换以下各项的报告：\n\n* static 字段访问：  \n  `void bar() { System.out.println(Foo.x); }`\n\n* 对 static 方法的调用：  \n  `void bar() { Foo.foo(); }`\n\n\n此外，您可以将检查配置为仅报告 static 上下文中的 static 成员用法。 在这种情况下，只会报告 `static void baz() { Foo.foo(); }`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedStaticUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGetProperty",
                "shortDescription": {
                  "text": "对 'System.getProperty(str)' 的调用可以简化"
                },
                "fullDescription": {
                  "text": "报告方法 'System.getProperty(str)' 的用法，并在以下 2 种情况下提出修正建议： 'System.getProperty(\"path.separator\")' -> 'File.pathSeparator' 'System.getProperty(\"line.separator\")' -> 'System.lineSeparator()' 第二种方式不仅不太容易出错，而且可能更快，因为 'System.lineSeparator()' 返回缓存值，而 'System.getProperty(\"line.separator\")' 每次都调用属性（Hashtable 或 CHM，具体取决于实现）。",
                  "markdown": "报告方法 `System.getProperty(str)` 的用法，并在以下 2 种情况下提出修正建议：\n\n* `System.getProperty(\"path.separator\")` -\\> `File.pathSeparator`\n* `System.getProperty(\"line.separator\")` -\\> `System.lineSeparator()`\n\n第二种方式不仅不太容易出错，而且可能更快，因为 `System.lineSeparator()` 返回缓存值，而 `System.getProperty(\"line.separator\")` 每次都调用属性（Hashtable 或 CHM，具体取决于实现）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SystemGetProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionsMustHaveInitialCapacity",
                "shortDescription": {
                  "text": "没有初始容量的集合"
                },
                "fullDescription": {
                  "text": "报告在不指定初始容量的情况下实例化新 'Collection' 对象的尝试。 如果未指定初始容量，则使用默认容量，这很少是最佳选择。 如果在超出初始容量时需要重新分配空间和复制内存，则未能为集合指定初始容量可能会导致性能问题。 此检查会检查在检查的设置中列出的类的分配。 示例： 'new HashMap<String, String>();' 使用以下选项配置检查： 列出应检查的集合类。 是否忽略字段初始值设定项。",
                  "markdown": "报告在不指定初始容量的情况下实例化新 `Collection` 对象的尝试。\n\n\n如果未指定初始容量，则使用默认容量，这很少是最佳选择。 如果在超出初始容量时需要重新分配空间和复制内存，则未能为集合指定初始容量可能会导致性能问题。\n此检查会检查在检查的设置中列出的类的分配。\n\n**示例：**\n\n\n      new HashMap<String, String>();\n\n使用以下选项配置检查：\n\n* 列出应检查的集合类。\n* 是否忽略字段初始值设定项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionWithoutInitialCapacity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassOnlyUsedInOneModule",
                "shortDescription": {
                  "text": "仅在其他模块中使用的类"
                },
                "fullDescription": {
                  "text": "报告符合以下情况的类： 不依赖于其模块中的任何其他类 依赖于来自不同模块的类 仅是来自该其他模块的类的依赖项 这种类可以移动到它们所依赖的模块中。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告符合以下情况的类：\n\n* 不依赖于其模块中的任何其他类\n* 依赖于来自不同模块的类\n* 仅是来自该其他模块的类的依赖项\n\n这种类可以移动到它们所依赖的模块中。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassOnlyUsedInOneModule",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryStatementWithMultipleResources",
                "shortDescription": {
                  "text": "可以拆分具有多个资源的 'try' 语句"
                },
                "fullDescription": {
                  "text": "报告带有多个资源的 'try' 语句，这些语句可以自动拆分为多条 try-with-resources 语句。 这种转换对于进一步重构很有用 （例如，用于将嵌套的 'try' 语句提取到单独的方法中）。 示例： 'try (FileInputStream in = new FileInputStream(\"in.txt\");\n     FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n     /*读取和写入*/\n  }' 在应用快速修复后： 'try (FileInputStream in = new FileInputStream(\"in.txt\")) {\n    try (FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n      /*读取和写入*/\n    }\n  }'",
                  "markdown": "报告带有多个资源的 `try` 语句，这些语句可以自动拆分为多条 try-with-resources 语句。\n\n这种转换对于进一步重构很有用 （例如，用于将嵌套的 `try` 语句提取到单独的方法中）。\n\n示例：\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\");\n         FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n         /*读取和写入*/\n      }\n\n在应用快速修复后：\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\")) {\n        try (FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n          /*读取和写入*/\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TryStatementWithMultipleResources",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeMayBeWeakened",
                "shortDescription": {
                  "text": "类型可能被削弱"
                },
                "fullDescription": {
                  "text": "报告可以更改为更抽象（更弱）类型的变量和方法返回类型。 这使代码更抽象，因此可重用性更高。 示例： '// 形参类型可以削弱为 java.util.List\n  void processList(ArrayList<String> list) {\n    if (list.isEmpty()) return;\n    System.out.println(\"Processing\");\n    for (String s : list) {\n      System.out.println(\"String: \" + s);\n    }\n  }' 启用下面的仅削弱为接口复选框可以仅在类型可以削弱为接口类型时报告问题。 启用下面的不建议削弱声明为 'var' 的变量复选框可以防止报告使用 'var' 关键字声明的局部变量 (Java 10+) 停止类意在防止类削弱至低于停止类的程度，即便可能出现这种情况，也能予以防止。 在某些情况下，这可能会提高可读性。",
                  "markdown": "报告可以更改为更抽象（更弱）类型的变量和方法返回类型。 这使代码更抽象，因此可重用性更高。\n\n示例：\n\n\n      // 形参类型可以削弱为 java.util.List\n      void processList(ArrayList<String> list) {\n        if (list.isEmpty()) return;\n        System.out.println(\"Processing\");\n        for (String s : list) {\n          System.out.println(\"String: \" + s);\n        }\n      }\n\n\n启用下面的**仅削弱为接口**复选框可以仅在类型可以削弱为接口类型时报告问题。\n\n\n启用下面的**不建议削弱声明为 'var' 的变量**复选框可以防止报告使用 'var' 关键字声明的局部变量 (Java 10+)\n\n\n**停止类**意在防止类削弱至低于停止类的程度，即便可能出现这种情况，也能予以防止。\n在某些情况下，这可能会提高可读性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeMayBeWeakened",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneableImplementsClone",
                "shortDescription": {
                  "text": "没有 'clone()' 方法的可克隆类"
                },
                "fullDescription": {
                  "text": "报告实现 'Cloneable' 接口但不重写 'clone()' 方法的类。 这种类使用 'clone()' 的默认实现，它不是 'public'，而是 'protected'，并且不复制该类的可变状态。 可以通过快速修复生成基本的 'clone()' 方法，它可以作为 'Cloneable' 类所期望的正常运行的 'clone()' 方法的基础。 示例： 'public class Data implements Cloneable {\n    private String[] names;\n  }' 在应用快速修复后： 'public class Data implements Cloneable {\n    private String[] names;\n\n    @Override\n    public Data clone() {\n      try {\n        Data clone = (Data) super.clone();\n        // TODO：在此处复制可变状态，因此克隆无法更改原始克隆的内部项 \n         return clone;\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }' 使用忽略由于继承而可克隆的类选项可以忽略因继承自 'Cloneable' 类而 'Cloneable' 的类。 使用忽略需要 Cloneable 才能调用超类的 clone() 方法的情况选项可以忽略因从超类调用 'clone()' 方法而需要实现 'Cloneable' 的类。",
                  "markdown": "报告实现 `Cloneable` 接口但不重写 `clone()` 方法的类。\n\n这种类使用 `clone()` 的默认实现，它不是 `public`，而是 `protected`，并且不复制该类的可变状态。\n\n可以通过快速修复生成基本的 `clone()` 方法，它可以作为 `Cloneable` 类所期望的正常运行的 `clone()` 方法的基础。\n\n**示例：**\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n      }\n\n在应用快速修复后：\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n\n        @Override\n        public Data clone() {\n          try {\n            Data clone = (Data) super.clone();\n            // TODO：在此处复制可变状态，因此克隆无法更改原始克隆的内部项 \n             return clone;\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\n使用**忽略由于继承而可克隆的类** 选项可以忽略因继承自 `Cloneable` 类而 `Cloneable` 的类。\n\n使用**忽略需要 Cloneable 才能调用超类的 clone() 方法的情况** 选项可以忽略因从超类调用 `clone()` 方法而需要实现 `Cloneable` 的类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneableClassWithoutClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 89,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OctalAndDecimalIntegersMixed",
                "shortDescription": {
                  "text": "同一数组中的八进制和十进制整数"
                },
                "fullDescription": {
                  "text": "报告单个数组初始值设定项中混合的八进制和十进制整数文字。 当您将数字列表复制到数组初始值设定项中时，可能会发生这种情况。 数组中的某些数字可能用零填充，编译器会将它们解释为八进制。 示例： 'int[] elapsed = {1, 13, 052};' 应用移除前导零的快速修复后： 'int[] elapsed = {1, 13, 52};' 如果它是一个八进制数（例如，在内联变量之后），那么您可以使用另一个将八进制转换为十进制的快速修复： 'int[] elapsed = {1, 13, 42};'",
                  "markdown": "报告单个数组初始值设定项中混合的八进制和十进制整数文字。 当您将数字列表复制到数组初始值设定项中时，可能会发生这种情况。 数组中的某些数字可能用零填充，编译器会将它们解释为八进制。\n\n**示例：**\n\n    int[] elapsed = {1, 13, 052};\n\n应用移除前导零的快速修复后：\n\n    int[] elapsed = {1, 13, 52};\n\n如果它是一个八进制数（例如，在内联变量之后），那么您可以使用另一个将八进制转换为十进制的快速修复：\n`int[] elapsed = {1, 13, 42};`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OctalAndDecimalIntegersInSameArray",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Deprecation",
                "shortDescription": {
                  "text": "弃用的 API 用法"
                },
                "fullDescription": {
                  "text": "报告已弃用类、字段和方法的用法。 当可以从已弃用成员的 Javadoc 中提取必要的信息时，可以使用快速修复来自动转换已弃用的用法。 示例： 'class Interesting {\n\n    /**\n     * @deprecated 改用 {@link #newHotness()}\n     */\n    @Deprecated\n    public void oldAndBusted() {}\n\n    public void newHotness() {}\n  }\n  class ElseWhere {\n    void x(Interesting i) {\n      i.oldAndBusted(); // 此处为已弃用警告\n    }\n  }' 在应用快速修复后： 'class Interesting {\n\n    /**\n     * @deprecated 改用 {@link #newHotness()}\n     */\n    @Deprecated\n    public void oldAndBusted() {}\n\n    public void newHotness() {}\n  }\n  class ElseWhere {\n    void x(Interesting i) {\n      i.newHotness();\n    }\n  }' 默认情况下，如果不可能或很难避免，则检查不会发出警告。 比如下面的代码就不会被报告： 'abstract class A { //库代码\n     @Deprecated\n     abstract void m();\n  }\n  class B extends A { //项目代码\n     @Override\n     void m() {\n        //doSmth;\n     }\n  }' 配置检查： 使用选项可以在弃用成员、abstract 弃用方法重写、非 static import 语句、弃用类的方法或相同的顶级类中禁用此检查。",
                  "markdown": "报告已弃用类、字段和方法的用法。 当可以从已弃用成员的 Javadoc 中提取必要的信息时，可以使用快速修复来自动转换已弃用的用法。\n\n**示例：**\n\n\n      class Interesting {\n\n        /**\n         * @deprecated 改用 {@link #newHotness()}\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.oldAndBusted(); // 此处为已弃用警告\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Interesting {\n\n        /**\n         * @deprecated 改用 {@link #newHotness()}\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.newHotness();\n        }\n      }\n\n默认情况下，如果不可能或很难避免，则检查不会发出警告。 比如下面的代码就不会被报告：\n\n\n      abstract class A { //库代码\n         @Deprecated\n         abstract void m();\n      }\n      class B extends A { //项目代码\n         @Override\n         void m() {\n            //doSmth;\n         }\n      }\n\n配置检查：\n\n\n使用选项可以在弃用成员、abstract 弃用方法重写、非 static import 语句、弃用类的方法或相同的顶级类中禁用此检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "deprecation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionSignal",
                "shortDescription": {
                  "text": "调用 'signal()' 而不是 'signalAll()'"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.concurrent.locks.Condition.signal()' 的调用。 虽然偶尔有用，但在几乎所有情况下，'signalAll()' 都是更好、更安全的选择。",
                  "markdown": "报告对 `java.util.concurrent.locks.Condition.signal()` 的调用。 虽然偶尔有用，但在几乎所有情况下，`signalAll()` 都是更好、更安全的选择。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSignalInsteadOfSignalAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicMethodWithoutLogging",
                "shortDescription": {
                  "text": "'public' 方法没有日志记录"
                },
                "fullDescription": {
                  "text": "报告任何不包含日志记录语句的 public 方法。 此检查不报告简单的 getter 和 setter。 示例： 'public class Crucial {\n    private static final Logger LOG = LoggerFactory.getLogger(Crucial.class);\n    public void doImportantStuff() {\n      // 对此方法发出警告\n    }\n\n    public void doOtherStuff() {\n      LOG.info(\"do other stuff\");\n    }\n  }' 使用下表可指定 Logger 类名。 此检查将报告不使用指定类的实例方法的 public 方法。",
                  "markdown": "报告任何不包含日志记录语句的 public 方法。 此检查不报告简单的 getter 和 setter。\n\n示例：\n\n\n      public class Crucial {\n        private static finalLogger LOG = LoggerFactory.getLogger(Crucial.class);\n        public void doImportantStuff() {\n          // 对此方法发出警告\n        }\n\n        public void doOtherStuff() {\n          LOG.info(\"do other stuff\");\n        }\n      }\n\n\n使用下表可指定 Logger 类名。\n此检查将报告不使用指定类的实例方法的 public 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicMethodWithoutLogging",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 57,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNestingDepth",
                "shortDescription": {
                  "text": "内部类嵌套太深"
                },
                "fullDescription": {
                  "text": "报告嵌套内部类的数量超过指定最大值的类。 将内部类嵌套在其他内部类中令人困惑，并表明可能有必要重构。 使用嵌套限制字段可指定类允许的最大嵌套深度。",
                  "markdown": "报告嵌套内部类的数量超过指定最大值的类。\n\n将内部类嵌套在其他内部类中令人困惑，并表明可能有必要重构。\n\n使用**嵌套限制**字段可指定类允许的最大嵌套深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassTooDeeplyNested",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterTypeCanBeSpecified",
                "shortDescription": {
                  "text": "可以指定 lambda 形参类型"
                },
                "fullDescription": {
                  "text": "报告未指定其类型的 lambda 形参并建议添加缺少的类型声明。 示例： 'Function<String, Integer> length = a -> a.length();' 在应用快速修复后： 'Function<String, Integer> length = (String a) -> a.length();' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告未指定其类型的 lambda 形参并建议添加缺少的类型声明。\n\n示例：\n\n\n      Function<String, Integer> length = a -> a.length();\n\n在应用快速修复后：\n\n\n      Function<String, Integer> length = (String a) -> a.length();\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaParameterTypeCanBeSpecified",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextLabelInSwitchStatement",
                "shortDescription": {
                  "text": "'switch' 语句中的文本标签"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句中的标签语句。 虽然偶尔是有意为之，但此结构通常由拼写错误所致。 示例： 'switch (x) {\n      case 1:\n      case2:   // 警告：'switch' 语句中存在文本标签 'case2:'\n      case 3:\n          break;\n  }'",
                  "markdown": "报告 `switch` 语句中的标签语句。 虽然偶尔是有意为之，但此结构通常由拼写错误所致。\n\n**示例：**\n\n\n      switch (x) {\n          case 1:\n          case2:   // 警告：'switch' 语句中存在文本标签 'case2:'\n          case 3:\n              break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TextLabelInSwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageVisibleInnerClass",
                "shortDescription": {
                  "text": "软件包可见的嵌套类"
                },
                "fullDescription": {
                  "text": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的嵌套类。 示例： 'public class Outer {\n    static class Nested {}  // 警告\n    class Inner {}          // 警告\n    enum Mode {}            // 警告取决于设置\n    interface I {}          // 警告取决于设置\n  }' 配置检查： 使用忽略软件包可见的内部枚举选项可忽略 package-private 内部枚举。 使用忽略软件包可见的内部接口选项可忽略 package-private 内部接口。",
                  "markdown": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的嵌套类。\n\n**示例：**\n\n\n      public class Outer {\n        static class Nested {}  // 警告\n        class Inner {}          // 警告\n        enum Mode {}            // 警告取决于设置\n        interface I {}          // 警告取决于设置\n      }\n\n配置检查：\n\n* 使用**忽略软件包可见的内部枚举**选项可忽略 package-private 内部枚举。\n* 使用**忽略软件包可见的内部接口**选项可忽略 package-private 内部接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageVisibleInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnaryMinus",
                "shortDescription": {
                  "text": "不必要的一元负号"
                },
                "fullDescription": {
                  "text": "报告不必要的一元减号。 此类表达式可能难以理解并且可能包含错误。 示例： 'void unaryMinus(int i) {\n    int x = - -i;\n  }' 此处建议使用以下快速修复： 移除 'i' 变量前的 '-' 运算符： 'void unaryMinus(int i) {\n    int x = i;\n  }' 使用前缀递减运算符替换 '-' 运算符： 'void unaryMinus(int i) {\n    int x = --i;\n  }' 另一个示例： 'void unaryMinus(int i) {\n    i += - 8;\n  }' 在应用快速修复后： 'void unaryMinus(int i) {\n    i -= 8;\n  }'",
                  "markdown": "报告不必要的一元减号。 此类表达式可能难以理解并且可能包含错误。\n\n**示例：**\n\n    void unaryMinus(int i) {\n        int x = - -i;\n      }\n\n此处建议使用以下快速修复：\n\n* 移除 `i` 变量前的 `-` 运算符：\n\n      void unaryMinus(int i) {\n          int x = i;\n        }\n\n* 使用前缀递减运算符替换 `-` 运算符：\n\n      void unaryMinus(int i) {\n          int x = --i;\n        }\n\n**另一个示例：**\n\n    void unaryMinus(int i) {\n        i += - 8;\n      }\n\n在应用快速修复后：\n\n    void unaryMinus(int i) {\n        i -= 8;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnaryMinus",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodMayBeStatic",
                "shortDescription": {
                  "text": "方法可以为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以安全设置为 'static' 的方法。 尽可能将方法设置为 static 可减少内存消耗并提高代码质量。 如果满足以下条件，则方法可以为 'static'： 不是 'synchronized'、'native' 或 'abstract'， 不引用包含类中的任何非 static 方法和非 static 字段， 不是重写，也不会在子类中被重写。 使用以下选项配置检查： 是否只报告 'private' 和 'final' 方法，从而提高此检查的性能。 是否忽略空方法。 使用 Java 8 或更高版本时是否忽略接口中的默认方法。 是否让该快速修复在调用被设为 'static' 的方法时使用类引用替换实例限定符，即调用 'myClass.m()' 将被替换为 'MyClass.m()'。",
                  "markdown": "报告可以安全设置为 `static` 的方法。 尽可能将方法设置为 static 可减少内存消耗并提高代码质量。\n\n如果满足以下条件，则方法可以为 `static`：\n\n* 不是 `synchronized`、`native` 或 `abstract`，\n* 不引用包含类中的任何非 static 方法和非 static 字段，\n* 不是重写，也不会在子类中被重写。\n\n使用以下选项配置检查：\n\n* 是否只报告 `private` 和 `final` 方法，从而提高此检查的性能。\n* 是否忽略空方法。\n* 使用 Java 8 或更高版本时是否忽略接口中的默认方法。\n* 是否让该快速修复在调用被设为 `static` 的方法时使用类引用替换实例限定符，即调用 `myClass.m()` 将被替换为 `MyClass.m()`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestMethodWithoutAssertion",
                "shortDescription": {
                  "text": "不带断言的测试方法"
                },
                "fullDescription": {
                  "text": "报告不包含任何断言的测试方法。 此类方法可能表示测试用例不完整或薄弱。 示例： 'public class ExtensiveTest {\n\n    @Test\n    public void testAlive() {\n      System.out.println(\"nothing\");\n    }\n  }' 配置检查： 使用该表可以指定应作为断言的完全限定类名和方法名正则表达式的组合。 类名也匹配子类。 使用 'assert' 关键字被视为断言选项可以指定是否应将使用 'assert' 关键字的 Java 'assert' 语句视为断言。 使用忽略声明异常的测试方法选项可以忽略声明异常的测试方法。 当您的测试会在失败时抛出异常并因此不需要任何断言时，这会很有用。",
                  "markdown": "报告不包含任何断言的测试方法。 此类方法可能表示测试用例不完整或薄弱。\n\n**示例：**\n\n\n      public class ExtensiveTest {\n\n        @Test\n        public void testAlive() {\n          System.out.println(\"nothing\");\n        }\n      }\n\n\n配置检查：\n\n* 使用该表可以指定应作为断言的完全限定类名和方法名正则表达式的组合。 类名也匹配子类。\n* 使用 **'assert' 关键字被视为断言** 选项可以指定是否应将使用 `assert` 关键字的 Java `assert` 语句视为断言。\n* 使用**忽略声明异常的测试方法**选项可以忽略声明异常的测试方法。 当您的测试会在失败时抛出异常并因此不需要任何断言时，这会很有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestMethodWithoutAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EscapedSpace",
                "shortDescription": {
                  "text": "'\\s' 转义序列的非终止使用"
                },
                "fullDescription": {
                  "text": "报告在除文本块行结尾以外的任何位置或在一系列多个转义空格内的 '\\s' 转义序列。 此类用法可能会造成困惑或出错，尤其是在将字符串解释为正则表达式的情况下。 '\\s' 转义序列用于在文本块行末尾编码一个空格，其中，普通空格将被修剪。 在其他位置，以及在常规字符串或字符文字中，'\\s' 与普通空格字符 ('\" \"') 相同。 示例： 'if (str.matches(\"\\s+\")) {...}' 在这里，'\"\\\\s+\"' 可能是有意为之（以匹配任何空白字符）。 如果不是，使用 'str.matches(\" +\")' 则不那么容易造成困惑。 提供的快速修复是将 '\\s' 转义替换为空格字符。 2022.3 最新变化 此检查取决于 Java 功能 ''\\s'转义序列'，该功能自 Java 15 起可用。",
                  "markdown": "报告在除文本块行结尾以外的任何位置或在一系列多个转义空格内的 `\\s` 转义序列。 此类用法可能会造成困惑或出错，尤其是在将字符串解释为正则表达式的情况下。 `\\s` 转义序列用于在文本块行末尾编码一个空格，其中，普通空格将被修剪。 在其他位置，以及在常规字符串或字符文字中，`\\s` 与普通空格字符 (`\" \"`) 相同。\n\n**示例：**\n\n\n      if (str.matches(\"\\s+\")) {...}\n\n在这里，`\"\\\\s+\"` 可能是有意为之（以匹配任何空白字符）。 如果不是，使用 `str.matches(\" +\")` 则不那么容易造成困惑。\n\n\n提供的快速修复是将 `\\s` 转义替换为空格字符。\n\n2022.3 最新变化\n\n此检查取决于 Java 功能 ''\\\\s'转义序列'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EscapedSpace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatement",
                "shortDescription": {
                  "text": "'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告 'continue' 语句。 'continue' 语句导致重构复杂化，可能令人困惑。 示例： 'void foo(List<String> strs) {\n    for (String str : strs) {\n      if (str.contains(\"skip\")) continue;\n      handleStr(str);\n    }\n  }'",
                  "markdown": "报告 `continue` 语句。\n\n`continue` 语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n      void foo(List<String> strs) {\n        for (String str : strs) {\n          if (str.contains(\"skip\")) continue;\n          handleStr(str);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisorderedAssertEqualsArguments",
                "shortDescription": {
                  "text": "顺序错误的 'assertEquals()' 实参"
                },
                "fullDescription": {
                  "text": "报告对预期实参和实际实参的顺序错误的 'assertEquals()' 的调用。 对于 JUnit 3、4 和 5，正确的顺序是'(expected, actual)'。 对于 TestNG，正确的顺序是'(actual, expected)'。 对于通过的断言，此类调用没有问题，但可能会在失败时给出令人困惑的错误报告。 使用该快速修复可以翻转实参顺序。 示例 (JUnit)： 'assertEquals(actual, expected)' 在应用快速修复后： 'assertEquals(expected, actual)'",
                  "markdown": "报告对预期实参和实际实参的顺序错误的 `assertEquals()` 的调用。\n\n\n对于 JUnit 3、4 和 5，正确的顺序是`(expected, actual)`。\n对于 TestNG，正确的顺序是`(actual, expected)`。\n\n\n对于通过的断言，此类调用没有问题，但可能会在失败时给出令人困惑的错误报告。\n使用该快速修复可以翻转实参顺序。\n\n**示例 (JUnit)：**\n\n\n      assertEquals(actual, expected)\n\n在应用快速修复后：\n\n\n      assertEquals(expected, actual)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MisorderedAssertEqualsArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 98,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticVariableInitialization",
                "shortDescription": {
                  "text": "static 字段可能无法初始化"
                },
                "fullDescription": {
                  "text": "报告在类初始化时可能未被初始化的 'static' 变量。 示例： 'class Foo {\n    public static int bar;\n\n    static { }\n  }' 请注意，此检查使用非常保守的数据流算法，并且可能会将 'static' 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在类初始化时可能未被初始化的 `static` 变量。\n\n**示例：**\n\n\n      class Foo {\n        public static int bar;\n\n        static { }\n      }\n\n请注意，此检查使用非常保守的数据流算法，并且可能会将 `static` 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticVariableMayNotBeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantAssertCondition",
                "shortDescription": {
                  "text": "'assert' 语句中的常量条件"
                },
                "fullDescription": {
                  "text": "报告为常量的 'assert' 语句条件。 具有常量条件的 'assert' 语句要么总是失败，要么总是成功。 此类语句可能在重构后遗留下来，并且可能不是有意的。 示例： 'void foo() {\n        assert true;\n    }'",
                  "markdown": "报告为常量的 `assert` 语句条件。 具有常量条件的 `assert` 语句要么总是失败，要么总是成功。 此类语句可能在重构后遗留下来，并且可能不是有意的。\n\n**示例：**\n\n\n        void foo() {\n            assert true;\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantAssertCondition",
                    "cweIds": [
                      570,
                      571
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaReflectionInvocation",
                "shortDescription": {
                  "text": "反射调用实参不匹配"
                },
                "fullDescription": {
                  "text": "报告提供给 'Method.invoke()' 和 'Constructor.newInstance()' 的实参与 'Class.getMethod()' 和 'Class.getConstructor()' 中指定的签名不匹配的情况。 示例： 'Method m = myObj.getClass().getMethod(\"myMethod\", int.class);\n  //此实参应为 int 值\n  m.invoke(myObj, \"abc\");' 2017.2 最新变化",
                  "markdown": "报告提供给 `Method.invoke()` 和 `Constructor.newInstance()` 的实参与 `Class.getMethod()` 和 `Class.getConstructor()` 中指定的签名不匹配的情况。\n\n示例：\n\n\n      Method m = myObj.getClass().getMethod(\"myMethod\", int.class);\n      //此实参应为 **int** 值\n      m.invoke(myObj, \"abc\");\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaReflectionInvocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CaughtExceptionImmediatelyRethrown",
                "shortDescription": {
                  "text": "捕获的异常被立即重新抛出"
                },
                "fullDescription": {
                  "text": "报告不对其执行任何操作，而是立即重新抛出所捕获的异常的 'catch' 块。 此类 'catch' 块非必要，并且没有处理错误。 示例： 'try {\n            new FileInputStream(\"\");\n        } catch (FileNotFoundException e) {\n            throw e;\n        }'",
                  "markdown": "报告不对其执行任何操作，而是立即重新抛出所捕获的异常的 `catch` 块。 此类 `catch` 块非必要，并且没有处理错误。\n\n**示例：**\n\n\n            try {\n                new FileInputStream(\"\");\n            } catch (FileNotFoundException e) {\n                throw e;\n            }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CaughtExceptionImmediatelyRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayHashCode",
                "shortDescription": {
                  "text": "在数组上调用了 'hashCode()'"
                },
                "fullDescription": {
                  "text": "报告数组的不正确哈希代码计算。 为正确计算数组的哈希代码，请执行以下操作： 为线性数组使用 'Arrays.hashcode()' 为多维数组使用 'Arrays.deepHashcode()' 当输入值序列包含数组时，例如 'Objects.hash(string, Arrays.hashcode(array))'，这些方法还应与 'Objects.hash()' 一起使用：",
                  "markdown": "报告数组的不正确哈希代码计算。\n\n为正确计算数组的哈希代码，请执行以下操作：\n\n* 为线性数组使用 `Arrays.hashcode()`\n* 为多维数组使用 `Arrays.deepHashcode()`\n\n当输入值序列包含数组时，例如 `Objects.hash(string, Arrays.hashcode(array))`，这些方法还应与 `Objects.hash()` 一起使用："
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayHashCode",
                    "cweIds": [
                      328
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitNotInLoop",
                "shortDescription": {
                  "text": "未在循环中调用的 'wait()'"
                },
                "fullDescription": {
                  "text": "报告不是在循环中进行的 'wait()' 调用。 'wait()' 通常用于挂起线程，直到某个条件变为 true 为止。 线程可能出于不同的原因而被唤醒，因此在 'wait()' 调用返回后应检查条件。 使用循环很容易做到这一点。 示例： 'class BoundedCounter {\n    private int count;\n    synchronized void inc() throws InterruptedException {\n      if (count >= 10) wait();\n      ++count;\n    }\n  }' 优良的代码应类似于： 'class BoundedCounter {\n    private int count;\n    synchronized void inc() throws InterruptedException {\n      while (count >= 10) wait();\n      ++count;\n    }\n  }'",
                  "markdown": "报告不是在循环中进行的 `wait()` 调用。\n\n\n`wait()` 通常用于挂起线程，直到某个条件变为 true 为止。\n线程可能出于不同的原因而被唤醒，因此在 `wait()` 调用返回后应检查条件。\n使用循环很容易做到这一点。\n\n**示例：**\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          if (count >= 10) wait();\n          ++count;\n        }\n      }\n\n优良的代码应类似于：\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          while (count >= 10) wait();\n          ++count;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExternalizableWithSerializationMethods",
                "shortDescription": {
                  "text": "具有 'readObject()' 或 'writeObject()' 的可外部化类"
                },
                "fullDescription": {
                  "text": "报告定义 'readObject()' 或 'writeObject()' 方法的 'Externalizable' 类。 这些方法并非为了序列化 'Externalizable' 对象而调用。 示例： 'abstract class Crucial implements Externalizable {\n    int value;\n    private void readObject(ObjectInputStream in) {\n      value = in.readInt();\n    }\n  }'",
                  "markdown": "报告定义 `readObject()` 或 `writeObject()` 方法的 `Externalizable` 类。 这些方法并非为了序列化 `Externalizable` 对象而调用。\n\n**示例：**\n\n\n      abstract class Crucial implements Externalizable {\n        int value;\n        private void readObject(ObjectInputStream in) {\n          value = in.readInt();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExternalizableClassWithSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeLock",
                "shortDescription": {
                  "text": "已获取但未安全解锁的锁"
                },
                "fullDescription": {
                  "text": "报告没有在 'try' 块前面获取，或者没有在相应的 'finally' 块中解锁的 'java.util.concurrent.locks.Lock' 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。 示例： 'lock.lock(); // 由于缺少 'finally' 块，因此会报告\n  try {\n    doSmthWithLock();\n  } catch (IOException e) {\n    throw new UncheckedIOException(e);\n  }\n  lock.unlock();'",
                  "markdown": "报告没有在 `try` 块前面获取，或者没有在相应的 `finally` 块中解锁的 `java.util.concurrent.locks.Lock` 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。\n\n**示例：**\n\n\n      lock.lock(); // 由于缺少 'finally' 块，因此会报告\n      try {\n        doSmthWithLock();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      lock.unlock();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LockAcquiredButNotSafelyReleased",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaLangInvokeHandleSignature",
                "shortDescription": {
                  "text": "MethodHandle/VarHandle 类型不匹配"
                },
                "fullDescription": {
                  "text": "报告不匹配任何方法或字段的 'MethodHandle' 和 'VarHandle' 工厂方法调用。 也报告不匹配 'MethodHandle' 签名的 'MethodHandle.invoke()' 和类似方法的实参以及不匹配 'VarHandle' 类型的 'VarHandle.set()' 的实参 示例：   MethodHandle mh = MethodHandles.lookup().findVirtual(\n      MyClass.class, \"foo\", MethodType.methodType(void.class, int.class));\n  // 此实参应为 int 值\n  mh.invoke(myObj, \"abc\");\n   // 此实参应为 String.class\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", int.class);\n   VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", String.class);\n  // 此实参应为 String 值\n  vh.set(myObj, 42);\n 2017.2 最新变化",
                  "markdown": "报告不匹配任何方法或字段的 `MethodHandle` 和 `VarHandle` 工厂方法调用。\n\n也报告不匹配 `MethodHandle` 签名的 `MethodHandle.invoke()` 和类似方法的实参以及不匹配 `VarHandle` 类型的 `VarHandle.set()` 的实参\n\n\n示例：\n\n```\n  MethodHandle mh = MethodHandles.lookup().findVirtual(\n      MyClass.class, \"foo\", MethodType.methodType(void.class, int.class));\n  // 此实参应为 int 值\n  mh.invoke(myObj, \"abc\");\n```\n\n```\n  // 此实参应为 String.class\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", int.class);\n```\n\n```\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", String.class);\n  // 此实参应为 String 值\n  vh.set(myObj, 42);\n```\n\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaLangInvokeHandleSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnThis",
                "shortDescription": {
                  "text": "返回 'this'"
                },
                "fullDescription": {
                  "text": "报告返回 'this' 的方法。 虽然此类返回是有效的，但很少有必要，并且通常表明该方法旨在被用作类似方法调用链的一部分（例如，'buffer.append(\"foo\").append( \"bar\").append(\"baz\")'）。 许多编码标准不赞成此类链。 示例： 'public Builder append(String str) {\n    // [...]\n    return this;\n  }'",
                  "markdown": "报告返回 `this` 的方法。\n\n\n虽然此类返回是有效的，但很少有必要，并且通常表明该方法旨在被用作类似方法调用链的一部分（例如，`buffer.append(\"foo\").append( \"bar\").append(\"baz\")`）。\n许多编码标准不赞成此类链。\n\n**示例：**\n\n\n      public Builder append(String str) {\n        // [...]\n        return this;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CanBeFinal",
                "shortDescription": {
                  "text": "声明可以有 'final' 修饰符"
                },
                "fullDescription": {
                  "text": "报告可能在其声明中添加了 'final' 修饰符的字段、方法或类。 final 类不能被扩展，final 方法不能被重写，final 字段不能被重新分配。 示例： 'public class Person {\n    private String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n\n    public String toString() {\n      return getName();\n    }\n  }' 在应用快速修复后： 'public final class Person {\n    private final String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public final String getName() {\n      return name;\n    }\n\n    public final String toString() {\n      return getName();\n    }\n  }' 使用报告类和报告方法选项可定义要报告的声明。",
                  "markdown": "报告可能在其声明中添加了 `final` 修饰符的字段、方法或类。\n\nfinal 类不能被扩展，final 方法不能被重写，final 字段不能被重新分配。\n\n**示例：**\n\n\n      public class Person {\n        private String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n\n        public String toString() {\n          return getName();\n        }\n      }\n\n在应用快速修复后：\n\n\n      public final class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public final String getName() {\n          return name;\n        }\n\n        public final String toString() {\n          return getName();\n        }\n      }\n\n使用**报告类** 和**报告方法**选项可定义要报告的声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnBreakStatement",
                "shortDescription": {
                  "text": "'break' 语句上的标签不必要"
                },
                "fullDescription": {
                  "text": "报告包含不必要标签的 'break' 语句。 此类标签不会改变控制流，但会导致难以跟随代码。 示例： 'label:\n  for(int i = 0; i < 10; i++) {\n    if (shouldBreak()) break label;\n    //doSmth\n  }' 在应用快速修复后： 'label:\n  for(int i = 0; i < 10; i++) {\n    if (shouldBreak()) break;\n    //doSmth\n  }'",
                  "markdown": "报告包含不必要标签的 `break` 语句。 此类标签不会改变控制流，但会导致难以跟随代码。\n\n**示例：**\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break label;\n        //doSmth\n      }\n\n在应用快速修复后：\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break;\n        //doSmth\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnBreakStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NakedNotify",
                "shortDescription": {
                  "text": "没有相应状态更改的 'notify()' 或 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "报告调用的未发生任何可检测到的状态更改的 'Object.notify()' 或 'Object.notifyAll()'。 'Object.notify()' 和 'Object.notifyAll()' 通常用于通知其他线程发生了状态更改。 该状态更改应发生在包含 'Object.notify()' 或 'Object.notifyAll()' 调用的同步上下文中，并且发生在调用之前。 尽管没有此类状态更改未必就不正确，但肯定值得检查。 示例： 'synchronized (this) {\n    notify();\n  }\n  // 无状态更改\n  synchronized (this) {\n    notify(); // 告知可能冗余\n  }'",
                  "markdown": "报告调用的未发生任何可检测到的状态更改的 `Object.notify()` 或 `Object.notifyAll()`。\n\n\n`Object.notify()` 和 `Object.notifyAll()` 通常用于通知其他线程发生了状态更改。 该状态更改应发生在包含 `Object.notify()` 或\n`Object.notifyAll()` 调用的同步上下文中，并且发生在调用之前。 尽管没有此类状态更改未必就不正确，但肯定值得检查。\n\n**示例：**\n\n\n      synchronized (this) {\n        notify();\n      }\n      // 无状态更改\n      synchronized (this) {\n        notify(); // 告知可能冗余\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NakedNotify",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassCoupling",
                "shortDescription": {
                  "text": "过度耦合的类"
                },
                "fullDescription": {
                  "text": "报告引用过多其他类的类。 耦合度过高的类可能非常脆弱，应该被拆分为较小的类。 配置检查： 使用类耦合限制字段可指定类允许的最大耦合度。 使用包括与 Java 系统类的耦合选项可指定是否应计算对系统类（'java.' 或 'javax.' 软件包中的那些类）的引用。 使用包括与库类的耦合选项可指定是否应该计算对任何库类的引用。",
                  "markdown": "报告引用过多其他类的类。\n\n耦合度过高的类可能非常脆弱，应该被拆分为较小的类。\n\n配置检查：\n\n* 使用**类耦合限制**字段可指定类允许的最大耦合度。\n* 使用**包括与 Java 系统类的耦合** 选项可指定是否应计算对系统类（`java.` 或 `javax.` 软件包中的那些类）的引用。\n* 使用**包括与库类的耦合**选项可指定是否应该计算对任何库类的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyCoupledClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptySynchronizedStatement",
                "shortDescription": {
                  "text": "空 'synchronized' 语句"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'synchronized' 语句。 空的 'synchronized' 语句有时用于等待其他线程释放特定资源。 但是，不能保证空的 'synchronized' 语句完成后不会再次获取同一资源。 为了正确同步，应当在 'synchronized' 块中使用此资源。 此外，在移除冗余代码后，重构后可能会出现空的 'synchronized' 块。 在本例中，'synchronized' 块本身是冗余的，也应移除。 示例： 'synchronized(lock) {}' 建议通过快速修复移除空的 synchronized 语句。 JSP 文件中禁用了此检查。",
                  "markdown": "报告语句体为空的 `synchronized` 语句。\n\n\n空的 `synchronized` 语句有时用于等待其他线程释放特定资源。 但是，不能保证空的 `synchronized` 语句完成后不会再次获取同一资源。\n为了正确同步，应当在 `synchronized` 块中使用此资源。\n\n\n此外，在移除冗余代码后，重构后可能会出现空的 `synchronized` 块。 在本例中，`synchronized` 块本身是冗余的，也应移除。\n\n示例：\n\n\n      synchronized(lock) {}\n\n\n建议通过快速修复移除空的 synchronized 语句。\n\n\nJSP 文件中禁用了此检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptySynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextBlockMigration",
                "shortDescription": {
                  "text": "可以使用文本块"
                },
                "fullDescription": {
                  "text": "报告可通过替换为文本块来简化的 'String' 串联。 要求： '\\n' 发生两次或多次。 文本块未串联。 使用报告单个字符串文字选项高亮显示包含换行符的单个文字。 即使禁用此选项，快速修复仍然可用。 示例： 'String html = \"<html>\\n\" +\n                \"    <body>\\n\" +\n                \"        <p>Hello, world</p>\\n\" +\n                \"    </body>\\n\" +\n                \"</html>\\n\";' 在应用快速修复后： 'String html = \"\"\"\n                <html>\n                    <body>\n                        <p>Hello, world</p>\n                    </body>\n                </html>\n                \"\"\";' 2019.3 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告可通过替换为文本块来简化的 `String` 串联。\n\n要求：\n\n* `\\n` 发生两次或多次。\n* 文本块未串联。\n\n\n使用**报告单个字符串文字**选项高亮显示包含换行符的单个文字。\n即使禁用此选项，快速修复仍然可用。\n\n\n**示例：**\n\n\n      String html = \"<html>\\n\" +\n                    \"    <body>\\n\" +\n                    \"        <p>Hello, world</p>\\n\" +\n                    \"    </body>\\n\" +\n                    \"</html>\\n\";\n\n在应用快速修复后：\n\n\n      String html = \"\"\"\n                    <html>\n                        <body>\n                            <p>Hello, world</p>\n                        </body>\n                    </html>\n                    \"\"\";\n\n2019.3 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TextBlockMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 15",
                      "index": 103,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectAllocationInLoop",
                "shortDescription": {
                  "text": "循环中的对象分配"
                },
                "fullDescription": {
                  "text": "报告循环内的对象或数组分配。 虽然不一定是问题，但循环内的对象分配是查找内存泄漏和性能问题的好地方。 检查会报告以下结构： 通过 'new' 运算符进行的显式分配 已知会返回新对象的方法 实例绑定方法引用 捕获变量或 'this' 引用的 lambda 示例： '// 显式分配\n  for (Status status : Status.values()) {\n    declarationsMap.put(status, new ArrayList<>());\n  }\n\n  // Lambda 捕获变量\n  String message = \"Engine running.\";\n  for (Engine engine : engines) {\n      if (!isRunning(engine)) {\n          logger.warn(() -> {\n              return String.format(message);\n          });\n      }\n  }\n\n  // 实例绑定方法引用\n  for(Node node : nodes) {\n    descriptor = node.getDescription();\n    descriptor.ifPresent(dynamicTestExecutor::execute);\n  }'",
                  "markdown": "报告循环内的对象或数组分配。 虽然不一定是问题，但循环内的对象分配是查找内存泄漏和性能问题的好地方。\n\n\n检查会报告以下结构：\n\n* 通过 `new` 运算符进行的显式分配\n* 已知会返回新对象的方法\n* 实例绑定方法引用\n* 捕获变量或 `this` 引用的 lambda\n\n**示例：**\n\n\n      // 显式分配\n      for (Status status : Status.values()) {\n        declarationsMap.put(status, new ArrayList<>());\n      }\n\n      // Lambda 捕获变量\n      String message = \"Engine running.\";\n      for (Engine engine : engines) {\n          if (!isRunning(engine)) {\n              logger.warn(() -> {\n                  return String.format(message);\n              });\n          }\n      }\n\n      // 实例绑定方法引用\n      for(Node node : nodes) {\n        descriptor = node.getDescription();\n        descriptor.ifPresent(dynamicTestExecutor::execute);\n      }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectAllocationInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalClone",
                "shortDescription": {
                  "text": "非 final 'clone()' 位于安全上下文中"
                },
                "fullDescription": {
                  "text": "报告没有 'final' 修饰符的 'clone()' 方法。 'clone()' 可以用于在不使用构造函数的情况下实例化对象，因此允许重写 'clone()' 方法可能导致对象损坏，甚至导致安全漏洞。 将 'clone()' 方法或封闭类本身设为 'final' 可以防止这种情况。 示例： 'class Main implements Cloneable {\n      @Override\n      protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n      }\n  }'",
                  "markdown": "报告没有 `final` 修饰符的 `clone()` 方法。\n\n\n`clone()` 可以用于在不使用构造函数的情况下实例化对象，因此允许重写 `clone()` 方法可能导致对象损坏，甚至导致安全漏洞。 将 `clone()` 方法或封闭类本身设为 `final` 可以防止这种情况。\n\n**示例：**\n\n\n      class Main implements Cloneable {\n          @Override\n          protected Object clone() throws CloneNotSupportedException {\n            return super.clone();\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedEquality",
                "shortDescription": {
                  "text": "链式相等比较"
                },
                "fullDescription": {
                  "text": "报告链式相等比较。 此类比较可能令人困惑：'a == b == c' 表示 '(a == b) == c'，但可能 'a == b && a == c' 是有意为之。 示例： 'boolean chainedEquality(boolean a, boolean b, boolean c) {\n    return a == b == c;\n  }' 您可以使用圆括号使比较不那么令人困惑： 'boolean chainedEquality(boolean a, boolean b, boolean c) {\n    return (a == b) == c;\n  }'",
                  "markdown": "报告链式相等比较。\n\n此类比较可能令人困惑：`a == b == c` 表示 `(a == b) == c`，但可能 `a == b && a == c` 是有意为之。\n\n**示例：**\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return a == b == c;\n      }\n\n您可以使用圆括号使比较不那么令人困惑：\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return (a == b) == c;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedEqualityComparisons",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LossyConversionCompoundAssignment",
                "shortDescription": {
                  "text": "复合赋值中可能存在有损隐式转换"
                },
                "fullDescription": {
                  "text": "如果右侧操作数的类型与变量的类型不兼容，则报告复合赋值。 在此类复合赋值过程中，会发生隐式强制转换，这可能会导致有损转换。 示例： 'long c = 1;\n  c += 1.2;' 在应用快速修复后： 'long c = 1;\n  c += (long) 1.2;' 2023.2 最新变化",
                  "markdown": "如果右侧操作数的类型与变量的类型不兼容，则报告复合赋值。\n\n\n在此类复合赋值过程中，会发生隐式强制转换，这可能会导致有损转换。\n\n示例：\n\n\n      long c = 1;\n      c += 1.2;\n\n在应用快速修复后：\n\n\n      long c = 1;\n      c += (long) 1.2;\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "lossy-conversions",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowFromFinallyBlock",
                "shortDescription": {
                  "text": "'throw' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块内的 'throw' 语句。 虽然偶尔是有意为之，但此类 'throw' 语句可能隐藏从 'try'-'catch' 抛出的异常，并因此导致调试变得极其复杂。",
                  "markdown": "报告 `finally` 块内的 `throw` 语句。\n\n虽然偶尔是有意为之，但此类 `throw` 语句可能隐藏从 `try`-`catch` 抛出的异常，并因此导致调试变得极其复杂。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticNonFinalField",
                "shortDescription": {
                  "text": "'static' 非 'final' 字段"
                },
                "fullDescription": {
                  "text": "报告非 'final' 'static' 字段。 可以通过快速修复将 'final' 修饰符添加到非 'final' 'static' 字段中。 此检查不检查字段的可变性。 例如，将 'final' 修饰符添加到在某个位置设置了值的字段，将导致编译错误。 使用仅报告 'public' 字段选项，使该检查只报告 'public' 字段。",
                  "markdown": "报告非 `final` `static` 字段。\n\n可以通过快速修复将 `final` 修饰符添加到非 `final` `static` 字段中。\n\n此检查不检查字段的可变性。 例如，将 `final` 修饰符添加到在某个位置设置了值的字段，将导致编译错误。\n\n\n使用**仅报告 'public' 字段** 选项，使该检查只报告 `public` 字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyMethod",
                "shortDescription": {
                  "text": "空方法"
                },
                "fullDescription": {
                  "text": "报告可以移除的空方法。 如果方法本身是空的并且仅被空方法重写或实现，则方法被视为空。 请注意，仅包含注释的方法和带有自己形参的 'super()' 调用也被视为空。 该检查会忽略带有特殊注解的方法，例如 'javax.ejb.Init' 和 'javax.ejb.Remove' EJB 注释。 该快速修复会安全地移除不必要的方法。 配置检查： 使用注释和 javadoc 计为内容选项可选择是否应将带有注释的方法视为非空方法。 使用额外的特别注解选项可配置此检查应忽略的其他注解。",
                  "markdown": "报告可以移除的空方法。\n\n如果方法本身是空的并且仅被空方法重写或实现，则方法被视为空。 请注意，仅包含注释的方法和带有自己形参的 `super()` 调用也被视为空。\n\n该检查会忽略带有特殊注解的方法，例如 `javax.ejb.Init` 和 `javax.ejb.Remove` EJB 注释。\n\n该快速修复会安全地移除不必要的方法。\n\n配置检查：\n\n* 使用**注释和 javadoc 计为内容**选项可选择是否应将带有注释的方法视为非空方法。\n* 使用**额外的特别注解**选项可配置此检查应忽略的其他注解。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableEqualsExpression",
                "shortDescription": {
                  "text": "'equals()' 调用之前的 'null' 检查不必要"
                },
                "fullDescription": {
                  "text": "报告与后接使用常量实参调用 'equals()' 的 'null' 的比较。 示例： 'if (s != null && s.equals(\"literal\")) {}' 在应用快速修复后： 'if (\"literal\".equals(s)) {}' 当 'equals()' 的实参被证明不是 'null' 时，使用检查设置可以报告带有非常量实参的 'equals()' 调用。",
                  "markdown": "报告与后接使用常量实参调用 `equals()` 的 `null` 的比较。\n\n**示例：**\n\n\n      if (s != null && s.equals(\"literal\")) {}\n\n在应用快速修复后：\n\n\n      if (\"literal\".equals(s)) {}\n\n\n当 `equals()` 的实参被证明不是 `null` 时，使用检查设置可以报告带有非常量实参的 `equals()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableEqualsExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonCommentSourceStatements",
                "shortDescription": {
                  "text": "过长的方法"
                },
                "fullDescription": {
                  "text": "报告语句数超过指定最大值的方法。 语句过多的方法可能令人困惑，并且表明可能有必要重构。 以下语句不计算在内： 空语句（分号） 块语句 'for' 循环初始化语句，即 'for(int i = ...;...)' 语句内的 'int i = ...' 'for' 循环 update 语句，即 'for(int i = ...;...; i += 2)' 语句内的 'i += 2' 使用每个方法的最大语句数字段可指定方法中允许的最大语句数。",
                  "markdown": "报告语句数超过指定最大值的方法。\n\n语句过多的方法可能令人困惑，并且表明可能有必要重构。\n\n以下语句不计算在内：\n\n* 空语句（分号）\n* 块语句\n* `for` 循环初始化语句，即 `for(int i = ...;...)` 语句内的 `int i = ...`\n* `for` 循环 update 语句，即 `for(int i = ...;...; i += 2)` 语句内的 `i += 2`\n\n使用**每个方法的最大语句数**字段可指定方法中允许的最大语句数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLongMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingMainMethod",
                "shortDescription": {
                  "text": "引起混淆的 'main()' 方法"
                },
                "fullDescription": {
                  "text": "在 Java 21 及更低版本中，报告命名为 \"main\" 但没有 'public static void main(String[])' 签名的方法。 从 Java 21 预览版开始，检查不会高亮显示 package-private、protected 或实例 main 方法（也没有形参）。 此外，还会报告位于匿名或局部类中的 main 方法。 匿名类和局部类没有完全限定名称，因此无法运行。 此类方法可能令人困惑，因为命名为 \"main\" 的方法应为应用程序入口点。 示例： 'class Main {\n    void main(String[] args) {} //此处有警告，因为没有“public static”修饰符\n  }' 只能在编辑器中使用重命名此类方法的快速修复。",
                  "markdown": "在 Java 21 及更低版本中，报告命名为 \"main\" 但没有 `public static void main(String[])` 签名的方法。 从 Java 21 预览版开始，检查不会高亮显示 package-private、protected 或实例 main 方法（也没有形参）。 此外，还会报告位于匿名或局部类中的 main 方法。 匿名类和局部类没有完全限定名称，因此无法运行。\n\n此类方法可能令人困惑，因为命名为 \"main\" 的方法应为应用程序入口点。\n\n**示例：**\n\n\n      class Main {\n        void main(String[] args) {} //此处有警告，因为没有\"public static\"修饰符\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingMainMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleVariablesInDeclaration",
                "shortDescription": {
                  "text": "一个声明中的多个变量"
                },
                "fullDescription": {
                  "text": "报告在单个声明中声明的多个变量，并建议为每个变量创建单独的声明。 一些编码标准禁止此类声明。 示例： 'int x = 1, y = 2;' 在应用快速修复后： 'int x = 1;\n  int y = 2;' 配置检查： 使用 忽略 'for' 循环声明 选项可忽略在 'for' 循环语句的初始化中声明的多个变量，例如： 'for (int i = 0, max = list.size(); i > max; i++) {}' 使用 仅在单个声明中对不同的数组维度发出警告 选项，以仅在单个声明中声明具有不同数组维度的变量时发出警告，例如： 'String s = \"\", array[];' 2019.2 最新变化",
                  "markdown": "报告在单个声明中声明的多个变量，并建议为每个变量创建单独的声明。\n\n一些编码标准禁止此类声明。\n\n示例：\n\n\n      int x = 1, y = 2;\n\n在应用快速修复后：\n\n\n      int x = 1;\n      int y = 2;\n\n配置检查：\n\n* 使用 **忽略 'for' 循环声明** 选项可忽略在 'for' 循环语句的初始化中声明的多个变量，例如：\n\n\n        for (int i = 0, max = list.size(); i > max; i++) {}\n\n* 使用 **仅在单个声明中对不同的数组维度发出警告** 选项，以仅在单个声明中声明具有不同数组维度的变量时发出警告，例如：\n\n\n        String s = \"\", array[];\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MultipleVariablesInDeclaration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IOResource",
                "shortDescription": {
                  "text": "I/O 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 I/O 资源。 此检查所检查的 I/O 资源包括 'java.io.InputStream'、'java.io.OutputStream'、'java.io.Reader'、'java.io.Writer'、'java.util.zip.ZipFile'、'java.io.Closeable' 和 'java.io.RandomAccessFile'。 不报告由其他 I/O 资源包装的 I/O 资源，因为包装资源将关闭被包装资源。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'void save() throws IOException {\n    FileWriter writer = new FileWriter(\"filename.txt\"); //警告\n    writer.write(\"sample\");\n  }' 使用以下选项配置检查： 列出不需关闭并且此检查应当忽略的 I/O 资源类。 是否允许在 'try' 块内打开 I/O 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 I/O 资源。 此检查所检查的 I/O 资源包括 `java.io.InputStream`、`java.io.OutputStream`、`java.io.Reader`、`java.io.Writer`、`java.util.zip.ZipFile`、`java.io.Closeable` 和 `java.io.RandomAccessFile`。\n\n\n不报告由其他 I/O 资源包装的 I/O 资源，因为包装资源将关闭被包装资源。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      void save() throws IOException {\n        FileWriter writer = new FileWriter(\"filename.txt\"); //警告\n        writer.write(\"sample\");\n      }\n\n\n使用以下选项配置检查：\n\n* 列出不需关闭并且此检查应当忽略的 I/O 资源类。\n* 是否允许在 `try` 块内打开 I/O 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IOResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSimpleGetterInClass",
                "shortDescription": {
                  "text": "从类内调用简单 getter"
                },
                "fullDescription": {
                  "text": "报告从属性的类内部对简单属性 getter 的调用。 简单的属性 getter 会被定义为只返回字段的值，而不进行其他计算。 可以使用该快速修复安全地内联此类简单的 getter 调用。 为了保持代码清晰，某些编码标准还建议不使用简单的 getter。 示例： 'public class Salient {\n    private String name;\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return getName();\n    }\n  }' 在应用快速修复后： 'public class Salient {\n    private String name;\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return name;\n    }\n  }' 使用以下选项配置检查： 是否仅报告 'this' 上的 getter 调用，而不报告作为形参传入的相同类型的对象。 是否忽略非 'private' getter。",
                  "markdown": "报告从属性的类内部对简单属性 getter 的调用。\n\n\n简单的属性 getter 会被定义为只返回字段的值，而不进行其他计算。 可以使用该快速修复安全地内联此类简单的 getter 调用。\n为了保持代码清晰，某些编码标准还建议不使用简单的 getter。\n\n**示例：**\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return getName();\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return name;\n        }\n      }\n\n使用以下选项配置检查：\n\n* 是否仅报告 `this` 上的 getter 调用，而不报告作为形参传入的相同类型的对象。\n* 是否忽略非 `private` getter。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSimpleGetterFromWithinClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableFieldInSerializableClass",
                "shortDescription": {
                  "text": "'Serializable' 类中有不可序列化的字段"
                },
                "fullDescription": {
                  "text": "报告实现 'java.io.Serializable' 的类中的不可序列化字段。 如果对象被序列化，此类字段将导致运行时异常。 不报告被声明为 'transient' 或 'static' 的字段，也不报告定义了 'writeObject' 方法的类的字段。 此检查假定 'java.util.Collection' 和 'java.util.Map' 类型的字段为 'Serializable'，除非声明它们的类型为非 'Serializable'。 示例： 'class NonSerializableClass {}\n\n  public class SerializableClass implements Serializable {\n      NonSerializableClass clazz; // //警告：可序列化类中存在不可序列化字段 'clazz'\n      static NonSerializableClass staticClazz; // 无警告\n  }'\n 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 列出会使检查忽略注解字段的注解。 是否忽略使用匿名类初始化的字段。",
                  "markdown": "报告实现 `java.io.Serializable` 的类中的不可序列化字段。 如果对象被序列化，此类字段将导致运行时异常。\n\n\n不报告被声明为 `transient` 或 `static` 的字段，也不报告定义了 `writeObject` 方法的类的字段。\n\n\n此检查假定 `java.util.Collection` 和 `java.util.Map` 类型的字段为 `Serializable`，除非声明它们的类型为非 `Serializable`。\n\n**示例：**\n\n\n      class NonSerializableClass {}\n\n      public class SerializableClass implements Serializable {\n          NonSerializableClass clazz; // //警告：可序列化类中存在不可序列化字段 'clazz'\n          static NonSerializableClass staticClazz; // 无警告\n      }\n      \n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 列出会使检查忽略注解字段的注解。\n* 是否忽略使用匿名类初始化的字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableFieldInSerializableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnhancedSwitchMigration",
                "shortDescription": {
                  "text": "语句可被替换为增强的 'switch'"
                },
                "fullDescription": {
                  "text": "报告可以自动替换为增强型 'switch' 语句或表达式的 'switch' 语句。 示例： 'double getPrice(String fruit) {\n    // Switch 语句可以替换为增强型 'switch'\n    switch (fruit) {\n      case \"Apple\":\n        return 1.0;\n      case \"Orange\":\n        return 1.5;\n      case \"Mango\":\n        return 2.0;\n      default:\n        throw new IllegalArgumentException();\n    }\n  }' 在应用快速修复后： 'double getPrice(String fruit) {\n    return switch (fruit) {\n      case \"Apple\" -> 1.0;\n      case \"Orange\" -> 1.5;\n      case \"Mango\" -> 2.0;\n      default -> throw new IllegalArgumentException();\n    };\n  }' 使用仅在可以转换为表达式时显示警告选项，不对转换为 'switch' 语句发出警告。 使用一个分支中转换为 switch 表达式的最大语句数选项，仅在每个分支的语句数小于给定的语句数时才对转换为表达式发出警告。 2019.1 最新变化 此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。",
                  "markdown": "报告可以自动替换为增强型 `switch` 语句或表达式的 `switch` 语句。\n\n**示例：**\n\n\n      double getPrice(String fruit) {\n        // Switch 语句可以替换为增强型 'switch'\n        switch (fruit) {\n          case \"Apple\":\n            return 1.0;\n          case \"Orange\":\n            return 1.5;\n          case \"Mango\":\n            return 2.0;\n          default:\n            throw new IllegalArgumentException();\n        }\n      }\n\n在应用快速修复后：\n\n\n      double getPrice(String fruit) {\n        return switch (fruit) {\n          case \"Apple\" -> 1.0;\n          case \"Orange\" -> 1.5;\n          case \"Mango\" -> 2.0;\n          default -> throw new IllegalArgumentException();\n        };\n      }\n      \n\n* 使用**仅在可以转换为表达式时显示警告** 选项，不对转换为 `switch` 语句发出警告。\n* 使用**一个分支中转换为 switch 表达式的最大语句数**选项，仅在每个分支的语句数小于给定的语句数时才对转换为表达式发出警告。\n\n2019.1 最新变化\n\n此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnhancedSwitchMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 14",
                      "index": 108,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleLiteralMayBeFloatLiteral",
                "shortDescription": {
                  "text": "转换为 'float' 可以是 'float' 文字"
                },
                "fullDescription": {
                  "text": "报告被立即转换为 'float' 的 'double' 文字表达式。 此类文字表达式可以替换为等效的 'float' 文字。 示例： 'float f = (float)1.1;' 在应用快速修复后： 'float f = 1.1f;'",
                  "markdown": "报告被立即转换为 `float` 的 `double` 文字表达式。\n\n此类文字表达式可以替换为等效的 `float` 文字。\n\n**示例：**\n\n    float f = (float)1.1;\n\n在应用快速修复后：\n\n    float f = 1.1f;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleLiteralMayBeFloatLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 109,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverloadedMethodsWithSameNumberOfParameters",
                "shortDescription": {
                  "text": "具有相同形参数量的重载方法"
                },
                "fullDescription": {
                  "text": "报告在同一类中声明、具有相同名称和相同数量形参的方法。 此类重载可能非常令人困惑，因为可能不清楚调用的是哪个重载。 示例： 'class Main {\n    public static void execute(Runnable r) {}\n    public static <T> void execute(RunnableFuture<T> c) {}\n  }' 使用该选项可以忽略形参类型绝对不兼容的重载方法。",
                  "markdown": "报告在同一类中声明、具有相同名称和相同数量形参的方法。 此类重载可能非常令人困惑，因为可能不清楚调用的是哪个重载。\n\n**示例：**\n\n\n      class Main {\n        public static void execute(Runnable r) {}\n        public static <T> void execute(RunnableFuture<T> c) {}\n      }\n\n\n使用该选项可以忽略形参类型绝对不兼容的重载方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverloadedMethodsWithSameNumberOfParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyLongLambda",
                "shortDescription": {
                  "text": "过长的 lambda 表达式"
                },
                "fullDescription": {
                  "text": "报告语句数超过指定最大值的 lambda 表达式。 过长的 lambda 表达式可能令人困惑，将语句提取到单独的方法中通常会更好。 以下语句不计算在内： 空语句（分号） 块语句 'for' 循环初始化语句，即 'for(int i = ...;...)' 语句内的 'int i = ...' 'for' 循环 update 语句，即 'for(int i = ...;...; i += 2)' 语句内的 'i += 2' 使用非注释源语句限制字段可指定 lambda 表达式中允许的最大语句数。",
                  "markdown": "报告语句数超过指定最大值的 lambda 表达式。\n\n过长的 lambda 表达式可能令人困惑，将语句提取到单独的方法中通常会更好。\n\n\n以下语句不计算在内：\n\n* 空语句（分号）\n* 块语句\n* `for` 循环初始化语句，即 `for(int i = ...;...)` 语句内的 `int i = ...`\n* `for` 循环 update 语句，即 `for(int i = ...;...; i += 2)` 语句内的 `i += 2`\n\n使用**非注释源语句限制**字段可指定 lambda 表达式中允许的最大语句数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLongLambda",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParametersPerMethod",
                "shortDescription": {
                  "text": "形参过多的方法"
                },
                "fullDescription": {
                  "text": "报告形参数量超过指定最大值的方法。 方法的形参过多可能表明有必要重构。 不报告具有 super 方法的方法。 使用形参限制字段可以指定方法允许的最大形参数量。",
                  "markdown": "报告形参数量超过指定最大值的方法。 方法的形参过多可能表明有必要重构。\n\n不报告具有 super 方法的方法。\n\n使用**形参限制**字段可以指定方法允许的最大形参数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithTooManyParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneDeclaresCloneNotSupported",
                "shortDescription": {
                  "text": "'clone()' 未声明 'CloneNotSupportedException'"
                },
                "fullDescription": {
                  "text": "报告不声明 'throws CloneNotSupportedException' 的 'clone()' 方法。 如果没有声明 'throws CloneNotSupportedException'，该方法的子类将不能以标准方式禁止克隆。 此检查不会报告声明为 'final' 的 'clone()' 方法和 'final' 类内的 'clone()' 方法。 配置检查： 使用仅对 'protected' 克隆方法发出警告选项可以指示此检查仅对 'protected clone()' 方法发出警告。 Effective Java 一书（第二版和第三版）建议在 'public' 方法上省略 'CloneNotSupportedException' 声明，因为不抛出已检查的异常的方法更容易使用。 示例： 'public class Example implements Cloneable {\n    // 方法未声明 ’throws CloneNotSupportedException‘\n    protected Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n  }'",
                  "markdown": "报告不声明 `throws CloneNotSupportedException` 的 `clone()` 方法。\n\n如果没有声明 `throws CloneNotSupportedException`，该方法的子类将不能以标准方式禁止克隆。 此检查不会报告声明为 `final` 的 `clone()` 方法和 `final` 类内的 `clone()` 方法。\n\n配置检查：\n\n使用**仅对 'protected' 克隆方法发出警告** 选项可以指示此检查仅对 `protected clone()` 方法发出警告。\n*Effective Java* 一书（第二版和第三版）建议在 `public` 方法上省略 `CloneNotSupportedException` 声明，因为不抛出已检查的异常的方法更容易使用。\n\n示例：\n\n\n      public class Example implements Cloneable {\n        // 方法未声明 'throws CloneNotSupportedException'\n        protected Object clone() {\n            try {\n                return super.clone();\n            } catch (CloneNotSupportedException e) {\n                return null;\n            }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneDoesntDeclareCloneNotSupportedException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 89,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanExpressionMayBeConditional",
                "shortDescription": {
                  "text": "布尔表达式可被替换为条件表达式"
                },
                "fullDescription": {
                  "text": "报告任何能够以比使用条件表达式更紧凑、更清晰的方式来表述的 'boolean' 表达式。 使用该快速修复可以将 'boolean' 表达式替换为条件表达式。 示例： 'a && b || !a && c;' 在应用快速修复后： 'a ? b : c;'",
                  "markdown": "报告任何能够以比使用条件表达式更紧凑、更清晰的方式来表述的 `boolean` 表达式。\n\n使用该快速修复可以将 `boolean` 表达式替换为条件表达式。\n\n**示例：**\n\n\n      a && b || !a && c;\n\n在应用快速修复后：\n\n\n      a ? b : c;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "BooleanExpressionMayBeConditional",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryExplicitNumericCast",
                "shortDescription": {
                  "text": "不必要的显式数字转换"
                },
                "fullDescription": {
                  "text": "报告将由编译器隐式插入的基元数字类型转换。 此外，报告编译器将移除的任何基元数值转换。 示例： 'int x = (short)5; // 该转换将被 javac 工具移除' 在应用快速修复后： 'int x = 5;'",
                  "markdown": "报告将由编译器隐式插入的基元数字类型转换。 此外，报告编译器将移除的任何基元数值转换。\n\n**示例：**\n\n    int x = (short)5; // 该转换将被 javac 工具移除\n\n在应用快速修复后：\n`int x = 5;`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryExplicitNumericCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 109,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TransientFieldNotInitialized",
                "shortDescription": {
                  "text": "transient 字段在反序列化时未初始化"
                },
                "fullDescription": {
                  "text": "报告在正常对象构造过程中初始化，但其类没有 'readObject' 方法的 'transient' 字段。 'transient' 字段未被序列化，因此在反序列化期间，需要在 'readObject()' 方法中单独初始化。 任何在正常对象构造过程中未被初始化的 'transient' 字段都被视为使用默认初始化，并且不会被此检查报告。 示例： 'class Person implements Serializable {\n    transient String name = \"Default\"; //警告，反序列化后实际上可能为 null\n    transient String surname; //null 被视为默认值，不予报告\n  }'",
                  "markdown": "报告在正常对象构造过程中初始化，但其类没有 `readObject` 方法的 `transient` 字段。\n\n\n`transient` 字段未被序列化，因此在反序列化期间，需要在 `readObject()` 方法中单独初始化。\n\n\n任何在正常对象构造过程中未被初始化的 `transient` 字段都被视为使用默认初始化，并且不会被此检查报告。\n\n**示例：**\n\n\n      class Person implements Serializable {\n        transient String name = \"Default\"; //警告，反序列化后实际上可能为 null\n        transient String surname; //null 被视为默认值，不予报告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TransientFieldNotInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PropertyValueSetToItself",
                "shortDescription": {
                  "text": "属性值设置为自身"
                },
                "fullDescription": {
                  "text": "报告以相同的对象 getter 作为值的 setter 方法的调用。 该代码通常不执行任何工作，并且可能不是有意为之。 示例： 'bean.setPayerId(bean.getPayerId());'",
                  "markdown": "报告以相同的对象 getter 作为值的 setter 方法的调用。 该代码通常不执行任何工作，并且可能不是有意为之。\n\n**示例：**\n\n    bean.setPayerId(bean.getPayerId());\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PropertyValueSetToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 110,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInitializer",
                "shortDescription": {
                  "text": "非 'static' 初始值设定项"
                },
                "fullDescription": {
                  "text": "报告类中的非 'static' 初始值设定项。 某些编码标准禁止实例初始值设定项，建议使用构造函数或字段初始值设定项进行初始化。 此外，删除 'static' 关键字可能会导致意外创建非 'static' 初始值设定项，造成模糊不清的错误。 此检查不报告匿名类中的实例初始值设定项。 使用仅在类具有一个或多个构造函数时警告选项，可忽略没有任何构造函数的类中的实例初始值设定项。",
                  "markdown": "报告类中的非 `static` 初始值设定项。\n\n某些编码标准禁止实例初始值设定项，建议使用构造函数或字段初始值设定项进行初始化。\n此外，删除 `static` 关键字可能会导致意外创建非 `static` 初始值设定项，造成模糊不清的错误。\n\n此检查不报告匿名类中的实例初始值设定项。\n\n\n使用**仅在类具有一个或多个构造函数时警告**选项，可忽略没有任何构造函数的类中的实例初始值设定项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonStaticInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueOrBreakFromFinallyBlock",
                "shortDescription": {
                  "text": "'continue' 或 'break' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'break' 或 'continue' 语句。 虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试复杂化。 示例： 'while (true) {\n        try {\n          throwingMethod();\n        } finally {\n            continue;\n        }\n    }'",
                  "markdown": "报告 `finally` 块中的 `break` 或 `continue` 语句。\n\n虽然偶尔是有意为之，但此类语句非常令人困惑，可能会掩盖抛出的异常，并导致调试复杂化。\n\n**示例：**\n\n\n        while (true) {\n            try {\n              throwingMethod();\n            } finally {\n                continue;\n            }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueOrBreakFromFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LengthOneStringsInConcatenation",
                "shortDescription": {
                  "text": "单字符字符串串联"
                },
                "fullDescription": {
                  "text": "报告与一个字符组成的字符串文字的串联。 这些文字可以替换为等效的字符文字，从而提升一定的性能。 示例： 'String hello = hell + \"o\";' 在应用快速修复后： 'String hello = hell + 'o';'",
                  "markdown": "报告与一个字符组成的字符串文字的串联。\n\n这些文字可以替换为等效的字符文字，从而提升一定的性能。\n\n**示例：**\n\n\n      String hello = hell + \"o\";\n\n在应用快速修复后：\n\n\n      String hello = hell + 'o';\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStringConcatenation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyTransitiveDependencies",
                "shortDescription": {
                  "text": "可传递依赖项过多的类"
                },
                "fullDescription": {
                  "text": "报告直接或间接依赖于过多其他类的类。 对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。 仅报告顶级类。 使用最大传递依赖项数字段可指定类允许的最大直接或间接依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告直接或间接依赖于过多其他类的类。\n\n对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。\n\n仅报告顶级类。\n\n使用**最大传递依赖项数**字段可指定类允许的最大直接或间接依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyTransitiveDependencies",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 113,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryThis",
                "shortDescription": {
                  "text": "不必要的 'this' 限定符"
                },
                "fullDescription": {
                  "text": "报告不必要的 'this' 限定符。 使用 'this' 来消除代码引用的歧义在许多编码样式中都不受鼓励，并且很容易通过自动重构变得不必要。 示例： 'class Foo {\n    int x;\n    void foo() {\n      this.x = 2;\n    }\n  }' 在应用快速修复后： 'class Foo {\n    int x;\n    void foo() {\n      x = 2;\n    }\n  }' 使用检查设置可以忽略对字段的赋值。 例如，'this.x = 2;' 不会被报告，但 'int y = this.x;' 会被报告。",
                  "markdown": "报告不必要的 `this` 限定符。\n\n\n使用 ` this ` 来消除代码引用的歧义在许多编码样式中都不受鼓励，并且很容易通过自动重构变得不必要。\n\n**示例：**\n\n\n      class Foo {\n        int x;\n        void foo() {\n          this.x = 2;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        int x;\n        void foo() {\n          x = 2;\n        }\n      }\n\n\n使用检查设置可以忽略对字段的赋值。\n例如，`this.x = 2;` 不会被报告，但 `int y = this.x;` 会被报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopWithImplicitTerminationCondition",
                "shortDescription": {
                  "text": "具有隐式终止条件的循环"
                },
                "fullDescription": {
                  "text": "报告任何以 'true' 常量作为其唯一条件的 'while'、'do-while' 和 'for' 循环。 同时，此类循环仍然能够被可以跳出循环的包含 'if' 语句终止。 此类 'if' 语句必须是 'while' 或 'for' 循环中的第一个或唯一语句，也必须是 'do-while' 循环中的最后一个或唯一语句。 移除 'if' 语句并将其条件设为显式循环条件可简化循环。",
                  "markdown": "报告任何以 `true` 常量作为其唯一条件的 `while`、`do-while` 和 `for` 循环。 同时，此类循环仍然能够被可以跳出循环的包含 `if` 语句终止。\n\n此类 `if` 语句必须是 `while` 或 `for` 循环中的第一个或唯一语句，也必须是 `do-while` 循环中的最后一个或唯一语句。\n\n移除 `if` 语句并将其条件设为显式循环条件可简化循环。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopWithImplicitTerminationCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitArrayFilling",
                "shortDescription": {
                  "text": "显式数组填充"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'Arrays.setAll()' 或 'Arrays.fill()' 调用的循环。 如果项目或模块的语言级别为 8 或更高，则此检查建议将循环替换为 'Arrays.setAll()'。 您可以在任何语言级别将循环替换为 'Arrays.fill()'。 示例： 'for (int i=0; i<array.length; i++) {\n     array[i] = calc(i);\n  }' 在应用快速修复后： 'Arrays.setAll(array, this::calc);' 2017.1 最新变化",
                  "markdown": "报告可以替换为 `Arrays.setAll()` 或 `Arrays.fill()` 调用的循环。\n\n如果项目或模块的语言级别为 8 或更高，则此检查建议将循环替换为 `Arrays.setAll()`。\n您可以在任何语言级别将循环替换为 `Arrays.fill()`。\n\n示例：\n\n\n      for (int i=0; i<array.length; i++) {\n         array[i] = calc(i);\n      }\n\n在应用快速修复后：\n\n\n      Arrays.setAll(array, this::calc);\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExplicitArrayFilling",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionDeclared",
                "shortDescription": {
                  "text": "已声明禁止异常"
                },
                "fullDescription": {
                  "text": "报告在其 'throws' 子句中声明不适当异常的方法。 例如，异常可能因为过于通用而不适当，例如 'java.lang.Exception' 或 'java.lang.Throwable'。 示例： 'void describeModule(String module) throws Exception {} // 警告：声明了禁止的异常 'Exception'' 配置检查： 使用被禁止的异常列表可指定应报告哪些异常。 使用忽略在重写库方法的方法上声明的异常选项可忽略在重写库方法的方法上声明的异常。",
                  "markdown": "报告在其 `throws` 子句中声明不适当异常的方法。 例如，异常可能因为过于通用而不适当，例如 `java.lang.Exception` 或 `java.lang.Throwable`。\n\n**示例：**\n\n\n      void describeModule(String module) throws Exception {} // 警告：声明了禁止的异常 'Exception'\n\n配置检查：\n\n* 使用**被禁止的异常**列表可指定应报告哪些异常。\n* 使用**忽略在重写库方法的方法上声明的异常**选项可忽略在重写库方法的方法上声明的异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionDeclared",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntegerMultiplicationImplicitCastToLong",
                "shortDescription": {
                  "text": "整数乘法或移位隐式转换为 'long'"
                },
                "fullDescription": {
                  "text": "报告隐式转换为 long 的整数乘法和左移。 示例： 'void f(int i) {\n    long val = 65536 * i;\n  }' 应用快速修复后，代码变为： 'void x(int i) {\n    long val = 65536L * i;\n  }' 示例： 'void f(int i) {\n    long value = i << 24;\n  }' 应用快速修复后，代码变为： 'void f(int i) {\n    long value = (long) i << 24;\n  }' 此类乘法通常表明有错误，因为可能会意外发生溢出截断。 将 'int' 文字转换为 'long' 文字 ('65536L') 可以修正该问题。",
                  "markdown": "报告隐式转换为 long 的整数乘法和左移。\n\n**示例：**\n\n\n      void f(int i) {\n        long val = 65536 * i;\n      }\n\n应用快速修复后，代码变为：\n\n\n      void x(int i) {\n        long val = 65536L * i;\n      }\n\n**示例：**\n\n\n      void f(int i) {\n        long value = i << 24;\n      }\n\n应用快速修复后，代码变为：\n\n\n      void f(int i) {\n        long value = (long) i << 24;\n      }\n\n\n此类乘法通常表明有错误，因为可能会意外发生溢出截断。\n将 `int` 文字转换为 `long` 文字 (`65536`**L**) 可以修正该问题。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntegerMultiplicationImplicitCastToLong",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 109,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssignmentWithOperatorAssignment",
                "shortDescription": {
                  "text": "赋值可被替换为运算符赋值"
                },
                "fullDescription": {
                  "text": "报告可以替换为运算符赋值的赋值运算。 使用运算符赋值的代码更短，可能更清晰。 示例： 'x = x + 3;\n  x = x / 3;' 在应用快速修复后： 'x += 3;\n  x /= 3;' 使用忽略条件运算符选项可忽略 '&&' 和 '||'。 将条件运算符替换为运算符赋值将使惰性求值变为及早求值，从而可能改变表达式的语义。 使用忽略模糊运算符选项可忽略不太为人所知的 '^' 和 '%'。",
                  "markdown": "报告可以替换为运算符赋值的赋值运算。\n\n使用运算符赋值的代码更短，可能更清晰。\n\n**示例：**\n\n      x = x + 3;\n      x = x / 3;\n\n在应用快速修复后：\n\n      x += 3;\n      x /= 3;\n\n\n使用**忽略条件运算符** 选项可忽略 `&&` 和 `||`。 将条件运算符替换为运算符赋值将使惰性求值变为及早求值，从而可能改变表达式的语义。\n\n\n使用**忽略模糊运算符** 选项可忽略不太为人所知的 `^` 和 `%`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AssignmentReplaceableWithOperatorAssignment",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnFromFinallyBlock",
                "shortDescription": {
                  "text": "'return' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'return' 语句。 虽然偶尔是有意为之，但此类 'return' 语句可能会掩盖抛出的异常，并导致调试复杂化。 示例： 'try {\n    foo();\n  } finally {\n    if (bar()) return;\n  }'",
                  "markdown": "报告 `finally` 块中的 `return` 语句。\n\n虽然偶尔是有意为之，但此类 `return` 语句可能会掩盖抛出的异常，并导致调试复杂化。\n\n**示例：**\n\n\n      try {\n        foo();\n      } finally {\n        if (bar()) return;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnInsideFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitClose",
                "shortDescription": {
                  "text": "冗余 'close()'"
                },
                "fullDescription": {
                  "text": "报告在 try-with-resources 块的末尾对 'close()' 的不必要调用，并建议移除它们。 示例： 'try(MyAutoCloseable ac = new MyAutoCloseable()) {\n    foo();\n    ac.close();\n  }' 在应用快速修复后： 'try(MyAutoCloseable ac = new MyAutoCloseable()) {\n    foo();\n  }' 2018.1 最新变化",
                  "markdown": "报告在 try-with-resources 块的末尾对 `close()` 的不必要调用，并建议移除它们。\n\n**示例**：\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n        ac.close();\n      }\n\n在应用快速修复后：\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n      }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitClose",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertStatement",
                "shortDescription": {
                  "text": "'assert' 语句"
                },
                "fullDescription": {
                  "text": "报告 'assert' 语句。 默认情况下，在生产环境中执行期间禁用 'assert' 语句。 可以考虑改用记录器或异常。 Java 1.3 和更早版本的 JVM 不支持 'assert' 语句。",
                  "markdown": "报告 `assert` 语句。 默认情况下，在生产环境中执行期间禁用 `assert` 语句。 可以考虑改用记录器或异常。\n\nJava 1.3 和更早版本的 JVM 不支持 `assert` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 114,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySemicolon",
                "shortDescription": {
                  "text": "不必要的分号"
                },
                "fullDescription": {
                  "text": "报告任何不必要的分号，包括在类成员之间、块语句内部或类定义之后使用的分号。 尽管这些分号在 Java 中有效，但它们是冗余的，可以被删除。 示例： 'class C {\n    ;\n    void m() throws Exception {\n        try (AutoCloseable r1 = createAutoCloseable();) {\n          ;\n        }\n    }\n    ;\n  }' 在应用快速修复后： 'class C {\n    void m() throws Exception {\n      try (AutoCloseable r1 = createAutoCloseable()) {\n      }\n    }\n  }'",
                  "markdown": "报告任何不必要的分号，包括在类成员之间、块语句内部或类定义之后使用的分号。\n\n尽管这些分号在 Java 中有效，但它们是冗余的，可以被删除。\n\n示例：\n\n\n      class C {\n        ;\n        void m() throws Exception {\n            try (AutoCloseable r1 = createAutoCloseable();) {\n              ;\n            }\n        }\n        ;\n      }\n\n在应用快速修复后：\n\n\n      class C {\n        void m() throws Exception {\n          try (AutoCloseable r1 = createAutoCloseable()) {\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarySemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocBlankLines",
                "shortDescription": {
                  "text": "空行应替换为 <p> 以换行"
                },
                "fullDescription": {
                  "text": "报告 Javadoc 注释中的空行。 Javadoc 中的空行可能表示将文本拆分为不同段落的意图。 但是，Javadoc 工具和 IntelliJ IDEA 在呈现文档注释时会忽略它们。 该快速修复会建议将空行替换为段落标记 (<p>)。 示例： 'class Main {\n    /**\n     * 不起作用。\n     *\n     * 完全不起作用\n     */\n    void foo() {}\n  }' 在应用快速修复后： 'class Main {\n    /**\n     * 不起作用。\n     * <p>\n     * 完全不起作用\n     */\n    void foo() {}\n  }' 2022.1 最新变化",
                  "markdown": "报告 Javadoc 注释中的空行。\n\n\nJavadoc 中的空行可能表示将文本拆分为不同段落的意图。 但是，Javadoc 工具和 IntelliJ IDEA 在呈现文档注释时会忽略它们。\n\n\n该快速修复会建议将空行替换为段落标记 (\\<p\\>)。\n\n**示例：**\n\n\n      class Main {\n        /**\n         * 不起作用。\n         *\n         * 完全不起作用\n         */\n        void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        /**\n         * 不起作用。\n         * <p>\n         * 完全不起作用\n         */\n        void foo() {}\n      }\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocBlankLines",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassWithPublicConstructor",
                "shortDescription": {
                  "text": "实用程序类具有 'public' 构造函数"
                },
                "fullDescription": {
                  "text": "报告包含 'public' 构造函数的实用程序类。 实用程序类将所有字段和方法声明为 'static'。 在这种类中创建 'public' 构造函数令人困惑，并且可能导致类意外实例化。 示例： 'public final class UtilityClass {\n    public UtilityClass(){\n    }\n    public static void foo() {}\n  }' 在应用快速修复后： 'public final class UtilityClass {\n    private UtilityClass(){\n    }\n    public static void foo() {}\n  }'",
                  "markdown": "报告包含 `public` 构造函数的实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`。 在这种类中创建 `public` 构造函数令人困惑，并且可能导致类意外实例化。\n\n**示例：**\n\n\n      public final class UtilityClass {\n        public UtilityClass(){\n        }\n        public static void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      public final class UtilityClass {\n        private UtilityClass(){\n        }\n        public static void foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassWithPublicConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterExtendsFinalClass",
                "shortDescription": {
                  "text": "类型形参扩展 'final' 类"
                },
                "fullDescription": {
                  "text": "报告为扩展 'final' 类而声明的类型形参。 由于无法扩展 'final' 类，建议将类型形参替换为指定的 'final' 类的类型。 示例： 'void foo() {\n    List<? extends Integer> list; // 警告：Integer 类为 final 类\n  }' 在应用快速修复后： 'void foo() {\n    List<Integer> list;\n  }' 此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。",
                  "markdown": "报告为扩展 `final` 类而声明的类型形参。\n\n由于无法扩展 `final` 类，建议将类型形参替换为指定的 `final` 类的类型。\n\n**示例：**\n\n\n      void foo() {\n        List<? extends Integer> list; // 警告：Integer 类为 final 类\n      }\n\n在应用快速修复后：\n\n\n      void foo() {\n        List<Integer> list;\n      }\n\n此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterExtendsFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialIf",
                "shortDescription": {
                  "text": "冗余的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告可以简化为单个赋值、'return' 或 'assert' 语句的 'if' 语句。 示例： 'if (foo()) {\n    return true;\n  } else {\n    return false;\n  }' 在应用快速修复后： 'return foo();' 配置检查： 如果要隐藏链式 'if' 语句的警告，请使用忽略链式 'if' 语句选项。 例如，在以下代码中，警告将被隐藏，但快速修复仍然可用： 'if (condition1) return true;\n  if (condition2) return false;\n  return true;' 请注意，如果条件有副作用，将 'if (isTrue()) assert false;' 替换为 'assert isTrue();' 可能会改变禁用 assert 时的程序语义。 如果要隐藏 'if' 语句在其主体中仅包含 'assert' 语句的警告，请使用忽略带有普通 'assert' 的 'if' 语句选项。",
                  "markdown": "报告可以简化为单个赋值、`return` 或 `assert` 语句的 `if` 语句。\n\n示例：\n\n\n      if (foo()) {\n        return true;\n      } else {\n        return false;\n      }\n\n在应用快速修复后：\n\n\n      return foo();\n\n配置检查：\n\n如果要隐藏链式 `if` 语句的警告，请使用**忽略链式 'if' 语句**选项。\n\n例如，在以下代码中，警告将被隐藏，但快速修复仍然可用：\n\n\n      if (condition1) return true;\n      if (condition2) return false;\n      return true;\n\n请注意，如果条件有副作用，将 `if (isTrue()) assert false;` 替换为 `assert isTrue();` 可能会改变禁用 assert 时的程序语义。\n如果要隐藏 `if` 语句在其主体中仅包含 `assert` 语句的警告，请使用**忽略带有普通 'assert' 的 'if' 语句**选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantIfStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceGuardedByStatic",
                "shortDescription": {
                  "text": "由 static 字段保护的实例成员"
                },
                "fullDescription": {
                  "text": "报告保护符是 'static' 字段的实例字段或方法上的 '@GuardedBy' 注解。 用 static 来保护非 static 可能会导致过度的锁争用，因为访问任何对象实例中的每个锁定字段均将阻止同时访问每个对象实例中的字段。 示例： 'private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static 保护字段\n    private Object state;\n\n    @GuardedBy(\"lock\")\n    public void bar() {\n        state = new Object();\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告保护符是 `static` 字段的实例字段或方法上的 `@GuardedBy` 注解。 用 static 来保护非 static 可能会导致过度的锁争用，因为访问任何对象实例中的每个锁定字段均将阻止同时访问每个对象实例中的字段。\n\n示例：\n\n\n        private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static 保护字段\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceGuardedByStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 76,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanMethodIsAlwaysInverted",
                "shortDescription": {
                  "text": "布尔方法总是反向的"
                },
                "fullDescription": {
                  "text": "报告返回值类型为 'boolean' 且在调用时始终求反的方法。 提供了一种快速修复方法来反转并可选择地重命名该方法。 由于性能原因，并不是所有有问题的方法都会在编辑器中高亮显示。 示例： 'class C {\n    boolean alwaysTrue() {\n      return true;\n    }\n\n    void f() {\n      if (!alwaysTrue()) {\n        return;\n      }\n    }\n    boolean member = !alwaysTrue();\n  }' 在应用快速修复后： 'class C {\n    boolean alwaysFalse() {\n      return false;\n    }\n\n    void f() {\n      if (alwaysFalse()) {\n        return;\n      }\n    }\n    boolean member = alwaysFalse();\n  }'",
                  "markdown": "报告返回值类型为 `boolean` 且在调用时始终求反的方法。\n\n提供了一种快速修复方法来反转并可选择地重命名该方法。\n由于性能原因，并不是所有有问题的方法都会在编辑器中高亮显示。\n\n示例：\n\n\n      class C {\n        boolean alwaysTrue() {\n          return true;\n        }\n\n        void f() {\n          if (!alwaysTrue()) {\n            return;\n          }\n        }\n        boolean member = !alwaysTrue();\n      }\n\n在应用快速修复后：\n\n\n      class C {\n        boolean alwaysFalse() {\n          return false;\n        }\n\n        void f() {\n          if (alwaysFalse()) {\n            return;\n          }\n        }\n        boolean member = alwaysFalse();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanMethodIsAlwaysInverted",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoCloseableResource",
                "shortDescription": {
                  "text": "在没有 'try-with-resources' 的情况下使用 AutoCloseable"
                },
                "fullDescription": {
                  "text": "报告未在 try-with-resources 语句中使用的 'AutoCloseable' 实例，也称 自动资源管理。 这意味着还报告在 try-with-resources 可用前使用的“在 'try' 前面/中打开资源，在 'finally' 中关闭资源”的样式。 在 Java 7 及更高版本中开发时，此检查意在取代所有已打开但未安全关闭的检查。 示例： 'private static void foo() throws IOException {\n    InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/someFile\");\n    System.out.println(profile.read());\n  }' 使用以下选项配置检查： 列出不需关闭并且此检查应当忽略的 'AutoCloseable' 的子类。 注意：即便列出将忽略 'java.util.stream.Stream'，该检查仍将报告从 'java.nio.file.Files' 方法 'lines()'、'walk()'、'list()' 以及 'find()' 返回的流。 这些流包含需要关闭的关联 I/O 资源。 列出在调用时应被忽略的返回 'AutoCloseable' 的方法。 如果为方法调用的结果时是否忽略 'AutoCloseable'。 启用此选项时，工厂方法的结果也将被忽略。 当 'AutoCloseable' 实例作为方法调用实参传递时，该检查是否应报告。 如果启用此选项，该检查将假定所调用方法中的资源已关闭。 不会忽略名称中含有 'close' 的 'finally' 块和 'AutoCloseable' 实参中的方法调用。 是否忽略对资源类构造函数的方法引用。 是否忽略返回资源且名称以 'get' 开头的方法。 这可能会减少误报，因为大多数 getter 不转移资源的所有权，并且其调用点不负责关闭资源。 此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。",
                  "markdown": "报告未在 try-with-resources 语句中使用的 `AutoCloseable` 实例，也称 *自动资源管理* 。\n\n\n这意味着还报告在 try-with-resources 可用前使用的\"在 `try` 前面/中打开资源，在 `finally` 中关闭资源\"的样式。\n在 Java 7 及更高版本中开发时，此检查意在取代所有*已打开但未安全关闭*的检查。\n\n**示例：**\n\n\n      private static void foo() throws IOException {\n        InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/someFile\");\n        System.out.println(profile.read());\n      }\n\n\n使用以下选项配置检查：\n\n* 列出不需关闭并且此检查应当忽略的 `AutoCloseable` 的子类。   \n  **注意** ：即便列出将忽略 `java.util.stream.Stream`，该检查仍将报告从 `java.nio.file.Files` 方法 `lines()`、`walk()`、`list()` 以及 `find()` 返回的流。 这些流包含需要关闭的关联 I/O 资源。\n* 列出在调用时应被忽略的返回 `AutoCloseable` 的方法。\n* 如果为方法调用的结果时是否忽略 `AutoCloseable`。 启用此选项时，工厂方法的结果也将被忽略。\n* 当 `AutoCloseable` 实例作为方法调用实参传递时，该检查是否应报告。 如果启用此选项，该检查将假定所调用方法中的资源已关闭。 不会忽略名称中含有 'close' 的 `finally` 块和 `AutoCloseable` 实参中的方法调用。\n* 是否忽略对资源类构造函数的方法引用。\n* 是否忽略返回资源且名称以 'get' 开头的方法。 这可能会减少误报，因为大多数 getter 不转移资源的所有权，并且其调用点不负责关闭资源。\n\n此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "resource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleStatementInBlock",
                "shortDescription": {
                  "text": "代码块包含单条语句"
                },
                "fullDescription": {
                  "text": "报告代码块中仅有一条语句的控制流语句，并建议移除控制流语句体中的大括号。 示例： 'if (x > 0) {\n    System.out.println(\"x is positive\");\n  }' 在应用快速修复后： 'if (x > 0) System.out.println(\"x is positive\");'",
                  "markdown": "报告代码块中仅有一条语句的控制流语句，并建议移除控制流语句体中的大括号。\n\n示例：\n\n\n      if (x > 0) {\n        System.out.println(\"x is positive\");\n      }\n\n在应用快速修复后：\n\n\n      if (x > 0) System.out.println(\"x is positive\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleStatementInBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestCaseWithConstructor",
                "shortDescription": {
                  "text": "具有非普通构造函数的 TestCase"
                },
                "fullDescription": {
                  "text": "报告在其构造函数中具有初始化逻辑的测试用例。 如果构造函数失败，将不会调用 '@After' 注解方法或 'tearDown()' 方法。 这可能导致测试环境部分初始化，因而对其他测试产生不利影响。 相反，测试用例初始化应在 'setUp()' 或 '@Before' 注解方法中完成。 不良示例： 'public class ImportantTest {\n    private File file;\n\n    public ImportantTest() throws IOException {\n      file = File.createTempFile(\"xyz\", \".tmp\");\n    }\n\n    // ... tests go here\n  }'",
                  "markdown": "报告在其构造函数中具有初始化逻辑的测试用例。 如果构造函数失败，将不会调用 `@After` 注解方法或 `tearDown()` 方法。 这可能导致测试环境部分初始化，因而对其他测试产生不利影响。 相反，测试用例初始化应在 `setUp()` 或 `@Before` 注解方法中完成。\n\n不良示例：\n\n\n      public class ImportantTest {\n        private File file;\n\n        public ImportantTest() throws IOException {\n          file = File.createTempFile(\"xyz\", \".tmp\");\n        }\n\n        // ... tests go here\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JUnitTestCaseWithNonTrivialConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadObjectAndWriteObjectPrivate",
                "shortDescription": {
                  "text": "'readObject()' 或 'writeObject()' 未被声明为 'private'"
                },
                "fullDescription": {
                  "text": "报告 'readObject' 或 'writeObject' 方法未被声明为 private 的 'Serializable' 类。 这些方法的可见性没有理由比 'private' 更高。 建议通过快速修复将相应的方法设为 'private'。 示例： 'public class Test implements Serializable {\n    public void readObject(ObjectInputStream stream) {\n      /* ... */\n    }\n  }' 在应用快速修复后： 'public class Test implements Serializable {\n    private void readObject(ObjectInputStream stream) {\n      /* ... */\n    }\n  }'",
                  "markdown": "报告 `readObject` 或 `writeObject` 方法未被声明为 private 的 `Serializable` 类。 这些方法的可见性没有理由比 `private` 更高。\n\n\n建议通过快速修复将相应的方法设为 `private`。\n\n**示例：**\n\n\n      public class Test implements Serializable {\n        public void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Test implements Serializable {\n        private void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPrivateSerializationMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantFileCreation",
                "shortDescription": {
                  "text": "创建冗余 'File' 实例"
                },
                "fullDescription": {
                  "text": "在只能使用 'String' 路径的情况下，报告在下面的一种构造函数中创建的冗余 'File'：'FileInputStream'、'FileOutputStream'、'FileReader'、'FileWriter'、'PrintStream'、'PrintWriter'、'Formatter'。 示例： 'InputStream is = new FileInputStream(new File(\"in.txt\"));' 在应用快速修复后： 'InputStream is = new FileInputStream(\"in.txt\");' 2020.3 最新变化",
                  "markdown": "在只能使用 `String` 路径的情况下，报告在下面的一种构造函数中创建的冗余 `File`：`FileInputStream`、`FileOutputStream`、`FileReader`、`FileWriter`、`PrintStream`、`PrintWriter`、`Formatter`。\n\n示例：\n\n\n    InputStream is = new FileInputStream(new File(\"in.txt\"));\n\n在应用快速修复后：\n\n\n    InputStream is = new FileInputStream(\"in.txt\");\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantFileCreation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBooleanExpression",
                "shortDescription": {
                  "text": "无意义的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告不必要的或过于复杂的布尔表达式。 此类表达式包括： '&&' 和 'true' 的组合、 '||' 和 'false' 的组合、布尔文字的相等比较或布尔文字求反。 此类表达可以简化。 示例： 'boolean a = !(x && false);\n  boolean b = false || x;\n  boolean c = x != true;' 在应用快速修复后： 'boolean a = true;\n  boolean b = x;\n  boolean c = !x;' 配置检查： 使用 在确定无意义表达式时忽略命名常量 选项可在确定表达式是否无意义时忽略命名常量。",
                  "markdown": "报告不必要的或过于复杂的布尔表达式。\n\n此类表达式包括： `&&` 和 `true` 的组合、\n`||` 和 `false` 的组合、布尔文字的相等比较或布尔文字求反。 此类表达可以简化。\n\n示例：\n\n\n      boolean a = !(x && false);\n      boolean b = false || x;\n      boolean c = x != true;\n\n在应用快速修复后：\n\n\n      boolean a = true;\n      boolean b = x;\n      boolean c = !x;\n\n\n配置检查：\n使用 **在确定无意义表达式时忽略命名常量** 选项可在确定表达式是否无意义时忽略命名常量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListenerMayUseAdapter",
                "shortDescription": {
                  "text": "类可以扩展适配器而不是实现侦听器"
                },
                "fullDescription": {
                  "text": "报告实现侦听器而不是扩展相应适配器的类。 在将侦听器实现替换为适配器扩展后，可以通过快速修复来移除任何冗余的空方法。 使用仅在找到空实现方法时发出警告选项可将检查配置为即便未发现空方法也发出警告。",
                  "markdown": "报告实现侦听器而不是扩展相应适配器的类。\n\n在将侦听器实现替换为适配器扩展后，可以通过快速修复来移除任何冗余的空方法。\n\n\n使用**仅在找到空实现方法时发出警告**选项可将检查配置为即便未发现空方法也发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListenerMayUseAdapter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RefusedBequest",
                "shortDescription": {
                  "text": "方法不调用 super 方法"
                },
                "fullDescription": {
                  "text": "报告重写而不调用 super 方法的方法。 这也称作被拒绝的遗赠。 此类方法可能表明抽象失败，导致出现难以跟踪的 bug。 检查不报告从 'java.lang.Object'重写的方法（'clone()' 除外）。 按照惯例，'clone()' 应该调用其 super 方法，该方法将返回正确类型的对象。 示例 1： 'class A {\n    @Override\n    public Object clone() {\n      // 不调用 'super.clone()'\n      return new A();\n    }\n  }' 示例 2： 'interface I {\n    default void foo() {}\n  }\n\n  class A implements I {\n    // 禁用“忽略 'default' super 方法”时\n    //  对方法发出警告\n    @Override\n    public void foo(){}\n  }' 配置检查： 使用仅在通过以下方式注解 super 方法时报告选项，可以忽略使用所提供列表中的注解标记的 super 方法。 您可以手动将注解添加到此列表中。 使用忽略空 super 方法选项，可以忽略仅抛出异常或空的 super 方法。 使用忽略 'default' super 方法选项，可以忽略接口中的 'default' super 方法。",
                  "markdown": "报告重写而不调用 super 方法的方法。 这也称作*被拒绝的遗赠* 。 此类方法可能表明抽象失败，导致出现难以跟踪的 bug。\n\n\n检查不报告从 `java.lang.Object`重写的方法（`clone()` 除外）。\n按照惯例，`clone()` 应该调用其 super 方法，该方法将返回正确类型的对象。\n\n**示例 1：**\n\n\n      class A {\n        @Override\n        public Object clone() {\n          // 不调用 'super.clone()'\n          return new A();\n        }\n      }\n\n**示例 2：**\n\n\n      interface I {\n        default void foo() {}\n      }\n\n      class A implements I {\n        // 禁用\"忽略 'default' super 方法\"时\n        //  对方法发出警告\n        @Override\n        public void foo(){}\n      }\n\n配置检查：\n\n* 使用**仅在通过以下方式注解 super 方法时报告**选项，可以忽略使用所提供列表中的注解标记的 super 方法。 您可以手动将注解添加到此列表中。\n* 使用**忽略空 super 方法**选项，可以忽略仅抛出异常或空的 super 方法。\n* 使用**忽略 'default' super 方法** 选项，可以忽略接口中的 `default` super 方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodDoesntCallSuperMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryReturn",
                "shortDescription": {
                  "text": "不必要的 'return' 语句"
                },
                "fullDescription": {
                  "text": "报告返回 'void' 的构造函数和方法结尾的 'return' 语句。 这些语句冗余，可以安全移除。 此检查不会在 JSP 文件中报告。 示例： 'void message() {\n    System.out.println(\"Hello World\");\n    return;\n  }' 在应用快速修复后： 'void message() {\n    System.out.println(\"Hello World\");\n  }' 使用在具有 'else' 分支的 'if' 语句的 then 分支中忽略选项可以忽略也有 'else' 分支的 'if' 语句的 then 分支中的 'return' 语句。",
                  "markdown": "报告返回 `void` 的构造函数和方法结尾的 `return` 语句。 这些语句冗余，可以安全移除。\n\n此检查不会在 JSP 文件中报告。\n\n示例：\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n        return;\n      }\n\n在应用快速修复后：\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n      }\n\n\n使用**在具有 'else' 分支的 'if' 语句的 then 分支中忽略** 选项可以忽略也有 `else` 分支的 `if` 语句的 then 分支中的 `return` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryReturnStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicInnerClass",
                "shortDescription": {
                  "text": "'public' 嵌套类"
                },
                "fullDescription": {
                  "text": "报告 'public' 嵌套类。 示例： 'public class Outer {\n    public static class Nested {} // 警告\n    public class Inner {}         // 警告\n    public enum Mode {}           // 警告取决于设置\n    public interface I {}         // 警告取决于设置\n  }' 配置检查： 使用忽略 'public' 内部枚举选项可忽略 'public' 内部枚举。 使用忽略 'public' 内部接口选项可忽略 'public' 内部接口。",
                  "markdown": "报告 `public` 嵌套类。\n\n**示例：**\n\n\n      public class Outer {\n        public static class Nested {} // 警告\n        public class Inner {}         // 警告\n        public enum Mode {}           // 警告取决于设置\n        public interface I {}         // 警告取决于设置\n      }\n\n配置检查：\n\n* 使用**忽略 'public' 内部枚举** 选项可忽略 `public` 内部枚举。\n* 使用**忽略 'public' 内部接口** 选项可忽略 `public` 内部接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalGuard",
                "shortDescription": {
                  "text": "非 final '@GuardedBy' 字段"
                },
                "fullDescription": {
                  "text": "报告其中的保护字段不是 'final' 的 '@GuardedBy' 注解。 在非 final 字段上进行保护可能会导致意外的竞争条件，因为该字段的值会被锁定（可能会变化），而不是锁定字段本身。 示例： 'private ReadWriteLock lock = new ReentrantReadWriteLock(); //非 final 保护字段\n    private Object state;\n\n    @GuardedBy(\"lock\")\n    public void bar() {\n        state = new Object();\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告其中的保护字段不是 `final` 的 `@GuardedBy` 注解。\n\n在非 final 字段上进行保护可能会导致意外的竞争条件，因为该字段的值会被锁定（可能会变化），而不是锁定字段本身。\n\n示例：\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock(); //非 final 保护字段\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalGuard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 76,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionAddedToSelf",
                "shortDescription": {
                  "text": "集合已添加到自身"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Collection' 或 'java.util.Map' 的方法调用的实参是集合或映射本身的情况。 由于复制粘贴，原始类型的代码中可能会出现此类情况。 示例： 'ArrayList list = new ArrayList<>();\n  list.add(list); // 此处为警告\n  return list.hashCode(); // 抛出 StackOverflowError'",
                  "markdown": "报告对 `java.util.Collection` 或 `java.util.Map` 的方法调用的实参是集合或映射本身的情况。 由于复制粘贴，原始类型的代码中可能会出现此类情况。\n\n**示例：**\n\n\n      ArrayList list = new ArrayList<>();\n      list.add(list); // 此处为警告\n      return list.hashCode(); // 抛出 StackOverflowError\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionAddedToSelf",
                    "cweIds": [
                      664,
                      688
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySuperQualifier",
                "shortDescription": {
                  "text": "不必要的 'super' 限定符"
                },
                "fullDescription": {
                  "text": "报告方法调用和字段引用中不必要的 'super' 限定符。 当超类的字段或方法在调用类中未被隐藏/重写时，不需要 'super' 限定符。 示例： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      super.foo();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    void foo() {}\n  }\n\n  class Bar extends Foo {\n    void bar() {\n      foo();\n    }\n  }' 使用检查设置可以忽略有助于区分超类成员访问与外部类的同名成员的限定符。 另请参阅以下检查： Java | 可见性 | 继承字段的访问类似于访问周围代码中的元素 Java | 可见性 | 对继承方法的调用类似于对局部方法的调用",
                  "markdown": "报告方法调用和字段引用中不必要的 `super` 限定符。\n\n\n当超类的字段或方法在调用类中未被隐藏/重写时，不需要 `super` 限定符。\n\n**示例：**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          foo();\n        }\n      }\n\n\n使用检查设置可以忽略有助于区分超类成员访问与外部类的同名成员的限定符。\n\n\n另请参阅以下检查：\n\n* *Java \\| 可见性 \\| 继承字段的访问类似于访问周围代码中的元素*\n* *Java \\| 可见性 \\| 对继承方法的调用类似于对局部方法的调用*"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarySuperQualifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsOnSuspiciousObject",
                "shortDescription": {
                  "text": "在不对其进行重写的类上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'StringBuilder'、'StringBuffer' 和 'java.util.concurrent.atomic' 软件包的实例的 'equals()' 调用。 'equals()' 方法在这些类中没有被重写，因此即使两个对象的内容相同，它也可能返回 'false'。 如果您打算使用引用相等，我们建议您使用 '==' 以避免混淆。 'StringBuilder'、'StringBuffer'、'AtomicBoolean'、'AtomicInteger'、'AtomicBoolean' 和 'AtomicLong' 的快速修复可用来转换为内容的比较。 当其中一个实例为 null 时，快速修复可能会改变语义。 示例： 'public void test(StringBuilder sb1, StringBuilder sb2) {\n    boolean result = sb1.equals(sb2); // 可疑\n  }' 在应用快速修复后： 'public void test(StringBuilder sb1, StringBuilder sb2) {\n      boolean result = sb1.toString().equals(sb2.toString());\n  }' 2017.2 最新变化",
                  "markdown": "报告对 `StringBuilder`、`StringBuffer` 和 `java.util.concurrent.atomic` 软件包的实例的 `equals()` 调用。\n\n`equals()` 方法在这些类中没有被重写，因此即使两个对象的内容相同，它也可能返回 `false`。\n如果您打算使用引用相等，我们建议您使用 `==` 以避免混淆。\n`StringBuilder`、`StringBuffer`、`AtomicBoolean`、`AtomicInteger`、`AtomicBoolean` 和 `AtomicLong` 的快速修复可用来转换为内容的比较。 当其中一个实例为 null 时，快速修复可能会改变语义。\n\n示例：\n\n\n      public void test(StringBuilder sb1, StringBuilder sb2) {\n        boolean result = sb1.equals(sb2); // 可疑\n      }\n\n在应用快速修复后：\n\n\n      public void test(StringBuilder sb1, StringBuilder sb2) {\n          boolean result = sb1.toString().equals(sb2.toString());\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsOnSuspiciousObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfPropertiesAsHashtable",
                "shortDescription": {
                  "text": "将 'Properties' 对象用作 'Hashtable'"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Properties' 对象上的以下方法的调用： 'put()' 'putIfAbsent()' 'putAll()' 'get()' 由于历史原因，'java.util.Properties' 继承自 'java.util.Hashtable'，但为防止污染 'String' 以外类型的属性值，不建议使用这些方法。 当映射中的键和值形参都为 'String' 类型时，不会报告对 'java.util.Properties.putAll()' 的调用。 此类调用是安全的，且没有更好的选择。 示例： 'Object f(Properties props) {\n    props.put(\"hello\", \"world\");\n    props.putIfAbsent(\"hello\", \"world\");\n    props.putAll(new HashMap<>());\n    return props.get(\"Hello\");\n  }' 在应用快速修复后： 'Object f(Properties props) {\n    props.setProperty(\"hello\", \"world\");\n    props.putIfAbsent(\"hello\", \"world\");\n    props.putAll(new HashMap<>());\n    return props.getProperty(\"hello\");\n  }'",
                  "markdown": "报告对 `java.util.Properties` 对象上的以下方法的调用：\n\n* `put()`\n* `putIfAbsent()`\n* `putAll()`\n* `get()`\n\n\n由于历史原因，`java.util.Properties` 继承自 `java.util.Hashtable`，但为防止污染 `String` 以外类型的属性值，不建议使用这些方法。\n\n\n当映射中的键和值形参都为 `String` 类型时，不会报告对 `java.util.Properties.putAll()` 的调用。\n此类调用是安全的，且没有更好的选择。\n\n**示例：**\n\n\n      Object f(Properties props) {\n        props.put(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.get(\"Hello\");\n      }\n\n在应用快速修复后：\n\n\n      Object f(Properties props) {\n        props.setProperty(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.getProperty(\"hello\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfPropertiesAsHashtable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCoupling",
                "shortDescription": {
                  "text": "过度耦合的方法"
                },
                "fullDescription": {
                  "text": "报告引用过多其他类的方法。 耦合度过高的方法可能非常脆弱，应该被拆分为较小的方法。 无论被引用多少次，每个被引用的类都只被计算一次。 配置检查： 使用方法耦合限制字段可指定方法允许的最大耦合度。 使用包括与 Java 系统类的耦合选项可计算对 'java' 或 'javax' 软件包中的类的引用。 使用包括与库类的耦合选项可计算对第三方库类的引用。",
                  "markdown": "报告引用过多其他类的方法。 耦合度过高的方法可能非常脆弱，应该被拆分为较小的方法。\n\n无论被引用多少次，每个被引用的类都只被计算一次。\n\n配置检查：\n\n* 使用**方法耦合限制**字段可指定方法允许的最大耦合度。\n* 使用**包括与 Java 系统类的耦合** 选项可计算对 `java` 或 `javax` 软件包中的类的引用。\n* 使用**包括与库类的耦合**选项可计算对第三方库类的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyCoupledMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessToStaticFieldLockedOnInstance",
                "shortDescription": {
                  "text": "访问实例数据上锁定的 'static' 字段"
                },
                "fullDescription": {
                  "text": "报告对在 'this' 或 'this' 的实例字段上锁定的非常量 static 字段的访问。 在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。 示例： 'static String test;\n  public void foo() {\n      synchronized (this) {\n          System.out.println(test); // 警告\n      }\n  }' 通过快速修复可以忽略特定类型的 static 字段。 可以在检查选项中管理被忽略的类型。 使用检查选项可以指定应忽略哪些用于 static 字段的类。",
                  "markdown": "报告对在 `this` 或 `this` 的实例字段上锁定的非常量 static 字段的访问。\n\n\n在实例数据上锁定 static 字段并不能防止其他实例修改该字段，因此可能会导致意外的竞争条件。\n\n**示例：**\n\n\n      static String test;\n      public void foo() {\n          synchronized (this) {\n              System.out.println(test); // 警告\n          }\n      }\n\n\n通过快速修复可以忽略特定类型的 static 字段。\n可以在检查选项中管理被忽略的类型。\n\n\n使用检查选项可以指定应忽略哪些用于 static 字段的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessToStaticFieldLockedOnInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VariableTypeCanBeExplicit",
                "shortDescription": {
                  "text": "变量类型可以是显式的"
                },
                "fullDescription": {
                  "text": "报告可以替换为显式类型的 'var' 类型的局部变量。 示例： 'var str = \"Hello\";' 在应用快速修复后： 'String str = \"Hello\";' 此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。",
                  "markdown": "报告可以替换为显式类型的 `var` 类型的局部变量。\n\n**示例：**\n\n\n      var str = \"Hello\";\n\n在应用快速修复后：\n\n\n      String str = \"Hello\";\n\n此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VariableTypeCanBeExplicit",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 10",
                      "index": 126,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8ListSort",
                "shortDescription": {
                  "text": "'Collections.sort()' 可被替换为 'List.sort()'"
                },
                "fullDescription": {
                  "text": "报告 'Collections.sort(list,comparator)' 的调用，可以替换为 'list.sort(comparator)'。 'Collections.sort' 只是一个包装器，所以最好直接使用实例方法。 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告 `Collections.sort(list,comparator)` 的调用，可以替换为 `list.sort(comparator)`。\n\n`Collections.sort` 只是一个包装器，所以最好直接使用实例方法。\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8ListSort",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorCombinators",
                "shortDescription": {
                  "text": "可以使用 'Comparator' 连结符"
                },
                "fullDescription": {
                  "text": "报告定义为可以使用 'Comparator.comparing()' 调用表示的 lambda 表达式的 'Comparator' 实例。 还会报告可以替换为 'Comparator.thenComparing()' 表达式的链式比较。 示例： 'myList.sort((person1, person2) -> person1.getName().compareTo(person2.getName()));\n\n  myList2.sort((person1, person2) -> {\n      int res = person1.first().compareTo(person2.first());\n      if(res == 0) res = person1.second().compareTo(person2.second());\n      if(res == 0) res = person1.third() - person2.third();\n      return res;\n  });' 在应用快速修复后： 'myList.sort(Comparator.comparing(Person::getName));\n\n  myList2.sort(Comparator.comparing(Person::first)\n                         .thenComparing(Person::second)\n                         .thenComparingInt(Person::third));' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告定义为可以使用 `Comparator.comparing()` 调用表示的 lambda 表达式的 `Comparator` 实例。 还会报告可以替换为 `Comparator.thenComparing()` 表达式的链式比较。\n\n示例：\n\n\n      myList.sort((person1, person2) -> person1.getName().compareTo(person2.getName()));\n\n      myList2.sort((person1, person2) -> {\n          int res = person1.first().compareTo(person2.first());\n          if(res == 0) res = person1.second().compareTo(person2.second());\n          if(res == 0) res = person1.third() - person2.third();\n          return res;\n      });\n\n在应用快速修复后：\n\n\n      myList.sort(Comparator.comparing(Person::getName));\n\n      myList2.sort(Comparator.comparing(Person::first)\n                             .thenComparing(Person::second)\n                             .thenComparingInt(Person::third));\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorCombinators",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodCallInConstructor",
                "shortDescription": {
                  "text": "对象构造期间调用的 abstract 方法"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对当前类的 'abstract' 方法的调用。 如果方法位于以下位置，则会在对象构造期间调用： 构造函数 非 static 实例初始值设定项 非 static 字段初始值设定项 'clone()' 方法 'readObject()' 方法 'readObjectNoData()' 方法 此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。 示例： 'abstract class Parent {\n    abstract void abstractMethod();\n  }\n\n  class Child extends Parent {\n    Child() {\n      abstractMethod();\n    }\n  }' 此检查与以下检查共享功能： 在对象构造期间调用的可重写方法 在对象构造期间调用的重写的方法 一次只能启用一个检查，以防止警告重复。",
                  "markdown": "报告在对象构造期间对当前类的 `abstract` 方法的调用。\n\n如果方法位于以下位置，则会在对象构造期间调用：\n\n* 构造函数\n* 非 static 实例初始值设定项\n* 非 static 字段初始值设定项\n* `clone()` 方法\n* `readObject()` 方法\n* `readObjectNoData()` 方法\n\n此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。\n\n**示例：**\n\n\n      abstract class Parent {\n        abstract void abstractMethod();\n      }\n\n      class Child extends Parent {\n        Child() {\n          abstractMethod();\n        }\n      }\n\n此检查与以下检查共享功能：\n\n* 在对象构造期间调用的可重写方法\n* 在对象构造期间调用的重写的方法\n\n一次只能启用一个检查，以防止警告重复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodCallInConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsReplaceableByObjectsCall",
                "shortDescription": {
                  "text": "'equals()' 表达式可被替换为 'Objects.equals()' 表达式"
                },
                "fullDescription": {
                  "text": "报告可以替换为对 'java.util.Objects#equals' 的调用的表达式。 示例： 'void f(Object a, Object b) {\n    boolean result = a != null && a.equals(b);\n  }' 在应用快速修复后： 'void f(Object a, Object b) {\n    boolean result = Objects.equals(a, b);\n  }' 将 'a != null && a.equals(b)' 之类的表达式替换为 'Objects.equals(a, b)' 会略微改变语义。 使用高亮显示与 'a != null && a.equals(b)' 类似的表达式选项，可启用或禁用此行为。 仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。",
                  "markdown": "报告可以替换为对 `java.util.Objects#equals` 的调用的表达式。\n\n**示例：**\n\n\n      void f(Object a, Object b) {\n        boolean result = a != null && a.equals(b);\n      }\n\n在应用快速修复后：\n\n\n      void f(Object a, Object b) {\n        boolean result = Objects.equals(a, b);\n      }\n\n\n将 `a != null && a.equals(b)` 之类的表达式替换为 `Objects.equals(a, b)` 会略微改变语义。 使用**高亮显示与 'a != null \\&\\& a.equals(b)' 类似的表达式**选项，可启用或禁用此行为。\n\n仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EqualsReplaceableByObjectsCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 127,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TailRecursion",
                "shortDescription": {
                  "text": "尾递归"
                },
                "fullDescription": {
                  "text": "报告尾递归，即方法在返回前调用自身作为其最后一项操作。 尾递归总是可以替换为循环，循环的速度快得多。 有些 JVM 执行尾调用优化，而其他一些 JVM 则不执行。 因此，尾递归解决方案在不同的虚拟机上可能有截然不同的性能特征。 示例： 'int factorial(int val, int runningVal) {\n    if (val == 1) {\n      return runningVal;\n    } else {\n      return factorial(val - 1, runningVal * val);\n    }\n  }' 在应用快速修复后： 'int factorial(int val, int runningVal) {\n    while (true) {\n      if (val == 1) {\n        return runningVal;\n      } else {\n        runningVal = runningVal * val;\n        val = val - 1;\n      }\n    }\n  }'",
                  "markdown": "报告尾递归，即方法在返回前调用自身作为其最后一项操作。\n\n\n尾递归总是可以替换为循环，循环的速度快得多。\n有些 JVM 执行尾调用优化，而其他一些 JVM 则不执行。 因此，尾递归解决方案在不同的虚拟机上可能有截然不同的性能特征。\n\n示例：\n\n\n      int factorial(int val, int runningVal) {\n        if (val == 1) {\n          return runningVal;\n        } else {\n          return factorial(val - 1, runningVal * val);\n        }\n      }\n\n在应用快速修复后：\n\n\n      int factorial(int val, int runningVal) {\n        while (true) {\n          if (val == 1) {\n            return runningVal;\n          } else {\n            runningVal = runningVal * val;\n            val = val - 1;\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TailRecursion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEqualsEmptyString",
                "shortDescription": {
                  "text": "'String.equals()' 可被替换为 'String.isEmpty()'"
                },
                "fullDescription": {
                  "text": "报告 'equals()' 被调用以将 'String' 与空字符串进行比较的情况。 在这种情况下，使用 '.isEmpty()' 更好，因为它可以准确显示您正在检查的内容。 示例： 'void checkString(String s){\n    if (\"\".equals(s)) throw new IllegalArgumentException();\n  }' 在应用快速修复后： 'void checkString(String s){\n    if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n  }' '\"\".equals(str)' 在 'str' 为空时返回 false。 为了安全起见，当 'equals()' 实参可以为空时，此检查的快速修复会插入一个显式 null 检查。 使用该选项可使检查忽略此类情况。",
                  "markdown": "报告 `equals()` 被调用以将 `String` 与空字符串进行比较的情况。 在这种情况下，使用 `.isEmpty()` 更好，因为它可以准确显示您正在检查的内容。\n\n**示例：**\n\n\n      void checkString(String s){\n        if (\"\".equals(s)) throw new IllegalArgumentException();\n      }\n\n在应用快速修复后：\n\n\n      void checkString(String s){\n        if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n      }\n\n\n`\"\".equals(str)` 在 `str` 为空时返回 false。 为了安全起见，当 `equals()` 实参可以为空时，此检查的快速修复会插入一个显式 null 检查。 使用该选项可使检查忽略此类情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEqualsEmptyString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PreviewFeature",
                "shortDescription": {
                  "text": "预览功能警告"
                },
                "fullDescription": {
                  "text": "报告预览功能 API 的用法，即使用 '@PreviewFeature' 注解的 'java.*' 或 'javax.*' 命名空间中的模块、软件包、类、接口、方法、构造函数或枚举常量。 预览特性是 Java 语言、Java 虚拟机或 Java SE API 的一个新特性，它已完全指定、完全实现，但不是永久性的。 预览特性的概念在 JEP 12 中进行了定义。 如果某段代码依赖于预览 API，如果更改或移除该功能，该段代码可能会在未来的 JDK 版本中停止编译。 仅当项目或模块的语言级别为预览版时，此检查才会报告。 2021.1 最新变化",
                  "markdown": "报告预览功能 API 的用法，即使用 `@PreviewFeature` 注解的 `java.*` 或 `javax.*` 命名空间中的模块、软件包、类、接口、方法、构造函数或枚举常量。\n\n\n预览特性是 Java 语言、Java 虚拟机或 Java SE API 的一个新特性，它已完全指定、完全实现，但不是永久性的。 预览特性的概念在 [JEP 12](https://openjdk.org/jeps/12) 中进行了定义。\n\n\n如果某段代码依赖于预览 API，如果更改或移除该功能，该段代码可能会在未来的 JDK 版本中停止编译。\n\n仅当项目或模块的语言级别为**预览版**时，此检查才会报告。\n\n2021.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "preview",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 128,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadThrows",
                "shortDescription": {
                  "text": "过宽的 'throws' 子句"
                },
                "fullDescription": {
                  "text": "报告异常比方法实际抛出的异常更通用的 'throws' 子句。 示例： 'public void createFile() throws Exception { // 警告：'throws Exception' 范围过广，屏蔽异常 'IOException'\n    File file = new File(\"pathToFile\");\n    file.createNewFile();\n  }' 在应用快速修复后： 'public void createFile() throws IOException {\n    File file = new File(\"pathToFile\");\n    file.createNewFile();\n  }' 配置检查： 使用要警告的隐藏异常的最大数量字段可以忽略隐藏了比指定数量更多的其他异常的异常。 使用仅对 RuntimeException、异常、错误或 Throwable 发出警告选项可以使此检查仅对最常见的异常发出警告。 使用忽略在重写库方法的方法上声明的异常选项可以忽略在重写库方法的方法中过于宽泛的 'throws' 子句。 使用忽略隐藏其他异常但自身被抛出的异常选项可以忽略任何隐藏其他异常，但仍可能从方法体抛出并因此在技术上不会过于宽泛的异常。",
                  "markdown": "报告异常比方法实际抛出的异常更通用的 `throws` 子句。\n\n**示例：**\n\n\n      public void createFile() throws Exception { // 警告：'throws Exception' 范围过广，屏蔽异常 'IOException'\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\n在应用快速修复后：\n\n\n      public void createFile() throws IOException {\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\n配置检查：\n\n* 使用**要警告的隐藏异常的最大数量**字段可以忽略隐藏了比指定数量更多的其他异常的异常。\n* 使用**仅对 RuntimeException、异常、错误或 Throwable 发出警告**选项可以使此检查仅对最常见的异常发出警告。\n* 使用**忽略在重写库方法的方法上声明的异常** 选项可以忽略在重写库方法的方法中过于宽泛的 `throws` 子句。\n* 使用**忽略隐藏其他异常但自身被抛出的异常**选项可以忽略任何隐藏其他异常，但仍可能从方法体抛出并因此在技术上不会过于宽泛的异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyBroadThrowsClause",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitSubclassInspection",
                "shortDescription": {
                  "text": "final 声明不能在运行时被重写"
                },
                "fullDescription": {
                  "text": "报告在运行时代码阻止某个框架（例如 Spring 或 Hibernate）对类进行子类化的情况。 必要但不可能进行子类化的典型示例： 使用特定于框架的注解（例如 Spring '@Configuration'）标记的 'final' 类 使用特定于框架的注解（例如 Spring '@Transactional'）标记的 'final'、'static' 或 'private' 方法 'final' 类中使用特定于框架的注解标记的方法 报告的情况清单取决于使用的框架。",
                  "markdown": "报告在运行时代码阻止某个框架（例如 Spring 或 Hibernate）对类进行子类化的情况。\n\n必要但不可能进行子类化的典型示例：\n\n* 使用特定于框架的注解（例如 Spring `@Configuration`）标记的 `final` 类\n* 使用特定于框架的注解（例如 Spring `@Transactional`）标记的 `final`、`static` 或 `private` 方法\n* `final` 类中使用特定于框架的注解标记的方法\n\n报告的情况清单取决于使用的框架。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ImplicitSubclassInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectEqualsCanBeEquality",
                "shortDescription": {
                  "text": "'equals()' 调用可被替换为 '=='"
                },
                "fullDescription": {
                  "text": "报告对可以替换为 '==' 或 '!=' 表达式而又不改变语义的 'equals()' 的调用。 当这些调用用于比较没有自身的 'equals()' 实现但使用默认 'Object.equals()' 的'final' 类时，可以替换这些调用。 此替换可能会提升性能。 对 'enum' 值上的 'equals()' 调用进行单独检查：对 Enum 值调用 'equals()'。",
                  "markdown": "报告对可以替换为 `==` 或 `!=` 表达式而又不改变语义的 `equals()` 的调用。\n\n当这些调用用于比较没有自身的 `equals()` 实现但使用默认 `Object.equals()` 的`final` 类时，可以替换这些调用。\n此替换可能会提升性能。\n\n对 `enum` 值上的 `equals()` 调用进行单独检查：对 Enum 值调用 'equals()'。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectEqualsCanBeEquality",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCPrepareStatementWithNonConstantString",
                "shortDescription": {
                  "text": "'Connection.prepare*()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对 'java.sql.Connection.prepareStatement()'、'java.sql.Connection.prepareCall()' 或其任何变体的调用，这些变体会将动态构造的字符串作为要准备的语句。 构造的 SQL 语句是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'String bar() { return \"bar\"; }\n\n  Connection connection = DriverManager.getConnection(\"\", \"\", \"\");\n  connection.(\"SELECT * FROM user WHERE name='\" + bar() + \"'\");' 使用检查设置可以将任何 'static' 'final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";'",
                  "markdown": "报告对 `java.sql.Connection.prepareStatement()`、`java.sql.Connection.prepareCall()` 或其任何变体的调用，这些变体会将动态构造的字符串作为要准备的语句。\n\n\n构造的 SQL 语句是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      String bar() { return \"bar\"; }\n\n      Connection connection = DriverManager.getConnection(\"\", \"\", \"\");\n      connection.(\"SELECT * FROM user WHERE name='\" + bar() + \"'\");\n\n使用检查设置可以将任何 `static` `final` 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCPrepareStatementWithNonConstantString",
                    "cweIds": [
                      89
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemProperties",
                "shortDescription": {
                  "text": "系统属性的访问"
                },
                "fullDescription": {
                  "text": "报告使用以下其中一种方法访问系统属性的代码： 'System.getProperties()'、'System.setProperty()'、'System.setProperties()'、'System.clearProperties()' 'Integer.getInteger()' 'Boolean.getBoolean()' 虽然访问系统属性本身并不是安全风险，但它经常出现在恶意代码中。 在任何安全审核中都应该仔细检查访问系统属性的代码。",
                  "markdown": "报告使用以下其中一种方法访问系统属性的代码：\n\n* `System.getProperties()`、`System.setProperty()`、`System.setProperties()`、`System.clearProperties()`\n* `Integer.getInteger()`\n* `Boolean.getBoolean()`\n\n\n虽然访问系统属性本身并不是安全风险，但它经常出现在恶意代码中。\n在任何安全审核中都应该仔细检查访问系统属性的代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessOfSystemProperties",
                    "cweIds": [
                      250,
                      668
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InvalidComparatorMethodReference",
                "shortDescription": {
                  "text": "用于 'Comparator' 的无效方法引用"
                },
                "fullDescription": {
                  "text": "报告映射到 'Comparator' 接口的不履行其约定的方法引用。 某些方法引用，例如 'Integer::max'，可以映射到 'Comparator' 接口。 但是，将它们用作 'Comparator' 是没有意义的，结果可能是不可预测的。 示例： 'ArrayList<Integer> ints = foo();\n  ints.sort(Math::min);' 在应用快速修复后： 'ArrayList<Integer> ints = foo();\n  ints.sort(Comparator.reverseOrder());'",
                  "markdown": "报告映射到 `Comparator` 接口的不履行其约定的方法引用。\n\n\n某些方法引用，例如 `Integer::max`，可以映射到 `Comparator` 接口。\n但是，将它们用作 `Comparator` 是没有意义的，结果可能是不可预测的。\n\n示例：\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Math::min);\n\n在应用快速修复后：\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Comparator.reverseOrder());\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InvalidComparatorMethodReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9ModuleExportsPackageToItself",
                "shortDescription": {
                  "text": "模块将软件包导出/打开到本身"
                },
                "fullDescription": {
                  "text": "报告导出到定义它们的同一 Java 9 模块或在该模块中打开的软件包。 该快速修复会从 'module-info.java' 中移除此类指令。 示例： 'module com.mycomp {\n    exports com.mycomp.main to com.mycomp;\n  }' 在应用快速修复后： 'module main {\n  }' 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告导出到定义它们的同一 Java 9 模块或在该模块中打开的软件包。 该快速修复会从 `module-info.java` 中移除此类指令。\n\n示例：\n\n\n      module com.mycomp {\n        exports com.mycomp.main to com.mycomp;\n      }\n\n在应用快速修复后：\n\n\n      module main {\n      }\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9ModuleExportsPackageToItself",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ToArrayCallWithZeroLengthArrayArgument",
                "shortDescription": {
                  "text": "'Collection.toArray()' 调用样式"
                },
                "fullDescription": {
                  "text": "报告非首选样式的 'Collection.toArray()' 调用，并建议应用首选样式。 将集合转换为数组有两种样式： 预先确定大小的数组，例如 'c.toArray(new String[c.size()])' 空数组，例如 'c.toArray(new String[0])' 在旧的 Java 版本中，建议使用预先确定大小的数组，因为创建适当大小的数组所需的反射调用非常慢。 不过，自 OpenJDK 6 的最新更新以来，此调用已被添加，使得空数组版本的性能与预先确定大小的版本相同，有时甚至更高一筹。 此外，传递预先确定大小的数组对于并发集合或同步集合很危险，因为 'size' 和 'toArray' 调用之间可能会发生数据竞争。 如果在运算过程中并发收缩该集合，可能导致数组末尾出现额外的 'null'。 使用检查选项可以选择首选样式。",
                  "markdown": "报告非首选样式的 `Collection.toArray()` 调用，并建议应用首选样式。\n\n将集合转换为数组有两种样式：\n\n* 预先确定大小的数组，例如 `c.toArray(new String[c.size()])`\n* 空数组，例如 `c.toArray(new String[0])`\n\n在旧的 Java 版本中，建议使用预先确定大小的数组，因为创建适当大小的数组所需的反射调用非常慢。\n\n不过，自 OpenJDK 6 的最新更新以来，此调用已被添加，使得空数组版本的性能与预先确定大小的版本相同，有时甚至更高一筹。 此外，传递预先确定大小的数组对于并发集合或同步集合很危险，因为 `size` 和 `toArray` 调用之间可能会发生数据竞争。 如果在运算过程中并发收缩该集合，可能导致数组末尾出现额外的 `null`。\n\n使用检查选项可以选择首选样式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ToArrayCallWithZeroLengthArrayArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggerInitializedWithForeignClass",
                "shortDescription": {
                  "text": "使用外类初始化记录器"
                },
                "fullDescription": {
                  "text": "报告用来初始化的 'class' 文字所属的类与 'Logger' 所属的类不同的 'Logger' 实例。 从另一个类复制粘贴某些代码时，很容易发生这种情况，并可能导致在意外类别下记录事件，并导致筛选器应用不正确。 提供了一个快速修复来用周围类中的文字替换外类文字。 示例： 'public class Paramount {\n    protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n    // …其他字段和方法\n  }' 在应用快速修复后： 'public class Paramount {\n    protected static final Logger LOG = Logger.getLogger(Paramount.class);\n\n    // …其他字段和方法\n  }' 配置检查： 使用该表可以指定此检查识别的记录器工厂类和记录器工厂方法。 使用忽略使用超类初始化的记录器选项可以忽略使用包含该记录器的类的超类初始化的记录器。 使用忽略非 public 类中的记录器，仅对 'public' 类中的记录器发出警告。",
                  "markdown": "报告用来初始化的 `class` 文字所属的类与 `Logger` 所属的类不同的 `Logger` 实例。 从另一个类复制粘贴某些代码时，很容易发生这种情况，并可能导致在意外类别下记录事件，并导致筛选器应用不正确。\n\n提供了一个快速修复来用周围类中的文字替换外类文字。\n\n**示例：**\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        // ...其他字段和方法\n      }\n\n在应用快速修复后：\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Paramount.class);\n\n        // ...其他字段和方法\n      }\n\n\n配置检查：\n\n* 使用该表可以指定此检查识别的记录器工厂类和记录器工厂方法。\n* 使用**忽略使用超类初始化的记录器**选项可以忽略使用包含该记录器的类的超类初始化的记录器。\n* 使用**忽略非 public 类中的记录器** ，仅对 `public` 类中的记录器发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggerInitializedWithForeignClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 57,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkerInterface",
                "shortDescription": {
                  "text": "标记接口"
                },
                "fullDescription": {
                  "text": "报告不含任何方法或字段的标记接口。 此类接口可能令人困惑，通常表明设计失败。 该检查将忽略扩展两个或多个接口的接口以及指定其超接口泛型类型的接口。",
                  "markdown": "报告不含任何方法或字段的标记接口。\n\n此类接口可能令人困惑，通常表明设计失败。\n\n该检查将忽略扩展两个或多个接口的接口以及指定其超接口泛型类型的接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkerInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SortedCollectionWithNonComparableKeys",
                "shortDescription": {
                  "text": "包含不可比较元素的排序集合"
                },
                "fullDescription": {
                  "text": "报告排序集合的结构，例如 'TreeSet'，它依赖于自然排序，其元素类型不实现 'Comparable' 接口。 此类集合不太可能正常工作。 如果集合元素类型是不可比较的父类型，但集合只打算保存可比较的子类型，则可能出现误报。 即便这样，也最好缩小集合元素类型的范围或将父类型声明为 'Comparable' ，因为上述方法容易出错。 该检查还会报告集合元素是未声明为 'extends Comparable' 的类型形参的情况。 您可以使用所提供的选项禁止对类型形参发出警告（例如，为了保持 API 兼容性）。 2018.3 最新变化",
                  "markdown": "报告排序集合的结构，例如 `TreeSet`，它依赖于自然排序，其元素类型不实现 `Comparable` 接口。\n\n此类集合不太可能正常工作。\n\n\n如果集合元素类型是不可比较的父类型，但集合只打算保存可比较的子类型，则可能出现误报。 即便这样，也最好缩小集合元素类型的范围或将父类型声明为 `Comparable` ，因为上述方法容易出错。\n\n\n该检查还会报告集合元素是未声明为 `extends Comparable` 的类型形参的情况。\n您可以使用所提供的选项禁止对类型形参发出警告（例如，为了保持 API 兼容性）。\n\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SortedCollectionWithNonComparableKeys",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CommentedOutCode",
                "shortDescription": {
                  "text": "注释掉的代码"
                },
                "fullDescription": {
                  "text": "报告包含 Java 代码的注释。 通常，被注释掉的代码很快就会过时并且会引起误解。 由于大多数项目使用某种版本控制系统，因此最好完全删除注释掉的代码并改用 VCS 历史记录。 2020.3 最新变化",
                  "markdown": "报告包含 Java 代码的注释。\n\n通常，被注释掉的代码很快就会过时并且会引起误解。\n由于大多数项目使用某种版本控制系统，因此最好完全删除注释掉的代码并改用 VCS 历史记录。\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CommentedOutCode",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutLogger",
                "shortDescription": {
                  "text": "不带记录器的类"
                },
                "fullDescription": {
                  "text": "报告没有声明记录器的类。 确保每个类都有一个专用的记录器是为应用程序提供统一的日志记录实现的重要步骤。 此检查不报告接口、枚举、注解、内部类和 abstract 类。 示例： 'public class NoLoggerDeclared {\n\n    int calculateNthDigitOfPi(int n) {\n      // todo\n      return 1;\n    }\n  }' 使用 Options 部分中的表可以指定记录器类名。 此检查将报告未声明具有指定类之一类型的字段的类。",
                  "markdown": "报告没有声明记录器的类。\n\n确保每个类都有一个专用的记录器是为应用程序提供统一的日志记录实现的重要步骤。 此检查不报告接口、枚举、注解、内部类和 abstract 类。\n\n示例：\n\n\n      public class NoLoggerDeclared {\n\n        int calculateNthDigitOfPi(int n) {\n          // todo\n          return 1;\n        }\n      }\n\n\n使用 **Options** 部分中的表可以指定记录器类名。\n此检查将报告未声明具有指定类之一类型的字段的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutLogger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 57,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnOfInnerClass",
                "shortDescription": {
                  "text": "返回匿名、局部或内部类的实例"
                },
                "fullDescription": {
                  "text": "报告返回匿名类、局部类或内部类实例的 'return' 语句。 此类实例会保持对外部实例的隐式引用，这可以防止外部实例被垃圾回收。 任何返回此类实例的方法的调用方都可能通过保留返回的实例而导致内存泄漏。 配置检查： 使用忽略非 public 方法的返回值选项可以忽略来自 'protected' 或 package-private 方法的返回值。 始终忽略来自 'private' 方法的返回。",
                  "markdown": "报告返回匿名类、局部类或内部类实例的 `return` 语句。 此类实例会保持对外部实例的隐式引用，这可以防止外部实例被垃圾回收。 任何返回此类实例的方法的调用方都可能通过保留返回的实例而导致内存泄漏。\n\n\n配置检查：\n\n* 使用**忽略非 public 方法的返回值** 选项可以忽略来自 `protected` 或 package-private 方法的返回值。 始终忽略来自 `private` 方法的返回。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassComplexity",
                "shortDescription": {
                  "text": "过度复杂的匿名类"
                },
                "fullDescription": {
                  "text": "报告总复杂度超过指定最大值的匿名内部类。 类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。 匿名类应该具有非常低的复杂度，否则它们会难以理解并且应提升为命名的内部类。 使用循环复杂度限制字段可指定类允许的最大复杂度。",
                  "markdown": "报告总复杂度超过指定最大值的匿名内部类。\n\n类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。\n\n匿名类应该具有非常低的复杂度，否则它们会难以理解并且应提升为命名的内部类。\n\n使用**循环复杂度限制**字段可指定类允许的最大复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexAnonymousInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitWithoutCorrespondingNotify",
                "shortDescription": {
                  "text": "没有相应 'notify()' 的 'wait()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Object.notify()' 或 'Object.notifyAll()' 调用的 'Object.wait()' 的调用。 此检查仅报告包含引用当前类字段的限定符的调用。 示例： 'public class Foo {\n    public Object foo = new Object();\n\n    void bar() throws InterruptedException {\n      this.foo.wait();\n    }\n  }'",
                  "markdown": "报告对无法为之找到相应 `Object.notify()` 或 `Object.notifyAll()` 调用的 `Object.wait()` 的调用。\n\n此检查仅报告包含引用当前类字段的限定符的调用。\n\n**示例：**\n\n\n      public class Foo {\n        public Object foo = new Object();\n\n        void bar() throws InterruptedException {\n          this.foo.wait();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitWithoutCorrespondingNotify",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfAWTPeerClass",
                "shortDescription": {
                  "text": "使用 AWT 对等类"
                },
                "fullDescription": {
                  "text": "报告使用 AWT 对等类的情况。 这些类代表原生窗口系统微件，并且不可在不同的窗口系统之间移植。 示例： 'import java.awt.peer.ButtonPeer;\n\n  abstract class Sample implements ButtonPeer {\n    public void foo() {\n        Sample sample;\n    }\n  }'",
                  "markdown": "报告使用 AWT 对等类的情况。 这些类代表原生窗口系统微件，并且不可在不同的窗口系统之间移植。\n\n**示例：**\n\n\n      import java.awt.peer.ButtonPeer;\n\n      abstract class Sample implements ButtonPeer {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfAWTPeerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitVariableType",
                "shortDescription": {
                  "text": "可以省略局部变量类型"
                },
                "fullDescription": {
                  "text": "报告冗余局部变量类型。 这些类型可以从上下文中推断出来，因此替换为 'var'。 示例： 'void test(InputStream s) {\n    try (InputStream in = s) {}\n  }' 应用修正后： 'void test(InputStream s) {\n    try (var in = s) {}\n  }' 此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。",
                  "markdown": "报告冗余局部变量类型。\n\n这些类型可以从上下文中推断出来，因此替换为 `var`。\n\n**示例：**\n\n\n      void test(InputStream s) {\n        try (InputStream in = s) {}\n      }\n\n应用修正后：\n\n\n      void test(InputStream s) {\n        try (var in = s) {}\n      }\n\n\n此检查取决于 Java 功能 '局部变量类型推断'，该功能自 Java 10 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitVariableType",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 10",
                      "index": 126,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableWithUnconstructableAncestor",
                "shortDescription": {
                  "text": "具有不可构造上级的可序列化类"
                },
                "fullDescription": {
                  "text": "报告最近的不可序列化祖先没有无实参构造函数的 'Serializable' 类。 这种类无法反序列化，将失败并抛出 'InvalidClassException'。 示例： 'class Ancestor {\n    private String name;\n    Ancestor(String name) {\n      this.name = name;\n    }\n  }\n\n  //对此类发出警告，因为超类并非\n//可序列化，并且其构造函数接受实参\n  class Descendant extends Ancestor implements Serializable {\n    Descendant() {\n      super(\"Bob\");\n    }\n  }'",
                  "markdown": "报告最近的不可序列化祖先没有无实参构造函数的 `Serializable` 类。 这种类无法反序列化，将失败并抛出 `InvalidClassException`。\n\n**示例：**\n\n\n      class Ancestor {\n        private String name;\n        Ancestor(String name) {\n          this.name = name;\n        }\n      }\n\n      //对此类发出警告，因为超类并非\n    //可序列化，并且其构造函数接受实参\n      class Descendant extends Ancestor implements Serializable {\n        Descendant() {\n          super(\"Bob\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableClassWithUnconstructableAncestor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExcessiveLambdaUsage",
                "shortDescription": {
                  "text": "过度使用 lambda"
                },
                "fullDescription": {
                  "text": "报告一个普通的 lambda 表达式被用在另一种方法中的情况，这种方法以相同方式运行，但只接受一个具体的值而不是 lambda。 此检查有助于简化代码。 示例： 'Optional.orElseGet(() -> null)' 在应用快速修复后： 'Optional.orElse(null)' 2017.1 最新变化 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告一个普通的 lambda 表达式被用在另一种方法中的情况，这种方法以相同方式运行，但只接受一个具体的值而不是 lambda。\n\n此检查有助于简化代码。\n\n示例：\n\n\n      Optional.orElseGet(() -> null)\n\n在应用快速修复后：\n\n\n      Optional.orElse(null)\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExcessiveLambdaUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterHidingMemberVariable",
                "shortDescription": {
                  "text": "形参隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的方法形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该形参。 建议通过快速修复重命名该形参。 示例： 'class Main {\n    private String value;\n\n    public Main(String value) {\n      value = value.toUpperCase();\n    }\n  }' 您可以为此检查配置以下选项： 对属性 setter 忽略 - 忽略简单 setter 的形参。 忽略从子类不可见的超类字段 - 忽略超类中对此方法不可见的 'private' 字段。 对构造函数忽略 - 忽略构造函数的形参。 对 abstract 方法忽略 - 忽略 abstract 方法的形参。 对隐藏实例字段的 static 方法形参忽略 - 忽略隐藏实例字段的 'static' 方法的形参，并忽略隐藏外部类实例字段的 static 内部类中实例方法的形参。 虽然不是严格意义上的隐藏，但此类形参仍然令人困惑。",
                  "markdown": "报告与周围类的字段同名的方法形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该形参。\n\n建议通过快速修复重命名该形参。\n\n**示例：**\n\n\n      class Main {\n        private String value;\n\n        public Main(String value) {\n          value = value.toUpperCase();\n        }\n      }\n      \n\n您可以为此检查配置以下选项：\n\n1. **对属性 setter 忽略** - 忽略简单 setter 的形参。\n2. **忽略从子类不可见的超类字段** - 忽略超类中对此方法不可见的 `private` 字段。\n3. **对构造函数忽略** - 忽略构造函数的形参。\n4. **对 abstract 方法忽略** - 忽略 abstract 方法的形参。\n5. **对隐藏实例字段的 static 方法形参忽略** - 忽略隐藏实例字段的 `static` 方法的形参，并忽略隐藏外部类实例字段的 static 内部类中实例方法的形参。 虽然不是严格意义上的隐藏，但此类形参仍然令人困惑。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaBodyCanBeCodeBlock",
                "shortDescription": {
                  "text": "lambda 体可以是代码块"
                },
                "fullDescription": {
                  "text": "报告主体为表达式的 lambda，并建议将表达式主体转换为代码块。 示例： 'n -> n + 1' 在应用快速修复后： 'n -> {\n  return n + 1;\n}' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告主体为表达式的 lambda，并建议将表达式主体转换为代码块。\n\n示例：\n\n\n      n -> n + 1\n\n在应用快速修复后：\n\n    n -> {\n      return n + 1;\n    }\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaBodyCanBeCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomSecurityManager",
                "shortDescription": {
                  "text": "自定义 'SecurityManager'"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.SecurityManager' 的用户定义子类。 虽然不一定代表安全漏洞，但应彻底和专业地检查这种类是否存在可能的安全问题。 示例： 'class CustomSecurityManager extends SecurityManager {\n  }'",
                  "markdown": "报告 `java.lang.SecurityManager` 的用户定义子类。\n\n\n虽然不一定代表安全漏洞，但应彻底和专业地检查这种类是否存在可能的安全问题。\n\n**示例：**\n\n\n      class CustomSecurityManager extends SecurityManager {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomSecurityManager",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'equals()' 进行对象比较"
                },
                "fullDescription": {
                  "text": "报告使用 '==' 或 '!=' 而不是 'equals()' 测试对象相等性的代码。 使用 '==' 或 '!=' 比较对象通常是 bug，因为它不是通过相等性而是通过同一性来比较对象。 不报告与 'null' 的比较。 数组、'String' 和 'Number' 比较由单独的检查报告。 示例： 'if (list1 == list2) {\n    return;\n  }' 在应用快速修复后： 'if (Objects.equals(list1, list2)) {\n    return;\n  }' 使用检查设置为此检查配置异常。",
                  "markdown": "报告使用 `==` 或 `!=` 而不是 `equals()` 测试对象相等性的代码。\n\n\n使用 `==` 或 `!=` 比较对象通常是 bug，因为它不是通过相等性而是通过同一性来比较对象。\n不报告与 `null` 的比较。\n\n\n数组、`String` 和 `Number` 比较由单独的检查报告。\n\n**示例：**\n\n      if (list1 == list2) {\n        return;\n      }\n\n在应用快速修复后：\n\n      if (Objects.equals(list1, list2)) {\n        return;\n      }\n\n使用检查设置为此检查配置异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectEquality",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TimeToString",
                "shortDescription": {
                  "text": "调用 'Time.toString()'"
                },
                "fullDescription": {
                  "text": "报告 'java.sql.Time' 对象上的 'toString()' 调用。 在国际化环境中，此类调用通常是不正确的。",
                  "markdown": "报告 `java.sql.Time` 对象上的 `toString()` 调用。 在国际化环境中，此类调用通常是不正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToTimeToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariablesCanBeReplacedWithCast",
                "shortDescription": {
                  "text": "将 'instanceof' 与模式一起使用"
                },
                "fullDescription": {
                  "text": "报告带模式的 'instanceof'，并建议将其转换为带转换的普通 'instanceof'。 通过应用快速修复，此检查可以将带模式的 'instanceof' 移到使用早期 Java 版本的代码库。 请注意，在 'instanceof' 前面使用复杂表达式时，结果不能完全等同于带模式的原始 'instanceof'。 在这种情况下，将对该表达式重新求值。 示例： 'if (object instanceof String txt && txt.length() == 1) {\n      System.out.println(txt);\n  } else {\n      return;\n  }\n  System.out.println(txt);' 在应用快速修复后： 'if (object instanceof String && ((String) object).length() ==1) {\n      String txt = (String) object;\n      System.out.println(txt);\n  } else {\n      return;\n  }\n  String txt = (String) object;\n  System.out.println(txt);' 2023.1 最新变化",
                  "markdown": "报告带模式的 `instanceof`，并建议将其转换为带转换的普通 `instanceof`。\n\n通过应用快速修复，此检查可以将带模式的 `instanceof` 移到使用早期 Java 版本的代码库。\n\n\n请注意，在 `instanceof` 前面使用复杂表达式时，结果不能完全等同于带模式的原始 `instanceof`。 在这种情况下，将对该表达式重新求值。\n\n示例：\n\n\n      if (object instanceof String txt && txt.length() == 1) {\n          System.out.println(txt);\n      } else {\n          return;\n      }\n      System.out.println(txt);\n\n在应用快速修复后：\n\n\n      if (object instanceof String && ((String) object).length() ==1) {\n          String txt = (String) object;\n          System.out.println(txt);\n      } else {\n          return;\n      }\n      String txt = (String) object;\n      System.out.println(txt);\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PatternVariablesCanBeReplacedWithCast",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualArrayToCollectionCopy",
                "shortDescription": {
                  "text": "手动数组到集合复制"
                },
                "fullDescription": {
                  "text": "报告使用循环将数组内容复制到集合中的代码。 一种更短并且有可能更快（取决于集合实现）的方法是使用 'Collection.addAll(Arrays.asList())' 或 'Collections.addAll()'。 仅报告内部没有附加语句的循环。 示例： 'void addAll(List<String> list, String[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n      String s = arr[i];\n      list.add(s);\n    }\n  }' 在应用快速修复后： 'void addAll(List<String> list, String[] arr) {\n    Collections.addAll(list, arr);\n  }'",
                  "markdown": "报告使用循环将数组内容复制到集合中的代码。\n\n\n一种更短并且有可能更快（取决于集合实现）的方法是使用 `Collection.addAll(Arrays.asList())` 或 `Collections.addAll()`。\n\n\n仅报告内部没有附加语句的循环。\n\n**示例：**\n\n\n      void addAll(List<String> list, String[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n          String s = arr[i];\n          list.add(s);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void addAll(List<String> list, String[] arr) {\n        Collections.addAll(list, arr);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualArrayToCollectionCopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchLabeledRuleCanBeCodeBlock",
                "shortDescription": {
                  "text": "标记的 switch 规则可以具有代码块"
                },
                "fullDescription": {
                  "text": "报告 'switch' 表达式或带有表达式体的增强 'switch' 语句的规则。 这些可以转换为代码块。 示例： 'String message = switch (errorCode) {\n    case 404 -> \"Not found!\";\n    ...\n  };' 在应用快速修复后： 'String message = switch (errorCode) {\n    case 404 -> {\n                yield \"Not found!\";\n            }\n    ...\n  };' 2019.1 最新变化 此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。",
                  "markdown": "报告 `switch` 表达式或带有表达式体的增强 `switch` 语句的规则。 这些可以转换为代码块。\n\n示例：\n\n\n      String message = switch (errorCode) {\n        case 404 -> \"Not found!\";\n        ...\n      };\n\n在应用快速修复后：\n\n\n      String message = switch (errorCode) {\n        case 404 -> {\n                    yield \"Not found!\";\n                }\n        ...\n      };\n\n2019.1 最新变化\n\n此检查取决于 Java 功能 '增强的 'switch' 块'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchLabeledRuleCanBeCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaReflectionMemberAccess",
                "shortDescription": {
                  "text": "对不存在或不可见的类成员的反射访问"
                },
                "fullDescription": {
                  "text": "报告对不存在或不可见的字段和方法的反射访问。 示例： 'Field stringHashField() throws NoSuchFieldException {\n    return String.class.getField(\"hash\");\n  }' 在应用快速修复后： 'Field stringHashField() throws NoSuchFieldException {\n    return String.class.getDeclaredField(\"hash\");\n  }' 对于 'final' 类，很清楚该类中是否存在具有指定名称的字段或方法。 对于非 'final' 类，子类中可能有使用该名称的字段或方法，因此可能会出现误报。 使用该项检查的设置，可消除任何位置或特定类的此类误报。 2017.2 最新变化",
                  "markdown": "报告对不存在或不可见的字段和方法的反射访问。\n\n示例：\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getField(\"hash\");\n      }\n\n在应用快速修复后：\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getDeclaredField(\"hash\");\n      }\n\n\n对于 `final` 类，很清楚该类中是否存在具有指定名称的字段或方法。\n\n\n对于非 `final` 类，子类中可能有使用该名称的字段或方法，因此可能会出现误报。\n使用该项检查的设置，可消除任何位置或特定类的此类误报。\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaReflectionMemberAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObviousNullCheck",
                "shortDescription": {
                  "text": "使用明显非 null 实参调用 null 检查方法"
                },
                "fullDescription": {
                  "text": "报告是否在明显为非 null 的值（例如，新创建的对象）上调用 null 检查方法（例如，'Objects.requireNonNull' 或 'Assert.assertNotNull'）。 这种检查是冗余的，可能表明存在编程错误。 示例： 'final String greeting = Objects.requireNonNull(\"Hi!\");' 在应用快速修复后： 'final String greeting = \"Hi!\";' 2017.2 最新变化",
                  "markdown": "报告是否在明显为非 null 的值（例如，新创建的对象）上调用 null 检查方法（例如，`Objects.requireNonNull` 或 `Assert.assertNotNull`）。 这种检查是冗余的，可能表明存在编程错误。\n\n**示例：**\n\n\n      final String greeting = Objects.requireNonNull(\"Hi!\");\n\n在应用快速修复后：\n\n\n      final String greeting = \"Hi!\";\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObviousNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialVersionUIDNotStaticFinal",
                "shortDescription": {
                  "text": "'serialVersionUID' 字段未被声明为 'private static final long'"
                },
                "fullDescription": {
                  "text": "报告 'serialVersionUID' 字段未被声明为 'private static final long' 的 'Serializable' 类。 示例： 'class SampleClass implements Serializable {\n    private long serialVersionUID = 1; // Serializable 类的字段未声明为 'private static final long'\n\n    public SampleClass() {\n        System.out.println(serialVersionUID);\n    }\n  }'",
                  "markdown": "报告 `serialVersionUID` 字段未被声明为 `private static final long` 的 `Serializable` 类。\n\n**示例：**\n\n\n      class SampleClass implements Serializable {\n        private long serialVersionUID = 1; // Serializable 类的字段未声明为 'private static final long'\n\n        public SampleClass() {\n            System.out.println(serialVersionUID);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerialVersionUIDWithWrongSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassOnInterface",
                "shortDescription": {
                  "text": "接口的内部类"
                },
                "fullDescription": {
                  "text": "报告 'interface' 类中的内部类。 有些编码标准不建议使用这种类。 该检查不报告枚举类和注解接口。 使用忽略接口的内部接口选项，可以忽略内部接口。 示例： 'interface I {\n    interface Inner {\n    }\n  }'",
                  "markdown": "报告 `interface` 类中的内部类。\n\n有些编码标准不建议使用这种类。 该检查不报告枚举类和注解接口。\n\n\n使用**忽略接口的内部接口**选项，可以忽略内部接口。 示例：\n\n\n      interface I {\n        interface Inner {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassOfInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicFieldAccessedInSynchronizedContext",
                "shortDescription": {
                  "text": "在 'synchronized' 上下文中访问d了非 private 字段"
                },
                "fullDescription": {
                  "text": "报告在同步上下文中访问的非 'final'、非 'private' 字段。 不能保证始终以同步方式访问非 'private' 字段，此类“部分同步的”访问可能意外导致不一致的数据结构。 示例： 'class Bar {\n    public String field1;\n  }\n  public Bar myBar;\n\n  synchronized public void sample() {\n   myBar.field1 = \"bar\";\n  }'",
                  "markdown": "报告在同步上下文中访问的非 `final`、非 `private` 字段。\n\n\n不能保证始终以同步方式访问非 `private` 字段，此类\"部分同步的\"访问可能意外导致不一致的数据结构。\n\n**示例：**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPrivateFieldAccessedInSynchronizedContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedLabel",
                "shortDescription": {
                  "text": "未使用的标签"
                },
                "fullDescription": {
                  "text": "报告不是任何 'break' 或 'continue' 语句目标的标签。 示例： 'label: for (int i = 0; i < 10; i++) {\n    if (i == 3) {\n      break;\n    }\n  }' 应用快速修复后，该标签将被移除： 'for (int i = 0; i < 10; i++) {\n    if (i == 3) {\n      break;\n    }\n  }'",
                  "markdown": "报告不是任何 `break` 或 `continue` 语句目标的标签。\n\n**示例：**\n\n\n      label: for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n\n应用快速修复后，该标签将被移除：\n\n\n      for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForeachStatement",
                "shortDescription": {
                  "text": "增强的 'for' 语句"
                },
                "fullDescription": {
                  "text": "报告增强型 'for' 语句。 示例： 'for (int x: Arrays.asList(1, 2, 3)) {\n    System.out.println(x);\n  }' 在应用快速修复后： 'for (Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {\n    final int x = iterator.next();\n    System.out.println(x);\n  }' 增强型 'for' 语句在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告增强型 `for` 语句。\n\n示例：\n\n\n      for (int x: Arrays.asList(1, 2, 3)) {\n        System.out.println(x);\n      }\n\n在应用快速修复后：\n\n\n      for (Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {\n        final int x = iterator.next();\n        System.out.println(x);\n      }\n\n\n*增强型* `for` *语句*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForeachStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 114,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalUsedAsFieldOrParameterType",
                "shortDescription": {
                  "text": "用作字段或形参类型的 'Optional'"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Optional<T>'、'java.util.OptionalDouble'、'java.util.OptionalInt'、'java.util.OptionalLong' 或 'com.google.common.base.Optional' 用为字段或形参的类型的任何情况。 'Optional' 设计为在需要一个明确的方式来表示 \"没有结果\"的情况下，为库方法的返回类型提供有限的机制。 如果类需要 'Serializable'，则使用 'java.util.Optional' 类型的字段也有问题，因为 'java.util.Optional' 不可序列化。 示例： 'class MyClass {\n    Optional<String> name; // Optional 字段\n\n    // Optional 形参\n    void setName(Optional<String> name) {\n      this.name = name;\n    }\n  }'",
                  "markdown": "报告 `java.util.Optional<T>`、`java.util.OptionalDouble`、`java.util.OptionalInt`、`java.util.OptionalLong` 或 `com.google.common.base.Optional` 用为字段或形参的类型的任何情况。\n\n`Optional` 设计为在需要一个明确的方式来表示 \"没有结果\"的情况下，为库方法的返回类型提供有限的机制。\n\n如果类需要 `Serializable`，则使用 `java.util.Optional` 类型的字段也有问题，因为 `java.util.Optional` 不可序列化。\n\n示例：\n\n\n      class MyClass {\n        Optional<String> name; // Optional 字段\n\n        // Optional 形参\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalUsedAsFieldOrParameterType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAllDot",
                "shortDescription": {
                  "text": "可疑的正则表达式实参"
                },
                "fullDescription": {
                  "text": "报告对其中第一个实参为单一正则表达式元字符实参的 'String.replaceAll()' 或 'String.split()' 的调用。 正则表达式元字符为 '.$|()[{^?*+\\' 之一。 它们在正则表达式中有特殊的含义。 例如，调用 '\"ab.cd\".replaceAll(\".\", \"-\")' 将生成 '\"-----\"'，因为点匹配任意字符。 很可能本意是转义变体 '\"\\\\.\"'。 还报告了将 'File.separator' 用作正则表达式的情况。 'File.separator' 具有平台特定的值。 它在 Linux 和 Mac 上等于 '/'，而在 Windows 上等于 '\\'，这不是一个有效的正则表达式，因此这样的代码无法移植。 示例： 's.replaceAll(\".\", \"-\");' 在应用快速修复后： 's.replaceAll(\"\\\\.\", \"-\");'",
                  "markdown": "报告对其中第一个实参为单一正则表达式元字符实参的 `String.replaceAll()` 或 `String.split()` 的调用。\n\n\n正则表达式元字符为 `.$|()[{^?*+\\` 之一。 它们在正则表达式中有特殊的含义。\n例如，调用 `\"ab.cd\".replaceAll(\".\", \"-\")` 将生成 `\"-----\"`，因为点匹配任意字符。\n很可能本意是转义变体 `\"\\\\.\"`。\n\n\n还报告了将 `File.separator` 用作正则表达式的情况。 `File.separator` 具有平台特定的值。 它在 Linux 和 Mac 上等于 `/`，而在 Windows 上等于 `\\`，这不是一个有效的正则表达式，因此这样的代码无法移植。\n\n**示例：**\n\n\n      s.replaceAll(\".\", \"-\");\n\n在应用快速修复后：\n\n\n      s.replaceAll(\"\\\\.\", \"-\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousRegexArgument",
                    "cweIds": [
                      20,
                      185,
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForCanBeForeach",
                "shortDescription": {
                  "text": "'for' 循环可被替换为增强的 for 循环"
                },
                "fullDescription": {
                  "text": "报告迭代集合或数组并且可以自动替换为增强型 'for' 循环（foreach 迭代语法）的 'for' 循环。 示例： 'for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n    String item = iterator.next();\n    System.out.println(item);\n  }' 在应用快速修复后： 'for (String item : list) {\n    System.out.println(item);\n  }' 使用报告索引的 'java.util.List' 循环选项可查找涉及 'list.get(index)' 调用的循环。 这些循环通常可以替换为增强型 'for' 循环，除非它们修改了进程中的基础列表，例如通过调用 'list.remove(index)' 进行修改。 如果是后面这种情况，增强型 'for' 循环可能抛出 'ConcurrentModificationException'。 在某些情况下，'list.get(index)' 循环的操作速度也可能更快一些。 使用不报告无类型集合上的迭代选项可忽略没有类型形参的集合。 这将防止创建 'java.lang.Object' 类型的增强型 'for' 循环变量以及在使用循环变量的位置插入转换。 此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。",
                  "markdown": "报告迭代集合或数组并且可以自动替换为增强型 `for` 循环（foreach 迭代语法）的 `for` 循环。\n\n**示例：**\n\n\n      for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n        String item = iterator.next();\n        System.out.println(item);\n      }\n\n在应用快速修复后：\n\n\n      for (String item : list) {\n        System.out.println(item);\n      }\n\n\n使用**报告索引的 'java.util.List' 循环** 选项可查找涉及 `list.get(index)` 调用的循环。\n这些循环通常可以替换为增强型 `for` 循环，除非它们修改了进程中的基础列表，例如通过调用 `list.remove(index)` 进行修改。\n如果是后面这种情况，增强型 `for` 循环可能抛出 `ConcurrentModificationException`。\n在某些情况下，`list.get(index)` 循环的操作速度也可能更快一些。\n\n\n使用**不报告无类型集合上的迭代** 选项可忽略没有类型形参的集合。\n这将防止创建 `java.lang.Object` 类型的增强型 `for` 循环变量以及在使用循环变量的位置插入转换。\n\n此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopReplaceableByForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageVisibleField",
                "shortDescription": {
                  "text": "软件包可见字段"
                },
                "fullDescription": {
                  "text": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的字段。 不报告常量（即标记为 'static' 和 'final' 的字段）。 示例： 'public class A {\n    Object object;             // 警告\n    final static int MODE = 0; // 常量，无警告\n  }'",
                  "markdown": "报告在没有任何访问修饰符（也称为 package-private）的情况下声明的字段。\n\n不报告常量（即标记为 `static` 和 `final` 的字段）。\n\n**示例：**\n\n\n      public class A {\n        Object object;             // 警告\n        final static int MODE = 0; // 常量，无警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageVisibleField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstantiationOfUtilityClass",
                "shortDescription": {
                  "text": "实用程序类的实例化"
                },
                "fullDescription": {
                  "text": "报告使用 'new' 关键字的实用程序类的实例化。 在实用程序类中，所有字段和方法均为 'static'。 这种类的实例化很可能不必要，并且表明存在错误。 示例： 'class MyUtils {\n    public static double cube(double x) {\n      return x * x * x;\n    }\n  }\n  class Main {\n    public static void main(String[] args) {\n      // 实用类的实例化\n      MyUtils utils = new MyUtils();\n    }\n  }' 为防止实用程序类被实例化，建议使用 'private' 构造函数。",
                  "markdown": "报告使用 `new` 关键字的实用程序类的实例化。\n\n\n在实用程序类中，所有字段和方法均为 `static`。\n这种类的实例化很可能不必要，并且表明存在错误。\n\n**示例：**\n\n\n      class MyUtils {\n        public static double cube(double x) {\n          return x * x * x;\n        }\n      }\n      class Main {\n        public static void main(String[] args) {\n          // 实用类的实例化\n          MyUtils utils = new MyUtils();\n        }\n      }\n\n\n为防止实用程序类被实例化，建议使用 `private` 构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiationOfUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingWhitespacesInTextBlock",
                "shortDescription": {
                  "text": "文本块中的尾随空格"
                },
                "fullDescription": {
                  "text": "报告带有尾随空格字符的文本块。 尾随空格被视为是附带的，将被 Java 编译器去除。 2021.1 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告带有尾随空格字符的文本块。 尾随空格被视为是附带的，将被 Java 编译器去除。\n\n2021.1 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrailingWhitespacesInTextBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewClassNamingConvention",
                "shortDescription": {
                  "text": "类命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的类。 示例：如果为测试启用了检查，并且指定的最小类名称长度为 8（默认值），因以下测试类的名称长度为 6，即小于 8，因此将生成警告：'public class MyTest{}'。 只能在编辑器中采用快速修复来重命名这种类。 配置检查： 使用选项部分中的列表来指定应检查哪些类。 取消选中要为之跳过检查的类对应的复选框。 对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。 在长度字段中指定 0 可跳过相应检查。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的类。\n\n**示例** ：如果为测试启用了检查，并且指定的最小类名称长度为 8（默认值），因以下测试类的名称长度为 6，即小于 8，因此将生成警告：`public class MyTest{}`。\n\n只能在编辑器中采用快速修复来重命名这种类。\n\n配置检查：\n\n\n使用**选项**部分中的列表来指定应检查哪些类。 取消选中要为之跳过检查的类对应的复选框。\n\n对于类的每种类型，请使用所提供的输入字段指定类名应有的最小长度、最大长度和正则表达式。 在长度字段中指定 **0** 可跳过相应检查。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewClassNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 61,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseCompareMethod",
                "shortDescription": {
                  "text": "可以使用 'compare()' 方法比较数值"
                },
                "fullDescription": {
                  "text": "报告可被替换为对 'Integer.compare()' 方法或来自 'Long'、'Short'、'Byte'、'Double' 或 'Float' 类的类似方法（而非更冗长或更低效构造）的调用的表达式。 如果 'x' 和 'y' 是已装箱整数，则建议使用 'x.compareTo(y)'；如果它们是基元，则建议使用 'Integer.compare(x, y)'。 示例： 'public int compare(int x, int y) {\n    return x > y ? 1 : x < y ? -1 : 0;\n  }' 在应用快速修复后： 'public int compare(int x, int y) {\n    return Integer.compare(x, y);\n  }' 请注意，'Double.compare' 和 'Float.compare' 会略微更改代码语义。 特别是，它们会使 '-0.0' 和 '0.0' 可以区分（'Double.compare(-0.0, 0.0)' 生成 -1）。 此外，它们会一致地处理 'NaN' 值。 在大多数情况下，这种语义更改实际上会改进代码。 如果您的情况无法接受语义更改，请使用复选框禁用此项对浮点数的检查。 2017.2 最新变化",
                  "markdown": "报告可被替换为对 `Integer.compare()` 方法或来自 `Long`、`Short`、`Byte`、`Double` 或 `Float` 类的类似方法（而非更冗长或更低效构造）的调用的表达式。\n\n如果 `x` 和 `y` 是已装箱整数，则建议使用 `x.compareTo(y)`；如果它们是基元，则建议使用 `Integer.compare(x, y)`。\n\n**示例：**\n\n\n      public int compare(int x, int y) {\n        return x > y ? 1 : x < y ? -1 : 0;\n      }\n\n在应用快速修复后：\n\n\n      public int compare(int x, int y) {\n        return Integer.compare(x, y);\n      }\n\n\n请注意，`Double.compare` 和 `Float.compare` 会略微更改代码语义。 特别是，它们会使 `-0.0` 和 `0.0` 可以区分（`Double.compare(-0.0, 0.0)` 生成 -1）。\n此外，它们会一致地处理 `NaN` 值。 在大多数情况下，这种语义更改实际上会改进代码。 如果您的情况无法接受语义更改，请使用复选框禁用此项对浮点数的检查。\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseCompareMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 51,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MoveFieldAssignmentToInitializer",
                "shortDescription": {
                  "text": "字段赋值可以移至初始值设定项中"
                },
                "fullDescription": {
                  "text": "建议将使用赋值的字段的初始化替换为字段声明中的初始化。 仅当字段赋值位于实例或 static 初始值设定项中时报告，并且将其与字段声明联接可能比较安全。 在其他情况下（比如构造函数中的赋值），提供的快速修复不会高亮显示，因为修正可能会更改语义。 示例： 'class MyClass {\n    static final int intConstant;\n    \n    static {\n      intConstant = 10;\n    }\n  }' 该快速修复会将赋予的值移至字段初始值设定项，并移除类初始值设定项（如果可能）： 'class MyClass {\n    static final int intConstant = 10;\n  }' 自从 2017.2",
                  "markdown": "建议将使用赋值的字段的初始化替换为字段声明中的初始化。\n\n仅当字段赋值位于实例或 static 初始值设定项中时报告，并且将其与字段声明联接可能比较安全。\n在其他情况下（比如构造函数中的赋值），提供的快速修复不会高亮显示，因为修正可能会更改语义。\n\n示例：\n\n\n      class MyClass {\n        static final int intConstant;\n        \n        static {\n          intConstant = 10;\n        }\n      }\n\n该快速修复会将赋予的值移至字段初始值设定项，并移除类初始值设定项（如果可能）：\n\n\n      class MyClass {\n        static final int intConstant = 10;\n      }\n\n自从 2017.2"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MoveFieldAssignmentToInitializer",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInFormatCall",
                "shortDescription": {
                  "text": "字符串串联作为 'format()' 调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作格式字符串实参的非常量字符串串联。 虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中使用的变量包含 '%' 等特殊字符时，甚至可能导致安全问题。 此外，有时这可能是在本应键入 ',' 时键入了 '+' 而错误串联字符串格式实参所致。 示例： 'static String formatGreeting(String userName) {\n    return String.format(\"Hello, \" + userName);\n  }' 这里的 'userName' 将解释为格式字符串的一部分，从而可能导致 'IllegalFormatException'（例如，如果 'userName' 为 '\"%\"'）或使用大量内存（例如，如果 'userName' 为 '\"%2000000000%\"'）。 该调用可能应替换为 'String.format(\"Hello, %s\", userName);'。 此检查将检查对 'java.util.Formatter'、'java.lang.String'、'java.io.PrintWriter' 或 'java.io.PrintStream' 的格式化方法的调用。",
                  "markdown": "报告用作格式字符串实参的非常量字符串串联。\n\n\n虽然偶尔是有意为之，但这通常是误用格式化方法，串联的字符串中使用的变量包含 `%` 等特殊字符时，甚至可能导致安全问题。\n\n\n此外，有时这可能是在本应键入 `,` 时键入了 `+` 而错误串联字符串格式实参所致。\n\n**示例：**\n\n\n      static String formatGreeting(String userName) {\n        return String.format(\"Hello, \" + userName);\n      }\n\n\n这里的 `userName` 将解释为格式字符串的一部分，从而可能导致 `IllegalFormatException`（例如，如果 `userName` 为 `\"%\"`）或使用大量内存（例如，如果 `userName` 为 `\"%2000000000%\"`）。\n该调用可能应替换为 `String.format(\"Hello, %s\", userName);`。\n\n\n此检查将检查对 `java.util.Formatter`、`java.lang.String`、`java.io.PrintWriter` 或 `java.io.PrintStream` 的格式化方法的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInFormatCall",
                    "cweIds": [
                      116,
                      134
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitWhileHoldingTwoLocks",
                "shortDescription": {
                  "text": "保持两个锁时 'wait()'"
                },
                "fullDescription": {
                  "text": "报告在当前线程持有两个锁定时可能发生的对 'wait()' 方法的调用。 调用 'wait()' 只会释放目标上的一个锁定，因此持有两个锁定时的等待很容易导致死锁。 示例： 'synchronized (lockA) {\n    synchronized (lockB) {\n      lockB.wait(); //警告\n      //线程 A 卡在这里，持有 lockA\n    }\n  }\n\n  synchronized (lockA) { //线程 B 无法进入此块和释放线程 A\n    lockB.notify();\n  }'",
                  "markdown": "报告在当前线程持有两个锁定时可能发生的对 `wait()` 方法的调用。\n\n\n调用 `wait()` 只会释放目标上的一个锁定，因此持有两个锁定时的等待很容易导致死锁。\n\n**示例：**\n\n\n      synchronized (lockA) {\n        synchronized (lockB) {\n          lockB.wait(); //警告\n          //线程 A 卡在这里，持有 lockA\n        }\n      }\n\n      synchronized (lockA) { //线程 B 无法进入此块和释放线程 A\n        lockB.notify();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitWhileHoldingTwoLocks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableInnerClassWithNonSerializableOuterClass",
                "shortDescription": {
                  "text": "可序列化非 'static' 内部类具有不可序列化外部类"
                },
                "fullDescription": {
                  "text": "报告实现 'Serializable' 并在未实现 'Serializable' 的类中声明的非 static 内部类。 由于对外部类的隐式引用，这种类不太可能正确序列化。 示例： 'class A {\n      class Main implements Serializable {\n    }\n  }' 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告实现 `Serializable` 并在未实现 `Serializable` 的类中声明的非 static 内部类。\n\n\n由于对外部类的隐式引用，这种类不太可能正确序列化。\n\n**示例：**\n\n\n      class A {\n          class Main implements Serializable {\n        }\n      }\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableInnerClassWithNonSerializableOuterClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousListRemoveInLoop",
                "shortDescription": {
                  "text": "循环中的 'List.remove()' 可疑"
                },
                "fullDescription": {
                  "text": "报告升序计数循环中的 'list.remove(index)' 调用。 这很可疑，因为移除后列表变短，下一个元素被跳过。 简单的修正方法是在移除后减小索引变量，但更稳健的做法可能是通过迭代器或使用 'removeIf()' 方法（Java 8 及更高版本）移除。 如果您不希望 'remove()' 在循环中被多次调用，不妨在它后面添加 'break'。 示例： 'public static void main(String[] args) {\n    process(new ArrayList<>(\n      Arrays.asList(\"1\", \"2\", \"|\", \"3\", \"4\")));\n  }\n\n  static void process(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n      if (list.get(i).equals(\"|\")) {\n        list.remove(i);\n        continue;\n      }\n      System.out.println(list.get(i));\n    }\n  }' 代码看起来像是会打印 '1 2 3 4'，但实则在输出中将跳过 '3'。 2018.2 最新变化",
                  "markdown": "报告升序计数循环中的 `list.remove(index)` 调用。\n\n\n这很可疑，因为移除后列表变短，下一个元素被跳过。 简单的修正方法是在移除后减小索引变量，但更稳健的做法可能是通过迭代器或使用 `removeIf()` 方法（Java 8 及更高版本）移除。\n如果您不希望 `remove()` 在循环中被多次调用，不妨在它后面添加 `break`。\n\n**示例：**\n\n      public static void main(String[] args) {\n        process(new ArrayList<>(\n          Arrays.asList(\"1\", \"2\", \"|\", \"3\", \"4\")));\n      }\n\n      static void process(List<String> list) {\n        for (int i = 0; i < list.size(); i++) {\n          if (list.get(i).equals(\"|\")) {\n            list.remove(i);\n            continue;\n          }\n          System.out.println(list.get(i));\n        }\n      }\n\n代码看起来像是会打印 `1 2 3 4`，但实则在输出中将跳过 `3`。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousListRemoveInLoop",
                    "cweIds": [
                      129
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegativeIntConstantInLongContext",
                "shortDescription": {
                  "text": "长整型上下文中的负整型十六进制常量"
                },
                "fullDescription": {
                  "text": "报告 long 上下文中的负 int 十六进制常量。 此类常量会被隐式加宽为 long，意味着它们的高位将为 1，而不是 0（例如，0xFFFF_FFFF 将变成 0xFFFF_FFFF_FFFF_FFFFL）。 这不太可能是有意为之，即使是有意为之，使用显式 long 常量也不会那么容易造成困惑。 示例： '// 警告：这是 int 常量 -1，它被加宽为 long\n  // 成为 0xFFFF_FFFF_FFFF_FFFFL.\n  long mask = 0xFFFF_FFFF;' 2022.3 最新变化",
                  "markdown": "报告 long 上下文中的负 int 十六进制常量。 此类常量会被隐式加宽为 long，意味着它们的高位将为 1，而不是 0（例如，0xFFFF_FFFF 将变成 0xFFFF_FFFF_FFFF_FFFFL）。 这不太可能是有意为之，即使是有意为之，使用显式 long 常量也不会那么容易造成困惑。\n\n**示例：**\n\n\n      // 警告：这是 int 常量 -1，它被加宽为 long\n      // 成为 0xFFFF_FFFF_FFFF_FFFFL.\n      long mask = 0xFFFF_FFFF;\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegativeIntConstantInLongContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DefaultAnnotationParam",
                "shortDescription": {
                  "text": "默认注解形参值"
                },
                "fullDescription": {
                  "text": "报告被赋值给其 'default' 值的注解形参。 示例： '@interface Test {\n      Class<?> expected() default Throwable.class;\n  }\n\n  @Test(expected = Throwable.class)\n  void testSmth() {}' 在应用快速修复后： '@Test()\n  void testSmth() {}'",
                  "markdown": "报告被赋值给其 `default` 值的注解形参。\n\n示例：\n\n\n      @interface Test {\n          Class<?> expected() default Throwable.class;\n      }\n\n      @Test(expected = Throwable.class)\n      void testSmth() {}\n\n在应用快速修复后：\n\n\n      @Test()\n      void testSmth() {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DefaultAnnotationParam",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileLoopSpinsOnField",
                "shortDescription": {
                  "text": "'while' 循环在字段上自旋"
                },
                "fullDescription": {
                  "text": "报告在非 'volatile' 字段值上自旋，等待它被另一个线程更改的 'while' 循环。 除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。 即便另一个线程更改了该字段的值，Java 内存模型也允许此类循环永不完成。 此外，自 Java 9 起，建议在 'volatile' 字段上的自旋循环中调用 'Thread.onSpinWait()'，这可能会显著提高某些硬件上的性能。 示例： 'class SpinsOnField {\n    boolean ready = false;\n\n    void run() {\n      while (!ready) {\n      }\n      // 执行某些工作\n    }\n\n    void markAsReady() {\n      ready = true;\n    }\n  }' 在应用快速修复后： 'class SpinsOnField {\n    volatile boolean ready = false;\n\n    void run() {\n      while (!ready) {\n        Thread.onSpinWait();\n      }\n      // 执行某些工作\n    }\n\n    void markAsReady() {\n      ready = true;\n    }\n  }' 使用检查选项可仅报告空的 'while' 循环。",
                  "markdown": "报告在非 `volatile` 字段值上自旋，等待它被另一个线程更改的 `while` 循环。\n\n\n除了在循环内完成少量工作时可能会非常耗费 CPU 之外，此类循环很可能具有与预期不同的语义。\n即便另一个线程更改了该字段的值，Java 内存模型也允许此类循环永不完成。\n\n\n此外，自 Java 9 起，建议在 `volatile` 字段上的自旋循环中调用 `Thread.onSpinWait()`，这可能会显著提高某些硬件上的性能。\n\n**示例：**\n\n\n      class SpinsOnField {\n        boolean ready = false;\n\n        void run() {\n          while (!ready) {\n          }\n          // 执行某些工作\n        }\n\n        void markAsReady() {\n          ready = true;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class SpinsOnField {\n        volatile boolean ready = false;\n\n        void run() {\n          while (!ready) {\n            Thread.onSpinWait();\n          }\n          // 执行某些工作\n        }\n\n        void markAsReady() {\n          ready = true;\n        }\n      }\n\n\n使用检查选项可仅报告空的 `while` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WhileLoopSpinsOnField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnLock",
                "shortDescription": {
                  "text": "在 'Lock' 对象上同步"
                },
                "fullDescription": {
                  "text": "报告锁定 'java.util.concurrent.locks.Lock' 实例的 'synchronized' 块。 此类同步几乎肯定是无意为之，应当改用适当版本的 '.lock()' 和 '.unlock()'。 示例： 'final ReentrantLock lock = new ReentrantLock();\n\n  public void foo() {\n    synchronized (lock) {}\n  }'",
                  "markdown": "报告锁定 `java.util.concurrent.locks.Lock` 实例的 `synchronized` 块。 此类同步几乎肯定是无意为之，应当改用适当版本的 `.lock()` 和 `.unlock()`。\n\n**示例：**\n\n\n      final ReentrantLock lock = new ReentrantLock();\n\n      public void foo() {\n        synchronized (lock) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchroniziationOnLockObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExceptionCaught",
                "shortDescription": {
                  "text": "已捕获禁止的 'Exception'"
                },
                "fullDescription": {
                  "text": "报告捕获不适当异常的 'catch' 子句。 一些异常（例如 'java.lang.NullPointerException' 或 'java.lang.IllegalMonitorStateException'）表示编程错误，因此几乎肯定不会在生产代码中被捕获。 示例： 'try {\n    return component.getMousePosition(true) != null;\n  } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught\n    return false;\n  }' 使用被禁止的异常列表可指定应报告哪些异常。",
                  "markdown": "报告捕获不适当异常的 `catch` 子句。\n\n一些异常（例如 `java.lang.NullPointerException` 或 `java.lang.IllegalMonitorStateException`）表示编程错误，因此几乎肯定不会在生产代码中被捕获。\n\n**示例：**\n\n\n      try {\n        return component.getMousePosition(true) != null;\n      } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught\n        return false;\n      }\n\n使用**被禁止的异常**列表可指定应报告哪些异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProhibitedExceptionCaught",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofCatchParameter",
                "shortDescription": {
                  "text": "'catch' 形参上的 'instanceof'"
                },
                "fullDescription": {
                  "text": "报告使用 'instanceof' 表达式来测试 'catch' 块中形参类型的情况。 测试 'catch' 形参的类型通常最好使用单独的 'catch' 块，而不是使用 'instanceof'。 示例： 'void foo(Runnable runnable) {\n    try {\n        runnable.run();\n    } catch (Throwable throwable) {\n        if (throwable instanceof NoClassDefFoundError) { // 警告：'catch' 形参 'throwable' 上的 'instanceof'\n            System.out.println(\"Class not found!\");\n        }\n    }\n  }'",
                  "markdown": "报告使用 `instanceof` 表达式来测试 `catch` 块中形参类型的情况。\n\n测试 `catch` 形参的类型通常最好使用单独的 `catch` 块，而不是使用 `instanceof`。\n\n**示例：**\n\n\n      void foo(Runnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable throwable) {\n            if (throwable instanceof NoClassDefFoundError) { // 警告：'catch' 形参 'throwable' 上的 'instanceof'\n                System.out.println(\"Class not found!\");\n            }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofCatchParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantScheduledForRemovalAnnotation",
                "shortDescription": {
                  "text": "冗余的 @ScheduledForRemoval 注解"
                },
                "fullDescription": {
                  "text": "报告无 'inVersion' 特性的 '@ApiStatus.ScheduledForRemoval' 注解在以 Java 9 或更高版本为目标的代码中的用法。 此类用法可以用 '@Deprecated' 注解中的 'forRemoval' 特性代替以简化代码。 2022.1 最新变化",
                  "markdown": "报告无 `inVersion` 特性的 `@ApiStatus.ScheduledForRemoval` 注解在以 Java 9 或更高版本为目标的代码中的用法。\n\n\n此类用法可以用 `@Deprecated` 注解中的 `forRemoval` 特性代替以简化代码。\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantScheduledForRemovalAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalGetWithoutIsPresent",
                "shortDescription": {
                  "text": "在不进行 isPresent() 检查的情况下调用 Optional.get()"
                },
                "fullDescription": {
                  "text": "报告对 'Optional' 上的 'get()' 的调用而不检查它是否有值。 在空 'Optional' 实例上调用 'Optional.get()' 将抛出异常。 示例： 'void x(List<Integer> list) {\n    final Optional<Integer> optional =\n      list.stream().filter(x -> x > 10).findFirst();\n    final Integer result = optional.get(); // 此处有问题\n  }' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告对 `Optional` 上的 `get()` 的调用而不检查它是否有值。\n\n在空 `Optional` 实例上调用 `Optional.get()` 将抛出异常。\n\n**示例：**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // 此处有问题\n      }\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalGetWithoutIsPresent",
                    "cweIds": [
                      252,
                      476
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OnDemandImport",
                "shortDescription": {
                  "text": "'*' 导入"
                },
                "fullDescription": {
                  "text": "报告任何涵盖整个软件包的 'import' 语句 ('* imports')。 某些编码标准禁止此类 'import' 语句。 您可以将 IntelliJ IDEA 配置为使用优化 import 命令检测和修正此类语句。 转到设置 | 编辑器 | 代码样式 | Java | 导入，确保启用使用单个类导入选项，并在将 import 与 '*' 搭配使用的类计数和将静态 import 与 '*' 搭配使用的名称计数字段中指定值。 因此，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告任何涵盖整个软件包的 `import` 语句 ('\\* imports')。\n\n某些编码标准禁止此类 `import` 语句。\n\n\n您可以将 IntelliJ IDEA 配置为使用**优化 import** 命令检测和修正此类语句。 转到[设置 \\| 编辑器 \\| 代码样式 \\| Java \\| 导入](settings://preferences.sourceCode.Java?Use%20single%20class%20import)，确保启用**使用单个类导入** 选项，并在**将 import 与 '\\*' 搭配使用的类计数** 和**将静态 import 与 '\\*' 搭配使用的名称计数**字段中指定值。\n因此，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OnDemandImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 14,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FallthruInSwitchStatement",
                "shortDescription": {
                  "text": "'switch' 语句中的直落"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句中的直落。 当 'case' 标签后面的一系列可执行语句不能保证在下一个 'case' 标签前转移控制权时，就会发生直落。 例如，如果分支缺少 'break' 语句，就可能发生这种情况。 在这种情况下，即便 'switch' 表达式不等于被直落标签的值，控制权也会直落到 'switch' 标签后面的语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。 此检查将忽略任何使用与正则表达式模式 '(?i)falls?\\s*thro?u' 相匹配的文本注释的直落。 可以通过修正向可能直落到下一个分支的分支添加 'break'。 示例： 'switch(x) {\n      case (4):\n          if (condition) {\n              System.out.println(\"3\");\n              // 此处无 break\n          } else {\n              break;\n          }\n      case (6):\n          System.out.println(\"4\");\n    }' 在应用快速修复后： 'switch(x) {\n        case (4):\n            if (condition) {\n                System.out.println(\"3\");\n            } else {\n                break;\n            }\n            break;\n        case (6):\n            System.out.println(\"4\");\n    }'",
                  "markdown": "报告 `switch` 语句中的直落。\n\n当 `case` 标签后面的一系列可执行语句不能保证在下一个 `case` 标签前转移控制权时，就会发生直落。 例如，如果分支缺少 `break` 语句，就可能发生这种情况。\n在这种情况下，即便 `switch` 表达式不等于被直落标签的值，控制权也会直落到 `switch` 标签后面的语句。 虽然偶尔是有意为之，但此结构令人困惑，并且通常是由拼写错误所致。\n\n\n此检查将忽略任何使用与正则表达式模式 `(?i)falls?\\s*thro?u` 相匹配的文本注释的直落。\n\n可以通过修正向可能直落到下一个分支的分支添加 `break`。\n\n示例：\n\n\n        switch(x) {\n          case (4):\n              if (condition) {\n                  System.out.println(\"3\");\n                  // 此处无 break\n              } else {\n                  break;\n              }\n          case (6):\n              System.out.println(\"4\");\n        }\n\n在应用快速修复后：\n\n\n        switch(x) {\n            case (4):\n                if (condition) {\n                    System.out.println(\"3\");\n                } else {\n                    break;\n                }\n                break;\n            case (6):\n                System.out.println(\"4\");\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "fallthrough",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalIsPresent",
                "shortDescription": {
                  "text": "非函数样式 'Optional.isPresent()' 用法"
                },
                "fullDescription": {
                  "text": "报告可用函数样式重写的、用作 'if' 或条件表达式条件的 'Optional' 表达式。 结果往往更短，更易于阅读。 示例： 'if (str.isPresent()) str.get().trim();' 在应用快速修复后： 'str.ifPresent(String::trim);' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可用函数样式重写的、用作 `if` 或条件表达式条件的 `Optional` 表达式。 结果往往更短，更易于阅读。\n\n示例：\n\n\n      if (str.isPresent()) str.get().trim();\n\n在应用快速修复后：\n\n\n      str.ifPresent(String::trim);\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalIsPresent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantOperationOnEmptyContainer",
                "shortDescription": {
                  "text": "空容器上存在冗余操作"
                },
                "fullDescription": {
                  "text": "报告对空集合、映射或数组的冗余操作。 在空集合上迭代、移除元素、排序和某些其他操作没有任何效果，可以移除。 此外，它们可能表明存在错误。 示例： 'if (numbers.isEmpty()){\n    //由于缺少否定，因此出现错误\n    int max = numbers.stream().max(Comparator.naturalOrder()).get();\n    ...\n  }' 2019.1 最新变化",
                  "markdown": "报告对空集合、映射或数组的冗余操作。\n\n\n在空集合上迭代、移除元素、排序和某些其他操作没有任何效果，可以移除。 此外，它们可能表明存在错误。\n\n**示例：**\n\n\n      if (numbers.isEmpty()){\n        //由于缺少否定，因此出现错误\n        int max = numbers.stream().max(Comparator.naturalOrder()).get();\n        ...\n      }\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantOperationOnEmptyContainer",
                    "cweIds": [
                      561
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AtomicFieldUpdaterNotStaticFinal",
                "shortDescription": {
                  "text": "'AtomicFieldUpdater' 字段未被声明为 'static final'"
                },
                "fullDescription": {
                  "text": "报告以下类型的字段： 'java.util.concurrent.atomic.AtomicLongFieldUpdater' 'java.util.concurrent.atomic.AtomicIntegerFieldUpdater' 'java.util.concurrent.atomic.AtomicReferenceFieldUpdater' 其类型为 'static final'。 因为在一个类的所有实例中，只需要一个原子字段更新程序来更新 'volatile' 字段，所以它几乎总是 'static'。 使更新程序为 'final'，JVM 就能优化访问以提高性能。 示例： 'class Main {\n    private volatile int id;\n    private AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n  }' 在应用快速修复后： 'class Main {\n    private volatile int id;\n    private static final AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n  }'",
                  "markdown": "报告以下类型的字段：\n\n* `java.util.concurrent.atomic.AtomicLongFieldUpdater`\n* `java.util.concurrent.atomic.AtomicIntegerFieldUpdater`\n* `java.util.concurrent.atomic.AtomicReferenceFieldUpdater`\n\n其类型为 `static final`。 因为在一个类的所有实例中，只需要一个原子字段更新程序来更新 `volatile` 字段，所以它几乎总是 `static`。\n\n使更新程序为 `final`，JVM 就能优化访问以提高性能。\n\n**示例：**\n\n\n      class Main {\n        private volatile int id;\n        private AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        private volatile int id;\n        private static final AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AtomicFieldUpdaterNotStaticFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8MapForEach",
                "shortDescription": {
                  "text": "可以使用 Map.forEach()"
                },
                "fullDescription": {
                  "text": "建议将 'for(Entry<?,?> entry : map.entrySet()) {...}' 或 'map.entrySet().forEach(entry -> ...)' 替换为 'map.forEach((key, value) -> ...)'。 示例 'void print(Map<String, Integer> map) {\n    map.entrySet().forEach(entry -> {\n      String str = entry.getKey();\n      System.out.println(str + \":\" + entry.getValue());\n    });\n  }' 在应用快速修复后： 'void print(Map<String, Integer> map) {\n    map.forEach((str, value) -> System.out.println(str + \":\" + value));\n  }' 启用 不要报告循环选项后，只会报告 'entrySet().forEach()' 情况。 但是，该快速修复操作也可用于 'for' 循环。 2017.1 最新变化 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "建议将 `for(Entry<?,?> entry : map.entrySet()) {...}` 或 `map.entrySet().forEach(entry -> ...)` 替换为 `map.forEach((key, value) -> ...)`。\n\n示例\n\n\n      void print(Map<String, Integer> map) {\n        map.entrySet().forEach(entry -> {\n          String str = entry.getKey();\n          System.out.println(str + \":\" + entry.getValue());\n        });\n      }\n\n在应用快速修复后：\n\n\n      void print(Map<String, Integer> map) {\n        map.forEach((str, value) -> System.out.println(str + \":\" + value));\n      }\n\n\n启用 **不要报告循环** 选项后，只会报告 `entrySet().forEach()` 情况。\n但是，该快速修复操作也可用于 `for` 循环。\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8MapForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecordStoreResource",
                "shortDescription": {
                  "text": "打开了 'RecordStore'，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未在 'try' 块前打开并在相应的 'finally' 块中关闭的 Java ME 'javax.microedition.rms.RecordStore' 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'void foo1() throws RecordStoreException {\n      RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告\n  }\n  void foo2() throws RecordStoreException {\n      RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 无警告\n      try {\n          /* ... */\n      } finally {\n          rs.closeRecordStore();\n      }\n  }'",
                  "markdown": "报告未在 `try` 块前打开并在相应的 `finally` 块中关闭的 Java ME `javax.microedition.rms.RecordStore` 资源。\n\n如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      void foo1() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 警告\n      }\n      void foo2() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // 无警告\n          try {\n              /* ... */\n          } finally {\n              rs.closeRecordStore();\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RecordStoreOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectsEqualsCanBeSimplified",
                "shortDescription": {
                  "text": "'Objects.equals()' 可被替换为 'equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'Objects.equals(a, b)' 的调用，其中第一个实参是静态已知为非 null。 如果两个实参都是基元，此类调用可以安全地替换为 'a.equals(b)' 或 'a == b'。 示例： 'String defaultName = \"default\";\n  boolean isDefault = Objects.equals(defaultName, name);' 在应用快速修复后： 'String defaultName = \"default\";\n  boolean isDefault = defaultName.equals(name);' 2018.3 最新变化",
                  "markdown": "报告对 `Objects.equals(a, b)` 的调用，其中第一个实参是静态已知为非 null。\n\n如果两个实参都是基元，此类调用可以安全地替换为 `a.equals(b)` 或 `a == b`。\n\n示例：\n\n\n      String defaultName = \"default\";\n      boolean isDefault = Objects.equals(defaultName, name);\n\n在应用快速修复后：\n\n\n      String defaultName = \"default\";\n      boolean isDefault = defaultName.equals(name);\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ObjectsEqualsCanBeSimplified",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassLoaderInstantiation",
                "shortDescription": {
                  "text": "'ClassLoader' 实例化"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.ClassLoader' 类的实例化。 虽然通常是良性的，但在任何安全审核中都应该仔细检查 'ClassLoader' 的任何实例化。 示例： 'Class<?> loadExtraClass(String name) throws Exception {\n      try(URLClassLoader loader =\n          new URLClassLoader(new URL[]{new URL(\"extraClasses/\")})) {\n        return loader.loadClass(name);\n      }\n    }'",
                  "markdown": "报告 `java.lang.ClassLoader` 类的实例化。\n\n虽然通常是良性的，但在任何安全审核中都应该仔细检查 `ClassLoader` 的任何实例化。\n\n**示例：**\n\n        Class<?> loadExtraClass(String name) throws Exception {\n          try(URLClassLoader loader =\n              new URLClassLoader(new URL[]{new URL(\"extraClasses/\")})) {\n            return loader.loadClass(name);\n          }\n        }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassLoaderInstantiation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NativeMethods",
                "shortDescription": {
                  "text": "本地方法"
                },
                "fullDescription": {
                  "text": "报告被声明为 'native' 的方法。 原生方法本质上不可移植。",
                  "markdown": "报告被声明为 `native` 的方法。 原生方法本质上不可移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NativeMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsWithItself",
                "shortDescription": {
                  "text": "在自身上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'equals()'、'compareTo()' 或比较一个对象是否与自身相等的类似方法的调用。 这些方法的方法约定指定了此类调用将始终为 'equals()' 返回 'true' 或为 'compareTo()' 返回 '0'。 该检查还会检查对 'Objects.equals()'、'Objects.deepEquals()'、'Arrays.equals()'、'Comparator.compare()'、测试框架（JUnit、TestNG、AssertJ）的 'assertEquals()' 方法、'Integer.compare()'、'Integer.compareUnsigned()' 以及类似方法的调用。 示例： 'class Foo {\n    boolean foo(Object o) {\n        return o.equals(o); // 警告\n    }\n\n    boolean bar(String[] ss) {\n        return Arrays.equals(ss, ss); // 警告\n    }\n}' 使用该选项可以仅报告对不可扩展的库类（如 'String'）和基元类型的测试断言。 当测试 'equals' 方法时，此选项可能很有用。",
                  "markdown": "报告对 `equals()`、`compareTo()` 或比较一个对象是否与自身相等的类似方法的调用。 这些方法的方法约定指定了此类调用将始终为 `equals()` 返回 `true` 或为 `compareTo()` 返回 `0`。 该检查还会检查对 `Objects.equals()`、`Objects.deepEquals()`、`Arrays.equals()`、`Comparator.compare()`、测试框架（JUnit、TestNG、AssertJ）的 `assertEquals()` 方法、`Integer.compare()`、`Integer.compareUnsigned()` 以及类似方法的调用。\n\n**示例：**\n\n\n      class Foo {\n        boolean foo(Object o) {\n            return o.equals(o); // 警告\n        }\n\n        boolean bar(String[] ss) {\n            return Arrays.equals(ss, ss); // 警告\n        }\n    }\n\n\n使用该选项可以仅报告对不可扩展的库类（如 `String`）和基元类型的测试断言。\n当测试 `equals` 方法时，此选项可能很有用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsWithItself",
                    "cweIds": [
                      571
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInheritanceDepth",
                "shortDescription": {
                  "text": "类在继承树中太深"
                },
                "fullDescription": {
                  "text": "报告继承层次结构过深的类。 继承太深的类可能令人困惑，并表明有必要重构。 库中的所有超类都被视为单个超类，库被认为不可修改。 使用继承深度限制字段可指定类的最大继承深度。",
                  "markdown": "报告继承层次结构过深的类。\n\n继承太深的类可能令人困惑，并表明有必要重构。\n\n库中的所有超类都被视为单个超类，库被认为不可修改。\n\n使用**继承深度限制**字段可指定类的最大继承深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassTooDeepInInheritanceTree",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkedForRemoval",
                "shortDescription": {
                  "text": "使用API标记为删除"
                },
                "fullDescription": {
                  "text": "报告已用 '@Deprecated(forRemoval=true)' 标记为移除的已弃用的 API（类、字段和方法）的用法。 使用标记为移除的 API 的代码可能会导致未来版本的 API 出现运行时错误。 这就是为什么此检查的推荐严重性为 Error。 如果您想使用与普通弃用相同的代码高亮显示，您可以将严重性更改为 警告。 2017.3 最新变化",
                  "markdown": "报告已用 `@Deprecated(`**forRemoval**`=true)` 标记为移除的已弃用的 API（类、字段和方法）的用法。\n\n\n使用标记为移除的 API 的代码可能会导致未来版本的 API 出现运行时错误。 这就是为什么此检查的推荐严重性为 *Error*。\n\n\n如果您想使用与普通弃用相同的代码高亮显示，您可以将严重性更改为 *警告*。\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "removal",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedConditionalExpression",
                "shortDescription": {
                  "text": "嵌套条件表达式"
                },
                "fullDescription": {
                  "text": "报告嵌套的条件表达式，因为它们可能导致代码格外令人困惑。 示例： 'int y = a == 10 ? b == 20 ? 10 : a : b;'",
                  "markdown": "报告嵌套的条件表达式，因为它们可能导致代码格外令人困惑。\n\n示例：\n\n\n      int y = a == 10 ? b == 20 ? 10 : a : b;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileCanBeForeach",
                "shortDescription": {
                  "text": "'while' 循环可被替换为增强的 'for' 循环"
                },
                "fullDescription": {
                  "text": "报告迭代集合并且可以替换为增强型 'for' 循环（foreach 迭代语法）的 'while' 循环。 示例： 'Iterator it = c.iterator();\n  while(it.hasNext()) {\n    Object obj = it.next();\n    System.out.println(obj);\n  }' 可以替换为： 'for (Object obj : c) {\n    System.out.println(obj);\n  }' 此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。",
                  "markdown": "报告迭代集合并且可以替换为增强型 `for` 循环（foreach 迭代语法）的 `while` 循环。\n\n**示例：**\n\n\n      Iterator it = c.iterator();\n      while(it.hasNext()) {\n        Object obj = it.next();\n        System.out.println(obj);\n      }\n\n可以替换为：\n\n\n      for (Object obj : c) {\n        System.out.println(obj);\n      }\n\n此检查取决于 Java 功能 'For-each 循环'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WhileLoopReplaceableByForEach",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BulkFileAttributesRead",
                "shortDescription": {
                  "text": "可使用批量 'Files.readAttributes()' 调用"
                },
                "fullDescription": {
                  "text": "报告连续多个 'java.io.File' 特性检查，例如： 'isDirectory()' 'isFile()' 'lastModified()' 'length()' 此类调用可被替换为批量 'Files.readAttributes()' 调用。 这通常比多个单独的特性检查性能更好。 示例： 'boolean isNewFile(File file, long lastModified) throws IOException {\n    return file.isFile() && file.lastModified() > lastModified;\n  }' 在应用快速修复后： 'boolean isNewFile(File file, long lastModified) throws IOException {\n    var fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n    return fileAttributes.isRegularFile() && fileAttributes.lastModifiedTime().toMillis() > lastModified;\n  }' 如果 'IOException' 在当前上下文中未被处理，则此检查不会显示警告，但快速修复仍然可用。 请注意，替换通常不完全相同，应谨慎使用。 特别是，如果文件根本不存在，行为可能会有所不同。 仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。 2022.1 最新变化",
                  "markdown": "报告连续多个 `java.io.File` 特性检查，例如：\n\n* `isDirectory()`\n* `isFile()`\n* `lastModified()`\n* `length()`\n\n此类调用可被替换为批量 `Files.readAttributes()` 调用。 这通常比多个单独的特性检查性能更好。\n\n示例：\n\n\n      boolean isNewFile(File file, long lastModified) throws IOException {\n        return file.isFile() && file.lastModified() > lastModified;\n      }\n\n在应用快速修复后：\n\n\n      boolean isNewFile(File file, long lastModified) throws IOException {\n        var fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n        return fileAttributes.isRegularFile() && fileAttributes.lastModifiedTime().toMillis() > lastModified;\n      }\n\n如果 `IOException` 在当前上下文中未被处理，则此检查不会显示警告，但快速修复仍然可用。\n\n请注意，替换通常不完全相同，应谨慎使用。 特别是，如果文件根本不存在，行为可能会有所不同。\n\n仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BulkFileAttributesRead",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitNumericConversion",
                "shortDescription": {
                  "text": "隐式数字转换"
                },
                "fullDescription": {
                  "text": "报告数值类型之间的隐式转换。 隐式数字转换本身不是问题，但如果是意外，可能会在跟踪错误时造成困难。 示例： 'double m(int i) {\n    return i * 10;\n  }' 在应用快速修复后： 'double m(int i) {\n    return (double) (i * 10);\n  }' 配置检查： 使用忽略扩大转换选项可以忽略不会导致数据丢失的隐式转换（例如，'int'->'long'）。 使用忽略 'char' 与其他类型之间的转换选项可以忽略 'char' 与其他类型之间的转换。 该检查仍将报告浮点数与其他类型之间的转换。 使用忽略来自常量和文字的转换可使检查忽略来自文字和编译时常量的转换。",
                  "markdown": "报告数值类型之间的隐式转换。\n\n隐式数字转换本身不是问题，但如果是意外，可能会在跟踪错误时造成困难。\n\n**示例：**\n\n\n      double m(int i) {\n        return i * 10;\n      }\n\n在应用快速修复后：\n\n\n      double m(int i) {\n        return (double) (i * 10);\n      }\n\n配置检查：\n\n* 使用**忽略扩大转换** 选项可以忽略不会导致数据丢失的隐式转换（例如，`int`-\\>`long`）。\n* 使用**忽略 'char' 与其他类型之间的转换** 选项可以忽略 `char` 与其他类型之间的转换。 该检查仍将报告浮点数与其他类型之间的转换。\n* 使用**忽略来自常量和文字的转换**可使检查忽略来自文字和编译时常量的转换。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitNumericConversion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotNullFieldNotInitialized",
                "shortDescription": {
                  "text": "@NotNull 字段未初始化"
                },
                "fullDescription": {
                  "text": "报告构造函数中未初始化的注解为非 null 的字段。 示例： 'public class MyClass {\n  private @NotNull String value;\n\n  public void setValue(@NotNull String value) {\n    this.value = value;\n  }\n\n  public @NotNull String getValue() {\n    return value;\n  }\n}' 此类字段可能违反非 null 约束。 在上例中，'setValue' 形参注解为非 null，但是如果没有调用 setter，'getValue' 可能返回 null。",
                  "markdown": "报告构造函数中未初始化的注解为非 null 的字段。\n\n示例：\n\n    public class MyClass {\n      private @NotNull String value;\n\n      public void setValue(@NotNull String value) {\n        this.value = value;\n      }\n\n      public @NotNull String getValue() {\n        return value;\n      }\n    }\n\n\n此类字段可能违反非 null 约束。 在上例中，`setValue` 形参注解为非 null，但是如果没有调用 setter，`getValue` 可能返回 null。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotNullFieldNotInitialized",
                    "cweIds": [
                      476
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug/为 null 性问题",
                      "index": 141,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexBooleanExpression",
                "shortDescription": {
                  "text": "过度复杂的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。 示例： 'cond(x1) && cond(x2) ^ cond(x3) && cond(x4);' 配置检查： 使用最大项数字段可以指定布尔表达式中允许的最大项数。 使用忽略纯合取和析取选项可以忽略重复使用单一布尔运算符的布尔表达式。",
                  "markdown": "报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。\n\n示例：\n\n\n      cond(x1) && cond(x2) ^ cond(x3) && cond(x4);\n\n配置检查：\n\n* 使用**最大项数**字段可以指定布尔表达式中允许的最大项数。\n* 使用**忽略纯合取和析取**选项可以忽略重复使用单一布尔运算符的布尔表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotifyCalledOnCondition",
                "shortDescription": {
                  "text": "在 'java.util.concurrent.locks.Condition' 对象上调用了 'notify()' 或 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "报告在 'java.util.concurrent.locks.Condition' 对象上对 'notify()' 或 'notifyAll()' 的调用。 这可能是编程错误，本应使用 'signal()' 或 'signalAll()' 方法的某些变体，否则可能出现 'IllegalMonitorStateException'。 示例： 'class C {\n    final Lock l = new ReentrantLock();\n    final Condition c = l.newCondition();\n\n    void release() {\n      l.lock();\n      try {\n        c.notifyAll(); // 此处可能本应使用 'signalAll()'\n      } finally {\n        l.unlock();\n      }\n    }\n  }'",
                  "markdown": "报告在 `java.util.concurrent.locks.Condition` 对象上对 `notify()` 或 `notifyAll()` 的调用。\n\n\n这可能是编程错误，本应使用 `signal()` 或 `signalAll()` 方法的某些变体，否则可能出现 `IllegalMonitorStateException`。\n\n**示例：**\n\n\n      class C {\n        final Lock l = new ReentrantLock();\n        final Condition c = l.newCondition();\n\n        void release() {\n          l.lock();\n          try {\n            c.notifyAll(); // 此处可能本应使用 'signalAll()'\n          } finally {\n            l.unlock();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotifyCalledOnCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewMethodNamingConvention",
                "shortDescription": {
                  "text": "方法命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的方法。 此检查将忽略重写库方法和构造函数的实例方法。 示例：如果对 static 方法启用检查，并且指定的方法名称的最小长度为 4（默认值），则以下 static 方法会产生警告，因为其名称长度为 3，即小于 4：'public static int max(int a, int b)'。 只能在编辑器中使用重命名此类方法的快速修复。 配置检查： 使用选项部分中的列表可指定应检查哪些方法。 取消选中要跳过检查的方法类型的复选框。 在长度字段中指定 0 可跳过相应检查。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的方法。\n\n此检查将忽略重写库方法和构造函数的实例方法。\n\n**示例** ：如果对 static 方法启用检查，并且指定的方法名称的最小长度为 4（默认值），则以下 static 方法会产生警告，因为其名称长度为 3，即小于 4：`public static int max(int a, int b)`。\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n配置检查：\n\n使用**选项** 部分中的列表可指定应检查哪些方法。 取消选中要跳过检查的方法类型的复选框。 在长度字段中指定 **0** 可跳过相应检查。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewMethodNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyStrongTypeCast",
                "shortDescription": {
                  "text": "过强的类型转换"
                },
                "fullDescription": {
                  "text": "报告过强的类型转换。 例如，将对象转换为 'ArrayList'，将其转换为 'List' 也可以。 注意：与冗余类型转换检查非常相似，如果您有意使用过强的转换来生成 'ClassCastException'，则对此检查应用修正可能会改变程序的语义。 示例： 'interface Super {\n    void doSmth();\n  }\n  interface Sub extends Super { }\n\n  void use(Object obj) {\n    // 警告：可以使用 ((Super)obj).doSmth()\n    ((Sub)obj).doSmth();\n  }' 在代码中有匹配的 'instanceof' 检查时，使用下面的复选框可忽略转换。",
                  "markdown": "报告过强的类型转换。 例如，将对象转换为 `ArrayList`，将其转换为 `List` 也可以。\n\n\n**注意** ：与*冗余类型转换* 检查非常相似，如果您有意使用过强的转换来生成 `ClassCastException`，则对此检查应用修正可能会改变程序的语义。\n\n示例：\n\n\n      interface Super {\n        void doSmth();\n      }\n      interface Sub extends Super { }\n\n      void use(Object obj) {\n        // 警告：可以使用 ((Super)obj).doSmth()\n        ((Sub)obj).doSmth();\n      }\n\n\n在代码中有匹配的 `instanceof` 检查时，使用下面的复选框可忽略转换。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyStrongTypeCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaLangImport",
                "shortDescription": {
                  "text": "'java.lang' 软件包中有不必要的 import"
                },
                "fullDescription": {
                  "text": "报告引用 'java.lang' 软件包的 'import' 语句。 'java.lang' 类始终隐式导入，因此此类 import 语句冗余，也令人困惑。 IntelliJ IDEA 可以通过优化 import 命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告引用 `java.lang` 软件包的 `import` 语句。\n\n\n`java.lang` 类始终隐式导入，因此此类 import 语句冗余，也令人困惑。\n\n\nIntelliJ IDEA 可以通过**优化 import** 命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaLangImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 14,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClass",
                "shortDescription": {
                  "text": "实用程序类"
                },
                "fullDescription": {
                  "text": "报告实用程序类。 实用程序类将所有字段和方法声明为 'static'，存在这样的情况可能表明欠缺面向对象的设计。 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的类。",
                  "markdown": "报告实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`，存在这样的情况可能表明欠缺面向对象的设计。\n\n\n使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNameDiffersFromFileName",
                "shortDescription": {
                  "text": "类名与文件名不同"
                },
                "fullDescription": {
                  "text": "报告所属的文件名与其不匹配的顶层类名。 虽然 Java 规范允许以这种方式命名非 'public' 类，但名称不匹配的文件可能令人困惑，并降低各种软件工具的实用性。",
                  "markdown": "报告所属的文件名与其不匹配的顶层类名。\n\n虽然 Java 规范允许以这种方式命名非 `public` 类，但名称不匹配的文件可能令人困惑，并降低各种软件工具的实用性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNameDiffersFromFileName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IndexOfReplaceableByContains",
                "shortDescription": {
                  "text": "'String.indexOf()' 表达式可被替换为 'contains()'"
                },
                "fullDescription": {
                  "text": "报告与 'String.indexOf()' 调用（可以替换为对 'String.contains()' 方法的调用）的比较。 示例： 'boolean b = \"abcd\".indexOf('e') >= 0;' 在应用快速修复后： 'boolean b = \"abcd\".contains('e');' 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告与 `String.indexOf()` 调用（可以替换为对 `String.contains()` 方法的调用）的比较。\n\n**示例：**\n\n\n      boolean b = \"abcd\".indexOf('e') >= 0;\n\n在应用快速修复后：\n\n\n      boolean b = \"abcd\".contains('e');\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IndexOfReplaceableByContains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationArgumentToLogCall",
                "shortDescription": {
                  "text": "非常量字符串串联作为日志调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作 SLF4J 和 Log4j 2 日志记录方法实参的非常量字符串串联。 即使未记录日志消息，也会在运行时评估非常量串联；这会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。 示例： 'public class Vital {\n    private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n    public void saveTheWorld(int i, String s, boolean b) {\n      LOG.info(\"saveTheWorld(\" + i + \", \" + s + \", \"  + b + \")\");\n      // todo\n    }\n  }' 在应用快速修复后： 'public class Vital {\n    private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n    public void saveTheWorld(int i, String s, boolean b) {\n      LOG.info(\"saveTheWorld({}, {}, {})\", i, s, b);\n      // todo\n    }\n  }' 配置检查： 使用警告对象列表可以忽略某些更高的日志记录级别。 即使在生产中也可以启用更高的日志记录级别，并且始终会评估实参。",
                  "markdown": "报告用作 **SLF4J** 和 **Log4j 2** 日志记录方法实参的非常量字符串串联。 即使未记录日志消息，也会在运行时评估非常量串联；这会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。\n\n**示例：**\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld(\" + i + \", \" + s + \", \"  + b + \")\");\n          // todo\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld({}, {}, {})\", i, s, b);\n          // todo\n        }\n      }\n\n\n配置检查：\n\n* 使用**警告对象**列表可以忽略某些更高的日志记录级别。 即使在生产中也可以启用更高的日志记录级别，并且始终会评估实参。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StringConcatenationArgumentToLogCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 57,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalContainsCollection",
                "shortDescription": {
                  "text": "'Optional' 包含数组或集合"
                },
                "fullDescription": {
                  "text": "报告包含数组或集合类型形参的 'java.util.Optional' 或 'com.google.common.base.Optional' 类型。 在此类情况下，使用空的数组或集合来表示无结果更为清晰。 示例： 'Optional<List<Integer>> foo() {\n    return Optional.empty();\n  }' 此代码可能如下所示： 'List<Integer> foo() {\n    return List.of();\n  }' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告包含数组或集合类型形参的 `java.util.Optional` 或 `com.google.common.base.Optional` 类型。\n\n在此类情况下，使用空的数组或集合来表示无结果更为清晰。\n\n**示例：**\n\n\n      Optional<List<Integer>> foo() {\n        return Optional.empty();\n      }\n\n此代码可能如下所示：\n\n\n      List<Integer> foo() {\n        return List.of();\n      }\n      \n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalContainsCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableAssertion",
                "shortDescription": {
                  "text": "可简化断言"
                },
                "fullDescription": {
                  "text": "报告任何可以替换为更简单的等效调用的 'assert' 调用。 示例 → 替换 'assertEquals(true, x());' 'assertTrue(x());' 'assertTrue(y() != null);' 'assertNotNull(y());' 'assertTrue(z == z());' 'assertSame(z, z());' 'assertTrue(a.equals(a()));' 'assertEquals(a, a());' 'assertTrue(false);' 'fail();'",
                  "markdown": "报告任何可以替换为更简单的等效调用的 `assert` 调用。\n\n|                示例                | → |           替换            |\n|----------------------------------|---|-------------------------|\n| `assertEquals(`**true**`, x());` |   | `assertTrue(x());`      |\n| `assertTrue(y() != null);`       |   | `assertNotNull(y());`   |\n| `assertTrue(z == z());`          |   | `assertSame(z, z());`   |\n| `assertTrue(a.equals(a()));`     |   | `assertEquals(a, a());` |\n| `assertTrue(`**false**`);`       |   | `fail();`               |"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 98,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoadLibraryWithNonConstantString",
                "shortDescription": {
                  "text": "'System.loadLibrary()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对'java.lang.System.loadLibrary()'、'java.lang.System.load()'、'java.lang.Runtime.loadLibrary()' 和 'java.lang.Runtime.load()' 的调用，它们会将动态构造的字符串作为库的名称。 构造的库名称字符串是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'void test(int i) {\n    System.loadLibrary(\"foo\" + i);\n  }' 使用检查设置可以将任何 'static final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'private static final String LIBRARY = getUserInput();'",
                  "markdown": "报告对`java.lang.System.loadLibrary()`、`java.lang.System.load()`、`java.lang.Runtime.loadLibrary()` 和 `java.lang.Runtime.load()` 的调用，它们会将动态构造的字符串作为库的名称。\n\n\n构造的库名称字符串是安全漏洞的常见来源。\n默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      void test(int i) {\n        System.loadLibrary(\"foo\" + i);\n      }\n\n\n使用检查设置可以将任何 `static final` 字段视为常量。\n请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      private static final String LIBRARY = getUserInput();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoadLibraryWithNonConstantString",
                    "cweIds": [
                      114,
                      494,
                      676,
                      829
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceMethodClashesWithObject",
                "shortDescription": {
                  "text": "接口方法与 'Object' 中的方法冲突"
                },
                "fullDescription": {
                  "text": "报告与 'java.lang.Object' 类中的 protected 方法 'clone()' 和 'finalize()' 冲突的接口方法。 在接口中，可以使用与 'java.lang.Object' 方法不兼容的返回类型来声明这些方法。 实现此类接口的类不可编译。 当接口正常工作时，虽然仍可根据它创建 lambda，但不建议这样做。 示例： '// // 警告：此接口不能由任何类实现，\n  // 只能由 lambda 或方法引用实现\n  interface MyInterface {\n    double clone();\n  }'",
                  "markdown": "报告与 `java.lang.Object` 类中的 **protected** 方法 `clone()` 和 `finalize()` 冲突的接口方法。\n\n在接口中，可以使用与 `java.lang.Object` 方法不兼容的返回类型来声明这些方法。\n实现此类接口的类不可编译。\n当接口正常工作时，虽然仍可根据它创建 lambda，但不建议这样做。\n\n示例：\n\n\n      // // 警告：此接口不能由任何类实现，\n      // 只能由 lambda 或方法引用实现\n      interface MyInterface {\n        double clone();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceMethodClashesWithObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticMethodOnlyUsedInOneClass",
                "shortDescription": {
                  "text": "static 成员仅在其他一个类中使用"
                },
                "fullDescription": {
                  "text": "报告仅从包含类以外的类使用的 'static' 方法和字段。 此类成员可以移动到所使用的类。 此检查将忽略从成员的类内部的匿名类访问的工厂方法和成员。 调用同一个类中名称相同但形参较少的方法的方便重载也会被忽略。 仅在从测试类使用 static 成员时，可以使用第一个复选框来禁止此检查。 使用下面的第二个复选框可以忽略匿名类、本地类或非 static 内部类中的成员用法。 使用下面的第三个复选框，可以不对没有问题的情况下也无法移动的成员发出警告，例如，由于目标类中已存在签名相同的方法，或者由于移动此方法时将无法访问方法内部使用的字段或方法。 使用第四个复选框可以忽略位于实用程序类中的成员。",
                  "markdown": "报告仅从包含类以外的类使用的 `static` 方法和字段。 此类成员可以移动到所使用的类。 此检查将忽略从成员的类内部的匿名类访问的工厂方法和成员。 调用同一个类中名称相同但形参较少的方法的方便重载也会被忽略。\n\n\n仅在从测试类使用 static 成员时，可以使用第一个复选框来禁止此检查。\n\n\n使用下面的第二个复选框可以忽略匿名类、本地类或非 static 内部类中的成员用法。\n\n\n使用下面的第三个复选框，可以不对没有问题的情况下也无法移动的成员发出警告，例如，由于目标类中已存在签名相同的方法，或者由于移动此方法时将无法访问方法内部使用的字段或方法。\n\n\n使用第四个复选框可以忽略位于实用程序类中的成员。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticMethodOnlyUsedInOneClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEscapeInRegexReplacement",
                "shortDescription": {
                  "text": "正则表达式替换字符串中的冗余转义"
                },
                "fullDescription": {
                  "text": "报告正则表达式方法的替换字符串中的冗余转义。 允许转义正则表达式替换字符串中的任何字符，但只有 '$' 和 '\\' 字符才需要转义。 示例： 'string.replaceAll(\"a\", \"\\\\b\");' 在应用快速修复后： 'string.replaceAll(\"a\", \"b\");' 2022.3 最新变化",
                  "markdown": "报告正则表达式方法的替换字符串中的冗余转义。 允许转义正则表达式替换字符串中的任何字符，但只有 `$` 和 `\\` 字符才需要转义。\n\n**示例：**\n\n\n      string.replaceAll(\"a\", \"\\\\b\");\n\n在应用快速修复后：\n\n\n      string.replaceAll(\"a\", \"b\");\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantEscapeInRegexReplacement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizedOnLiteralObject",
                "shortDescription": {
                  "text": "在使用文字初始化的对象上同步"
                },
                "fullDescription": {
                  "text": "报告在用文字初始化的对象上锁定的 'synchronized' 块。 字符串文字是暂存的，'Character'、'Boolean' 和 'Number' 文字可以从缓存中分配。 正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果锁定对象被认为是 private 对象，这可能会产生意外的死锁情况。 示例： 'class Main {\n    final String mutex = \"Mutex\";\n    void method() {\n      synchronized (mutex) {\n      }\n    }\n  }' 使用警告所有可能的文字选项可以报告 'String'、'Character'、'Boolean' 和 'Number' 对象的任何同步。",
                  "markdown": "报告在用文字初始化的对象上锁定的 `synchronized` 块。\n\n\n字符串文字是暂存的，`Character`、`Boolean` 和 `Number` 文字可以从缓存中分配。\n正因为如此，可能系统的其他某些部分（使用通过相同文字初始化的对象）实际上会包含对完全相同的对象的引用。 如果锁定对象被认为是 private 对象，这可能会产生意外的死锁情况。\n\n**示例：**\n\n\n      class Main {\n        final String mutex = \"Mutex\";\n        void method() {\n          synchronized (mutex) {\n          }\n        }\n      }\n\n\n使用**警告所有可能的文字** 选项可以报告 `String`、`Character`、`Boolean` 和 `Number` 对象的任何同步。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizedOnLiteralObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9ReflectionClassVisibility",
                "shortDescription": {
                  "text": "跨模块问题的反射访问"
                },
                "fullDescription": {
                  "text": "报告 'Class.forName()' 和 'ClassLoader.loadClass()' 调用，这些调用尝试访问由于 Java 9 模块可访问性规则而在当前范围内不可见的类。 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告 `Class.forName()` 和 `ClassLoader.loadClass()` 调用，这些调用尝试访问由于 Java 9 模块可访问性规则而在当前范围内不可见的类。\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9ReflectionClassVisibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/反射访问",
                      "index": 99,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharsetObjectCanBeUsed",
                "shortDescription": {
                  "text": "可以使用标准 'Charset' 对象"
                },
                "fullDescription": {
                  "text": "报告可以用预定义的 'StandardCharsets.UTF_8' 代码替换其中常量字符集 'String' 文字（例如，'\"UTF-8\"'）的方法和构造函数。 修复后可以加快代码的速度，因为字符集查找变得不必要。 此外，您可能也不需要捕捉 'UnsupportedEncodingException'。 在这种情况下，catch 块将被自动删除。 示例： 'try {\n    byte[] bytes = \"str\".getBytes(\"UTF-8\");\n  } catch (UnsupportedEncodingException e) {\n  }' 在应用快速修复后： 'byte[] bytes = \"str\".getBytes(StandardCharsets.UTF_8);' 该检查在 Java 7 及更高版本中可用。 2018.2 最新变化",
                  "markdown": "报告可以用预定义的 `StandardCharsets.UTF_8` 代码替换其中常量字符集 `String` 文字（例如，`\"UTF-8\"`）的方法和构造函数。\n\n修复后可以加快代码的速度，因为字符集查找变得不必要。\n此外，您可能也不需要捕捉 `UnsupportedEncodingException`。 在这种情况下，catch 块将被自动删除。\n\n示例：\n\n\n      try {\n        byte[] bytes = \"str\".getBytes(\"UTF-8\");\n      } catch (UnsupportedEncodingException e) {\n      }\n\n在应用快速修复后：\n\n\n      byte[] bytes = \"str\".getBytes(StandardCharsets.UTF_8);\n\n该检查在 Java 7 及更高版本中可用。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharsetObjectCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfSunClasses",
                "shortDescription": {
                  "text": "使用 'sun.*' 类"
                },
                "fullDescription": {
                  "text": "报告使用 'sun.*' 层次结构中的类的情况。 这种类不可在不同的 JVM 之间移植。",
                  "markdown": "报告使用 `sun.*` 层次结构中的类的情况。 这种类不可在不同的 JVM 之间移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfSunClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCast",
                "shortDescription": {
                  "text": "冗余类型转换"
                },
                "fullDescription": {
                  "text": "报告不必要的转换表达式。 示例： 'static Object toObject(String s) {\n    return (Object) s;\n  }' 使用下面的复选框可以忽略澄清转换，例如应为 'Object' 的集合调用中的转换： 'static void removeFromList(List<String> l, Object o) {\n    l.remove((String)o);\n  }'",
                  "markdown": "报告不必要的转换表达式。\n\n示例：\n\n\n      static Object toObject(String s) {\n        return (Object) s;\n      }\n\n\n使用下面的复选框可以忽略澄清转换，例如应为 `Object` 的集合调用中的转换：\n\n\n      static void removeFromList(List<String> l, Object o) {\n        l.remove((String)o);\n      } \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousInnerClass",
                "shortDescription": {
                  "text": "匿名类可被替换为内部类"
                },
                "fullDescription": {
                  "text": "报告匿名类。 偶尔将匿名类替换为内部类可以提高代码的可读性和可维护性。 有些代码标准不建议使用匿名类。 示例： 'class Example {\n    public static void main(String[] args) {\n      new Thread() {\n        public void run() {\n          work()\n        }\n\n        private void work() {}\n      }.start();\n    }\n  }' 在应用快速修复后： 'class Example {\n    public static void main(String[] args) {\n      new MyThread().start();\n    }\n\n    private static class MyThread extends Thread {\n      public void run() {\n        work();\n      }\n\n      private void work() {}\n    }\n  }'",
                  "markdown": "报告匿名类。\n\n偶尔将匿名类替换为内部类可以提高代码的可读性和可维护性。\n有些代码标准不建议使用匿名类。\n\n**示例：**\n\n\n      class Example {\n        public static void main(String[] args) {\n          new Thread() {\n            public void run() {\n              work()\n            }\n\n            private void work() {}\n          }.start();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example {\n        public static void main(String[] args) {\n          new MyThread().start();\n        }\n\n        private static class MyThread extends Thread {\n          public void run() {\n            work();\n          }\n\n          private void work() {}\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyCollector",
                "shortDescription": {
                  "text": "可简化的收集器"
                },
                "fullDescription": {
                  "text": "报告可以简化的收集器。 特别是，一些级联的 'groupingBy()' 收集器可以使用更简单的 'toMap()' 收集器来表示，这也可能会提高性能。 示例： 'Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));' 在应用快速修复后： 'Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));' 2017.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以简化的收集器。\n\n特别是，一些级联的 `groupingBy()` 收集器可以使用更简单的 `toMap()` 收集器来表示，这也可能会提高性能。\n\n示例：\n\n\n      Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));\n\n在应用快速修复后：\n\n\n      Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyCollector",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleTopLevelClassesInFile",
                "shortDescription": {
                  "text": "单个文件中的多个顶级类"
                },
                "fullDescription": {
                  "text": "报告单个 Java 文件中的多个顶层类。 将多个顶层类放在一个文件中可能令人困惑，并且会降低各种软件工具的实用性。",
                  "markdown": "报告单个 Java 文件中的多个顶层类。\n\n将多个顶层类放在一个文件中可能令人困惑，并且会降低各种软件工具的实用性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultipleTopLevelClassesInFile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IteratorNextDoesNotThrowNoSuchElementException",
                "shortDescription": {
                  "text": "无法抛出 'NoSuchElementException' 的 'Iterator.next()'"
                },
                "fullDescription": {
                  "text": "报告不能抛出 'java.util.NoSuchElementException' 的 'Iterator.next()' 的实现。 此类实现违反了 'java.util.iterator' 的约定，如果以非标准方式使用迭代器，可能会导致难以捉摸的错误。 示例： 'class Numbers implements Iterator<Integer> {\n    @Override\n    public Integer next() { //warning\n        if (hasNext()) {\n            return generateNext();\n        } else {\n            return null; //而是抛出 NoSuchElementException\n        }\n    }\n\n    ...\n  }'",
                  "markdown": "报告不能抛出 `java.util.NoSuchElementException` 的 `Iterator.next()` 的实现。\n\n\n此类实现违反了 `java.util.iterator` 的约定，如果以非标准方式使用迭代器，可能会导致难以捉摸的错误。\n\n**示例：**\n\n\n      class Numbers implements Iterator<Integer> {\n        @Override\n        public Integer next() { //warning\n            if (hasNext()) {\n                return generateNext();\n            } else {\n                return null; //而是抛出 NoSuchElementException\n            }\n        }\n\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IteratorNextCanNotThrowNoSuchElementException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectMessageFormat",
                "shortDescription": {
                  "text": "'MessageFormat' 模式不正确"
                },
                "fullDescription": {
                  "text": "报告不正确的消息格式模式或占位符的不正确索引 报告以下错误： 未解析的索引或负索引 未闭合的大括号 不成对的引号。 在这种情况下，模式的一部分可能不会被使用 可能引号的数量不正确 嵌套选择模式的下限不正确 占位符索引不正确。 在这种情况下，不能替换占位符或不能使用实参 示例： 'MessageFormat.format(\"{wrong}\", 1); // 不正确的索引\n  MessageFormat.format(\"{0\", 1); // 不匹配的大括号\n  MessageFormat.format(\"'{0}\", 1); // 不成对的引号\n  MessageFormat.format(\"It''''s {0}\", 1); // 将打印“It''s”而非“It's”\n  MessageFormat.format(\"{0}\", 1, 2); // 模式中未使用索引为 '1' 的实参' 2023.2 最新变化",
                  "markdown": "报告不正确的消息格式模式或占位符的不正确索引\n\n报告以下错误：\n\n* 未解析的索引或负索引\n* 未闭合的大括号\n* 不成对的引号。 在这种情况下，模式的一部分可能不会被使用\n* 可能引号的数量不正确\n* 嵌套选择模式的下限不正确\n* 占位符索引不正确。 在这种情况下，不能替换占位符或不能使用实参\n\n示例：\n\n\n      MessageFormat.format(\"{wrong}\", 1); // 不正确的索引\n      MessageFormat.format(\"{0\", 1); // 不匹配的大括号\n      MessageFormat.format(\"'{0}\", 1); // 不成对的引号\n      MessageFormat.format(\"It''''s {0}\", 1); // 将打印\"It''s\"而非\"It's\"\n      MessageFormat.format(\"{0}\", 1, 2); // 模式中未使用索引为 '1' 的实参\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncorrectMessageFormat",
                    "cweIds": [
                      628,
                      707
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousTernaryOperatorInVarargsCall",
                "shortDescription": {
                  "text": "vararg 方法调用中的可疑三元运算符"
                },
                "fullDescription": {
                  "text": "报告使用具有混合数组分支和非数组分支的三元运算符的 vararg 方法调用。 编译时，两个分支都被包装在数组中。 结果，数组分支变成了二维数组，这可能说明有问题。 该快速修复会将非数组分支包装在数组中以防止编译器执行转换。 示例： 'static void bar(boolean flag) {\n        Object[] a = {1, 2};\n        Object b = \"hello\";\n        foo(flag ? a : b);\n    }\n    static void foo(Object... obj) {\n    }' 应用该快速修复后： 'static void bar(boolean flag) {\n        Object[] a = {1, 2};\n        Object b = \"hello\";\n        foo(flag ? a : new Object[]{b});\n    }\n    static void foo(Object... obj) {\n    }' 2020.3 最新变化 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告使用具有混合数组分支和非数组分支的三元运算符的 vararg 方法调用。\n\n\n编译时，两个分支都被包装在数组中。 结果，数组分支变成了二维数组，这可能说明有问题。\n\n\n该快速修复会将非数组分支包装在数组中以防止编译器执行转换。\n\n**示例：**\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : b);\n        }\n        static void foo(Object... obj) {\n        }\n\n应用该快速修复后：\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : new Object[]{b});\n        }\n        static void foo(Object... obj) {\n        }\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousTernaryOperatorInVarargsCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableInnerClassHasSerialVersionUIDField",
                "shortDescription": {
                  "text": "没有 'serialVersionUID' 的可序列化非 static 内部类"
                },
                "fullDescription": {
                  "text": "报告实现 'java.io.Serializable' 但不定义 'serialVersionUID' 字段的非 static 内部类。 如果没有 'serialVersionUID' 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。 强烈建议 'Serializable' 非 static 内部类包含 'serialVersionUID' 字段，否则由于合成访问器方法的差异，默认序列化算法可能导致编译器之间的序列化版本不兼容。 建议通过快速修复添加缺失的 'serialVersionUID' 字段。 示例： 'class Outer {\n      class Inner implements Serializable {}\n  }' 在应用快速修复后： 'class Outer {\n      class Inner implements Serializable {\n          private static final long serialVersionUID = -7004458730436243902L;\n      }\n  }' 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告实现 `java.io.Serializable` 但不定义 `serialVersionUID` 字段的非 static 内部类。\n\n\n如果没有 `serialVersionUID` 字段，对该类做出的任何更改都将导致以前序列化的版本不可读。 强烈建议 `Serializable` 非 static 内部类包含 `serialVersionUID` 字段，否则由于合成访问器方法的差异，默认序列化算法可能导致编译器之间的序列化版本不兼容。\n\n\n建议通过快速修复添加缺失的 `serialVersionUID` 字段。\n\n**示例：**\n\n\n      class Outer {\n          class Inner implements Serializable {}\n      }\n\n在应用快速修复后：\n\n\n      class Outer {\n          class Inner implements Serializable {\n              private static final long serialVersionUID = -7004458730436243902L;\n          }\n      }\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableNonStaticInnerClassWithoutSerialVersionUID",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterNameDiffersFromOverriddenParameter",
                "shortDescription": {
                  "text": "形参名称与重写或重载方法中的形参不同"
                },
                "fullDescription": {
                  "text": "报告名称与其重写或重载方法的相应形参不同的形参。 虽然在 Java 中是合法的，但这种不一致的名称可能令人困惑，并减少具有良好命名做法的文档优势。 示例： 'class Person {\n    Person(String fullName) {}\n  }\n  class Child extends Person {\n    Child(String name) { super(name); }\n  }' 在应用快速修复后： 'class Person {\n    Person(String fullName) {}\n  }\n  class Child extends Person {\n    Child(String fullName) { super(fullName); }\n  }' 使用选项可以指示是否忽略只有单个字符长度或来自库方法的重写的形参名称。 如果您不希望受到库中使用的可疑命名约定的约束，那么两者都会很有用。",
                  "markdown": "报告名称与其重写或重载方法的相应形参不同的形参。 虽然在 Java 中是合法的，但这种不一致的名称可能令人困惑，并减少具有良好命名做法的文档优势。\n\n**示例：**\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String name) { super(name); }\n      }\n\n在应用快速修复后：\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String fullName) { super(fullName); }\n      }\n\n\n使用选项可以指示是否忽略只有单个字符长度或来自库方法的重写的形参名称。 如果您不希望受到库中使用的可疑命名约定的约束，那么两者都会很有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterNameDiffersFromOverriddenParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OctalLiteral",
                "shortDescription": {
                  "text": "八进制整数"
                },
                "fullDescription": {
                  "text": "报告八进制整数文字。 某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。 示例： 'int i = 015;\n  int j = 0_777;' 此检查有两种不同的快速修复。 应用将八进制文字转换为十进制文字快速修复后，代码变为： 'int i = 13;\n  int j = 511;' 应用移除前导零以变为十进制快速修复后，代码变为： 'int i = 15;\n  int j = 777;'",
                  "markdown": "报告八进制整数文字。 某些编码标准禁止使用八进制文字，因为它们可能容易与十进制文字混淆。\n\n示例：\n\n\n      int i = 015;\n      int j = 0_777;\n\n此检查有两种不同的快速修复。\n应用**将八进制文字转换为十进制文字**快速修复后，代码变为：\n\n\n      int i = 13;\n      int j = 511;\n\n应用**移除前导零以变为十进制**快速修复后，代码变为：\n\n\n      int i = 15;\n      int j = 777;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OctalInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadWriteStringCanBeUsed",
                "shortDescription": {
                  "text": "可以使用 'Files.readString()' 或 'Files.writeString()'"
                },
                "fullDescription": {
                  "text": "报告使用 'java.nio.file.Files' 将 'String' 作为字节读取或写入的方法调用 此类调用可被替换为对 Java 11 中引入的 'Files.readString()' 或 'Files.writeString()' 方法的调用。 示例： 'String s = \"example\";\n  Files.write(Paths.get(\"out.txt\"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);\n  s = new String(Files.readAllBytes(Paths.get(\"in.txt\")), StandardCharsets.ISO_8859_1);' 在应用快速修复后： 'String s = \"example\";\n  Files.writeString(Paths.get(\"out.txt\"), s, StandardOpenOption.WRITE);\n  s = Files.readString(Paths.get(\"in.txt\"), StandardCharsets.ISO_8859_1);' 2018.3 最新变化",
                  "markdown": "报告使用 `java.nio.file.Files` 将 `String` 作为字节读取或写入的方法调用 此类调用可被替换为对 Java 11 中引入的 `Files.readString()` 或 `Files.writeString()` 方法的调用。\n\n**示例：**\n\n\n      String s = \"example\";\n      Files.write(Paths.get(\"out.txt\"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);\n      s = new String(Files.readAllBytes(Paths.get(\"in.txt\")), StandardCharsets.ISO_8859_1);\n\n在应用快速修复后：\n\n\n      String s = \"example\";\n      Files.writeString(Paths.get(\"out.txt\"), s, StandardOpenOption.WRITE);\n      s = Files.readString(Paths.get(\"in.txt\"), StandardCharsets.ISO_8859_1);\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReadWriteStringCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 11",
                      "index": 145,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclomaticComplexity",
                "shortDescription": {
                  "text": "过度复杂的方法"
                },
                "fullDescription": {
                  "text": "报告分支点过多的方法。 分支点是以下选项之一： 循环语句 'if' 语句 三元表达式 'catch' 部分 包含一个或多个 '&&' 或 '||' 运算符的表达式 具有非默认分支的 'switch' 块 循环复杂度过高的方法可能令人困惑且难以测试。 使用方法复杂度限制字段可指定一个方法允许的最大循环复杂度。",
                  "markdown": "报告分支点过多的方法。\n\n分支点是以下选项之一：\n\n* 循环语句\n* `if` 语句\n* 三元表达式\n* `catch` 部分\n* 包含一个或多个 `&&` 或 `||` 运算符的表达式\n* 具有非默认分支的 `switch` 块\n\n循环复杂度过高的方法可能令人困惑且难以测试。\n\n使用**方法复杂度限制**字段可指定一个方法允许的最大循环复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AwaitNotInLoop",
                "shortDescription": {
                  "text": "未在循环中调用的 'await()'"
                },
                "fullDescription": {
                  "text": "报告没有在循环中调用的 'java.util.concurrent.locks.Condition.await()'。 'await()' 和相关方法通常用于挂起线程，直到某个条件变为 true 为止。 线程可能出于不同原因而被唤醒，因此应在 'await()' 调用返回后检查条件。 使用循环很容易做到这一点。 示例： 'void acquire(Condition released) throws InterruptedException {\n    released.await();\n  }' 优良的代码应类似于： 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.await();\n    }\n  }'",
                  "markdown": "报告没有在循环中调用的 `java.util.concurrent.locks.Condition.await()`。\n\n\n`await()` 和相关方法通常用于挂起线程，直到某个条件变为 true 为止。\n线程可能出于不同原因而被唤醒，因此应在 `await()` 调用返回后检查条件。\n使用循环很容易做到这一点。\n\n**示例：**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        released.await();\n      }\n\n优良的代码应类似于：\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AwaitNotInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticVariableUninitializedUse",
                "shortDescription": {
                  "text": "static 字段在初始化前使用"
                },
                "fullDescription": {
                  "text": "报告在初始化之前读取的 'static' 变量。 该检查会忽略 'null' 的相等检查。 示例： 'class Foo {\n    public static int bar;\n\n    public static void main(String[] args) {\n      System.out.println(bar);\n    }\n  }' 请注意，此检查使用非常保守的数据流算法，并且可能会将 'static' 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在初始化之前读取的 `static` 变量。\n\n该检查会忽略 `null` 的相等检查。\n\n**示例：**\n\n\n      class Foo {\n        public static int bar;\n\n        public static void main(String[] args) {\n          System.out.println(bar);\n        }\n      }\n\n请注意，此检查使用非常保守的数据流算法，并且可能会将 `static` 变量错误地报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticVariableUsedBeforeInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclicClassDependency",
                "shortDescription": {
                  "text": "循环类依赖"
                },
                "fullDescription": {
                  "text": "报告相互依赖或循环依赖于其他类的类。 此类循环依赖项会使代码变得脆弱且难以维护。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告相互依赖或循环依赖于其他类的类。\n\n此类循环依赖项会使代码变得脆弱且难以维护。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CyclicClassDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 113,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferReplaceableByStringBuilder",
                "shortDescription": {
                  "text": "'StringBuffer' 可能是 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "报告声明为 'StringBuffer' 的变量，并建议将它们替换为 'StringBuilder'。 'StringBuilder' 是 'StringBuffer' 的非线程安全替换。 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告声明为 `StringBuffer` 的变量，并建议将它们替换为 `StringBuilder`。 `StringBuilder` 是 `StringBuffer` 的非线程安全替换。\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferMayBeStringBuilder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizedMethod",
                "shortDescription": {
                  "text": "'synchronized' 方法"
                },
                "fullDescription": {
                  "text": "报告方法上的 'synchronized' 修饰符。 对方法使用 'synchronized' 修饰符可能并非好主意，原因有几点： 在锁定的情况下应尽可能少地执行工作。 因此，通常最好使用 'synchronized' 块，只保留共享状态的代码。 同步成为方法接口的一部分。 这导致难以转换到不同的锁定机制。 跟踪锁定特定对象的内容变得更加困难。 在继承方法的类时，无论是有意还是无意进行的 DoS（拒绝服务）攻击都变得可行。 替代做法是考虑在 'private final' 锁定对象上同步，可以完全控制对该对象的访问。 可以通过快速修复使用 'synchronized(this)' 包装方法体。 示例： 'class Main {\n    public synchronized void fooBar() {\n    }\n  }' 在应用快速修复后： 'class Main {\n    public void fooBar() {\n      synchronized (this) {\n      }\n    }\n  }' 您可以为此检查配置以下选项： 包括原生方法 - 将原生方法纳入检查范围。 忽略重写 synchronized 方法的方法 - 不报告重写 'synchronized' 方法的方法。",
                  "markdown": "报告方法上的 `synchronized` 修饰符。\n\n\n对方法使用 `synchronized` 修饰符可能并非好主意，原因有几点：\n\n1. 在锁定的情况下应尽可能少地执行工作。 因此，通常最好使用 `synchronized` 块，只保留共享状态的代码。\n2. 同步成为方法接口的一部分。 这导致难以转换到不同的锁定机制。\n3. 跟踪锁定特定对象的内容变得更加困难。\n4. 在继承方法的类时，无论是有意还是无意进行的 DoS（拒绝服务）攻击都变得可行。\n\n\n替代做法是考虑在 `private final` 锁定对象上同步，可以完全控制对该对象的访问。\n\n可以通过快速修复使用 `synchronized(this)` 包装方法体。\n\n**示例：**\n\n\n      class Main {\n        public synchronized void fooBar() {\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        public void fooBar() {\n          synchronized (this) {\n          }\n        }\n      }\n\n您可以为此检查配置以下选项：\n\n1. **包括原生方法** - 将原生方法纳入检查范围。\n2. **忽略重写 synchronized 方法的方法** - 不报告重写 `synchronized` 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodWithMissingImplementations",
                "shortDescription": {
                  "text": "缺少实现的 abstract 方法"
                },
                "fullDescription": {
                  "text": "报告每个具体子类中没有实现的 'abstract' 方法。 这会导致子类发生编译时错误；该检查会报告 abstract 方法点处的问题，从而可以更快地检测出问题。",
                  "markdown": "报告每个具体子类中没有实现的 `abstract` 方法。\n\n\n这会导致子类发生编译时错误；该检查会报告 abstract 方法点处的问题，从而可以更快地检测出问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodWithMissingImplementations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2MethodRef",
                "shortDescription": {
                  "text": "lambda 可被替换为方法引用"
                },
                "fullDescription": {
                  "text": "报告可以替换为方法引用的 lambda。 方法引用比 lambda 更容易理解和阅读，尽管它们通常取决于您的喜好。 示例： 'Runnable r = () -> System.out.println();' 在应用快速修复后： 'Runnable r = System.out::println;' 即使 lambda 不调用任何方法，该检查也可能会建议方法引用，例如将 'obj -> obj != null' 替换为 'Objects::nonNull'。 使用设置 | 编辑器 | 代码样式 | Java | 代码生成设置来配置特殊方法引用。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为方法引用的 lambda。 方法引用比 lambda 更容易理解和阅读，尽管它们通常取决于您的喜好。\n\n示例：\n\n\n      Runnable r = () -> System.out.println();\n\n在应用快速修复后：\n\n\n      Runnable r = System.out::println;\n\n\n即使 lambda 不调用任何方法，该检查也可能会建议方法引用，例如将 `obj -> obj != null` 替换为 `Objects::nonNull`。\n使用[设置 \\| 编辑器 \\| 代码样式 \\| Java \\| 代码生成](settings://preferences.sourceCode.Java?Lambda%20Body)设置来配置特殊方法引用。\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2MethodRef",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryToStringCall",
                "shortDescription": {
                  "text": "对 'toString()' 的调用不必要"
                },
                "fullDescription": {
                  "text": "报告在以下情况下使用的 'toString()' 调用： 在字符串串联中 在 'java.lang.StringBuilder#append()' 或 'java.lang.StringBuffer#append()' 方法中 在 'java.io.PrintWriter' 或 'java.io.PrintStream' 的方法中 在 'org.slf4j.Logger' 的方法中 在这些情况下，转换为字符串将由底层库方法处理，不需要显式调用 'toString()'。 示例： 'System.out.println(this.toString())' 在应用快速修复后： 'System.out.println(this)' 请注意，没有 'toString()' 调用，代码语义可能会有所不同：如果表达式为 null，则将使用 'null' 字符串，而不是抛出 'NullPointerException'。 使用 仅在已知限定符为非 null 时报告 选项以避免对可能为 null 的值发出警告。",
                  "markdown": "报告在以下情况下使用的 `toString()` 调用：\n\n* 在字符串串联中\n* 在 `java.lang.StringBuilder#append()` 或 `java.lang.StringBuffer#append()` 方法中\n* 在 `java.io.PrintWriter` 或 `java.io.PrintStream` 的方法中\n* 在 `org.slf4j.Logger` 的方法中\n\n在这些情况下，转换为字符串将由底层库方法处理，不需要显式调用 `toString()`。\n\n示例：\n\n\n      System.out.println(this.toString())\n\n在应用快速修复后：\n\n\n      System.out.println(this)\n\n\n请注意，没有 `toString()` 调用，代码语义可能会有所不同：如果表达式为 null，则将使用 `null` 字符串，而不是抛出 `NullPointerException`。\n\n使用 **仅在已知限定符为非 null 时报告** 选项以避免对可能为 null 的值发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryToStringCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuppressionAnnotation",
                "shortDescription": {
                  "text": "检查禁止注解"
                },
                "fullDescription": {
                  "text": "报告禁止检查的注释或注解。 当有意保留禁止以供进一步检查时，此检查可能有用。 示例： '@SuppressWarnings(\"unused\")\nstatic Stream<String> stringProvider() {\n    return Stream.of(\"foo\", \"bar\");\n}'",
                  "markdown": "报告禁止检查的注释或注解。\n\n当有意保留禁止以供进一步检查时，此检查可能有用。\n\n**示例：**\n\n\n    @SuppressWarnings(\"unused\")\n    static Stream<String> stringProvider() {\n        return Stream.of(\"foo\", \"bar\");\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuppressionAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassOnlyUsedInOnePackage",
                "shortDescription": {
                  "text": "仅在其他软件包中使用的类"
                },
                "fullDescription": {
                  "text": "报告如下类：不依赖于其软件包中的任何其他类，而是依赖于其他软件包中的类，并且本身仅是此其他软件包中类的依赖项。 请考虑将这种类移到它们所依赖的软件包中。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告如下类：不依赖于其软件包中的任何其他类，而是依赖于其他软件包中的类，并且本身仅是此其他软件包中类的依赖项。 请考虑将这种类移到它们所依赖的软件包中。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassOnlyUsedInOnePackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 36,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnSeparatedFromComputation",
                "shortDescription": {
                  "text": "与结果计算分离的 'return'"
                },
                "fullDescription": {
                  "text": "报告返回局部变量的 'return' 语句，其中变量的值在同一方法中的其他位置计算。 快速修复通过将 return 语句移动到计算变量值的位置来内联返回的变量。 当返回值无法内联到 'return' 语句中时，快速修复尝试将 return 语句移动到尽可能接近计算的返回值的位置。 示例： 'int n = -1;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] == b) {\n      n = i;\n      break;\n    }\n  }\n  return n;' 在应用快速修复后： 'int n = -1;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] == b) {\n      return i;\n    }\n  }\n  return n;'",
                  "markdown": "报告返回局部变量的 `return` 语句，其中变量的值在同一方法中的其他位置计算。\n\n快速修复通过将 return 语句移动到计算变量值的位置来内联返回的变量。\n当返回值无法内联到 `return` 语句中时，快速修复尝试将 return 语句移动到尽可能接近计算的返回值的位置。\n\n示例：\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          n = i;\n          break;\n        }\n      }\n      return n;\n\n在应用快速修复后：\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          return i;\n        }\n      }\n      return n;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReturnSeparatedFromComputation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnNonFinalField",
                "shortDescription": {
                  "text": "在非 final 字段上同步"
                },
                "fullDescription": {
                  "text": "报告由非 'final' 字段引用组成的 'synchronized' 语句锁定表达式。 此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象上操作时也可能获取不同的锁定。 示例： 'private Object o;\n  public void foo() {\n    synchronized (o) // 在非 final 字段上同步\n    { }\n  }'",
                  "markdown": "报告由非 `final` 字段引用组成的 `synchronized` 语句锁定表达式。 此类语句不太可能包含有用的语义，因为不同的线程即便在对同一对象上操作时也可能获取不同的锁定。\n\n**示例：**\n\n\n      private Object o;\n      public void foo() {\n        synchronized (o) // 在非 final 字段上同步\n        { }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizeOnNonFinalField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayObjectsEquals",
                "shortDescription": {
                  "text": "对数组使用浅层方法或 'Objects' 方法"
                },
                "fullDescription": {
                  "text": "报告似乎使用不当方法来确定数组相等性或计算其哈希代码的表达式。 报告的方法调用如下： 针对任何数组，报告 'Object.equals()' 针对多维数组，报告 'Arrays.equals()' 针对多维数组，报告 'Arrays.hashCode()'",
                  "markdown": "报告似乎使用不当方法来确定数组相等性或计算其哈希代码的表达式。\n\n报告的方法调用如下：\n\n* 针对任何数组，报告 `Object.equals()`\n* 针对多维数组，报告 `Arrays.equals()`\n* 针对多维数组，报告 `Arrays.hashCode()`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayObjectsEquals",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsWhichDoesntCheckParameterClass",
                "shortDescription": {
                  "text": "不检查形参的类的 'equals()' 方法"
                },
                "fullDescription": {
                  "text": "报告不检查其形参类型的 'equals()' 方法。 无法检查 'equals()' 方法中形参的类型时，如果在无类型集合中使用该对象，可能会导致潜在错误。 示例： 'class MyClass {\n    int x;\n\n    @Override\n    public boolean equals(Object obj) {\n      // 如果 obj 不为 MyClass，equals 方法应返回 false\n      return ((MyClass)obj).x == x;\n    }\n  }'",
                  "markdown": "报告不检查其形参类型的 `equals()` 方法。\n\n无法检查 `equals()` 方法中形参的类型时，如果在无类型集合中使用该对象，可能会导致潜在错误。\n\n**示例：**\n\n\n      class MyClass {\n        int x;\n\n        @Override\n        public boolean equals(Object obj) {\n          // 如果 obj 不为 MyClass，equals 方法应返回 false\n          return ((MyClass)obj).x == x;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsWhichDoesntCheckParameterClass",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseHashCodeMethodInspection",
                "shortDescription": {
                  "text": "可以使用标准 'hashCode()' 方法"
                },
                "fullDescription": {
                  "text": "报告可以替换为对 'Long.hashCode()' 或 'Double.hashCode()' 方法的调用的按位操作。 它会检测结构 '(int)(x ^ (x >>> 32))'，其中 'x' 是类型为 'long' 的变量，或者是前一个 'Double.doubleToLongBits()' 调用的结果。 此替换可以缩短代码，提高代码的可读性。 示例： 'int result = (int)(var ^ (var >>> 32));' 应用快速修复后： 'int result = Long.hashCode(var);' 仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。 2024.1 最新变化",
                  "markdown": "报告可以替换为对 `Long.hashCode()` 或 `Double.hashCode()` 方法的调用的按位操作。 它会检测结构 `(int)(x ^ (x >>> 32))`，其中 `x` 是类型为 `long` 的变量，或者是前一个 `Double.doubleToLongBits()` 调用的结果。 此替换可以缩短代码，提高代码的可读性。\n\n**示例：**\n\n\n      int result = (int)(var ^ (var >>> 32));\n\n应用快速修复后：\n\n\n      int result = Long.hashCode(var);\n\n仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseHashCodeMethodInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToSuperclassField",
                "shortDescription": {
                  "text": "构造函数将值赋给在超类中定义的字段"
                },
                "fullDescription": {
                  "text": "报告对超类中从子类构造函数中声明的字段的赋值或修改。 最好在其自己的构造函数中初始化超类的字段，并在子类中委托给该构造函数。 如果它在构造后没有改变，这还将允许声明一个字段 'final'。 示例： 'class Super {\n    int x;\n  }\n  class Sub extends Super {\n    Sub(int _x) {\n      // Warning: x is declared in a superclass\n      x = _x;\n    }\n  }' 要避免此问题，请声明超类构造函数： 'class Super {\n    final int x;\n\n    Super(int _x) {\n      x = _x;\n    }\n  }\n  class Sub extends Super {\n    Sub(int _x) {\n      super(_x);\n    }\n  }'",
                  "markdown": "报告对超类中从子类构造函数中声明的字段的赋值或修改。\n\n最好在其自己的构造函数中初始化超类的字段，并在子类中委托给该构造函数。 如果它在构造后没有改变，这还将允许声明一个字段 `final`。\n\n**示例：**\n\n\n      class Super {\n        int x;\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          // Warning: x is declared in a superclass\n          x = _x;\n        }\n      }\n\n要避免此问题，请声明超类构造函数：\n\n\n      class Super {\n        final int x;\n\n        Super(int _x) {\n          x = _x;\n        }\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          super(_x);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToSuperclassField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousIndentAfterControlStatement",
                "shortDescription": {
                  "text": "没有大括号的控制语句后存在可疑缩进"
                },
                "fullDescription": {
                  "text": "报告不带大括号控制语句后面的语句的可疑缩进。 进行此类缩进时，语句看似在控制语句内部，其实它将在控制语句后无条件地执行。 示例： 'class Bar {\n      void foo(int i) {\n          if (i == 0)\n              System.out.println(\"foo\");\n              System.out.println(\"bar\"); // 警告\n          if (i == 1);\n              System.out.println(\"great\"); // 警告\n          if (i == 42)\n              System.out.println(\"answer\");\n                  System.out.println(\"question\"); // 警告\n      }\n  }'",
                  "markdown": "报告不带大括号控制语句后面的语句的可疑缩进。\n\n\n进行此类缩进时，语句看似在控制语句内部，其实它将在控制语句后无条件地执行。\n\n**示例：**\n\n\n      class Bar {\n          void foo(int i) {\n              if (i == 0)\n                  System.out.println(\"foo\");\n                  System.out.println(\"bar\"); // 警告\n              if (i == 1);\n                  System.out.println(\"great\"); // 警告\n              if (i == 42)\n                  System.out.println(\"answer\");\n                      System.out.println(\"question\"); // 警告\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousIndentAfterControlStatement",
                    "cweIds": [
                      483
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumericOverflow",
                "shortDescription": {
                  "text": "数值溢出"
                },
                "fullDescription": {
                  "text": "报告计算过程中溢出的表达式。 通常是意外发生这种情况，并且表明存在错误。 例如，使用了错误的类型或应当反方向移位。 示例： 'float a = 1.0f/0.0f;\n  long b = 30 * 24 * 60 * 60 * 1000;\n  long c = 1000L << 62;'",
                  "markdown": "报告计算过程中溢出的表达式。 通常是意外发生这种情况，并且表明存在错误。 例如，使用了错误的类型或应当反方向移位。\n\n**示例：**\n\n\n      float a = 1.0f/0.0f;\n      long b = 30 * 24 * 60 * 60 * 1000;\n      long c = 1000L << 62;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumericOverflow",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNewInstance",
                "shortDescription": {
                  "text": "对 'Class.newInstance()' 的调用不安全"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.Class.newInstance()' 的调用。 此方法会传播由无实参构造函数抛出的异常，包括已检查的异常。 使用此方法可以有效地绕过本由编译器执行的编译时异常检查。 建议通过快速修复将该调用替换为对 'java.lang.reflect.Constructor.newInstance()' 方法的调用，这种方式将构造函数抛出的任何异常包装在（已检查的）'java.lang.reflect.InvocationTargetException' 中，从而可以避免这个问题。 示例： 'clazz.newInstance()' 在应用快速修复后： 'clazz.getConstructor().newInstance();'",
                  "markdown": "报告对 `java.lang.Class.newInstance()` 的调用。\n\n\n此方法会传播由无实参构造函数抛出的异常，包括已检查的异常。 使用此方法可以有效地绕过本由编译器执行的编译时异常检查。\n\n\n建议通过快速修复将该调用替换为对 `java.lang.reflect.Constructor.newInstance()` 方法的调用，这种方式将构造函数抛出的任何异常包装在（已检查的）`java.lang.reflect.InvocationTargetException` 中，从而可以避免这个问题。\n\n**示例：**\n\n\n      clazz.newInstance()\n\n在应用快速修复后：\n\n\n      clazz.getConstructor().newInstance();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNewInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LimitedScopeInnerClass",
                "shortDescription": {
                  "text": "局部类"
                },
                "fullDescription": {
                  "text": "报告本地类。 本地类是指在代码块中声明的命名嵌套类。 本地类不常见，因此可能令人困惑。 此外，有些代码标准不建议使用本地类。 示例： 'class Example {\n    void test() {\n      class Local { // 这里\n      }\n      new Local();\n    }\n  }' 在应用快速修复后： 'class Example {\n    void test() {\n      new Local();\n    }\n\n    private static class Local { // 这里\n    }\n  }'",
                  "markdown": "报告本地类。\n\n本地类是指在代码块中声明的命名嵌套类。\n本地类不常见，因此可能令人困惑。\n此外，有些代码标准不建议使用本地类。\n\n**示例：**\n\n\n      class Example {\n        void test() {\n          class Local { // 这里\n          }\n          new Local();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example {\n        void test() {\n          new Local();\n        }\n\n        private static class Local { // 这里\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LimitedScopeInnerClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultiplyOrDivideByPowerOfTwo",
                "shortDescription": {
                  "text": "乘以或除以 2 的幂"
                },
                "fullDescription": {
                  "text": "报告整数值与可表示为 2 的幂的常量整数的乘积。 此类表达式可以替换为右移或左移运算，以提高性能。 请注意，此检查与现代 JVM（例如 HotSpot 或 OpenJ9）无关，因为它们的 JIT 编译器将执行此优化。 它可能只在一些不执行 JIT 编译的嵌入式系统中有用。 示例： 'int y = x * 4;' 建议通过快速修复将乘法或除法运算替换为移位运算： 'int y = x << 2;' 使用该选项可使检查也报告二次幂除法。 请注意，用移位替换二次幂除法不适用于负数。",
                  "markdown": "报告整数值与可表示为 2 的幂的常量整数的乘积。 此类表达式可以替换为右移或左移运算，以提高性能。\n\n\n请注意，此检查与现代 JVM（例如 HotSpot 或 OpenJ9）无关，因为它们的 JIT 编译器将执行此优化。\n它可能只在一些不执行 JIT 编译的嵌入式系统中有用。\n\n**示例：**\n\n\n      int y = x * 4;\n\n建议通过快速修复将乘法或除法运算替换为移位运算：\n\n\n      int y = x << 2;\n\n\n使用该选项可使检查也报告二次幂除法。\n请注意，用移位替换二次幂除法不适用于负数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MultiplyOrDivideByPowerOfTwo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCallInLoopCondition",
                "shortDescription": {
                  "text": "循环条件下的方法调用"
                },
                "fullDescription": {
                  "text": "报告循环语句条件部分中的方法调用。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 此检查适用于 Java ME 和其他资源高度受限的环境。 示例： 'String s = \"example\";\n  for (int i = 0; i < s.length(); i++) {\n    System.out.println(s.charAt(i));\n  }' 在应用快速修复后： 'String s = \"example\";\n  int length = s.length();\n  for (int i = 0; i < length; i++) {\n    System.out.println(s.charAt(i));\n  }' 使用该选项可以忽略对常见 Java 迭代方法（例如 'Iterator.hasNext()'）和具有副作用的已知方法（例如 'Atomic*.compareAndSet'）的调用。",
                  "markdown": "报告循环语句条件部分中的方法调用。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。\n\n\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n此检查适用于 Java ME 和其他资源高度受限的环境。\n\n**示例：**\n\n\n      String s = \"example\";\n      for (int i = 0; i < s.length(); i++) {\n        System.out.println(s.charAt(i));\n      }\n\n在应用快速修复后：\n\n\n      String s = \"example\";\n      int length = s.length();\n      for (int i = 0; i < length; i++) {\n        System.out.println(s.charAt(i));\n      }\n\n\n使用该选项可以忽略对常见 Java 迭代方法（例如 `Iterator.hasNext()`）和具有副作用的已知方法（例如 `Atomic*.compareAndSet`）的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodCallInLoopCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopReplaceableByWhile",
                "shortDescription": {
                  "text": "'for' 循环可被替换为 'while' 循环"
                },
                "fullDescription": {
                  "text": "报告不包含初始化和更新组件的 'for' 循环，并建议将它们转换为 'while' 循环。 这使代码更易于阅读。 示例： 'for(; exitCondition(); ) {\n    process();\n  }' 在应用快速修复后： 'while(exitCondition()) {\n    process();\n  }' 快速修复也可用于其他 'for' 循环，因此您可以用 'while' 循环替换任何 'for' 循环。 如果您想忽略具有不重要或不存在条件的 'for' 循环，使用 忽略无条件的 'infinite' for 循环 选项。",
                  "markdown": "报告不包含初始化和更新组件的 `for` 循环，并建议将它们转换为 `while` 循环。 这使代码更易于阅读。\n\n示例：\n\n\n      for(; exitCondition(); ) {\n        process();\n      }\n\n在应用快速修复后：\n\n\n      while(exitCondition()) {\n        process();\n      }\n\n快速修复也可用于其他 `for` 循环，因此您可以用 `while` 循环替换任何 `for` 循环。\n\n如果您想忽略具有不重要或不存在条件的 `for` 循环，使用 **忽略无条件的 'infinite' for 循环** 选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopReplaceableByWhile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCount",
                "shortDescription": {
                  "text": "方法过多的类"
                },
                "fullDescription": {
                  "text": "报告方法数超过指定最大值的类。 具有太多方法的类通常会试图“进行过多处理”。 请考虑将这种类拆分为多个较小的类。 配置检查： 使用方法计数限制字段可指定类中允许的最大方法数。 使用忽略简单的 getter 和 setter 方法选项可忽略方法计数中的简单 getter 和 setter。 使用忽略重写/实现 super 方法的方法可忽略重写或实现 super 类方法的方法。",
                  "markdown": "报告方法数超过指定最大值的类。\n\n具有太多方法的类通常会试图\"进行过多处理\"。 请考虑将这种类拆分为多个较小的类。\n\n配置检查：\n\n* 使用**方法计数限制**字段可指定类中允许的最大方法数。\n* 使用**忽略简单的 getter 和 setter 方法**选项可忽略方法计数中的简单 getter 和 setter。\n* 使用**忽略重写/实现 super 方法的方法**可忽略重写或实现 super 类方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticFieldReferenceOnSubclass",
                "shortDescription": {
                  "text": "static 字段通过子类引用"
                },
                "fullDescription": {
                  "text": "报告对其中的调用由声明类的子类而不是由声明类本身限定的 static 字段的访问。 Java 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。 示例： 'class Parent {\n    static int foo = 0;\n  }\n\n  class Child extends Parent { }\n\n  void bar() {\n    System.out.println(Child.foo);\n  }' 应用快速修复后，结果如下所示： 'class Parent {\n    static int foo = 0;\n  }\n\n  class Child extends Parent { }\n\n  void bar() {\n    System.out.println(Parent.foo);\n  }'",
                  "markdown": "报告对其中的调用由声明类的子类而不是由声明类本身限定的 static 字段的访问。\n\n\nJava 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。\n\n**示例：**\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Child.foo);\n      }\n\n应用快速修复后，结果如下所示：\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Parent.foo);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticFieldReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BlockingMethodInNonBlockingContext",
                "shortDescription": {
                  "text": "可能在非阻塞上下文中使用阻塞调用"
                },
                "fullDescription": {
                  "text": "报告不应阻塞线程的代码段中的线程阻塞方法调用。 示例（项目 Reactor）： 'Flux.just(\"1\").flatMap(f -> {\n    Flux<String> just = loadUsersFromDatabase();\n    just.toIterable(); // 错误：在非阻塞范围内调用阻塞运算符\n    return just;\n  }\n);' 考虑使用适当的计划程序（例如 'Schedulers.boundedElastic()'）运行阻塞代码，或者尝试寻找替代的非阻塞 API。 示例（Kotlin 协程）： 'suspend fun exampleFun() {\n    Thread.sleep(100); // 错误：在挂起函数中调用阻塞方法\n}' 考虑使用特殊调度程序（例如 'Dispatchers.IO'）运行阻塞代码，或尝试寻找替代的非阻塞 API。 配置检查： 在阻塞注解列表中，指定标记线程阻塞方法的注解。 在无阻塞注解列表中，指定标记非阻塞方法的注解。 指定的注解可用作外部注解",
                  "markdown": "报告不应阻塞线程的代码段中的线程阻塞方法调用。\n\n**示例（项目 Reactor）：**\n\n\n    Flux.just(\"1\").flatMap(f -> {\n        Flux<String> just = loadUsersFromDatabase();\n        just.toIterable(); // 错误：在非阻塞范围内调用阻塞运算符\n        return just;\n      }\n    );\n\n考虑使用[适当的计划程序](https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking)（例如 `Schedulers.boundedElastic()`）运行阻塞代码，或者尝试寻找替代的非阻塞 API。\n\n**示例（Kotlin 协程）：**\n\n\n    suspend fun exampleFun() {\n        Thread.sleep(100); // 错误：在挂起函数中调用阻塞方法\n    }\n\n考虑[使用特殊调度程序](https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html)（例如 `Dispatchers.IO`）运行阻塞代码，或尝试寻找替代的非阻塞 API。\n\n配置检查：\n\n* 在**阻塞注解**列表中，指定标记线程阻塞方法的注解。\n* 在**无阻塞注解**列表中，指定标记非阻塞方法的注解。\n\n指定的注解可用作[外部注解](https://www.jetbrains.com/help/idea/external-annotations.html)"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BlockingMethodInNonBlockingContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoreResultOfCall",
                "shortDescription": {
                  "text": "方法调用的结果已忽略"
                },
                "fullDescription": {
                  "text": "报告其结果被忽略的方法调用。 忽略结果对于许多方法完全合法，但对于某些方法，几乎肯定是错误。 忽略结果可能是错误之举的方法示例包括返回实际读取字节数的 'java.io.inputStream.read()'，以及 'java.lang.String' 或 'java.math.BigInteger' 上的任何方法。 这些方法不会产生副作用，因此忽略它们的结果将毫无意义。 将检查对以下方法的调用： 简单 getter（除返回字段外别无他用） 在此检查的设置中指定的方法 使用 'org.jetbrains.annotations.Contract(pure=true)' 注解的方法 使用 .*.'CheckReturnValue' 注解的方法 使用 'javax.annotation.CheckReturnValue' 注解的类或软件包中的方法 所有非库方法（可选） 不会报告对使用 Error Prone 或 AssertJ 的 '@CanIgnoreReturnValue' 注解进行注解的方法的调用。 使用检查设置指定要检查的类。 方法采用 Java 正则表达式语法按名称或名称模式进行匹配。 对于类，请使用完全限定名称。 每个条目都应用于该类及其所有继承者。",
                  "markdown": "报告其结果被忽略的方法调用。\n\n忽略结果对于许多方法完全合法，但对于某些方法，几乎肯定是错误。 忽略结果可能是错误之举的方法示例包括返回实际读取字节数的 `java.io.inputStream.read()`，以及 `java.lang.String` 或 `java.math.BigInteger` 上的任何方法。 这些方法不会产生副作用，因此忽略它们的结果将毫无意义。\n\n将检查对以下方法的调用：\n\n* 简单 getter（除返回字段外别无他用）\n* 在此检查的设置中指定的方法\n* 使用 `org.jetbrains.annotations.Contract(pure=true)` 注解的方法\n* 使用 .\\*.`CheckReturnValue` 注解的方法\n* 使用 `javax.annotation.CheckReturnValue` 注解的类或软件包中的方法\n* 所有非库方法（可选）\n\n不会报告对使用 Error Prone 或 AssertJ 的 `@CanIgnoreReturnValue` 注解进行注解的方法的调用。\n\n\n使用检查设置指定要检查的类。\n方法采用 Java 正则表达式语法按名称或名称模式进行匹配。\n对于类，请使用完全限定名称。 每个条目都应用于该类及其所有继承者。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ResultOfMethodCallIgnored",
                    "cweIds": [
                      252,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "'assertEquals()' 位于不可转换类型的对象之间"
                },
                "fullDescription": {
                  "text": "报告“预期”实参和“实际”实参的类型不兼容时对断言方法的调用。 此类调用通常表明测试中存在错误。 该检查会检查相关的 JUnit、TestNG 和 AssertJ 方法。 示例： 'assertEquals(\"1\", 1);\n  assertNotSame(new int[0], 0);\n\n  // 弱警告，可能只测试 equals() 约定\n  assertThat(foo).as(\"user type\").isNotEqualTo(bar);'",
                  "markdown": "报告\"预期\"实参和\"实际\"实参的类型不兼容时对断言方法的调用。\n\n此类调用通常表明测试中存在错误。\n该检查会检查相关的 JUnit、TestNG 和 AssertJ 方法。\n\n**示例：**\n\n\n      assertEquals(\"1\", 1);\n      assertNotSame(new int[0], 0);\n\n      // 弱警告，可能只测试 equals() 约定\n      assertThat(foo).as(\"user type\").isNotEqualTo(bar);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchExpressionCanBePushedDown",
                "shortDescription": {
                  "text": "可以从 'switch' 中提取通用子表达式"
                },
                "fullDescription": {
                  "text": "报告每个分支都有通用子表达式，因此 switch 可以移动到内部的 'switch' 表达式和语句。 此操作会缩短代码。 在许多情况下，将得到的 switch 表达式提取到单独的变量或方法是合理的。 示例： 'switch (value) {\n    case 0 -> System.out.println(\"zero\");\n    case 1 -> System.out.println(\"one\");\n    case 2, 3, 4 -> System.out.println(\"few\");\n    default -> System.out.println(\"many\");\n  }' 在应用快速修复后： 'System.out.println(switch (value) {\n    case 0 -> \"zero\";\n    case 1 -> \"one\";\n    case 2, 3, 4 -> \"few\";\n    default -> \"many\";\n  });' 此检查仅适用于采用箭头语法的增强 switch。 2022.3 最新变化 此检查取决于 Java 功能 ''switch' 表达式'，该功能自 Java 14 起可用。",
                  "markdown": "报告每个分支都有通用子表达式，因此 switch 可以移动到内部的 `switch` 表达式和语句。 此操作会缩短代码。 在许多情况下，将得到的 switch 表达式提取到单独的变量或方法是合理的。\n\n示例：\n\n\n      switch (value) {\n        case 0 -> System.out.println(\"zero\");\n        case 1 -> System.out.println(\"one\");\n        case 2, 3, 4 -> System.out.println(\"few\");\n        default -> System.out.println(\"many\");\n      }\n\n在应用快速修复后：\n\n\n      System.out.println(switch (value) {\n        case 0 -> \"zero\";\n        case 1 -> \"one\";\n        case 2, 3, 4 -> \"few\";\n        default -> \"many\";\n      });\n\n\n此检查仅适用于采用箭头语法的增强 switch。\n\n2022.3 最新变化\n\n此检查取决于 Java 功能 ''switch' 表达式'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchExpressionCanBePushedDown",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassReferencedViaSubclass",
                "shortDescription": {
                  "text": "通过子类引用的内部类"
                },
                "fullDescription": {
                  "text": "报告对其中的调用由声明类的子类而不是声明类本身限定的内部类和嵌套类的访问。 Java 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。 示例： 'class Super {\n    static class Inner {}\n  }\n\n  class Sub extends Super {\n    void test() {\n      Sub.Inner s = new Sub.Inner(); // 'Inner' 类在 'Super' 类中声明，但通过 'Sub' 类引用\n    }\n  }' 在应用快速修复后： 'class Super {\n    static class Inner {}\n  }\n\n  class Sub extends Super {\n    void test() {\n      Super.Inner s = new Super.Inner();\n    }\n  }'",
                  "markdown": "报告对其中的调用由声明类的子类而不是声明类本身限定的内部类和嵌套类的访问。\n\n\nJava 允许此类限定，但是此类访问可能表明继承和重写之间存在难以捉摸的混淆。\n\n**示例：**\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Sub.Inner s = new Sub.Inner(); // 'Inner' 类在 'Super' 类中声明，但通过 'Sub' 类引用\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Super.Inner s = new Super.Inner();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingElse",
                "shortDescription": {
                  "text": "冗余的 'else'"
                },
                "fullDescription": {
                  "text": "在 'if'—'else' 语句和语句链中报告冗余的 'else' 关键字。 当所有之前的分支以 'return'、'throw'、'break' 或 'continue' 语句结尾时，'else' 关键字冗余。 在这种情况下，来自 'else' 分支的语句可以放在 'if' 语句之后，并且 'else' 关键字可以删除。 示例： 'if (name == null) {\n      throw new IllegalArgumentException();\n  } else {\n      System.out.println(name);\n  }' 在应用快速修复后： 'if (name == null) {\n      throw new IllegalArgumentException();\n  }\n  System.out.println(name);' 禁用当 'if' 语句之后没有其他语句时报告选项，以忽略 'if'—'else' 语句是代码块中最后一条语句的情况。",
                  "markdown": "在 `if`---`else` 语句和语句链中报告冗余的 `else` 关键字。\n\n\n当所有之前的分支以 `return`、`throw`、`break` 或 `continue` 语句结尾时，`else` 关键字冗余。 在这种情况下，来自 `else` 分支的语句可以放在 `if` 语句之后，并且 `else` 关键字可以删除。\n\n**示例：**\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      } else {\n          System.out.println(name);\n      }\n\n在应用快速修复后：\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      }\n      System.out.println(name);\n\n禁用**当 'if' 语句之后没有其他语句时报告** 选项，以忽略 `if`---`else` 语句是代码块中最后一条语句的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConfusingElseBranch",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ScheduledThreadPoolExecutorWithZeroCoreThreads",
                "shortDescription": {
                  "text": "带零个核心线程的 'ScheduledThreadPoolExecutor'"
                },
                "fullDescription": {
                  "text": "报告任何通过 'setCorePoolSize' 方法或对象构造函数将 'corePoolSize' 设置为零的 'java.util.concurrent.ScheduledThreadPoolExecutor' 实例。 无核心线程的 'ScheduledThreadPoolExecutor' 不运行任何内容。 示例： 'void foo(int corePoolSize) {\n      if (corePoolSize != 0) return;\n      ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 警告\n      executor.setCorePoolSize(corePoolSize); // 警告\n  }'",
                  "markdown": "报告任何通过 `setCorePoolSize` 方法或对象构造函数将 `corePoolSize` 设置为零的 `java.util.concurrent.ScheduledThreadPoolExecutor` 实例。\n\n\n无核心线程的 `ScheduledThreadPoolExecutor` 不运行任何内容。\n\n**示例：**\n\n\n      void foo(int corePoolSize) {\n          if (corePoolSize != 0) return;\n          ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // 警告\n          executor.setCorePoolSize(corePoolSize); // 警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ScheduledThreadPoolExecutorWithZeroCoreThreads",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChannelResource",
                "shortDescription": {
                  "text": "打开了 'Channel'，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 'Channel' 资源，包括任何通过在文件或套接字资源上调用 'getChannel()' 而创建的实例。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'void send(Socket socket) throws IOException {\n    SocketChannel channel = socket.getChannel(); //警告\n    channel.write(ByteBuffer.wrap(\"message\".getBytes()));\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 'Channel' 资源。 这种样式不太合意，因为它比在 'try' 块前面打开 'Channel' 更复杂。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 `Channel` 资源，包括任何通过在文件或套接字资源上调用 `getChannel()` 而创建的实例。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      void send(Socket socket) throws IOException {\n        SocketChannel channel = socket.getChannel(); //警告\n        channel.write(ByteBuffer.wrap(\"message\".getBytes()));\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 `Channel` 资源。 这种样式不太合意，因为它比在 `try` 块前面打开 `Channel` 更复杂。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChannelOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaEmptyModuleInfoFile",
                "shortDescription": {
                  "text": "空的 'module-info.java' 文件"
                },
                "fullDescription": {
                  "text": "报告空的 'module-info.java' 文件，指示未解析的模块依赖项。 通过检查导入自动添加必要的 'requires' 语句。 要取消显示此警告，您可以在模块语句主体中写入任何注释，如下所示： 'module module.name {\n    // 无依赖项\n}' 快速修复： 填充模块依赖项会基于源代码导入填充缺少的 'requires'。 2024.1 最新变化",
                  "markdown": "报告空的 `module-info.java` 文件，指示未解析的模块依赖项。 通过检查导入自动添加必要的 `requires` 语句。 要取消显示此警告，您可以在模块语句主体中写入任何注释，如下所示：\n\n\n    module module.name {\n        // 无依赖项\n    }\n\n**快速修复：** *填充模块依赖项* 会基于源代码导入填充缺少的 `requires`。 2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaEmptyModuleInfoFile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassMayBeInterface",
                "shortDescription": {
                  "text": "'abstract' 类可以是 'interface'"
                },
                "fullDescription": {
                  "text": "报告可以转换为接口的 'abstract' 类。 最好使用接口而不是类，因为 Java 不支持多类继承，而一个类可以实现多个接口。 如果一个类没有超类（Object 以外）、只有 'public static final' 字段、'public abstract' 方法和 'public' 内部类，则可以将其转换为接口。 示例： 'abstract class Example {\n    public static final int MY_CONST = 42;\n    public abstract void foo();\n}\n\nclass Inheritor extends Example {\n    @Override\n    public void foo() {\n        System.out.println(MY_CONST);\n    }\n}' 在应用快速修复后： 'interface Example {\n    int MY_CONST = 42;\n    void foo();\n}\n\nclass Inheritor implements Example {\n    @Override\n    public void foo() {\n        System.out.println(MY_CONST);\n    }\n}' 配置检查： 使用 Java 8 时报告包含非 abstract 方法的类 选项可用于仅报告其 'static' 和非 abstract 方法可以转换为 'default' 方法的类（仅适用于语言级别为 8 或更高时）。",
                  "markdown": "报告可以转换为接口的 `abstract` 类。\n\n最好使用接口而不是类，因为 Java 不支持多类继承，而一个类可以实现多个接口。\n\n如果一个类没有超类（Object 以外）、只有 `public static final` 字段、`public abstract` 方法和 `public` 内部类，则可以将其转换为接口。\n\n\n示例：\n\n\n    abstract class Example {\n        public static final int MY_CONST = 42;\n        public abstract void foo();\n    }\n\n    class Inheritor extends Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\n在应用快速修复后：\n\n\n    interface Example {\n        int MY_CONST = 42;\n        void foo();\n    }\n\n    class Inheritor implements Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\n配置检查：\n\n\n**使用 Java 8 时报告包含非 abstract 方法的类** 选项可用于仅报告其 `static` 和非 abstract 方法可以转换为 `default` 方法的类（仅适用于语言级别为 8 或更高时）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassMayBeInterface",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryCallToStringValueOf",
                "shortDescription": {
                  "text": "到 'String' 的不必要转换"
                },
                "fullDescription": {
                  "text": "报告对将其形参转换为字符串的 static 方法（例如 'String.valueOf()' 或 'Integer.toString()'）的不必要调用。 在字符串串联中使用时，此类调用是不必要的。 示例： 'System.out.println(\"Number: \" + Integer.toString(count));' 在应用快速修复后： 'System.out.println(\"Number: \" + count);' 此外，用作进行自身字符串转换的库方法的实参时，此类调用是不必要的。 一些进行自身字符串转换的库方法的示例如下： 类 'java.io.PrintWriter', 'java.io.PrintStream' 'print()', 'println()' 类 'java.lang.StringBuilder', 'java.lang.StringBuffer' 'append()' 类 'org.slf4j.Logger' 'trace()', 'debug()', 'info()', 'warn()', 'error()' 使用报告可被替换为带空字符串的串联的调用选项还可以报告可使用带空字符串的串联代替 'String.valueOf()' 调用的情况。",
                  "markdown": "报告对将其形参转换为字符串的 static 方法（例如 `String.valueOf()` 或 `Integer.toString()`）的不必要调用。 在字符串串联中使用时，此类调用是不必要的。\n\n示例：\n\n\n      System.out.println(\"Number: \" + Integer.toString(count));\n\n在应用快速修复后：\n\n\n      System.out.println(\"Number: \" + count);\n\n此外，用作进行自身字符串转换的库方法的实参时，此类调用是不必要的。 一些进行自身字符串转换的库方法的示例如下：\n\n* 类 `java.io.PrintWriter`, `java.io.PrintStream`\n  * `print()`, `println()`\n* 类 `java.lang.StringBuilder`, `java.lang.StringBuffer`\n  * `append()`\n* 类 `org.slf4j.Logger`\n  * `trace()`, `debug()`, `info()`, `warn()`, `error()`\n\n\n使用**报告可被替换为带空字符串的串联的调用** 选项还可以报告可使用带空字符串的串联代替 `String.valueOf()` 调用的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCallToStringValueOf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringReplaceableByStringBuffer",
                "shortDescription": {
                  "text": "非常量 'String' 可被替换为 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "报告被声明为 'java.lang.String' 且重复追加的变量。 此类变量可以更有效地被声明为 'java.lang.StringBuffer' 或 'java.lang.StringBuilder'。 示例： 'String s = \"\";\n  for (int i = 0; i < names.length; i++) {\n    String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n    s = s + name;\n  }' 此类循环可以替换为： 'StringBuilder s = new StringBuilder();\n  for (int i = 0; i < names.length; i++) {\n    String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n    s.append(name);\n  }' 或者甚至可以替换为： 'String s = String.join(\" \", names);' 使用该选项可使此检查仅在变量被附加到循环中时报告。",
                  "markdown": "报告被声明为 `java.lang.String` 且重复追加的变量。 此类变量可以更有效地被声明为 `java.lang.StringBuffer` 或 `java.lang.StringBuilder`。\n\n**示例：**\n\n\n      String s = \"\";\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s = s + name;\n      }\n\n此类循环可以替换为：\n\n\n      StringBuilder s = new StringBuilder();\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s.append(name);\n      }\n\n或者甚至可以替换为：\n\n\n      String s = String.join(\" \", names);\n\n\n使用该选项可使此检查仅在变量被附加到循环中时报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantStringShouldBeStringBuffer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinallyBlockCannotCompleteNormally",
                "shortDescription": {
                  "text": "不能正常完成的 'finally' 块"
                },
                "fullDescription": {
                  "text": "报告在 'finally' 块内使用的 'return'、'throw'、'break'、'continue' 和 'yield' 语句。 这些会导致 'finally' 块无法正常完成，而是突然完成。 从同一 'try'-'catch' 语句的 'try' 和 'catch' 块抛出的任何异常将被禁止。 示例： 'void x() {\n    try {\n      throw new RuntimeException();\n    } finally {\n      // 如果 bar() 返回 true，则 RuntimeException 将被禁止\n      if (bar()) return;\n    }\n  }'",
                  "markdown": "报告在 `finally` 块内使用的 `return`、`throw`、`break`、`continue` 和 `yield` 语句。 这些会导致 `finally` 块无法正常完成，而是突然完成。 从同一 `try`-`catch` 语句的 `try` 和 `catch` 块抛出的任何异常将被禁止。\n\n**示例：**\n\n\n      void x() {\n        try {\n          throw new RuntimeException();\n        } finally {\n          // 如果 bar() 返回 true，则 RuntimeException 将被禁止\n          if (bar()) return;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "finally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantOnWrongSideOfComparison",
                "shortDescription": {
                  "text": "常量位于比较的错误一侧"
                },
                "fullDescription": {
                  "text": "报告常量值在错误一侧的比较运算。 某些编码约定会指定常量应该位于比较的特定一侧，要么左侧，要么右侧。 示例： 'boolean compare(int x) {\n    return 1 > x; // 位于比较左侧的常量 '1'\n  }' 在应用快速修复后： 'boolean compare(int x) {\n    return x < 1;\n  }' 使用检查设置可以选择比较中的常量一侧，并选择 'null' 文字位于错误一侧时是否发出警告。 2019.2 最新变化",
                  "markdown": "报告常量值在错误一侧的比较运算。\n\n某些编码约定会指定常量应该位于比较的特定一侧，要么左侧，要么右侧。\n\n**示例：**\n\n\n      boolean compare(int x) {\n        return 1 > x; // 位于比较左侧的常量 '1'\n      }\n\n在应用快速修复后：\n\n\n      boolean compare(int x) {\n        return x < 1;\n      }\n\n\n使用检查设置可以选择比较中的常量一侧，并选择 `null` 文字位于错误一侧时是否发出警告。\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantOnWrongSideOfComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedStaticallyImportedElement",
                "shortDescription": {
                  "text": "不必要的限定静态导入元素"
                },
                "fullDescription": {
                  "text": "报告用其包含类名限定的静态导入成员的用法。 此类限定不必要且可移除，因为可以通过成员名称直接访问静态导入成员。 示例： 'import static foo.Test.WIDTH;\n\n  class Bar {\n    void bar() {\n      System.out.println(Test.WIDTH);\n    }\n  }' 在应用快速修复后： 'import static foo.Test.WIDTH;\n\n  class Bar {\n    void bar() {\n      System.out.println(WIDTH);\n    }\n  }'",
                  "markdown": "报告用其包含类名限定的静态导入成员的用法。\n\n此类限定不必要且可移除，因为可以通过成员名称直接访问静态导入成员。\n\n**示例：**\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(Test.WIDTH);\n        }\n      }\n\n在应用快速修复后：\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(WIDTH);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedStaticallyImportedElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectToString",
                "shortDescription": {
                  "text": "调用默认 'toString()'"
                },
                "fullDescription": {
                  "text": "报告对使用 'java.lang.Object' 中默认实现的 'toString()' 的调用。 该默认实现很少是有意为之，可能是误用。 此检查将忽略对包含 'java.lang.Object'、接口或 abstract 类类型的对象的 'toString()' 调用。 示例： 'class Bar {\n      void foo1(Bar bar) {\n          String s = bar.toString(); // 警告\n          /* ... */\n      }\n\n      void foo2(Object obj) {\n          String s = obj.toString(); // 此处无警告\n          /* ... */\n      }\n  }'",
                  "markdown": "报告对使用 `java.lang.Object` 中默认实现的 `toString()` 的调用。\n\n该默认实现很少是有意为之，可能是误用。\n\n\n此检查将忽略对包含 `java.lang.Object`、接口或 abstract 类类型的对象的 `toString()` 调用。\n\n**示例：**\n\n\n      class Bar {\n          void foo1(Bar bar) {\n              String s = bar.toString(); // 警告\n              /* ... */\n          }\n\n          void foo2(Object obj) {\n              String s = obj.toString(); // 此处无警告\n              /* ... */\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfJDBCDriverClass",
                "shortDescription": {
                  "text": "使用具体的 JDBC 驱动程序类"
                },
                "fullDescription": {
                  "text": "报告使用特定 JDBC 驱动程序类的情况。 使用这种类会将您的项目绑定到特定的数据库和驱动程序，从而违背了 JDBC 的目的并导致失去可移植性。 示例： 'import java.sql.Driver;\n\n  abstract class Sample implements Driver {\n    public void foo() {\n        Sample sample;\n    }\n  }'",
                  "markdown": "报告使用特定 JDBC 驱动程序类的情况。 使用这种类会将您的项目绑定到特定的数据库和驱动程序，从而违背了 JDBC 的目的并导致失去可移植性。\n\n**示例：**\n\n\n      import java.sql.Driver;\n\n      abstract class Sample implements Driver {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfJDBCDriverClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JDBCResource",
                "shortDescription": {
                  "text": "JDBC 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 JDBC 资源。 此检查报告的 JDBC 资源包括 'java.sql.Connection'、'java.sql.Statement'、'java.sql.PreparedStatement'、'java.sql.CallableStatement' 和 'java.sql.ResultSet'。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'ResultSet findAllElements(Connection connection) throws SQLException {\n    PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM TABLE\");//语句未关闭\n    statement.execute();\n    return statement.getResultSet();\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 JDBC 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 JDBC 资源。 此检查报告的 JDBC 资源包括 `java.sql.Connection`、`java.sql.Statement`、`java.sql.PreparedStatement`、`java.sql.CallableStatement` 和 `java.sql.ResultSet`。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      ResultSet findAllElements(Connection connection) throws SQLException {\n        PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM TABLE\");//语句未关闭\n        statement.execute();\n        return statement.getResultSet();\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 JDBC 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JDBCResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingSimilarMessage",
                "shortDescription": {
                  "text": "不可区分的日志记录调用"
                },
                "fullDescription": {
                  "text": "报告一个类中的 SLF4J 或 Log4j2 日志记录调用，例如具有类似日志消息的 'logger.info(\"message: {}\", key)'。 这些调用之间可能无法区分，这给理解某个日志消息来自何处带来了困难。 示例 (Java)： 'private static void request1(String text) {\n      log.info(\"Message: {}\", text); //类似调用\n      doSomething1();\n  }\n\n  private static void request2(int i) {\n      log.info(\"Message: {}\", i); //类似调用\n      doSomething2();\n  }' 使用相似序列的最小长度选项可设置相似序列的最小长度，之后将报告调用 使用不报告日志级别为 'error' 的调用选项可忽略日志级别为 `error` 且存在异常的消息。 隐藏警告可能会有用，因为仍然可以使用堆栈跟踪来定位调用站点 2024.1 最新变化",
                  "markdown": "报告一个类中的 SLF4J 或 Log4j2 日志记录调用，例如具有类似日志消息的 `logger.info(\"message: {}\", key)`。 这些调用之间可能无法区分，这给理解某个日志消息来自何处带来了困难。\n\n**示例 (Java)：**\n\n\n      private static void request1(String text) {\n          log.info(\"Message: {}\", text); //类似调用\n          doSomething1();\n      }\n\n      private static void request2(int i) {\n          log.info(\"Message: {}\", i); //类似调用\n          doSomething2();\n      }\n\n* 使用**相似序列的最小长度**选项可设置相似序列的最小长度，之后将报告调用\n* 使用**不报告日志级别为 'error' 的调用**选项可忽略日志级别为 \\`error\\` 且存在异常的消息。 隐藏警告可能会有用，因为仍然可以使用堆栈跟踪来定位调用站点\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LoggingSimilarMessage",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 40,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfCanBeAssertion",
                "shortDescription": {
                  "text": "语句可被替换为 'assert' 或 'Objects.requireNonNull'"
                },
                "fullDescription": {
                  "text": "报告仅从 'then' 分支抛出 'java.lang.Throwable' 而没有 'else' 分支的 'if' 语句。 此类语句可以转换为更紧凑的 'assert' 语句。 检查还报告 Guava 的 'Preconditions.checkNotNull()'。 它们可以替换为不需要库 'Objects.requireNonNull()' 调用。 示例： 'if (x == 2) throw new RuntimeException(\"fail\");\n  if (y == null) throw new AssertionError();\n  Preconditions.checkNotNull(z, \"z\");' 在应用快速修复后： 'assert x != 2 : \"fail\";\n  Objects.requireNonNull(y);\n  Objects.requireNonNull(z, \"z\");' 默认情况下，此检查在编辑器中提供快速修复，而没有高亮显示代码。",
                  "markdown": "报告仅从 `then` 分支抛出 `java.lang.Throwable` 而没有 `else` 分支的 `if` 语句。 此类语句可以转换为更紧凑的 `assert` 语句。\n\n\n检查还报告 Guava 的 `Preconditions.checkNotNull()`。\n它们可以替换为不需要库 `Objects.requireNonNull()` 调用。\n\n示例：\n\n\n      if (x == 2) throw new RuntimeException(\"fail\");\n      if (y == null) throw new AssertionError();\n      Preconditions.checkNotNull(z, \"z\");\n\n在应用快速修复后：\n\n\n      assert x != 2 : \"fail\";\n      Objects.requireNonNull(y);\n      Objects.requireNonNull(z, \"z\");\n\n默认情况下，此检查在编辑器中提供快速修复，而没有高亮显示代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfCanBeAssertion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocDeclaration",
                "shortDescription": {
                  "text": "Javadoc 声明问题"
                },
                "fullDescription": {
                  "text": "报告具有以下问题的 Javadoc 注释和标记： 标记名称无效 标记描述不完整 标记重复 缺少 Javadoc 描述 示例： '/**\n   * 标记名称无效\n   * @poram param description\n   */\n  public void sample(int param){\n  }' 示例： '/**\n   * 指向自身 {@link #sample(int)}\n   */\n  public void sample(int param){\n  }' 该快速修复会将未知的 Javadoc 标记添加到用户定义的附加标记列表中。 使用下面的文本字段可以定义附加 Javadoc 标记。 使用第一个复选框可以忽略重复的 'throws' 标记。 使用第二个复选框可以忽略描述中第一句话缺失或不完整的问题。 使用第三个复选框可以忽略指向自身的引用。",
                  "markdown": "报告具有以下问题的 Javadoc 注释和标记：\n\n* 标记名称无效\n* 标记描述不完整\n* 标记重复\n* 缺少 Javadoc 描述\n\n示例：\n\n\n      /**\n       * 标记名称无效\n       * @poram param description\n       */\n      public void sample(int param){\n      }\n\n示例：\n\n\n      /**\n       * 指向自身 {@link #sample(int)}\n       */\n      public void sample(int param){\n      }\n\n该快速修复会将未知的 Javadoc 标记添加到用户定义的附加标记列表中。\n\n使用下面的文本字段可以定义附加 Javadoc 标记。\n\n使用第一个复选框可以忽略重复的 'throws' 标记。\n\n使用第二个复选框可以忽略描述中第一句话缺失或不完整的问题。\n\n使用第三个复选框可以忽略指向自身的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToMethodParameter",
                "shortDescription": {
                  "text": "赋值给方法形参"
                },
                "fullDescription": {
                  "text": "报告对方法形参的赋值或修改。 虽然有时是有意为之，但此结构可能令人困惑，因此在一些 Java 项目中被禁止使用。 该快速修复会添加新变量的声明。 示例： 'void printTrimmed(String s) {\n    s = s.trim();\n    System.out.println(s);\n  }' 在应用快速修复后： 'void printTrimmed(String s) {\n    String trimmed = s.trim();\n    System.out.println(trimmed);\n  }' 使用如果赋值是原始形参的转换，则忽略选项可忽略根据先前值修改形参值的赋值。",
                  "markdown": "报告对方法形参的赋值或修改。\n\n虽然有时是有意为之，但此结构可能令人困惑，因此在一些 Java 项目中被禁止使用。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      void printTrimmed(String s) {\n        s = s.trim();\n        System.out.println(s);\n      }\n\n在应用快速修复后：\n\n\n      void printTrimmed(String s) {\n        String trimmed = s.trim();\n        System.out.println(trimmed);\n      }\n\n\n使用**如果赋值是原始形参的转换，则忽略**选项可忽略根据先前值修改形参值的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToMethodParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableHidingMemberVariable",
                "shortDescription": {
                  "text": "局部变量隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的局部变量。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该变量。 建议通过快速修复重命名该变量。 示例： 'public class Foo {\n    public Object foo;\n\n    void bar() {\n      Object o = new Object() {\n        void baz() {\n          Object foo; // 局部变量 'foo' 隐藏类 'Foo' 中的字段\n        }\n      };\n    }\n  }' 您可以为此检查配置以下选项： 忽略不可访问字段 - 忽略与不可见的超类字段同名的局部变量（例如，由于这些字段是 private 字段）。 忽略隐藏非 static 字段的 static 上下文中的局部变量 - 例如，当局部变量位于 static 方法内部或位于 static 内部类中的方法内部时。",
                  "markdown": "报告与周围类的字段同名的局部变量。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用该变量。\n\n建议通过快速修复重命名该变量。\n\n**示例：**\n\n\n      public class Foo {\n        public Object foo;\n\n        void bar() {\n          Object o = new Object() {\n            void baz() {\n              Object foo; // 局部变量 'foo' 隐藏类 'Foo' 中的字段\n            }\n          };\n        }\n      }\n\n\n您可以为此检查配置以下选项：\n\n1. **忽略不可访问字段** - 忽略与不可见的超类字段同名的局部变量（例如，由于这些字段是 private 字段）。\n2. **忽略隐藏非 static 字段的 static 上下文中的局部变量** - 例如，当局部变量位于 static 方法内部或位于 static 内部类中的方法内部时。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryTemporaryOnConversionToString",
                "shortDescription": {
                  "text": "转换为 'String' 时有不必要的临时对象"
                },
                "fullDescription": {
                  "text": "报告从基元类型转换为 'String' 时创建的不必要的临时对象。 示例： 'String foo = new Integer(3).toString();' 在应用快速修复后： 'String foo = Integer.toString(3);'",
                  "markdown": "报告从基元类型转换为 `String` 时创建的不必要的临时对象。\n\n**示例：**\n\n\n      String foo = new Integer(3).toString();\n\n在应用快速修复后：\n\n\n      String foo = Integer.toString(3);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryTemporaryOnConversionToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceMayBeAnnotatedFunctional",
                "shortDescription": {
                  "text": "接口可以注解为 '@FunctionalInterface'"
                },
                "fullDescription": {
                  "text": "报告可以用 '@FunctionalInterface' 注解的接口（自 JDK 1.8 起提供）。 使用 '@FunctionalInterface' 对接口进行注解会指示该接口为函数式接口，不能再向其添加其他 'abstract' 方法。 示例： 'interface FileProcessor {\n    void execute(File file);\n  }' 在应用快速修复后： '@FunctionalInterface\n  interface FileProcessor {\n    void execute(File file);\n  }' 仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以用 `@FunctionalInterface` 注解的接口（自 JDK 1.8 起提供）。\n\n使用 `@FunctionalInterface` 对接口进行注解会指示该接口为函数式接口，不能再向其添加其他 `abstract` 方法。\n\n**示例：**\n\n\n      interface FileProcessor {\n        void execute(File file);\n      }\n\n在应用快速修复后：\n\n\n      @FunctionalInterface\n      interface FileProcessor {\n        void execute(File file);\n      }\n\n仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceMayBeAnnotatedFunctional",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatementWithLabel",
                "shortDescription": {
                  "text": "带标签的 'break' 语句"
                },
                "fullDescription": {
                  "text": "报告包含标签的 'break' 语句。 'break' 标签语句导致重构复杂化，可能令人困惑。 示例： 'void handle(List<String> strs) {\n    outer:\n    for (String s: strs) {\n      for (char ch : s.toCharArray()) {\n        if ('s' == ch) break outer;\n        handleChar(ch);\n      }\n    }\n  }'",
                  "markdown": "报告包含标签的 `break` 语句。\n\n`break` 标签语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) break outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatementWithLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'equals()' 进行字符串比较"
                },
                "fullDescription": {
                  "text": "报告使用 == 或 != 比较字符串的代码。 这些运算符确定引用相等，而不是比较内容。 在大多数情况下，应使用 'equals()' 对字符串进行比较，当字符串为不同的对象时，会逐字符进行比较。 示例： 'void foo(String s, String t) {\n    final boolean b = t == s;\n  }' 如果已知 't' 为非 null 值，则可以安全地应用“不安全”的快速修复，并获得类似于以下的结果： 'void foo(String s, String t) {\n    final boolean b = t.equals(s);\n  }'",
                  "markdown": "报告使用 **==** 或 **!=** 比较字符串的代码。\n\n\n这些运算符确定引用相等，而不是比较内容。\n在大多数情况下，应使用 `equals()` 对字符串进行比较，当字符串为不同的对象时，会逐字符进行比较。\n\n**示例：**\n\n\n      void foo(String s, String t) {\n        final boolean b = t == s;\n      }\n\n如果已知 `t` 为非 null 值，则可以安全地应用\"不安全\"的快速修复，并获得类似于以下的结果：\n\n\n      void foo(String s, String t) {\n        final boolean b = t.equals(s);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEquality",
                    "cweIds": [
                      597
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousLiteralUnderscore",
                "shortDescription": {
                  "text": "数字文字中的可疑下划线"
                },
                "fullDescription": {
                  "text": "报告使用下划线数字分隔符且组的位数不为 3 的小数文字。 此类文字可能包含拼写错误。 此检查不会对包含两个连续下划线的文字发出警告。 还可以忽略 'double' 和 'float' 文字的分数部分的下划线。 示例：'int oneMillion = 1_000_0000;'",
                  "markdown": "报告使用下划线数字分隔符且组的位数不为 3 的小数文字。 此类文字可能包含拼写错误。\n\n此检查不会对包含两个连续下划线的文字发出警告。\n还可以忽略 `double` 和 `float` 文字的分数部分的下划线。\n\n**示例** ：`int oneMillion = 1_000_0000;`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousLiteralUnderscore",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticCallOnSubclass",
                "shortDescription": {
                  "text": "static 方法通过子类引用"
                },
                "fullDescription": {
                  "text": "报告其中的调用由声明类的子类而不是声明类本身限定的 static 方法调用。 Java 允许对类进行此类限定，但是此类调用可能表明继承和重写之间存在微妙的混淆。 示例： 'class Parent {\n    public static void print(String str) {}\n  }\n  class Child extends Parent {}\n\n  Child.print(\"Hello, world!\");' 在应用快速修复后： 'Parent.print(\"Hello, world!\");'",
                  "markdown": "报告其中的调用由声明类的子类而不是声明类本身限定的 static 方法调用。\n\n\nJava 允许对类进行此类限定，但是此类调用可能表明继承和重写之间存在微妙的混淆。\n\n**示例：**\n\n\n      class Parent {\n        public static void print(String str) {}\n      }\n      class Child extends Parent {}\n\n      Child.print(\"Hello, world!\");\n\n在应用快速修复后：\n\n\n      Parent.print(\"Hello, world!\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticMethodReferencedViaSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadResolveAndWriteReplaceProtected",
                "shortDescription": {
                  "text": "'readResolve()' 或 'writeReplace()' 未被声明为 'protected'"
                },
                "fullDescription": {
                  "text": "报告实现 'java.io.Serializable' 且其中的 'readResolve()' 或 'writeReplace()' 方法未被声明为 'protected' 的类。 将 'readResolve()' 和 'writeReplace()' 方法声明为 'private' 可以强制子类无提示地忽略它们，而声明为 'public' 则允许不受信任的代码调用它们。 如果包含类被声明为 'final'，这些方法就可以被声明为 'private'。 示例： 'class ClassWithSerialization implements Serializable {\n    public Object writeReplace() { // 警告：'writeReplace()' 未被声明为 protected\n        ...\n    }\n  }'",
                  "markdown": "报告实现 `java.io.Serializable` 且其中的 `readResolve()` 或 `writeReplace()` 方法未被声明为 `protected` 的类。\n\n\n将 `readResolve()` 和 `writeReplace()` 方法声明为 `private` 可以强制子类无提示地忽略它们，而声明为 `public` 则允许不受信任的代码调用它们。\n\n\n如果包含类被声明为 `final`，这些方法就可以被声明为 `private`。\n\n**示例：**\n\n\n      class ClassWithSerialization implements Serializable {\n        public Object writeReplace() { // 警告：'writeReplace()' 未被声明为 protected\n            ...\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReadResolveAndWriteReplaceProtected",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnContinueStatement",
                "shortDescription": {
                  "text": "'continue' 语句上的不必要标签"
                },
                "fullDescription": {
                  "text": "报告包含不必要标签的 'continue' 语句。 示例： 'LABEL:\n  while (a > b) {\n    System.out.println(\"Hello\");\n    //下面的代码是循环中的最后一条语句，\n    //因此可以移除不必要的标签和 continue\n    continue LABEL;\n  }'",
                  "markdown": "报告包含不必要标签的 `continue` 语句。\n\n示例：\n\n\n      LABEL:\n      while (a > b) {\n        System.out.println(\"Hello\");\n        //下面的代码是循环中的最后一条语句，\n        //因此可以移除不必要的标签和 continue\n        continue LABEL;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnContinueStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterNamingConvention",
                "shortDescription": {
                  "text": "方法形参命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的方法形参。 示例：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 'void fooBar(int X)'。 配置检查： 使用选项部分中的字段可指定方法形参名称的最小长度、最大长度以及预期的正则表达式。 指定 0 以便不检查名称的长度。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的方法形参。\n\n**示例** ：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 `void fooBar(int X)`。\n\n配置检查：\n\n\n使用**选项** 部分中的字段可指定方法形参名称的最小长度、最大长度以及预期的正则表达式。 指定 **0** 以便不检查名称的长度。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodCanBeVariableArityMethod",
                "shortDescription": {
                  "text": "方法可以有 varargs 形参"
                },
                "fullDescription": {
                  "text": "报告可以转换为可变 arity 方法的方法。 示例： 'void process(String name, Object[] objects);' 在应用快速修复后： 'void process(String name, Object... objects);' 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告可以转换为可变 arity 方法的方法。\n\n**示例：**\n\n\n      void process(String name, Object[] objects);\n\n在应用快速修复后：\n\n\n      void process(String name, Object... objects);\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MethodCanBeVariableArityMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassNeverImplemented",
                "shortDescription": {
                  "text": "没有具体子类的抽象类"
                },
                "fullDescription": {
                  "text": "报告没有任何具体子类的 'abstract' 类。",
                  "markdown": "报告没有任何具体子类的 `abstract` 类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassNeverImplemented",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StreamToLoop",
                "shortDescription": {
                  "text": "Stream API 调用链可被替换为循环"
                },
                "fullDescription": {
                  "text": "报告可以自动转换为经典循环的 Stream API 链、'Iterable.forEach()' 和 'Map.forEach()' 调用。 示例： 'String joinNonEmpty(List<String> list) {\n    return list.stream() // 流可以转换为循环\n      .filter(s -> !s.isEmpty())\n      .map(String::trim)\n      .collect(Collectors.joining(\", \"));\n  }' 在应用快速修复后： 'String joinNonEmpty(List<String> list) {\n    StringJoiner joiner = new StringJoiner(\", \");\n    for (String s : list) {\n      if (!s.isEmpty()) {\n        String trim = s.trim();\n        joiner.add(trim);\n      }\n    }\n    return joiner.toString();\n  }' 请注意，有时此检查可能会导致轻微的语义变化。 必须特别注意短路，因为流短路未指定读取的实际元素数。 配置检查： 使用 通过 Stream.iterator() 迭代未知的流源 选项来建议转换来源无法识别的流。 在这种情况下，迭代器将从流中创建。 例如，选择复选框时，此处将建议转换： 'List<ProcessHandle> handles = ProcessHandle.allProcesses().collect(Collectors.toList());' 在这种情况下，结果如下： 'List<ProcessHandle> handles = new ArrayList<>();\n  for (Iterator<ProcessHandle> it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {\n    ProcessHandle allProcess = it.next();\n    handles.add(allProcess);\n  }' 2017.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以自动转换为经典循环的 Stream API 链、`Iterable.forEach()` 和 `Map.forEach()` 调用。\n\n**示例：**\n\n\n      String joinNonEmpty(List<String> list) {\n        return list.stream() // 流可以转换为循环\n          .filter(s -> !s.isEmpty())\n          .map(String::trim)\n          .collect(Collectors.joining(\", \"));\n      }\n\n在应用快速修复后：\n\n\n      String joinNonEmpty(List<String> list) {\n        StringJoiner joiner = new StringJoiner(\", \");\n        for (String s : list) {\n          if (!s.isEmpty()) {\n            String trim = s.trim();\n            joiner.add(trim);\n          }\n        }\n        return joiner.toString();\n      }\n\n\n请注意，有时此检查可能会导致轻微的语义变化。\n必须特别注意短路，因为流短路未指定读取的实际元素数。\n\n配置检查：\n\n使用 **通过 Stream.iterator() 迭代未知的流源** 选项来建议转换来源无法识别的流。\n在这种情况下，迭代器将从流中创建。\n例如，选择复选框时，此处将建议转换：\n\n\n      List<ProcessHandle> handles = ProcessHandle.allProcesses().collect(Collectors.toList());\n\n在这种情况下，结果如下：\n\n\n      List<ProcessHandle> handles = new ArrayList<>();\n      for (Iterator<ProcessHandle> it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {\n        ProcessHandle allProcess = it.next();\n        handles.add(allProcess);\n      }\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "StreamToLoop",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NotifyWithoutCorrespondingWait",
                "shortDescription": {
                  "text": "没有相应 'wait()' 的 'notify()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Object.wait()' 调用的 'Object.notify()' 或 'Object.notifyAll()' 的调用。 此检查仅报告以当前类的目标字段为目标的调用。 示例： 'synchronized (synList) {\n    synList.notify(); //从未调用 synList.wait()\n  }'",
                  "markdown": "报告对无法为之找到相应 `Object.wait()` 调用的 `Object.notify()` 或 `Object.notifyAll()` 的调用。\n\n此检查仅报告以当前类的目标字段为目标的调用。\n\n**示例：**\n\n\n      synchronized (synList) {\n        synList.notify(); //从未调用 synList.wait()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NotifyWithoutCorrespondingWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassInitializerMayBeStatic",
                "shortDescription": {
                  "text": "类初始值设定项可能为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以使之为 'static' 的实例初始值设定项。 如果实例初始值设定项不引用其类的任何非 static 成员，则可以为 static。 static 初始值设定项在类解析后执行，而实例初始值设定项对此类的每个实例化执行。 此检查不报告匿名类中的实例空初始值设定项和初始值设定项。 示例： 'class A {\n     public static String CONSTANT;\n     {\n        CONSTANT = \"Hello\";\n     }\n  }' 在应用快速修复后： 'class A {\n     public static String CONSTANT;\n     static {\n        CONSTANT = \"Hello\"; // 现在每个类仅实例化一次\n     }\n  }'",
                  "markdown": "报告可以使之为 `static` 的实例初始值设定项。\n\n\n如果实例初始值设定项不引用其类的任何非 static 成员，则可以为 static。\nstatic 初始值设定项在类解析后执行，而实例初始值设定项对此类的每个实例化执行。\n\n此检查不报告匿名类中的实例空初始值设定项和初始值设定项。\n\n**示例：**\n\n\n      class A {\n         public static String CONSTANT;\n         {\n            CONSTANT = \"Hello\";\n         }\n      }\n\n在应用快速修复后：\n\n\n      class A {\n         public static String CONSTANT;\n         static {\n            CONSTANT = \"Hello\"; // 现在每个类仅实例化一次\n         }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassInitializerMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicCharacter",
                "shortDescription": {
                  "text": "魔幻字符"
                },
                "fullDescription": {
                  "text": "报告在没有常量声明的情况下使用的字符文字。 这些字符可能导致代码可读性差。 此外，如果只在代码中的一处更改某个字符，而不是在代码中的每一处都更改该字符，可能会出现错误。 示例： 'char c = 'c';'",
                  "markdown": "报告在没有常量声明的情况下使用的字符文字。 这些字符可能导致代码可读性差。 此外，如果只在代码中的一处更改某个字符，而不是在代码中的每一处都更改该字符，可能会出现错误。\n\n**示例：**\n\n    char c = 'c';\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicCharacter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SlowAbstractSetRemoveAll",
                "shortDescription": {
                  "text": "调用 'set.removeAll(list)' 可能较为缓慢"
                },
                "fullDescription": {
                  "text": "报告对包含 'java.util.List' 实参的 'java.util.Set.removeAll()' 的调用。 当实参大小大于或等于集合大小，并且集合是 'java.util.AbstractSet' 的子类时，此类调用可能会很慢。 在本例中，对集合中的每个元素调用了 'List.contains()'，将执行线性搜索。 示例： 'public void check(String... ss) {\n    // 可能的 O(n^2) 复杂度\n    mySet.removeAll(List.of(ss));\n  }' 在应用快速修复后： 'public void check(String... ss) {\n    // O(n) 复杂度\n    List.of(ss).forEach(mySet::remove);\n  }' 2020.3 最新变化",
                  "markdown": "报告对包含 `java.util.List` 实参的 `java.util.Set.removeAll()` 的调用。\n\n\n当实参大小大于或等于集合大小，并且集合是 `java.util.AbstractSet` 的子类时，此类调用可能会很慢。\n在本例中，对集合中的每个元素调用了 `List.contains()`，将执行线性搜索。\n\n**示例：**\n\n\n      public void check(String... ss) {\n        // 可能的 O(n^2) 复杂度\n        mySet.removeAll(List.of(ss));\n      }\n\n在应用快速修复后：\n\n\n      public void check(String... ss) {\n        // O(n) 复杂度\n        List.of(ss).forEach(mySet::remove);\n      }\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SlowAbstractSetRemoveAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayEquality",
                "shortDescription": {
                  "text": "使用 '==' 而不是 'Arrays.equals()' 进行数组比较"
                },
                "fullDescription": {
                  "text": "报告用于测试数组相等性的运算符 '==' 和 '!='。 在大多数情况下，如果原本就要测试数组内容的相等性，可以通过 'java.util.Arrays.equals()' 方法来完成。 建议通过快速修复将 '==' 替换为 'java.util.Arrays.equals()'。 示例： 'void foo(Object[] x, Object[] y) {\n    boolean comparison = x == y;\n  }' 在应用快速修复后： 'void foo(Object[] x, Object[] y) {\n    boolean comparison = Arrays.equals(x, y);\n  }'",
                  "markdown": "报告用于测试数组相等性的运算符 `==` 和 `!=`。 在大多数情况下，如果原本就要测试数组内容的相等性，可以通过 `java.util.Arrays.equals()` 方法来完成。\n\n\n建议通过快速修复将 `==` 替换为 `java.util.Arrays.equals()`。\n\n**示例：**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\n在应用快速修复后：\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticCollection",
                "shortDescription": {
                  "text": "静态集合"
                },
                "fullDescription": {
                  "text": "报告 'Collection' 类型的 static 字段。 虽然这不一定是问题，但静态集合通常会导致内存泄漏，因此会被某些编码标准禁止。 示例： 'public class Example {\n    static List<String> list = new ArrayList<>();\n\n  }' 配置检查： 使用忽略弱静态集合或映射选项可以忽略 'java.util.WeakHashMap' 类型的字段。",
                  "markdown": "报告 `Collection` 类型的 static 字段。 虽然这不一定是问题，但静态集合通常会导致内存泄漏，因此会被某些编码标准禁止。\n\n**示例：**\n\n\n      public class Example {\n        static List<String> list = new ArrayList<>();\n\n      }\n\n\n配置检查：\n\n* 使用**忽略弱静态集合或映射** 选项可以忽略 `java.util.WeakHashMap` 类型的字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExceptionNameEndsWithException",
                "shortDescription": {
                  "text": "非异常类名以 'Exception' 结尾"
                },
                "fullDescription": {
                  "text": "报告名称以 'Exception' 结尾的非 'exception' 类。 这种类可能会违反通用的命名约定而引起混淆，并且通常表示缺少 'extends Exception' 子句。 示例： 'public class NotStartedException {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告名称以 `Exception` 结尾的非 `exception` 类。\n\n这种类可能会违反通用的命名约定而引起混淆，并且通常表示缺少 `extends Exception` 子句。\n\n**示例：**\n\n    public class NotStartedException {}\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExceptionNameEndsWithException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 61,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassComplexity",
                "shortDescription": {
                  "text": "过度复杂的类"
                },
                "fullDescription": {
                  "text": "报告总复杂度超过指定最大值的类。 类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。 过高的复杂度表明该类应该被重构为几个更小的类。 使用下面的循环复杂度限制字段可指定类允许的最大复杂度。",
                  "markdown": "报告总复杂度超过指定最大值的类。\n\n类的总复杂度是该类声明的所有方法和初始值设定项的循环复杂度的总和。 继承的方法和初始值设定项不计入总复杂度。\n\n过高的复杂度表明该类应该被重构为几个更小的类。\n\n使用下面的**循环复杂度限制**字段可指定类允许的最大复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGC",
                "shortDescription": {
                  "text": "调用 'System.gc()' 或 'Runtime.gc()'"
                },
                "fullDescription": {
                  "text": "报告 'System.gc()' 或 'Runtime.gc()' 调用。 虽然在测试中偶尔有用，但在生产代码中几乎从不推荐通过 'System.gc()' 显式触发垃圾回收，这可能会导致严重的性能问题。",
                  "markdown": "报告 `System.gc()` 或 `Runtime.gc()` 调用。 虽然在测试中偶尔有用，但在生产代码中几乎从不推荐通过 `System.gc()` 显式触发垃圾回收，这可能会导致严重的性能问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemGC",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverflowingLoopIndex",
                "shortDescription": {
                  "text": "循环执行零次或无限次"
                },
                "fullDescription": {
                  "text": "报告没有索引溢出就无法完成的循环或根本不循环的循环。 之所以发生这种情况，通常是因为更新操作中有错误。 示例： 'void foo(int s) {\n    for (int i = s; i > 12; i++) { // i-- 应在此处\n      System.out.println(i);\n    }\n  }' 2019.1 最新变化",
                  "markdown": "报告没有索引溢出就无法完成的循环或根本不循环的循环。 之所以发生这种情况，通常是因为更新操作中有错误。\n\n示例：\n\n\n      void foo(int s) {\n        for (int i = s; i > 12; i++) { // i-- 应在此处\n          System.out.println(i);\n        }\n      }\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverflowingLoopIndex",
                    "cweIds": [
                      691,
                      835
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SetReplaceableByEnumSet",
                "shortDescription": {
                  "text": "'Set' 可被替换为 'EnumSet'"
                },
                "fullDescription": {
                  "text": "报告内容类型为枚举类的 'java.util.Set' 对象的实例化。 此类 'Set' 对象可以替换为 'java.util.EnumSet' 对象。 与其他集合相比，'EnumSet' 实现的效率更高，因为底层数据结构是位向量。 使用该快速修复可以将初始值设定项替换为 'EnumSet.noneOf()' 调用。 当变量类型是 'Set' 的子类时，此快速修复不可用。 示例： 'enum MyEnum { FOO, BAR; }\n\n  Set<MyEnum> enums = new HashSet<MyEnum>();' 在应用快速修复后： 'enum MyEnum { FOO, BAR; }\n\n  Set<MyEnum> enums = EnumSet.noneOf(MyEnum.class);'",
                  "markdown": "报告内容类型为枚举类的 `java.util.Set` 对象的实例化。 此类 `Set` 对象可以替换为 `java.util.EnumSet` 对象。\n\n\n与其他集合相比，`EnumSet` 实现的效率更高，因为底层数据结构是位向量。 使用该快速修复可以将初始值设定项替换为 `EnumSet.noneOf()` 调用。 当变量类型是 `Set` 的子类时，此快速修复不可用。\n\n**示例：**\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = new HashSet<MyEnum>();\n\n在应用快速修复后：\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = EnumSet.noneOf(MyEnum.class);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SetReplaceableByEnumSet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9UndeclaredServiceUsage",
                "shortDescription": {
                  "text": "服务的使用未在 'module-info' 中声明"
                },
                "fullDescription": {
                  "text": "报告使用 'java.util.ServiceLoader' 加载服务但未使用 'module-info.java' 文件中的 'uses' 子句声明的情况，并建议插入它。 2018.1 最新变化 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告使用 `java.util.ServiceLoader` 加载服务但未使用 `module-info.java` 文件中的 `uses` 子句声明的情况，并建议插入它。\n\n2018.1 最新变化\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9UndeclaredServiceUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassMayBeStatic",
                "shortDescription": {
                  "text": "内部类可能为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以设置为 'static' 的内部类。 'static' 内部类不保留对其封闭实例的隐式引用。 这可以防止常见的内存泄漏，减少类的每个实例使用的内存。 示例： 'public class Outer {\n    class Inner { // 非 static\n      public void foo() {\n        bar(\"x\");\n      }\n\n      private void bar(String string) {}\n    }\n  }' 在应用快速修复后： 'public class Outer {\n    static class Inner {\n      public void foo() {\n        bar(\"x\");\n      }\n\n      private void bar(String string) {}\n    }\n  }'",
                  "markdown": "报告可以设置为 `static` 的内部类。\n\n`static` 内部类不保留对其封闭实例的隐式引用。\n这可以防止常见的内存泄漏，减少类的每个实例使用的内存。\n\n**示例：**\n\n\n      public class Outer {\n        class Inner { // 非 static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToSimpleSetterInClass",
                "shortDescription": {
                  "text": "从类内调用简单 setter"
                },
                "fullDescription": {
                  "text": "报告从属性的类内部对简单属性 setter 的调用。 简单的属性 setter 被定义为只将其形参的值分配给一个字段，而不进行其他计算。 可以安全地内联此类简单的 setter 调用。 为了保持代码清晰，某些编码标准还建议不使用简单的 setter。 示例： 'class Foo {\n  private int index;\n    public Foo(int idx) {\n       setIndex(idx);\n    }\n    public void setIndex(int idx) {\n       index = idx;\n    }\n  }' 在应用快速修复后： 'class Foo {\n    private int index;\n    public Foo(int idx) {\n      index = idx;\n    }\n    public void setIndex(int idx) {\n      index = idx;\n    }\n  }' 使用以下选项配置检查： 是否仅报告 'this' 上的 setter 调用，而不报告作为形参传入的相同类型的对象。 是否忽略非 'private' setter。",
                  "markdown": "报告从属性的类内部对简单属性 setter 的调用。\n\n\n简单的属性 setter 被定义为只将其形参的值分配给一个字段，而不进行其他计算。 可以安全地内联此类简单的 setter 调用。\n为了保持代码清晰，某些编码标准还建议不使用简单的 setter。\n\n**示例：**\n\n\n      class Foo {\n      private int index;\n        public Foo(int idx) {\n           setIndex(idx);\n        }\n        public void setIndex(int idx) {\n           index = idx;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        private int index;\n        public Foo(int idx) {\n          index = idx;\n        }\n        public void setIndex(int idx) {\n          index = idx;\n        }\n      }\n\n使用以下选项配置检查：\n\n* 是否仅报告 `this` 上的 setter 调用，而不报告作为形参传入的相同类型的对象。\n* 是否忽略非 `private` setter。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSimpleSetterFromWithinClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryFinalOnLocalVariableOrParameter",
                "shortDescription": {
                  "text": "局部变量或形参上存在不必要的 'final'"
                },
                "fullDescription": {
                  "text": "报告不必要地声明为 'final' 的局部变量或形参。 出于简洁的原因，某些编码标准不赞成声明为 'final' 的变量。 示例： 'class Foo {\n    Foo(Object o) {}\n\n    void bar(final Object o) {\n      new Foo(o);\n    }\n  }' 在应用快速修复后： 'class Foo {\n    Foo(Object o) {}\n\n    void bar(Object o) {\n      new Foo(o);\n    }\n  }' 使用检查选项可以切换以下各项的报告： 局部变量 形参（包括 'catch' 块的形参和增强型 'for' 语句） 此外，您可以将检查配置为仅报告 'abstract' 或接口方法的 'final' 形参，这可能被认为是多余的，因为此类标记不会影响这些方法的实现。",
                  "markdown": "报告不必要地声明为 `final` 的局部变量或形参。\n\n出于简洁的原因，某些编码标准不赞成声明为 `final` 的变量。\n\n**示例：**\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(final Object o) {\n          new Foo(o);\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(Object o) {\n          new Foo(o);\n        }\n      }\n\n\n使用检查选项可以切换以下各项的报告：\n\n* 局部变量\n* 形参（包括 `catch` 块的形参和增强型 `for` 语句）\n\n\n此外，您可以将检查配置为仅报告 `abstract` 或接口方法的 `final` 形参，这可能被认为是多余的，因为此类标记不会影响这些方法的实现。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryFinalOnLocalVariableOrParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonBooleanMethodNameMayNotStartWithQuestion",
                "shortDescription": {
                  "text": "非布尔方法名称不能以疑问词开头"
                },
                "fullDescription": {
                  "text": "报告名称以疑问词开头的非布尔方法。 此类方法名称可能令人困惑。 此检查将忽略重写库方法的非布尔方法。 示例： 'public void hasName(String name) {\n    assert names.contains(name);\n  }' 只能在编辑器中使用重命名此类方法的快速修复。 配置检查： 使用布尔方法名称前缀列表可指定应仅用于布尔方法的疑问词。 使用忽略具有 'java.lang.Boolean' 返回类型的方法选项可忽略返回类型为 'java.lang.Boolean' 的方法。 使用忽略重写/实现 super 方法的方法选项可忽略具有 super 方法的方法。",
                  "markdown": "报告名称以疑问词开头的非布尔方法。 此类方法名称可能令人困惑。\n\n此检查将忽略重写库方法的非布尔方法。\n\n**示例：**\n\n\n      public void hasName(String name) {\n        assert names.contains(name);\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n配置检查：\n\n* 使用**布尔方法名称前缀**列表可指定应仅用于布尔方法的疑问词。\n* 使用**忽略具有 'java.lang.Boolean' 返回类型的方法** 选项可忽略返回类型为 `java.lang.Boolean` 的方法。\n* 使用**忽略重写/实现 super 方法的方法**选项可忽略具有 super 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonBooleanMethodNameMayNotStartWithQuestion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WeakerAccess",
                "shortDescription": {
                  "text": "声明访问可以更弱"
                },
                "fullDescription": {
                  "text": "报告可能缩小其访问修饰符范围的字段、方法或类。 示例： 'class Sample {\n    void foo() {\n        bar(\"foo\", \"foo\");\n    }\n    void bar(String x, String y) { } // 可以为 private\n  }' 在应用快速修复后： 'class Sample {\n    void foo() {\n        bar(\"foo\", \"foo\");\n    }\n    private void bar(String x, String y) { }\n  }' 使用检查选项可以定义修饰符更改建议的规则。",
                  "markdown": "报告可能缩小其访问修饰符范围的字段、方法或类。\n\n示例：\n\n\n      class Sample {\n        void foo() {\n            bar(\"foo\", \"foo\");\n        }\n        void bar(String x, String y) { } // 可以为 private\n      }\n\n在应用快速修复后：\n\n\n      class Sample {\n        void foo() {\n            bar(\"foo\", \"foo\");\n        }\n        private void bar(String x, String y) { }\n      }\n\n使用检查选项可以定义修饰符更改建议的规则。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WeakerAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceWithJavadoc",
                "shortDescription": {
                  "text": "可用 Javadoc 替换的注释"
                },
                "fullDescription": {
                  "text": "报告属于可被替换为 Javadoc 注释的字段、方法或类的常规注释。 示例： 'public class Main {\n    /*\n    * Hello,\n    */\n    // World!\n    void f() {\n    }\n  }' 在应用快速修复后： 'public class Main {\n    /**\n     * Hello,\n     * World!\n     */\n    void f() {\n    }\n  }'",
                  "markdown": "报告属于可被替换为 Javadoc 注释的字段、方法或类的常规注释。\n\n**示例：**\n\n\n      public class Main {\n        /*\n        * Hello,\n        */\n        // World!\n        void f() {\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Main {\n        /**\n         * Hello,\n         * World!\n         */\n        void f() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReplaceWithJavadoc",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrapperTypeMayBePrimitive",
                "shortDescription": {
                  "text": "包装器类型可能是基元"
                },
                "fullDescription": {
                  "text": "报告主要用作基元类型的包装器类型的局部变量。 在某些情况下，装箱可能会导致严重的性能损失，尤其是在循环中。 采用启发估计装箱操作次数。 例如，循环内的转换数量视为更多。 示例： 'public void example() {\n    Integer value = 12;\n    needBox(value);\n    for (int i = 0; i < 10; i++) {\n      // 循环的用法正变得越来越频繁\n      needPrimitive(value);\n    }\n  }\n\n  void needPrimitive(int value) {}\n  void needBox(Integer value) {}' 在应用快速修复后： 'public void example() {\n    int value = 12;\n    needBox(value);\n    for (int i = 0; i < 10; i++) {\n      // 循环的用法正变得越来越频繁\n      needPrimitive(value);\n    }\n  }\n\n  void needPrimitive(int value) {}\n  void needBox(Integer value) {}' 2018.2 最新变化",
                  "markdown": "报告主要用作基元类型的包装器类型的局部变量。\n\n在某些情况下，装箱可能会导致严重的性能损失，尤其是在循环中。\n\n采用启发估计装箱操作次数。 例如，循环内的转换数量视为更多。\n\n**示例：**\n\n      public void example() {\n        Integer value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // 循环的用法正变得越来越频繁\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\n在应用快速修复后：\n\n      public void example() {\n        int value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // 循环的用法正变得越来越频繁\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WrapperTypeMayBePrimitive",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyStatementBody",
                "shortDescription": {
                  "text": "带空体的语句"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'if'、'while'、'do'、'for'、'switch' 语句。 虽然偶尔是有意为之，但此类代码令人困惑，并且通常是由拼写错误所致。 JSP 文件中禁用了此检查。",
                  "markdown": "报告语句体为空的 `if`、`while`、`do`、`for`、`switch` 语句。\n\n虽然偶尔是有意为之，但此类代码令人困惑，并且通常是由拼写错误所致。\n\nJSP 文件中禁用了此检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StatementWithEmptyBody",
                    "cweIds": [
                      561
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyFinallyBlock",
                "shortDescription": {
                  "text": "空 'finally' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'finally' 块。 空的 'finally' 块通常表明存在编码错误。 在代码重构后它们可能保留下来，可以安全移除。 此检查不报告在 JSP 文件中发现的空 'finally' 块。 示例： 'try {\n    Files.readString(Paths.get(\"in.txt\"));\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  } finally {\n\n  }' 在应用快速修复后： 'try {\n    Files.readString(Paths.get(\"in.txt\"));\n  } catch (IOException e) {\n    throw new RuntimeException(e);\n  }'",
                  "markdown": "报告空的 `finally` 块。\n\n空的 `finally` 块通常表明存在编码错误。 在代码重构后它们可能保留下来，可以安全移除。\n\n此检查不报告在 JSP 文件中发现的空 `finally` 块。\n\n**示例：**\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      } finally {\n\n      }\n\n在应用快速修复后：\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyFinallyBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentLanguageLevel",
                "shortDescription": {
                  "text": "语言级别设置不一致"
                },
                "fullDescription": {
                  "text": "报告依赖于具有更高语言级别的其他模块的模块。 应该移除此类依赖项或提高模块的语言级别。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告依赖于具有更高语言级别的其他模块的模块。\n\n应该移除此类依赖项或提高模块的语言级别。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentLanguageLevel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumerationCanBeIteration",
                "shortDescription": {
                  "text": "枚举可以是迭代"
                },
                "fullDescription": {
                  "text": "报告对集合使用的可以替换为等效 'Iterator' 结构的 'Enumeration' 方法的调用。 示例： 'Enumeration<String> keys = map.keys();\n  while (keys.hasMoreElements()) {\n    String name = keys.nextElement();\n  }' 在应用快速修复后： 'Iterator<String> iterator = map.keySet().iterator();\n  while (iterator.hasNext()) {\n    String name = iterator.next();\n  }'",
                  "markdown": "报告对集合使用的可以替换为等效 `Iterator` 结构的 `Enumeration` 方法的调用。\n\n**示例：**\n\n\n      Enumeration<String> keys = map.keys();\n      while (keys.hasMoreElements()) {\n        String name = keys.nextElement();\n      }\n\n在应用快速修复后：\n\n\n      Iterator<String> iterator = map.keySet().iterator();\n      while (iterator.hasNext()) {\n        String name = iterator.next();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumerationCanBeIteration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 51,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalStaticMethod",
                "shortDescription": {
                  "text": "'static' 方法被声明为 'final'"
                },
                "fullDescription": {
                  "text": "报告标记为 'final' 的 static 方法。 此类代码可能表示错误或关于 'final' 关键字效果的不正确的假设。 由于 static 方法不受运行时多态性影响，因此与 static 方法一起使用的 'final' 关键字的唯一目的是确保该方法不会在子类中被隐藏。",
                  "markdown": "报告标记为 `final` 的 static 方法。\n\n此类代码可能表示错误或关于 `final` 关键字效果的不正确的假设。\n由于 static 方法不受运行时多态性影响，因此与 static 方法一起使用的 `final` 关键字的唯一目的是确保该方法不会在子类中被隐藏。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalStaticMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantTypeArguments",
                "shortDescription": {
                  "text": "冗余类型实参"
                },
                "fullDescription": {
                  "text": "报告对显式实参类型可以忽略（因为编译器将明确推断出这些实参类型）的形参化方法的调用。 使用冗余类型实参不必要，并且会降低代码的可读性。 示例： 'List<String> list = Arrays.<String>asList(\"Hello\", \"World\");' 通过快速修复可以移除冗余类型实参： 'List<String> list = Arrays.asList(\"Hello\", \"World\");'",
                  "markdown": "报告对显式实参类型可以忽略（因为编译器将明确推断出这些实参类型）的形参化方法的调用。\n\n\n使用冗余类型实参不必要，并且会降低代码的可读性。\n\n示例：\n\n\n      List<String> list = Arrays.<String>asList(\"Hello\", \"World\");\n\n通过快速修复可以移除冗余类型实参：\n\n\n      List<String> list = Arrays.asList(\"Hello\", \"World\");\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantTypeArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldHasSetterButNoGetter",
                "shortDescription": {
                  "text": "字段具有 setter 但没有 getter"
                },
                "fullDescription": {
                  "text": "报告含有 setter 方法但没有 getter 方法的字段。 在某些 bean 容器中，当在 Java bean 规范中使用时，这些字段可能难以使用。",
                  "markdown": "报告含有 setter 方法但没有 getter 方法的字段。\n\n\n在某些 bean 容器中，当在 Java bean 规范中使用时，这些字段可能难以使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldHasSetterButNoGetter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 110,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RuntimeExecWithNonConstantString",
                "shortDescription": {
                  "text": "'Runtime.exec()' 调用具有非常量字符串"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.Runtime.exec()' 的调用，该调用会将动态构造的字符串作为要执行的命令。 构造的执行字符串是安全漏洞的常见来源。 默认情况下，此检查会忽略编译时常量。 示例： 'String i = getUserInput();\n  Runtime runtime = Runtime.getRuntime();\n  runtime.exec(\"foo\" + i); // 报告警告' 使用检查设置可以将任何 'static' 'final' 字段视为常量。 请小心，因为启用该选项时，像下面这样的字符串将被忽略： 'static final String COMMAND = \"ping \" + getDomainFromUserInput() + \"'\";'",
                  "markdown": "报告对 `java.lang.Runtime.exec()` 的调用，该调用会将动态构造的字符串作为要执行的命令。\n\n\n构造的执行字符串是安全漏洞的常见来源。\n默认情况下，此检查会忽略编译时常量。\n\n**示例：**\n\n\n      String i = getUserInput();\n      Runtime runtime = Runtime.getRuntime();\n      runtime.exec(\"foo\" + i); // 报告警告\n\n\n使用检查设置可以将任何 `static` `final` 字段视为常量。\n请小心，因为启用该选项时，像下面这样的字符串将被忽略：\n\n\n      static final String COMMAND = \"ping \" + getDomainFromUserInput() + \"'\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToRuntimeExecWithNonConstantString",
                    "cweIds": [
                      20,
                      77,
                      78,
                      88,
                      94
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ErrorRethrown",
                "shortDescription": {
                  "text": "'Error' 未重新抛出"
                },
                "fullDescription": {
                  "text": "报告捕获 'java.lang.Error' 或其任何子类并且不重新抛出错误的 'try' 语句。 不会报告捕获 'java.lang.ThreadDeath' 的语句。 示例： 'try {\n    executeTests(request);\n  }\n  catch (OutOfMemoryError ex) { // 警告：错误 'ex' 未重新抛出\n    return false;\n  }'",
                  "markdown": "报告捕获 `java.lang.Error` 或其任何子类并且不重新抛出错误的 `try` 语句。\n\n不会报告捕获 `java.lang.ThreadDeath` 的语句。\n\n**示例：**\n\n\n      try {\n        executeTests(request);\n      }\n      catch (OutOfMemoryError ex) { // 警告：错误 'ex' 未重新抛出\n        return false;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ErrorNotRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclicPackageDependency",
                "shortDescription": {
                  "text": "循环软件包依赖关系"
                },
                "fullDescription": {
                  "text": "报告相互依赖或循环依赖于其他软件包的软件包。 此类循环依赖项会使代码变得脆弱且难以维护。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告相互依赖或循环依赖于其他软件包的软件包。\n\n此类循环依赖项会使代码变得脆弱且难以维护。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CyclicPackageDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 113,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemSetSecurityManager",
                "shortDescription": {
                  "text": "调用 'System.setSecurityManager()'"
                },
                "fullDescription": {
                  "text": "报告对 'System.setSecurityManager()' 的调用。 虽然通常是良性的，但任何对 'System.setSecurityManager()' 的调用都应在每个安全审核中仔细检查。",
                  "markdown": "报告对 `System.setSecurityManager()` 的调用。\n\n虽然通常是良性的，但任何对 `System.setSecurityManager()` 的调用都应在每个安全审核中仔细检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemSetSecurityManager",
                    "cweIds": [
                      250
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsatisfiedRange",
                "shortDescription": {
                  "text": "返回值超出声明的范围"
                },
                "fullDescription": {
                  "text": "报告从不符合所声明方法返回范围的方法返回的数值。 您可以使用许多注解声明方法的返回范围： JetBrains 注解软件包中的 'org.jetbrains.annotations.Range'（指定 'from' 和 'to'） Checker Framework 注解软件包中的 'org.checkerframework.common.value.qual.IntRange'（指定 'from' 和 'to'） Checker Framework 注解软件包中的 'org.checkerframework.checker.index.qual.GTENegativeOne'（范围为 '>= -1'） Checker Framework 注解软件包中的 'org.checkerframework.checker.index.qual.NonNegative'（范围为 '>= 0'） Checker Framework 注解软件包中的 'org.checkerframework.checker.index.qual.Positive'（范围为 '> 0'） JSR 305 注解软件包中的 'javax.annotation.Nonnegative'（范围为 '>= 0'） 'javax.validation.constraints.Min'（指定最小值） 'javax.validation.constraints.Max'（指定最大值） 示例： '@Range(from = 0, to = Integer.MAX_VALUE) int getValue() {\n    // 警告：-1 超出声明的范围\n    return -1;\n  }' 2021.2 最新变化",
                  "markdown": "报告从不符合所声明方法返回范围的方法返回的数值。 您可以使用许多注解声明方法的返回范围：\n\n* JetBrains 注解软件包中的 `org.jetbrains.annotations.Range`（指定 'from' 和 'to'）\n* Checker Framework 注解软件包中的 `org.checkerframework.common.value.qual.IntRange`（指定 'from' 和 'to'）\n* Checker Framework 注解软件包中的 `org.checkerframework.checker.index.qual.GTENegativeOne`（范围为 '\\>= -1'）\n* Checker Framework 注解软件包中的 `org.checkerframework.checker.index.qual.NonNegative`（范围为 '\\>= 0'）\n* Checker Framework 注解软件包中的 `org.checkerframework.checker.index.qual.Positive`（范围为 '\\> 0'）\n* JSR 305 注解软件包中的 `javax.annotation.Nonnegative`（范围为 '\\>= 0'）\n* `javax.validation.constraints.Min`（指定最小值）\n* `javax.validation.constraints.Max`（指定最大值）\n\n示例：\n\n\n      @Range(from = 0, to = Integer.MAX_VALUE) int getValue() {\n        // 警告：-1 超出声明的范围\n        return -1;\n      }\n\n2021.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsatisfiedRange",
                    "cweIds": [
                      129,
                      682
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug/为 null 性问题",
                      "index": 141,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutNoArgConstructor",
                "shortDescription": {
                  "text": "没有无实参构造函数的类"
                },
                "fullDescription": {
                  "text": "报告没有构造函数（不带实参，即没有形参）的类。 无实参构造函数在某些上下文中是必需的。 例如，如果需要使用反射来创建类。 示例： 'public class Bean {\n    private String name;\n\n    public Bean(String name) {\n      this.name = name;\n    }\n  }' 使用下面的复选框可忽略没有显式构造函数的类。 编译器为这种类提供了默认的无实参构造函数。",
                  "markdown": "报告没有构造函数（不带实参，即没有形参）的类。 无实参构造函数在某些上下文中是必需的。 例如，如果需要使用反射来创建类。\n\n**示例：**\n\n\n      public class Bean {\n        private String name;\n\n        public Bean(String name) {\n          this.name = name;\n        }\n      }\n\n\n使用下面的复选框可忽略没有显式构造函数的类。\n编译器为这种类提供了默认的无实参构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 110,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyDependencies",
                "shortDescription": {
                  "text": "依赖过多的类"
                },
                "fullDescription": {
                  "text": "报告直接依赖于项目中过多其他类的类。 对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。 仅报告顶级类。 使用最大依赖项数字段可指定类允许的最大依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告直接依赖于项目中过多其他类的类。\n\n对这种类的任何依赖项的修改都可能需要更改该类，从而使其容易出现不稳定。\n\n仅报告顶级类。\n\n使用**最大依赖项数**字段可指定类允许的最大依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyDependencies",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 113,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastConflictsWithInstanceof",
                "shortDescription": {
                  "text": "转换与 'instanceof' 冲突"
                },
                "fullDescription": {
                  "text": "报告前面包含用于检查不同类型的 'instanceof' 的类型转换表达式。 尽管这可能是有意为之，但此类结构很可能是错误，在运行时将导致 'java.lang.ClassCastException'。 示例： 'class Main {\n    int whenCharSequenceCastToNumber(Object o){\n      if (o instanceof CharSequence) {\n        return ((Number) o).intValue();\n      }\n      return 0;\n    }\n\n    int earlyReturnWhenNotCharSequence(Object o){\n      if (!(o instanceof CharSequence)) return 0;\n      return ((Number)o).intValue();\n    }\n  }'",
                  "markdown": "报告前面包含用于检查不同类型的 `instanceof` 的类型转换表达式。\n\n\n尽管这可能是有意为之，但此类结构很可能是错误，在运行时将导致 `java.lang.ClassCastException`。\n\n**示例：**\n\n\n      class Main {\n        int whenCharSequenceCastToNumber(Object o){\n          if (o instanceof CharSequence) {\n            return ((Number) o).intValue();\n          }\n          return 0;\n        }\n\n        int earlyReturnWhenNotCharSequence(Object o){\n          if (!(o instanceof CharSequence)) return 0;\n          return ((Number)o).intValue();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastConflictsWithInstanceof",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewExceptionWithoutArguments",
                "shortDescription": {
                  "text": "未使用实参调用异常构造函数"
                },
                "fullDescription": {
                  "text": "报告未指定任何实参的异常实例的创建。 当异常被构造为没有任何实参时，它不包含有关所发生问题的信息，这会使调试变得不必要地困难。 示例： 'throw new IOException(); // 警告：没有实参的异常'",
                  "markdown": "报告未指定任何实参的异常实例的创建。\n\n当异常被构造为没有任何实参时，它不包含有关所发生问题的信息，这会使调试变得不必要地困难。\n\n**示例：**\n\n\n      throw new IOException(); // 警告：没有实参的异常\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewExceptionWithoutArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Contract",
                "shortDescription": {
                  "text": "合同的问题"
                },
                "fullDescription": {
                  "text": "报告方法 '@Contract' 注解中的问题。 可以报告的问题类型有： 约定语法错误 不符合方法签名的约定（错误的形参计数） 与约定不一致的方法实现（例如，即使约定声明 'false'，也返回 'true'） 示例： '// 方法没有形参，参约定预期 1\n  @Contract(\"_ -> fail\")\n  void x() {\n    throw new AssertionError();\n  }'",
                  "markdown": "报告方法 `@Contract` 注解中的问题。 可以报告的问题类型有：\n\n* 约定语法错误\n* 不符合方法签名的约定（错误的形参计数）\n* 与约定不一致的方法实现（例如，即使约定声明 ` false`，也返回 `true`）\n\n示例：\n\n\n      // 方法没有形参，参约定预期 1\n      @Contract(\"_ -> fail\")\n      void x() {\n        throw new AssertionError();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Contract",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnhancedSwitchBackwardMigration",
                "shortDescription": {
                  "text": "增强的 'switch'"
                },
                "fullDescription": {
                  "text": "报告增强型 'switch' 语句和表达式。 建议将它们替换为常规的 'switch' 语句。 示例： 'boolean even = switch (condition) {\n    case 1, 3, 5, 7, 9 -> false;\n    default -> true;\n  };' 在应用快速修复后： 'boolean even;\n  switch (condition) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 9:\n      even = false;\n      break;\n    default:\n      even = true;\n      break;\n}' 增强型 'switch' 在 Java 14 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。 2019.1 最新变化",
                  "markdown": "报告增强型 `switch` 语句和表达式。 建议将它们替换为常规的 `switch` 语句。\n\n**示例：**\n\n\n      boolean even = switch (condition) {\n        case 1, 3, 5, 7, 9 -> false;\n        default -> true;\n      };\n\n在应用快速修复后：\n\n\n      boolean even;\n      switch (condition) {\n        case 1:\n        case 3:\n        case 5:\n        case 7:\n        case 9:\n          even = false;\n          break;\n        default:\n          even = true;\n          break;\n    }\n\n\n*增强型* `switch` 在 Java 14 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnhancedSwitchBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 14",
                      "index": 108,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageWithTooManyClasses",
                "shortDescription": {
                  "text": "类过多的软件包"
                },
                "fullDescription": {
                  "text": "报告包含过多类的软件包。 过大的软件包可能表明设计不够明确。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最大类数字段可指定软件包中允许的最大类数。",
                  "markdown": "报告包含过多类的软件包。\n\n过大的软件包可能表明设计不够明确。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最大类数**字段可指定软件包中允许的最大类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageWithTooManyClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 36,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryFinallyCanBeTryWithResources",
                "shortDescription": {
                  "text": "'try finally' 可被替换为 'try' with resources"
                },
                "fullDescription": {
                  "text": "报告可能使用 Java 7 Automatic Resource Management（这样不容易出错）的 'try'-'finally' 语句。 可以通过快速修复将 'try'-'finally' 语句转换为 'try'-with-resources 语句。 示例： 'PrintStream printStream = new PrintStream(fileName);\n  try {\n    printStream.print(true);\n  } finally {\n    printStream.close();\n  }' 通过快速修复将原因传递给构造函数： 'try (PrintStream printStream = new PrintStream(fileName)) {\n    printStream.print(true);\n  }' 此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。",
                  "markdown": "报告可能使用 Java 7 Automatic Resource Management（这样不容易出错）的 `try`-`finally` 语句。\n\n可以通过快速修复将 `try`-`finally` 语句转换为 `try`-with-resources 语句。\n\n**示例：**\n\n\n      PrintStream printStream = new PrintStream(fileName);\n      try {\n        printStream.print(true);\n      } finally {\n        printStream.close();\n      }\n\n通过快速修复将原因传递给构造函数：\n\n\n      try (PrintStream printStream = new PrintStream(fileName)) {\n        printStream.print(true);\n      }\n\n此检查取决于 Java 功能 'Try-with-resources'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TryFinallyCanBeTryWithResources",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 127,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SamePackageImport",
                "shortDescription": {
                  "text": "相同软件包中的不必要 import"
                },
                "fullDescription": {
                  "text": "报告引用的软件包与包含文件相同的 'import' 语句。 相同软件包的文件始终隐式导入，因此，此类 'import' 语句冗余，而且令人困惑。 由于 IntelliJ IDEA 可以通过优化导入命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。",
                  "markdown": "报告引用的软件包与包含文件相同的 `import` 语句。\n\n\n相同软件包的文件始终隐式导入，因此，此类 `import` 语句冗余，而且令人困惑。\n\n\n由于 IntelliJ IDEA 可以通过**优化导入**命令自动检测并修正此类语句，对于不打算更改的代码库的脱机报告，此检查非常有用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SamePackageImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 14,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadLocalSetWithNull",
                "shortDescription": {
                  "text": "以 null 作为实参的 'ThreadLocal.set()'"
                },
                "fullDescription": {
                  "text": "报告以 null 作为实参的 'java.lang.ThreadLocal.set()'。 此调用不会释放资源，并且可能导致内存泄漏。 这可能是因为： 首先，'ThreadLocal.set(null)' 会查找与当前线程相关联的映射。 如果没有此类映射，则会创建该映射 它会设置键和值：'map.set(this, value)'，其中 'this' 是指 'ThreadLocal' 的实例 应使用 'java.lang.ThreadLocal.remove()' 来释放资源。 示例： 'ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n  threadLocal.set(null);' 在应用快速修复后： 'threadLocal.remove();' 2023.2 最新变化",
                  "markdown": "报告以 null 作为实参的 `java.lang.ThreadLocal.set()`。\n\n此调用不会释放资源，并且可能导致内存泄漏。\n这可能是因为：\n\n* 首先，`ThreadLocal.set(null)` 会查找与当前线程相关联的映射。 如果没有此类映射，则会创建该映射\n* 它会设置键和值：`map.set(this, value)`，其中 `this` 是指 `ThreadLocal` 的实例\n\n应使用 `java.lang.ThreadLocal.remove()` 来释放资源。\n\n示例：\n\n\n      ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n      threadLocal.set(null);\n\n在应用快速修复后：\n\n\n      threadLocal.remove();\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ThreadLocalSetWithNull",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingJavadoc",
                "shortDescription": {
                  "text": "缺少 Javadoc"
                },
                "fullDescription": {
                  "text": "报告缺少 Javadoc 注释和标记。 示例： '/**\n   * 报告缺少 \"@param\"（如果配置）。\n   */\n  public void sample(int param){\n  }' 该快速修复会添加缺少的标记或缺少的 Javadoc 注释： '/**\n   * 报告缺少 \"@param\"（如果配置）。\n   * @param param\n   */\n  public void sample(int param){\n  }' 可以将检查配置为忽略弃用的元素或简单的访问器方法，如 'getField()' 或 'setField()'。 您还可以使用以下选项为方法、字段、类、软件包、模块等特定代码元素配置必需标记和最低要求的可见性。",
                  "markdown": "报告缺少 Javadoc 注释和标记。\n\n示例：\n\n\n      /**\n       * 报告缺少 \"@param\"（如果配置）。\n       */\n      public void sample(int param){\n      }\n\n该快速修复会添加缺少的标记或缺少的 Javadoc 注释：\n\n\n      /**\n       * 报告缺少 \"@param\"（如果配置）。\n       * @param param\n       */\n      public void sample(int param){\n      }\n\n\n可以将检查配置为忽略弃用的元素或简单的访问器方法，如 `getField()` 或 `setField()`。\n您还可以使用以下选项为方法、字段、类、软件包、模块等特定代码元素配置必需标记和最低要求的可见性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AwaitWithoutCorrespondingSignal",
                "shortDescription": {
                  "text": "没有相应 'signal()' 的 'await()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Condition.signal()' 或 'Condition.signalAll()' 调用的 'Condition.await()' 的调用。 在没有相应 'Condition.signal()' 的线程中调用 'Condition.await()' 可能导致该线程被禁用，直到它被中断或发生“可疑唤醒”为止。 此检查仅报告以当前类的目标字段为目标的调用。 示例： 'class Queue {\n    private final Condition isEmpty = ...;\n\n    void add(Object elem) {\n      // ...\n      // isEmpty.signal();\n      // ...\n    }\n\n    void remove(Object elem) throws InterruptedException {\n      // ...\n      isEmpty.await(); // 'await()' 不包含相应的 'signal()'/'signalAll()' 调用\n      // ...\n    }\n  }'",
                  "markdown": "报告对无法为之找到相应 `Condition.signal()` 或 `Condition.signalAll()` 调用的 `Condition.await()` 的调用。\n\n\n在没有相应 `Condition.signal()` 的线程中调用 `Condition.await()` 可能导致该线程被禁用，直到它被中断或发生\"可疑唤醒\"为止。\n\n此检查仅报告以当前类的目标字段为目标的调用。\n\n**示例：**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          // isEmpty.signal();\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          isEmpty.await(); // 'await()' 不包含相应的 'signal()'/'signalAll()' 调用\n          // ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AwaitWithoutCorrespondingSignal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java9RedundantRequiresStatement",
                "shortDescription": {
                  "text": "module-info 中的冗余 'requires' 指令"
                },
                "fullDescription": {
                  "text": "报告 Java Platform Module System 'module-info.java' 文件中的冗余 'requires' 指令。 当模块 'A' 需要模块 'B'，但模块 'A' 中的代码不从 'B' 导入任何软件包或类时，则 'requires' 指令冗余。 此外，所有模块都具有对 'java.base' 模块的隐式声明依赖，因此 'requires java.base;' 指令始终冗余。 该快速修复会删除冗余的 'requires' 指令。 如果删除的依赖项重新导出了实际使用的模块，则修复会为这些模块添加 'requires' 指令。 仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。 2017.1 最新变化",
                  "markdown": "报告 Java Platform Module System `module-info.java` 文件中的冗余 `requires` 指令。 当模块 `A` 需要模块 `B`，但模块 `A` 中的代码不从 `B` 导入任何软件包或类时，则 `requires` 指令冗余。 此外，所有模块都具有对 `java.base` 模块的隐式声明依赖，因此 `requires java.base;` 指令始终冗余。\n\n\n该快速修复会删除冗余的 `requires` 指令。\n如果删除的依赖项重新导出了实际使用的模块，则修复会为这些模块添加 `requires` 指令。\n\n仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java9RedundantRequiresStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLocalVariable",
                "shortDescription": {
                  "text": "冗余局部变量"
                },
                "fullDescription": {
                  "text": "报告不必要的、不会增加方法的可理解性的局部变量，包括： 立即返回的局部变量。 立刻赋值给另一个变量并且不再使用的局部变量。 始终与另一个局部变量或形参具有相同值的局部变量。 示例： 'boolean yes() {\n    boolean b = true;\n    return b;\n  }' 在应用快速修复后： 'boolean yes() {\n    return true;\n  }' 配置检查： 使用忽略立即返回或抛出的变量选项可以忽略立即返回或抛出的变量。 为清晰起见和易于调试，某些编码样式建议使用此类变量。 使用忽略具有注解的变量选项可以忽略注解的变量。",
                  "markdown": "报告不必要的、不会增加方法的可理解性的局部变量，包括：\n\n* 立即返回的局部变量。\n* 立刻赋值给另一个变量并且不再使用的局部变量。\n* 始终与另一个局部变量或形参具有相同值的局部变量。\n\n**示例：**\n\n\n      boolean yes() {\n        boolean b = true;\n        return b;\n      }\n\n在应用快速修复后：\n\n\n      boolean yes() {\n        return true;\n      }\n      \n配置检查：\n\n* 使用**忽略立即返回或抛出的变量**选项可以忽略立即返回或抛出的变量。 为清晰起见和易于调试，某些编码样式建议使用此类变量。\n* 使用**忽略具有注解的变量**选项可以忽略注解的变量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLocalVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BusyWait",
                "shortDescription": {
                  "text": "忙等待"
                },
                "fullDescription": {
                  "text": "报告在循环内发生的对 'java.lang.Thread.sleep()' 的调用。 此类调用表示“忙等待”。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。 示例： 'class X {\n     volatile int x;\n     public void waitX() throws Exception {\n      while (x > 0) {\n        Thread.sleep(10);// 警告：在循环中调用 'Thread.sleep()'，可能处于忙等待\n      }\n    }\n  }'",
                  "markdown": "报告在循环内发生的对 `java.lang.Thread.sleep()` 的调用。\n\n此类调用表示\"忙等待\"。 忙等待通常效率低下，并且可能导致意外死锁，因为忙等待线程不会释放锁定的资源。\n\n**示例：**\n\n\n      class X {\n         volatile int x;\n         public void waitX() throws Exception {\n          while (x > 0) {\n            Thread.sleep(10);// 警告：在循环中调用 'Thread.sleep()'，可能处于忙等待\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BusyWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopWithMissingComponent",
                "shortDescription": {
                  "text": "缺少组件的 'for' 循环"
                },
                "fullDescription": {
                  "text": "报告缺少初始化、条件或 update 子句的 'for' 循环。 某些编码样式禁止此类循环。 示例： 'for (int i = 0;;i++) {\n    //主体\n  }' 使用忽略集合迭代选项可以忽略使用迭代器的循环。 这是在 'for' 循环没有 update 子句的集合中迭代的标准方式。",
                  "markdown": "报告缺少初始化、条件或 update 子句的 `for` 循环。 某些编码样式禁止此类循环。\n\n示例：\n\n\n      for (int i = 0;;i++) {\n        //主体\n      }\n\n\n使用**忽略集合迭代** 选项可以忽略使用迭代器的循环。\n这是在 `for` 循环没有 update 子句的集合中迭代的标准方式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopWithMissingComponent",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverwrittenKey",
                "shortDescription": {
                  "text": "被覆盖的 Map、Set 或数组元素"
                },
                "fullDescription": {
                  "text": "报告覆盖 'Map' 键、'Set' 元素或 'add'/'put' 调用序列中的数组元素或使用类似于 'Set.of' 的 Java 9 工厂方法（将导致运行时异常）的代码。 这通常是复制粘贴错误所致。 示例： 'map.put(\"A\", 1);\n  map.put(\"B\", 2);\n  map.put(\"C\", 3);\n  map.put(\"D\", 4);\n  map.put(\"A\", 5); // 键 \"A\" 重复，覆盖以前写入的条目' 2017.3 最新变化",
                  "markdown": "报告覆盖 `Map` 键、`Set` 元素或 `add`/`put` 调用序列中的数组元素或使用类似于 `Set.of` 的 Java 9 工厂方法（将导致运行时异常）的代码。\n\n这通常是复制粘贴错误所致。\n\n**示例：**\n\n\n      map.put(\"A\", 1);\n      map.put(\"B\", 2);\n      map.put(\"C\", 3);\n      map.put(\"D\", 4);\n      map.put(\"A\", 5); // 键 \"A\" 重复，覆盖以前写入的条目\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverwrittenKey",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassMethodCount",
                "shortDescription": {
                  "text": "具有太多方法的匿名类"
                },
                "fullDescription": {
                  "text": "报告方法数超过指定最大值的匿名内部类。 具有大量方法的匿名类可能难以理解，应该提升为命名内部类。 使用方法计数限制字段可指定匿名内部类中允许的最大方法数。",
                  "markdown": "报告方法数超过指定最大值的匿名内部类。\n\n具有大量方法的匿名类可能难以理解，应该提升为命名内部类。\n\n使用**方法计数限制**字段可指定匿名内部类中允许的最大方法数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClassWithTooManyMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalOfNullableMisuse",
                "shortDescription": {
                  "text": "具有 null 或非 null 实参的 Optional.ofNullable"
                },
                "fullDescription": {
                  "text": "报告传递始终为 null 或始终为非 null 实参的 'Optional.ofNullable()' 用法。 在这种情况下使用 'Optional.ofNullable()' 没有意义：'Optional.empty()' 或 'Optional.of()' 应分别用于显式声明创建始终为空或始终非空的可选项的意图。 也可能是 'Optional.ofNullable()' 实参中存在错误，因此应对其进行检查。 示例： 'Optional<String> empty = Optional.ofNullable(null); // 应为 Optional.empty();\nOptional<String> present = Optional.ofNullable(\"value\"); // 应为 Optional.of(\"value\");' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告传递始终为 null 或始终为非 null 实参的 `Optional.ofNullable()` 用法。 在这种情况下使用 `Optional.ofNullable()` 没有意义：`Optional.empty()` 或 `Optional.of()` 应分别用于显式声明创建始终为空或始终非空的可选项的意图。 也可能是 `Optional.ofNullable()` 实参中存在错误，因此应对其进行检查。\n\n\n示例：\n\n\n    Optional<String> empty = Optional.ofNullable(null); // 应为 Optional.empty();\n    Optional<String> present = Optional.ofNullable(\"value\"); // 应为 Optional.of(\"value\"); \n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalOfNullableMisuse",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastToIncompatibleInterface",
                "shortDescription": {
                  "text": "转换为不兼容的类型"
                },
                "fullDescription": {
                  "text": "报告类型转换表达式，其中转换后的表达式具有既不扩展/实现转换类/接口类型的类/接口类型，也没有进行上述操作的子类。 此类结构很可能是错误的，并将在运行时抛出 'java.lang.ClassCastException'。 示例： 'interface A {}\n  interface Z {}\n  static class C {}\n\n  void x(C c) {\n    if (c instanceof Z) {\n      A a = ((A)c); // 转换为不兼容的接口 'A'\n    }\n  }'",
                  "markdown": "报告类型转换表达式，其中转换后的表达式具有既不扩展/实现转换类/接口类型的类/接口类型，也没有进行上述操作的子类。\n\n\n此类结构很可能是错误的，并将在运行时抛出 `java.lang.ClassCastException`。\n\n**示例：**\n\n\n      interface A {}\n      interface Z {}\n      static class C {}\n\n      void x(C c) {\n        if (c instanceof Z) {\n          A a = ((A)c); // 转换为不兼容的接口 'A'\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastToIncompatibleInterface",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableConditionalExpression",
                "shortDescription": {
                  "text": "可简化的条件表达式"
                },
                "fullDescription": {
                  "text": "报告并建议简化条件表达式。 示例： 'condition ? true : foo → condition || foo' 'condition ? false : foo → !condition && foo' 'condition ? foo : !foo → condition == foo' 'condition ? true : false → condition' 'a == b ? b : a → a' 'result != null ? result : null → result'",
                  "markdown": "报告并建议简化条件表达式。\n\n示例：\n\n    condition ? true : foo → condition || foo\n\n    condition ? false : foo → !condition && foo\n\n    condition ? foo : !foo → condition == foo\n\n    condition ? true : false → condition\n\n    a == b ? b : a → a\n\n    result != null ? result : null → result\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedMethodAccess",
                "shortDescription": {
                  "text": "未使用 'this' 限定的实例方法调用"
                },
                "fullDescription": {
                  "text": "报告对同一实例上未使用 'this' 限定的非 'static' 方法的调用。 示例： 'class Foo {\n    void bar() {}\n\n    void foo() {\n      bar();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    void bar() {}\n\n    void foo() {\n      this.bar();\n    }\n  }'",
                  "markdown": "报告对同一实例上未使用 `this` 限定的非 `static` 方法的调用。\n\n**示例：**\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          bar();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          this.bar();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedMethodAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofIncompatibleInterface",
                "shortDescription": {
                  "text": "具有不兼容类型的 'instanceof'"
                },
                "fullDescription": {
                  "text": "报告 'instanceof' 表达式，其中检查的表达式的类/接口类型既不扩展/实现 'instanceof' 表达式右侧的类/接口类型，也没有进行上述操作的子类。 尽管它可以用于库代码，但此类构造很可能是错误的，因为项目中声明的任何类的任何实例都无法通过此 'instanceof' 测试。 示例： 'class Foo { }\n\n  interface Bar { }\n  \n  class Main {\n      void test(Foo f, Bar b) {\n          if (f instanceof Bar) { // 问题\n              System.out.println(\"fail\");\n          }\n          if (b instanceof Foo) { // 问题\n              System.out.println(\"fail\");\n          }\n      }\n  }'",
                  "markdown": "报告 `instanceof` 表达式，其中检查的表达式的类/接口类型既不扩展/实现 `instanceof` 表达式右侧的类/接口类型，也没有进行上述操作的子类。\n\n\n尽管它可以用于库代码，但此类构造很可能是错误的，因为项目中声明的任何类的任何实例都无法通过此 `instanceof` 测试。\n\n**示例：**\n\n\n      class Foo { }\n\n      interface Bar { }\n      \n      class Main {\n          void test(Foo f, Bar b) {\n              if (f instanceof Bar) { // 问题\n                  System.out.println(\"fail\");\n              }\n              if (b instanceof Foo) { // 问题\n                  System.out.println(\"fail\");\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofIncompatibleInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionalExpressionCanBeFolded",
                "shortDescription": {
                  "text": "函数表达式可以折叠"
                },
                "fullDescription": {
                  "text": "报告指向具有自己的函数接口类型的方法的方法引用或 lambda 表达式，因此您可以通过替换为它们的限定符来移除不必要的对象分配。 示例： 'SwingUtilities.invokeLater(r::run);\n  SwingUtilities.invokeAndWait(() -> r.run());' 在应用快速修复后： 'SwingUtilities.invokeLater(r);\n  SwingUtilities.invokeAndWait(r);' 仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。",
                  "markdown": "报告指向具有自己的函数接口类型的方法的方法引用或 lambda 表达式，因此您可以通过替换为它们的限定符来移除不必要的对象分配。\n\n示例：\n\n\n      SwingUtilities.invokeLater(r::run);\n      SwingUtilities.invokeAndWait(() -> r.run());\n\n在应用快速修复后：\n\n\n      SwingUtilities.invokeLater(r);\n      SwingUtilities.invokeAndWait(r);\n\n仅当项目或模块的语言级别为 8 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionalExpressionCanBeFolded",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomClassloader",
                "shortDescription": {
                  "text": "声明了自定义的 'ClassLoader'"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.ClassLoader' 的用户定义子类。 虽然不一定代表安全漏洞，但应彻底检查这种类是否存在可能的安全问题。",
                  "markdown": "报告 `java.lang.ClassLoader` 的用户定义子类。\n\n\n虽然不一定代表安全漏洞，但应彻底检查这种类是否存在可能的安全问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomClassloader",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarySuperConstructor",
                "shortDescription": {
                  "text": "对 'super()' 的调用不必要"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对无实参超类构造函数的调用。 此类调用不必要，可以移除。 示例： 'class Foo {\n    Foo() {\n      super();\n    }\n  }' 在应用快速修复后： 'class Foo {\n    Foo() {\n    }\n  }'",
                  "markdown": "报告在对象构造期间对无实参超类构造函数的调用。\n\n此类调用不必要，可以移除。\n\n**示例：**\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        Foo() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCallToSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThisEscapedInConstructor",
                "shortDescription": {
                  "text": "对象构造中转义的 'this' 引用"
                },
                "fullDescription": {
                  "text": "报告对象初始化期间可能的 'this' 转义。 当 'this' 用作构造函数或初始值设定项中的方法实参或赋值对象时，就会发生转义。 此类转义可能会导致难以捉摸的错误，因为现在该对象在不保证得到初始化的上下文中可用。 示例： 'class Foo {\n    {\n      System.out.println(this);\n    }\n  }'",
                  "markdown": "报告对象初始化期间可能的 `this` 转义。 当 `this` 用作构造函数或初始值设定项中的方法实参或赋值对象时，就会发生转义。 此类转义可能会导致难以捉摸的错误，因为现在该对象在不保证得到初始化的上下文中可用。\n\n**示例：**\n\n\n      class Foo {\n        {\n          System.out.println(this);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThisEscapedInObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonPublicClone",
                "shortDescription": {
                  "text": "'clone()' 方法不是 'public'"
                },
                "fullDescription": {
                  "text": "报告 'protected' 而不是 'public' 的 'clone()' 方法。 从 'java.lang.Object' 重写 'clone()' 方法时，应将该方法设为 'public'，以便从软件包外部的非子类进行访问。",
                  "markdown": "报告 `protected` 而不是 `public` 的 `clone()` 方法。\n\n从 `java.lang.Object` 重写 `clone()` 方法时，应将该方法设为 `public`，以便从软件包外部的非子类进行访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonPublicClone",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 89,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfCanBeSwitch",
                "shortDescription": {
                  "text": "'if' 可被替换为 'switch'"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'switch' 语句的 'if' 语句。 替换结果通常更简短、更清晰。 示例： 'void test(String str) {\n    if (str.equals(\"1\")) {\n      System.out.println(1);\n    } else if (str.equals(\"2\")) {\n      System.out.println(2);\n    } else if (str.equals(\"3\")) {\n      System.out.println(3);\n    } else {\n      System.out.println(4);\n    }\n  }' 在应用快速修复后： 'void test(String str) {\n    switch (str) {\n      case \"1\" -> System.out.println(1);\n      case \"2\" -> System.out.println(2);\n      case \"3\" -> System.out.println(3);\n      default -> System.out.println(4);\n    }\n  }' 仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。 使用 'if' 条件分支的最小数量字段可指定必须报告 'if' 语句的最小 'if' 条件分支数。 注意，不计入终端 'else' 分支（无 'if'）。 使用对数字启用 switch 建议选项，可以对基元和装箱的数字及字符启用 'switch' 语句建议。 使用对枚举启用 switch 建议选项，可以对 'enum' 常量启用 'switch' 语句建议。 使用仅对 null-safe 表达式启用建议选项，可仅建议不能引入 'NullPointerException' 的 'switch' 语句。",
                  "markdown": "报告可以替换为 `switch` 语句的 `if` 语句。\n\n替换结果通常更简短、更清晰。\n\n**示例：**\n\n\n      void test(String str) {\n        if (str.equals(\"1\")) {\n          System.out.println(1);\n        } else if (str.equals(\"2\")) {\n          System.out.println(2);\n        } else if (str.equals(\"3\")) {\n          System.out.println(3);\n        } else {\n          System.out.println(4);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void test(String str) {\n        switch (str) {\n          case \"1\" -> System.out.println(1);\n          case \"2\" -> System.out.println(2);\n          case \"3\" -> System.out.println(3);\n          default -> System.out.println(4);\n        }\n      }\n      \n仅当项目或模块的语言级别为 7 或更高时，此检查才会报告。\n\n使用 **'if' 条件分支的最小数量** 字段可指定必须报告 `if` 语句的最小 `if` 条件分支数。 注意，不计入终端 `else` 分支（无 `if`）。\n\n\n使用**对数字启用 switch 建议** 选项，可以对基元和装箱的数字及字符启用 `switch` 语句建议。\n\n\n使用**对枚举启用 switch 建议** 选项，可以对 `enum` 常量启用 `switch` 语句建议。\n\n\n使用**仅对 null-safe 表达式启用建议** 选项，可仅建议不能引入 `NullPointerException` 的 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfCanBeSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级迁移帮助",
                      "index": 51,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteRecursion",
                "shortDescription": {
                  "text": "无限递归"
                },
                "fullDescription": {
                  "text": "报告除非抛出异常否则无限调用自身的方法。 此检查报告的方法不能正常返回。 虽然此类行为可能是有意为之，但在许多情况下，可能纯属疏忽。 示例： 'int baz() {\n      return baz();\n  }'",
                  "markdown": "报告除非抛出异常否则无限调用自身的方法。\n\n\n此检查报告的方法不能正常返回。\n虽然此类行为可能是有意为之，但在许多情况下，可能纯属疏忽。\n\n**示例：**\n\n      int baz() {\n          return baz();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteRecursion",
                    "cweIds": [
                      674,
                      835
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedIsStillUsed",
                "shortDescription": {
                  "text": "弃用的成员仍在使用"
                },
                "fullDescription": {
                  "text": "报告代码中使用的已弃用的类、方法和字段。 示例： 'class MyCode {\n  @Deprecated\n  void oldMethod() {}// 警告：\"弃用的成员仍在使用\"\n\n  void newMethod() {\n    oldMethod(); // 被遗忘的用法\n  }\n  }' 已弃用的元素中的用法将被忽略。 注意：由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。",
                  "markdown": "报告代码中使用的已弃用的类、方法和字段。\n\n示例：\n\n\n      class MyCode {\n      @Deprecated\n      void oldMethod() {}// 警告：\"弃用的成员仍在使用\"\n\n      void newMethod() {\n        oldMethod(); // 被遗忘的用法\n      }\n      }\n\n已弃用的元素中的用法将被忽略。\n\n**注意**：由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedIsStillUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantComparatorComparing",
                "shortDescription": {
                  "text": "可以简化 Comparator 方法"
                },
                "fullDescription": {
                  "text": "报告可简化的 'Comparator' 连结符构造。 示例： 'c.thenComparing(Comparator.comparing(function));\n\n  Comparator.comparing(Map.Entry::getKey);\n\n  Collections.max(list, Comparator.reverseOrder());' 在应用快速修复后： 'c.thenComparing(function)\n\n  Map.Entry.comparingByKey()\n\n  Collections.min(list, Comparator.naturalOrder());' 2018.1 最新变化",
                  "markdown": "报告可简化的 `Comparator` 连结符构造。\n\n示例：\n\n\n      c.thenComparing(Comparator.comparing(function));\n\n      Comparator.comparing(Map.Entry::getKey);\n\n      Collections.max(list, Comparator.reverseOrder());\n\n在应用快速修复后：\n\n\n      c.thenComparing(function)\n\n      Map.Entry.comparingByKey()\n\n      Collections.min(list, Comparator.naturalOrder());\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantComparatorComparing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VariableNotUsedInsideIf",
                "shortDescription": {
                  "text": "'if' 内未使用检查为 'null' 的引用"
                },
                "fullDescription": {
                  "text": "报告对在 'if' 语句或条件表达式的条件中检查可 null 性但未在该 'if' 语句内部使用的变量的引用。 这通常意味着不必要进行该检查，或者在 'if' 语句中没有错误引用变量。 示例： 'void test(Integer i) {\n    if (i != null) { // 这里的 'i' 没有在 'if' 语句内部使用\n      System.out.println();\n    }\n  }'",
                  "markdown": "报告对在 `if` 语句或条件表达式的条件中检查可 null 性但未在该 `if` 语句内部使用的变量的引用。\n\n\n这通常意味着不必要进行该检查，或者在 `if` 语句中没有错误引用变量。\n\n**示例：**\n\n\n      void test(Integer i) {\n        if (i != null) { // 这里的 'i' 没有在 'if' 语句内部使用\n          System.out.println();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VariableNotUsedInsideIf",
                    "cweIds": [
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionAddAllCanBeReplacedWithConstructor",
                "shortDescription": {
                  "text": "冗余的 'Collection.addAll()' 调用"
                },
                "fullDescription": {
                  "text": "在使用无参构造函数实例化集合后，立即报告 'Collection.addAll()' 和 'Map.putAll()' 调用。 此类结构可被替换为对形参化构造函数的单次调用，从而简化代码。 此外，对于某些集合，替换可能会更高效。 示例： 'Set<String> set = new HashSet<>();\n  set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));' 在应用快速修复后： 'Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));' 默认支持 JDK 集合类。 此外，还可以使用要检查的类面板指定其他类。",
                  "markdown": "在使用无参构造函数实例化集合后，立即报告 `Collection.addAll()` 和 `Map.putAll()` 调用。\n\n此类结构可被替换为对形参化构造函数的单次调用，从而简化代码。 此外，对于某些集合，替换可能会更高效。\n\n**示例：**\n\n\n      Set<String> set = new HashSet<>();\n      set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n在应用快速修复后：\n\n\n      Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n\n默认支持 JDK 集合类。\n此外，还可以使用**要检查的类**面板指定其他类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionAddAllCanBeReplacedWithConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultipleReturnPointsPerMethod",
                "shortDescription": {
                  "text": "具有多个返回点的方法"
                },
                "fullDescription": {
                  "text": "报告 'return' 点数超过指定最大值的方法。 具有太多 'return' 点的方法可能令人困惑且难以重构。 一个 'return' 点可以是 'return' 语句，也可以是从 'void' 方法或构造函数底部的直落。 示例： 如果只允许两个 'return' 语句，则报告以下方法： 'void doSmth(User[] users) {\n    for (User user : users) {\n      if (cond1(user)) {\n        user.setId(getId());\n        return;\n      } else if (cond2(user)) {\n        if (cond3(user)) {\n          user.setId(getId());\n          return;\n        }\n      }\n    }\n  }' 请考虑重写该方法，使其更容易理解： 'void doSmth(User[] users) {\n    for (User user : users) {\n      if (cond1(user) || cond2(user) && cond3(user)) {\n        user.setId(getId());\n        return;\n      }\n    }\n  }' 配置检查： 使用 return 点限制字段可指定方法允许的最大 'return' 点数。 使用忽略临界子句选项可忽略临界子句。 临界子句是只包含 'return' 语句的 'if' 语句 使用对 'equals()' 方法忽略选项可忽略 'equals()' 方法中的 'return' 点。",
                  "markdown": "报告 `return` 点数超过指定最大值的方法。 具有太多 `return` 点的方法可能令人困惑且难以重构。\n\n一个 `return` 点可以是 `return` 语句，也可以是从 `void` 方法或构造函数底部的直落。\n\n**示例：**\n\n如果只允许两个 `return` 语句，则报告以下方法：\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user)) {\n            user.setId(getId());\n            return;\n          } else if (cond2(user)) {\n            if (cond3(user)) {\n              user.setId(getId());\n              return;\n            }\n          }\n        }\n      }\n\n请考虑重写该方法，使其更容易理解：\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user) || cond2(user) && cond3(user)) {\n            user.setId(getId());\n            return;\n          }\n        }\n      }\n\n配置检查：\n\n* 使用 **return 点限制** 字段可指定方法允许的最大 `return` 点数。\n* 使用**忽略临界子句** 选项可忽略临界子句。 临界子句是只包含 `return` 语句的 `if` 语句\n* 使用**对 'equals()' 方法忽略** 选项可忽略 `equals()` 方法中的 `return` 点。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMultipleReturnPoints",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousMethodCalls",
                "shortDescription": {
                  "text": "可疑的集合方法调用"
                },
                "fullDescription": {
                  "text": "报告实际实参类型与集合的元素类型不一致的形参化集合的方法调用。 示例： 'List<Integer> list = getListOfElements();\n  list.remove(\"\"); //remove 被高亮显示' 在检查设置中，可以禁用对可能正确的代码发出警告，如下所示： 'public boolean accept(Map<Integer, String> map, Object key) {\n    return map.containsKey(key);\n  }'",
                  "markdown": "报告实际实参类型与集合的元素类型不一致的形参化集合的方法调用。\n\n**示例：**\n\n\n      List<Integer> list = getListOfElements();\n      list.remove(\"\"); //remove 被高亮显示\n\n\n在检查设置中，可以禁用对可能正确的代码发出警告，如下所示：\n\n\n      public boolean accept(Map<Integer, String> map, Object key) {\n        return map.containsKey(key);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousMethodCalls",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForwardCompatibility",
                "shortDescription": {
                  "text": "前向兼容性"
                },
                "fullDescription": {
                  "text": "报告未来 Java 版本中可能无法编译的 Java 代码结构。 报告的问题如下： 使用 'assert'、'enum' 或 '_' 作为标识符 使用 'var'、'yield' 或 'record' 受限标识符作为类型名称 对 'yield' 方法的非限定调用 'module-info.java' 内部的 'requires java.base' 语句的修饰符 import 语句之间的冗余分号 示例： '// 这个以前合法的类无法在 Java 14 中编译，\n  // 因为 'yield' 变成了一个受限的标识符。\n  public class yield {}' 及时解决这些问题，可以简化向未来 Java 版本的迁移。",
                  "markdown": "报告未来 Java 版本中可能无法编译的 Java 代码结构。\n\n报告的问题如下：\n\n* 使用 `assert`、`enum` 或 `_` 作为标识符\n* 使用 `var`、`yield` 或 `record` 受限标识符作为类型名称\n* 对 `yield` 方法的非限定调用\n* `module-info.java` 内部的 `requires java.base` 语句的修饰符\n* import 语句之间的冗余分号\n\n**示例：**\n\n\n      // 这个以前合法的类无法在 Java 14 中编译，\n      // 因为 'yield' 变成了一个受限的标识符。\n      public class yield {} \n\n及时解决这些问题，可以简化向未来 Java 版本的迁移。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForwardCompatibility",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 114,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DiamondCanBeReplacedWithExplicitTypeArguments",
                "shortDescription": {
                  "text": "diamond 可被替换为显式类型实参"
                },
                "fullDescription": {
                  "text": "报告泛型类的实例化，其中使用 <> 符号（菱形）代替类型形参。 快速修复会将 <>（菱形）替换为显式类型形参。 示例： 'List <String> list = new ArrayList<>()' 在应用快速修复后： 'List <String> list = new ArrayList<String>()' 菱形运算符在 Java 7 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告泛型类的实例化，其中使用 **\\<\\>** 符号（菱形）代替类型形参。\n\n快速修复会将 **\\<\\>**（菱形）替换为显式类型形参。\n\n示例：\n\n    List <String> list = new ArrayList<>()\n\n在应用快速修复后：\n\n    List <String> list = new ArrayList<String>()\n\n\n*菱形运算符*在 Java 7 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DiamondCanBeReplacedWithExplicitTypeArguments",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfProcessBuilder",
                "shortDescription": {
                  "text": "使用 'java.lang.ProcessBuilder' 类"
                },
                "fullDescription": {
                  "text": "报告使用 'java.lang.ProcessBuilder' 的情况，由于可执行文件、环境变量、命令行实参及其转义的路径可能会因操作系统而异，可能无法在操作系统之间移植。",
                  "markdown": "报告使用 `java.lang.ProcessBuilder` 的情况，由于可执行文件、环境变量、命令行实参及其转义的路径可能会因操作系统而异，可能无法在操作系统之间移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfProcessBuilder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaRequiresAutoModule",
                "shortDescription": {
                  "text": "依赖于自动模块"
                },
                "fullDescription": {
                  "text": "报告 'requires' 指令中自动模块的用法。 自动模块不可靠，因为它可能依赖于类路径中的类型，而且当它转换为显式模块时，它的名称和导出的软件包可能会改变。 对应于 '-Xlint:requires-automatic' 和 '-Xlint:requires-transitive-automatic' Javac 选项。 第一个选项增加了对何时使用自动模块的了解。 第二个选项则是警示模块的作者，建立自动模块的隐含可读性将使该模块的用户面临风险。 示例： '//module-info.java\n  module org.printer {\n    requires transitive drivers.corp.org; // 在 'drivers.corp.org' 为自动模块时报告\n  }' 使用仅高亮显示传递依赖选项，可仅对传递依赖发出警告。 此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。",
                  "markdown": "报告 `requires` 指令中自动模块的用法。\n\n自动模块不可靠，因为它可能依赖于类路径中的类型，而且当它转换为显式模块时，它的名称和导出的软件包可能会改变。\n\n对应于 `-Xlint:requires-automatic` 和 `-Xlint:requires-transitive-automatic` Javac 选项。\n第一个选项增加了对何时使用自动模块的了解。\n第二个选项则是警示模块的作者，建立自动模块的隐含可读性将使该模块的用户面临风险。\n\n**示例：**\n\n\n      //module-info.java\n      module org.printer {\n        requires transitive drivers.corp.org; // 在 'drivers.corp.org' 为自动模块时报告\n      }\n\n\n使用**仅高亮显示传递依赖**选项，可仅对传递依赖发出警告。\n\n此检查取决于 Java 功能 '模块'，该功能自 Java 9 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "requires-transitive-automatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 9",
                      "index": 67,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExcessiveRangeCheck",
                "shortDescription": {
                  "text": "过度范围检查"
                },
                "fullDescription": {
                  "text": "报告检查值范围的条件链，这些条件链可以简化为单个检查。 该快速修复会将条件链替换为简化的表达式： 示例： 'x > 2 && x < 4' 在应用快速修复后： 'x == 3' 示例： 'arr.length == 0 || arr.length > 1' 在应用快速修复后： 'arr.length != 1' 2019.1 最新变化",
                  "markdown": "报告检查值范围的条件链，这些条件链可以简化为单个检查。\n\n该快速修复会将条件链替换为简化的表达式：\n\n示例：\n\n\n      x > 2 && x < 4\n\n在应用快速修复后：\n\n\n      x == 3\n\n示例：\n\n\n      arr.length == 0 || arr.length > 1\n\n在应用快速修复后：\n\n\n      arr.length != 1\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExcessiveRangeCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenation",
                "shortDescription": {
                  "text": "字符串串联"
                },
                "fullDescription": {
                  "text": "报告 'String' 串联。 在国际化环境中，串联可能不正确，可被替换为 'java.text.MessageFormat' 或类似的类的用法。 示例： 'String getMessage(String string, int number) {\n    return string + number;\n  }'",
                  "markdown": "报告 `String` 串联。 在国际化环境中，串联可能不正确，可被替换为 `java.text.MessageFormat` 或类似的类的用法。\n\n**示例：**\n\n\n      String getMessage(String string, int number) {\n        return string + number;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassCanBeRecord",
                "shortDescription": {
                  "text": "类可以是记录类"
                },
                "fullDescription": {
                  "text": "报告可以转换为记录类的类。 记录类侧重于对不可变数据进行建模，而不是对可扩展行为进行建模。 数据驱动方法的自动隐式实现（例如 'equals()' 和访问器）有助于减少样板代码。 请注意，不是每个类都可以是记录类。 以下是一些限制： 该类必须是顶级类，并且不能有子类。 类中的所有非 static 字段必须为 final。 不能存在初始值设定项、泛型构造函数和原生方法。 有关记录类的完整描述，请参阅 < Java 语言规范。 示例： 'class Point {\n    private final double x;\n    private final double y;\n\n    Point(double x, double y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    double getX() {\n      return x;\n    }\n\n    double getY() {\n      return y;\n    }\n  }' 在应用快速修复后： 'record Point(int x, int y) {\n  }' 启用建议重命名访问器方法选项可自动将 'getX()'/'isX()' 访问器重命名为 'x()'。 使用如果成员变得更易于访问选项可指定当转换将使成员更易于访问时要执行的操作： 选择不建议转换选项可在成员变得更易于访问时不进行转换。 选择显示冲突视图选项可显示受影响的成员并要求继续。 在批处理模式下，将不建议进行转换。 选择静默转换选项可在需要时以静默方式提高可访问性。 使用禁止转换有以下注解的类列表可在要转换的类中排除其注解匹配指定模式的类。 2020.3 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告可以转换为记录类的类。\n\n记录类侧重于对不可变数据进行建模，而不是对可扩展行为进行建模。\n数据驱动方法的自动隐式实现（例如 `equals()` 和访问器）有助于减少样板代码。\n\n\n请注意，不是每个类都可以是记录类。 以下是一些限制：\n\n* 该类必须是顶级类，并且不能有子类。\n* 类中的所有非 static 字段必须为 final。\n* 不能存在初始值设定项、泛型构造函数和原生方法。\n\n有关记录类的完整描述，请参阅 \\<\n[Java 语言规范](https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10)。\n\n示例：\n\n\n      class Point {\n        private final double x;\n        private final double y;\n\n        Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        double getX() {\n          return x;\n        }\n\n        double getY() {\n          return y;\n        }\n      }\n\n在应用快速修复后：\n\n\n      record Point(int x, int y) {\n      }\n\n启用**建议重命名访问器方法** 选项可自动将 `getX()`/`isX()` 访问器重命名为 `x()`。\n\n\n使用**如果成员变得更易于访问**选项可指定当转换将使成员更易于访问时要执行的操作：\n\n* 选择**不建议转换**选项可在成员变得更易于访问时不进行转换。\n* 选择**显示冲突视图**选项可显示受影响的成员并要求继续。 在批处理模式下，将不建议进行转换。\n* 选择**静默转换**选项可在需要时以静默方式提高可访问性。\n\n使用**禁止转换有以下注解的类**列表可在要转换的类中排除其注解匹配指定模式的类。\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ClassCanBeRecord",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 16",
                      "index": 153,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantAssertArgument",
                "shortDescription": {
                  "text": "常量断言实参"
                },
                "fullDescription": {
                  "text": "报告 'assertTrue()'、'assertFalse()'、'assertNull()' 和 'assertNotNull()' 调用中的常量实参。 对这些包含常量实参的方法的调用要么总是成功，要么总是失败。 此类语句很容易在重构后遗留下来，并且可能并非有意为之。 示例： 'assertNotNull(\"foo\");'",
                  "markdown": "报告 `assertTrue()`、`assertFalse()`、`assertNull()` 和 `assertNotNull()` 调用中的常量实参。\n\n\n对这些包含常量实参的方法的调用要么总是成功，要么总是失败。\n此类语句很容易在重构后遗留下来，并且可能并非有意为之。\n\n**示例：**\n\n\n      assertNotNull(\"foo\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantAssertArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 98,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RuntimeExec",
                "shortDescription": {
                  "text": "调用 'Runtime.exec()'"
                },
                "fullDescription": {
                  "text": "报告对 'Runtime.exec()' 或其任何变体的调用。 对 'Runtime.exec()' 的调用本质上不可移植。",
                  "markdown": "报告对 `Runtime.exec()` 或其任何变体的调用。 对 `Runtime.exec()` 的调用本质上不可移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToRuntimeExec",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticInitializerReferencesSubClass",
                "shortDescription": {
                  "text": "static 初始值设定项引用子类"
                },
                "fullDescription": {
                  "text": "报告在 static 初始值设定项或 static 字段中引用其子类的类。 此类引用可能在多线程环境（即一个线程试图加载超类，另一个线程同时试图加载子类）中引起 JVM 级死锁。 示例： 'class Parent {\n    static final Child field = new Child();\n  }\n  class Child extends Parent { }'",
                  "markdown": "报告在 static 初始值设定项或 static 字段中引用其子类的类。\n\n此类引用可能在多线程环境（即一个线程试图加载超类，另一个线程同时试图加载子类）中引起 JVM 级死锁。\n\n**示例：**\n\n\n      class Parent {\n        static final Child field = new Child();\n      }\n      class Child extends Parent { }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticInitializerReferencesSubClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingDeprecatedAnnotationOnScheduledForRemovalApi",
                "shortDescription": {
                  "text": "已计划移除的 API 上缺少 '@Deprecated' 注解"
                },
                "fullDescription": {
                  "text": "报告使用 '@ApiStatus.ScheduledForRemoval'（没有 '@Deprecated'）标记的声明。 示例： '@ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }' 应用快速修复后，结果如下所示： '@Deprecated\n  @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }'",
                  "markdown": "报告使用 `@ApiStatus.ScheduledForRemoval`（没有 `@Deprecated`）标记的声明。\n\n示例：\n\n\n      @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n      public void myLegacyMethod() { }\n\n应用快速修复后，结果如下所示：\n\n\n      @Deprecated\n      @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n      public void myLegacyMethod() { }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MissingDeprecatedAnnotationOnScheduledForRemovalApi",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantDeclaredInAbstractClass",
                "shortDescription": {
                  "text": "在 'abstract' 类中声明的常量"
                },
                "fullDescription": {
                  "text": "报告在 abstract 类中声明的常量（'public static final' 字段）。 有些编码标准要求在接口中声明常量。",
                  "markdown": "报告在 abstract 类中声明的常量（`public static final` 字段）。\n\n有些编码标准要求在接口中声明常量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantDeclaredInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SubtractionInCompareTo",
                "shortDescription": {
                  "text": "'compareTo()' 中的减法"
                },
                "fullDescription": {
                  "text": "报告 'compareTo()' 方法和实现 'java.util.Comparator.compare()' 的方法中的减法。 虽然使用整数减法的结果作为 'compareTo()' 方法的结果是一种惯常做法，但在整数溢出的情况下，此结构可能会导致难以捉摸的错误。 在大多数情况下，更好的做法是直接比较整数值并返回 '-1'、'0' 或 '1' 。 四舍五入可能导致精度损失，因此也会报告直接转换为整型的浮点值减法。 在静态地确定值范围有限并且决不会发生溢出时，该检查不会报告。 此外，对 'int' 大于或等于 '0' 的数字执行减法绝不会溢出。 因此，在这样的情况下此检查不发出警告。 总是返回零或更大值的方法可以用 'javax.annotation.Nonnegative' 注解进行标记，或者在此检查的选项中指定。 示例： 'class DoubleHolder implements Comparable<DoubleHolder> {\n    double d;\n    public int compareTo(DoubleHolder that) {\n        return (int)(this.d - that.d);\n    }\n }' 这是一个无警告的示例，因为已知 'String.length()' 非负： 'class A implements Comparable<A> {\n    final String s = \"\";\n    public int compareTo(A a) {\n        return s.length() - a.s.length();\n    }\n }' 使用这些选项可列出在减法中安全使用的方法。 方法返回始终大于或等于 '0' 的 'int' 值时，表明方法就是安全的。",
                  "markdown": "报告 `compareTo()` 方法和实现 `java.util.Comparator.compare()` 的方法中的减法。\n\n\n虽然使用整数减法的结果作为 `compareTo()` 方法的结果是一种惯常做法，但在整数溢出的情况下，此结构可能会导致难以捉摸的错误。\n在大多数情况下，更好的做法是直接比较整数值并返回 `-1`、`0` 或 `1` 。\n\n\n四舍五入可能导致精度损失，因此也会报告直接转换为整型的浮点值减法。\n\n\n在静态地确定值范围有限并且决不会发生溢出时，该检查不会报告。\n此外，对 `int` 大于或等于 `0` 的数字执行减法绝不会溢出。\n因此，在这样的情况下此检查不发出警告。\n\n\n总是返回零或更大值的方法可以用 `javax.annotation.Nonnegative` 注解进行标记，或者在此检查的选项中指定。\n\n**示例：**\n\n\n      class DoubleHolder implements Comparable<DoubleHolder> {\n        double d;\n        public int compareTo(DoubleHolder that) {\n            return (int)(this.d - that.d);\n        }\n     }\n\n这是一个无警告的示例，因为已知 `String.length()` 非负：\n\n\n      class A implements Comparable<A> {\n        final String s = \"\";\n        public int compareTo(A a) {\n            return s.length() - a.s.length();\n        }\n     }\n\n\n使用这些选项可列出在减法中安全使用的方法。\n方法返回始终大于或等于 `0` 的 `int` 值时，表明方法就是安全的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SubtractionInCompareTo",
                    "cweIds": [
                      682
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConnectionResource",
                "shortDescription": {
                  "text": "集合已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未在 'try' 块前打开并在相应的 'finally' 块中关闭的 Java ME 'javax.microedition.io.Connection' 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。 示例： 'void example() throws IOException {\n    Connection c = Connector.open(\"foo\");\n  }'",
                  "markdown": "报告未在 `try` 块前打开并在相应的 `finally` 块中关闭的 Java ME `javax.microedition.io.Connection` 资源。 如果在资源关闭之前抛出异常，此类资源可能会被无意泄漏。\n\n**示例：**\n\n\n      void example() throws IOException {\n        Connection c = Connector.open(\"foo\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConnectionOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanVariableAlwaysNegated",
                "shortDescription": {
                  "text": "布尔变量始终反转"
                },
                "fullDescription": {
                  "text": "报告使用其值时总是否定的布尔变量或字段。 示例： 'void m() {\n        boolean b = true; //始终反转布尔变量 'b'\n        System.out.println(!b);\n      }'",
                  "markdown": "报告使用其值时总是否定的布尔变量或字段。\n\n示例：\n\n\n          void m() {\n            boolean b = true; //始终反转布尔变量 'b'\n            System.out.println(!b);\n          }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanVariableAlwaysNegated",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsAnnotation",
                "shortDescription": {
                  "text": "类扩展注解接口"
                },
                "fullDescription": {
                  "text": "报告声明为注解接口的实现或扩展的类。 尽管扩展注解接口是合法之举，但通常是偶然为之，并且结果不能作为注解使用。 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告声明为注解接口的实现或扩展的类。\n\n尽管扩展注解接口是合法之举，但通常是偶然为之，并且结果不能作为注解使用。\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "unused",
                "shortDescription": {
                  "text": "未使用的声明"
                },
                "fullDescription": {
                  "text": "报告未使用或无法从入口点访问的类、方法或字段。 入口点可以是 main 方法、测试、来自指定范围之外的类、可从 'module-info.java' 访问的类，等等。 可以通过使用名称模式或注解来配置自定义入口点。 示例： 'public class Department {\n    private Organization myOrganization;\n  }' 在本例中，'Department' 显式引用 'Organization'，但如果 'Department' 类本身未使用，那么该检查将报告这两个类。 该检查还会报告其方法、所有方法实现和重写器未使用的形参，以及已声明但未使用的局部变量。 注意：在编辑器中高亮显示代码期间可能不会报告某些未使用的成员。 由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。 要查看所有结果，请从主菜单中选择代码 | 检查代码或代码 | 分析代码 | 按名称运行检查来运行检查。 使用下面的可见性设置可以配置要报告的成员。 例如，配置报告 'private' 方法只表明将报告 'private' 内部类的 'public' 方法，顶层类的 'protected' 方法将被忽略。 使用入口点标签页可以配置检查运行期间要考虑的入口点。 在检查结果准备就绪后，可以手动添加入口点。 如果您的代码使用不受支持的框架，可以选择以下几个选项： 如果框架依赖于注解，使用注解…按钮可配置框架注解。 如果框架不依赖于注解，可尝试配置框架应有的类名模式。 这样，框架内部项可访问的注解代码将被视为已使用。",
                  "markdown": "报告未使用或无法从入口点访问的类、方法或字段。\n\n入口点可以是 main 方法、测试、来自指定范围之外的类、可从 `module-info.java` 访问的类，等等。 可以通过使用名称模式或注解来配置自定义入口点。\n\n**示例：**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\n在本例中，`Department` 显式引用 `Organization`，但如果 `Department` 类本身未使用，那么该检查将报告这两个类。\n\n\n该检查还会报告其方法、所有方法实现和重写器未使用的形参，以及已声明但未使用的局部变量。\n\n\n**注意** ：在编辑器中高亮显示代码期间可能不会报告某些未使用的成员。 由于性能原因，仅当非 private 成员的名称很少出现在项目中时，才会对其进行检查。\n要查看所有结果，请从主菜单中选择**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**来运行检查。\n\n使用下面的可见性设置可以配置要报告的成员。 例如，配置报告 `private` 方法只表明将报告 `private` 内部类的 `public` 方法，顶层类的 `protected` 方法将被忽略。\n\n\n使用**入口点**标签页可以配置检查运行期间要考虑的入口点。\n\n在检查结果准备就绪后，可以手动添加入口点。\n\n如果您的代码使用不受支持的框架，可以选择以下几个选项：\n\n* 如果框架依赖于注解，使用**注解...**按钮可配置框架注解。\n* 如果框架不依赖于注解，可尝试配置框架应有的类名模式。\n\n这样，框架内部项可访问的注解代码将被视为已使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedStringCase",
                "shortDescription": {
                  "text": "'String' 操作中不匹配的大小写"
                },
                "fullDescription": {
                  "text": "报告因为在仅大写的字符串中搜索小写字符或在仅小写的字符串中搜索大写字符而始终返回相同值（'-1' 或 'false'）的 'String' 方法调用。 报告的方法包括 'equals'、'startsWith'、'endsWith'、'contains'、'indexOf' 和 'lastIndexOf'。 示例：   if (columnName.toLowerCase().equals(\"ID\")) {...}\n 2019.3 最新变化",
                  "markdown": "报告因为在仅大写的字符串中搜索小写字符或在仅小写的字符串中搜索大写字符而始终返回相同值（`-1` 或 `false`）的 `String` 方法调用。\n\n报告的方法包括 `equals`、`startsWith`、`endsWith`、`contains`、`indexOf` 和 `lastIndexOf`。\n\n**示例：**\n\n```\n  if (columnName.toLowerCase().equals(\"ID\")) {...}\n```\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedStringCase",
                    "cweIds": [
                      597
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousGetterSetter",
                "shortDescription": {
                  "text": "可疑的 getter/setter"
                },
                "fullDescription": {
                  "text": "报告所访问字段的名称不是其预期名称的 getter 或 setter 方法。 例如，当 'getY()' 返回 'x' 字段时。 这通常可能表明复制粘贴错误。 示例： 'class Point {\n    private int x;\n    private int y;\n\n    public void setX(int x) { // 警告：setter 'setX()' 分配字段 'y'\n      this.y = x;\n    }\n\n    public int getY() { // 警告：getter 'getY()' 返回字段 'x'\n      return x;\n    }\n  }' 使用下面的复选框可报告类中字段的名称与 getter 或 setter 的名称相匹配的情况。",
                  "markdown": "报告所访问字段的名称不是其预期名称的 getter 或 setter 方法。 例如，当 `getY()` 返回 `x` 字段时。 这通常可能表明复制粘贴错误。\n\n**示例：**\n\n    class Point {\n        private int x;\n        private int y;\n\n        public void setX(int x) { // 警告：setter 'setX()' 分配字段 'y'\n          this.y = x;\n        }\n\n        public int getY() { // 警告：getter 'getY()' 返回字段 'x'\n          return x;\n        }\n      }\n\n\n使用下面的复选框可报告类中字段的名称与 getter 或 setter 的名称相匹配的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousGetterSetter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 110,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToNull",
                "shortDescription": {
                  "text": "'null' 赋值"
                },
                "fullDescription": {
                  "text": "报告在声明外被赋值给 'null' 的变量。 Java 中 'null' 的主要用途是表示未初始化的引用变量。 在极少数情况下，将变量显式赋值给 'null' 有助于垃圾回收。 但是，使用 'null' 来表示缺失、未指定、无效值或找不到的元素被认为是一种不好的做法，可能会使您的代码更容易出现 'NullPointerExceptions'。 请改为考虑定义具有预期语义的 sentinel 对象或使用像 'Optional' 这样的库类型来表示没有值。 示例： 'Integer convert(String s) {\n    Integer value;\n    try {\n      value = Integer.parseInt(s);\n    } catch (NumberFormatException e) {\n      // 警告：null 用于表示“无效值”\n      value = null;\n    }\n    return value;\n  }' 使用忽略对字段的赋值选项可忽略对字段的赋值。",
                  "markdown": "报告在声明外被赋值给 `null` 的变量。\n\nJava 中 `null` 的主要用途是表示未初始化的引用变量。 在极少数情况下，将变量显式赋值给 `null` 有助于垃圾回收。 但是，使用 `null` 来表示缺失、未指定、无效值或找不到的元素被认为是一种不好的做法，可能会使您的代码更容易出现 `NullPointerExceptions`。\n请改为考虑定义具有预期语义的 sentinel 对象或使用像 `Optional` 这样的库类型来表示没有值。\n\n**示例：**\n\n\n      Integer convert(String s) {\n        Integer value;\n        try {\n          value = Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n          // 警告：null 用于表示\"无效值\"\n          value = null;\n        }\n        return value;\n      }\n\n\n使用**忽略对字段的赋值**选项可忽略对字段的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSynchronizedMethodOverridesSynchronizedMethod",
                "shortDescription": {
                  "text": "未同步方法重写 'synchronized' 方法"
                },
                "fullDescription": {
                  "text": "报告重写 'synchronized' 方法的非 'synchronized' 方法。 如果超类方法被声明为 'synchronized'，重写的方法将不会自动同步。 这可能导致使用子类时出现意外的竞争条件。 示例： 'class Super {\n    synchronized void process() {}\n  }\n  class Sub extends Super {\n    // 非 synchronized 方法 'process()' 重写 synchronized 方法\n    void process() {}\n  }'",
                  "markdown": "报告重写 `synchronized` 方法的非 `synchronized` 方法。\n\n\n如果超类方法被声明为 `synchronized`，重写的方法将不会自动同步。 这可能导致使用子类时出现意外的竞争条件。\n\n**示例：**\n\n\n      class Super {\n        synchronized void process() {}\n      }\n      class Sub extends Super {\n        // 非 synchronized 方法 'process()' 重写 synchronized 方法\n        void process() {}\n      }  \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSynchronizedMethodOverridesSynchronizedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitCalledOnCondition",
                "shortDescription": {
                  "text": "在 'java.util.concurrent.locks.Condition' 对象上调用了 'wait()'"
                },
                "fullDescription": {
                  "text": "报告在 'java.util.concurrent.locks.Condition' 对象上进行的 'wait()' 调用。 这可能是编程错误，本应使用 'await()' 方法的某种变体。 示例： 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.wait();\n    }\n  }' 优良的代码应类似于： 'void acquire(Condition released) throws InterruptedException {\n    while (acquired) {\n      released.await();\n    }\n  }'",
                  "markdown": "报告在 `java.util.concurrent.locks.Condition` 对象上进行的 `wait()` 调用。 这可能是编程错误，本应使用 `await()` 方法的某种变体。\n\n**示例：**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.wait();\n        }\n      }\n\n优良的代码应类似于：\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitCalledOnCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedMemberInFinalClass",
                "shortDescription": {
                  "text": "'protected' 成员位于 'final' 类中"
                },
                "fullDescription": {
                  "text": "报告 'final' 类中的 'protected' 成员。 由于无法继承 'final' 类，将方法标记为 'protected' 可能令人困惑。 最好将此类成员声明为 'private' 或软件包可见。 示例： 'record Bar(int a, int b) {\n  protected int sum() { \n     return a + b;\n  }\n}'\n 在应用快速修复后： 'record Bar(int a, int b) {\n  int sum() { \n     return a + b;\n  }\n}' 如本例所示，可以显式或隐式地将类标记为 'final'。",
                  "markdown": "报告 `final` 类中的 `protected` 成员。\n\n由于无法继承 `final` 类，将方法标记为 `protected` 可能令人困惑。 最好将此类成员声明为 `private` 或软件包可见。\n\n**示例：**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\n在应用快速修复后：\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\n如本例所示，可以显式或隐式地将类标记为 `final`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedMemberInFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadCatch",
                "shortDescription": {
                  "text": "过宽的 'catch' 块"
                },
                "fullDescription": {
                  "text": "报告形参比相应的 'try' 块抛出的异常更通用的 'catch' 块。 示例： 'try  {\n    File file = new File(pathToFile);\n    return file.getAbsolutePath();\n  } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'\n    return defaultFilePath;\n  }' 在应用快速修复后： 'try  {\n    File file = new File(pathToFile);\n    return file.getAbsolutePath();\n  } catch (RuntimeException ex) {\n    return defaultFilePath;\n  }' 配置检查： 使用仅对 RuntimeException、异常、错误或 Throwable 发出警告选项可使此检查仅对最常见的异常发出警告。 使用忽略隐藏其他异常但自身被抛出的异常选项可忽略任何隐藏其他异常但仍可能被抛出的异常，因此在技术上不会过于宽泛。",
                  "markdown": "报告形参比相应的 `try` 块抛出的异常更通用的 `catch` 块。\n\n**示例：**\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'\n        return defaultFilePath;\n      }\n\n在应用快速修复后：\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (RuntimeException ex) {\n        return defaultFilePath;\n      }\n\n配置检查：\n\n* 使用**仅对 RuntimeException、异常、错误或 Throwable 发出警告**选项可使此检查仅对最常见的异常发出警告。\n* 使用**忽略隐藏其他异常但自身被抛出的异常**选项可忽略任何隐藏其他异常但仍可能被抛出的异常，因此在技术上不会过于宽泛。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyBroadCatchBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DanglingJavadoc",
                "shortDescription": {
                  "text": "悬空的 Javadoc 注释"
                },
                "fullDescription": {
                  "text": "报告不属于任何类、方法或字段的 Javadoc 注释。 Javadoc 工具会忽略悬空的 Javadoc 注释，并且不会将它们包含在其生成的 HTML 文档中。 示例： 'class A {\n    /**\n     * Dangling comment\n     */\n    /**\n     * Method javadoc\n     */\n     public void m(){}\n  }' 可以通过快速修复完全删除此类注释或将它们转换为块注释。 在应用快速修复后： 'class A {\n    /*\n      Dangling comment\n    */\n    /**\n     * Method javadoc\n     */\n    public void m(){}\n  }' 使用忽略 JavaDoc 格式的文件头注释选项可以忽略 Java 文件开头的注释。 这些通常是版权消息。",
                  "markdown": "报告不属于任何类、方法或字段的 Javadoc 注释。 Javadoc 工具会忽略悬空的 Javadoc 注释，并且不会将它们包含在其生成的 HTML 文档中。\n\n**示例：**\n\n\n      class A {\n        /**\n         * Dangling comment\n         */\n        /**\n         * Method javadoc\n         */\n         public void m(){}\n      }\n\n可以通过快速修复完全删除此类注释或将它们转换为块注释。 在应用快速修复后：\n\n\n      class A {\n        /*\n          Dangling comment\n        */\n        /**\n         * Method javadoc\n         */\n        public void m(){}\n      }\n\n使用**忽略 JavaDoc 格式的文件头注释**选项可以忽略 Java 文件开头的注释。\n这些通常是版权消息。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DanglingJavadoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HibernateResource",
                "shortDescription": {
                  "text": "Hibernate 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "如果返回的 'org.hibernate.Session' 资源没有被安全关闭，报告对 'openSession()' 方法的调用。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'void doHibernateQuery(SessionFactory factory) {\n    Session session = factory.openSession(); //警告\n    session.createQuery(\"...\");\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 'org.hibernate.Session' 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "如果返回的 `org.hibernate.Session` 资源没有被安全关闭，报告对 `openSession()` 方法的调用。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      void doHibernateQuery(SessionFactory factory) {\n        Session session = factory.openSession(); //警告\n        session.createQuery(\"...\");\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 `org.hibernate.Session` 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HibernateResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryInitCause",
                "shortDescription": {
                  "text": "对 'Throwable.initCause()' 的调用不必要"
                },
                "fullDescription": {
                  "text": "报告对 'Throwable.initCause()' 的调用，其中异常构造函数还包含 'Throwable cause' 实参。 在本例中，可以移除 'initCause()' 调用，并将其实参添加到对异常构造函数的调用中。 示例： 'try {\n      process();\n  }\n  catch (RuntimeException ex) {\n    RuntimeException wrapper = new RuntimeException(\"Error while processing\");\n    wrapper.initCause(ex); // 不必要调用 'Throwable.initCause()'\n    throw wrapper;\n  }' 可通过快速修复将 cause 实参传递给构造函数。 在应用快速修复后： 'try {\n      process();\n  }\n  catch (RuntimeException ex) {\n    RuntimeException wrapper = new RuntimeException(\"Error while processing\", ex);\n    throw wrapper;\n  }'",
                  "markdown": "报告对 `Throwable.initCause()` 的调用，其中异常构造函数还包含 `Throwable cause` 实参。\n\n在本例中，可以移除 `initCause()` 调用，并将其实参添加到对异常构造函数的调用中。\n\n**示例：**\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\");\n        wrapper.initCause(ex); // 不必要调用 'Throwable.initCause()'\n        throw wrapper;\n      }\n\n可通过快速修复将 cause 实参传递给构造函数。 在应用快速修复后：\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\", ex);\n        throw wrapper;\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryInitCause",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparisonOfShortAndChar",
                "shortDescription": {
                  "text": "比较 'short' 和 'char' 值"
                },
                "fullDescription": {
                  "text": "报告 'short' 与 'char' 值之间的相等比较。 此类比较可能会导致难以捉摸的错误，因为虽然两个值都是 2 字节长，'short' 值有符号，而 'char' 值无符号。 示例： 'if (Character.MAX_VALUE == shortValue()) {} // 永远不能为 true'",
                  "markdown": "报告 `short` 与 `char` 值之间的相等比较。\n\n此类比较可能会导致难以捉摸的错误，因为虽然两个值都是 2 字节长，`short` 值有符号，而 `char` 值无符号。\n\n**示例：**\n\n\n    if (Character.MAX_VALUE == shortValue()) {} // 永远不能为 true\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparisonOfShortAndChar",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayCanBeReplacedWithEnumValues",
                "shortDescription": {
                  "text": "可以将数组替换为枚举值"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'EnumType.values()' 调用的枚举常量数组。 通常，在更新这样一个枚举时，您必须同时更新数组。 但是，如果您改用 'EnumType.values()'，则无需修改。 示例： 'enum States {\n     NOT_RUN, IN_PROGRESS, FINISHED;\n  }\n  \n  handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});' 在应用快速修复后： 'handleStates(States.values());' 2019.1 最新变化",
                  "markdown": "报告可以替换为 `EnumType.values()` 调用的枚举常量数组。\n\n通常，在更新这样一个枚举时，您必须同时更新数组。 但是，如果您改用 `EnumType.values()`，则无需修改。\n\n示例：\n\n\n      enum States {\n         NOT_RUN, IN_PROGRESS, FINISHED;\n      }\n      \n      handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});\n\n在应用快速修复后：\n\n\n      handleStates(States.values());\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayCanBeReplacedWithEnumValues",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitNotifyNotInSynchronizedContext",
                "shortDescription": {
                  "text": "'wait()' 或 'notify()' 不在同步的上下文中"
                },
                "fullDescription": {
                  "text": "报告不是在相应的 synchronized 语句或 synchronized 方法进行中的 'wait()'、'notify()' 和 'notifyAll()' 调用。 在没有持有锁定的对象上调用这些方法会导 'IllegalMonitorStateException'。 此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。 示例： 'class Sync {\n    private final Object lock = new Object();\n\n    void test() throws InterruptedException {\n      synchronized (this) {\n        lock.wait(); // 'lock.wait()' 未在 'lock' 上同步\n      }\n    }\n  }'",
                  "markdown": "报告不是在相应的 synchronized 语句或 synchronized 方法进行中的 `wait()`、`notify()` 和 `notifyAll()` 调用。\n\n\n在没有持有锁定的对象上调用这些方法会导 `IllegalMonitorStateException`。\n此类结构不一定错误，因为在调用该包含方法前可能已获取必要的锁定，但即便如此，还是要仔细查看。\n\n**示例：**\n\n\n      class Sync {\n        private final Object lock = new Object();\n\n        void test() throws InterruptedException {\n          synchronized (this) {\n            lock.wait(); // 'lock.wait()' 未在 'lock' 上同步\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitNotifyWhileNotSynced",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DollarSignInName",
                "shortDescription": {
                  "text": "在标识符中使用 '$'"
                },
                "fullDescription": {
                  "text": "报告名称中带有美元符号 ('$') 的变量、方法和类。 虽然此类名称是合法的 Java，但强烈建议不要在生成的 Java 代码之外使用它们。 示例： 'class SalaryIn${}' 仅在编辑器中建议重命名快速修复。",
                  "markdown": "报告名称中带有美元符号 (`$`) 的变量、方法和类。 虽然此类名称是合法的 Java，但强烈建议不要在生成的 Java 代码之外使用它们。\n\n**示例：**\n\n\n      class SalaryIn${}\n\n仅在编辑器中建议重命名快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DollarSignInName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DynamicRegexReplaceableByCompiledPattern",
                "shortDescription": {
                  "text": "动态正则表达式可被替换为已编译的 'Pattern'"
                },
                "fullDescription": {
                  "text": "报告使用常量实参对 'java.lang.String' 的正则表达式方法（例如 'matches()' 或 'split()'）的调用。 此类调用可以有利地替换为 'private static final Pattern' 字段，从而不必在每次使用正则表达式时都对其进行编译。 示例： 'text.replaceAll(\"abc\", replacement);' 在应用快速修复后： 'private static final Pattern ABC = Pattern.compile(\"abc\", Pattern.LITERAL);\n  ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));'",
                  "markdown": "报告使用常量实参对 `java.lang.String` 的正则表达式方法（例如 `matches()` 或 `split()`）的调用。\n\n\n此类调用可以有利地替换为 `private static final Pattern` 字段，从而不必在每次使用正则表达式时都对其进行编译。\n\n**示例：**\n\n\n      text.replaceAll(\"abc\", replacement);\n\n在应用快速修复后：\n\n\n      private static final Pattern ABC = Pattern.compile(\"abc\", Pattern.LITERAL);\n      ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DynamicRegexReplaceableByCompiledPattern",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyInitializer",
                "shortDescription": {
                  "text": "空类初始值设定项"
                },
                "fullDescription": {
                  "text": "报告空类初始值设定项块。",
                  "markdown": "报告空类初始值设定项块。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyClassInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBreak",
                "shortDescription": {
                  "text": "不必要的 'break' 语句"
                },
                "fullDescription": {
                  "text": "报告任何不必要的 'break' 语句。 如果 'break' 语句在被移除后没有执行其他语句，则该语句是不必要的语句。 示例： 'switch (e) {\n    case A -> {\n        System.out.println(\"A\");\n        break; // 报告 'break' 为不必要的语句\n    }\n    default -> {\n        System.out.println(\"Default\");\n        break; // 报告 'break' 为不必要的语句\n    }\n  }'",
                  "markdown": "报告任何不必要的 `break` 语句。\n\n如果 `break` 语句在被移除后没有执行其他语句，则该语句是不必要的语句。\n\n**示例：**\n\n\n      switch (e) {\n        case A -> {\n            System.out.println(\"A\");\n            break; // 报告 'break' 为不必要的语句\n        }\n        default -> {\n            System.out.println(\"Default\");\n            break; // 报告 'break' 为不必要的语句\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryBreak",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RawUseOfParameterizedType",
                "shortDescription": {
                  "text": "形参化类的原始使用"
                },
                "fullDescription": {
                  "text": "报告类型形参被忽略的泛型类。 这种对泛型类型的原始使用在 Java 中虽然有效，但它违背了类型形参的用途，并且可能掩盖错误。 此检查反映出 'javac' 的 'rawtypes' 警告。 示例： '//警告：形参化类 'List' 的原始使用\nList list = new ArrayList<String>();\n//创建了字符串列表，但也接受整数\nlist.add(1);' '//无警告，因为在数组创建期间无法提供类型实参\nIntFunction<List<?>[]> fun = List[]::new;' 配置检查： 使用忽略新对象的构造选项，可忽略对象构造中使用的原始类型。 使用忽略类型转换选项，可忽略类型转换中使用的原始类型。 使用忽略类型形参无法编译的位置选项，可忽略类型形参编译失败的情况（例如创建数组或重写库方法的情况）。 使用忽略重写方法的形参类型选项，可忽略重写方法的形参中使用的类型形参。 使用在自动快速修复不可用时忽略选项，可忽略快速修复不可用的情况。 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。 此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。",
                  "markdown": "报告类型形参被忽略的泛型类。 这种对泛型类型的*原始* 使用在 Java 中虽然有效，但它违背了类型形参的用途，并且可能掩盖错误。 此检查反映出 `javac` 的 `rawtypes` 警告。\n\n**示例：**\n\n\n    //警告：形参化类 'List' 的原始使用\n    List list = new ArrayList<String>();\n    //创建了字符串列表，但也接受整数\n    list.add(1);\n\n\n    //无警告，因为在数组创建期间无法提供类型实参\n    IntFunction<List<?>[]> fun = List[]::new;\n\n配置检查：\n\n* 使用**忽略新对象的构造**选项，可忽略对象构造中使用的原始类型。\n* 使用**忽略类型转换**选项，可忽略类型转换中使用的原始类型。\n* 使用**忽略类型形参无法编译的位置**选项，可忽略类型形参编译失败的情况（例如创建数组或重写库方法的情况）。\n* 使用**忽略重写方法的形参类型**选项，可忽略重写方法的形参中使用的类型形参。\n* 使用**在自动快速修复不可用时忽略**选项，可忽略快速修复不可用的情况。\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。\n\n此检查取决于 Java 功能 '泛型'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "rawtypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicConstructorInNonPublicClass",
                "shortDescription": {
                  "text": "'public' 构造函数位于非 public 类中"
                },
                "fullDescription": {
                  "text": "报告非 'public' 类中的所有 'public' 构造函数。 在访问级别较低的类中，通常没有理由创建 'public' 构造函数。 但请注意，此检查会改变某些反射调用的行为。 特别是，'Class.getConstructor()' 将无法找到更新的构造函数（应改为使用 'Class.getDeclaredConstructor()'）。 如果您的代码或某些已使用的框架的代码通过 'getConstructor()' 依赖于构造函数的可访问性，请不要使用该检查。 示例： 'class House {\n    public House() {}\n  }' 在应用快速修复后： 'class House {\n    House() {}\n  }'",
                  "markdown": "报告非 `public` 类中的所有 `public` 构造函数。\n\n在访问级别较低的类中，通常没有理由创建 `public` 构造函数。\n但请注意，此检查会改变某些反射调用的行为。 特别是，`Class.getConstructor()` 将无法找到更新的构造函数（应改为使用 `Class.getDeclaredConstructor()`）。 如果您的代码或某些已使用的框架的代码通过 `getConstructor()` 依赖于构造函数的可访问性，请不要使用该检查。\n\n**示例：**\n\n\n      class House {\n        public House() {}\n      }\n\n在应用快速修复后：\n\n\n      class House {\n        House() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicConstructorInNonPublicClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedInnerClass",
                "shortDescription": {
                  "text": "protected 嵌套类"
                },
                "fullDescription": {
                  "text": "报告 'protected' 嵌套类。 示例： 'public class Outer {\n    protected static class Nested {} // 警告\n    protected class Inner {}         // 警告\n    protected enum Mode {}           // 警告取决于设置\n    protected interface I {}         // 警告取决于设置\n  }' 配置检查： 使用忽略 'protected' 内部枚举选项可忽略 'protected' 内部枚举。 使用忽略 'protected' 内部接口选项可忽略 'protected' 内部接口。",
                  "markdown": "报告 `protected` 嵌套类。\n\n**示例：**\n\n\n      public class Outer {\n        protected static class Nested {} // 警告\n        protected class Inner {}         // 警告\n        protected enum Mode {}           // 警告取决于设置\n        protected interface I {}         // 警告取决于设置\n      }\n\n配置检查：\n\n* 使用**忽略 'protected' 内部枚举** 选项可忽略 `protected` 内部枚举。\n* 使用**忽略 'protected' 内部接口** 选项可忽略 `protected` 内部接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedStaticUsage",
                "shortDescription": {
                  "text": "非限定静态访问"
                },
                "fullDescription": {
                  "text": "报告未用类名称限定的 static 成员的用法。 如果 static 成员在同一个类中，是合法的，但可能令人困惑。 示例： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      foo();\n      System.out.println(x);\n    }\n\n    static void baz() { foo(); }\n  }' 在应用快速修复后： 'class Foo {\n    static void foo() {}\n    static int x;\n\n    void bar() {\n      Foo.foo();\n      System.out.println(Foo.x);\n    }\n\n    static void baz() { Foo.foo(); }\n  }' 使用检查设置可以切换以下各项的报告： static 字段访问 'void bar() { System.out.println(x); }' 对 static 方法的调用 'void bar() { foo(); }' 'static void baz() { foo(); }' 您还可以将检查配置为仅报告来自非 static 上下文的 static 成员用法。 在上面的示例中，不会报告 'static void baz() { foo(); }'。",
                  "markdown": "报告未用类名称限定的 static 成员的用法。\n\n\n如果 static 成员在同一个类中，是合法的，但可能令人困惑。\n\n**示例：**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\n使用检查设置可以切换以下各项的报告：\n\n*\n  static 字段访问  \n\n  `void bar() { System.out.println(x); }`\n\n*\n  对 static 方法的调用  \n\n  `void bar() { foo(); }`  \n\n  `static void baz() { foo(); }`\n\n\n您还可以将检查配置为仅报告来自非 static 上下文的 static 成员用法。\n在上面的示例中，不会报告 `static void baz() { foo(); }`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedStaticUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticGuardedByInstance",
                "shortDescription": {
                  "text": "由实例字段或 this 防护的 static 成员"
                },
                "fullDescription": {
                  "text": "报告其中的保护符为非 static 字段或 'this' 的 'static' 字段或方法上的 '@GuardedBy' 注解。 使用非 static 元素保护 static 元素可能会导致过度并发，多个线程可能在不同的对象上下文中锁定，以同时访问保护字段。 示例： 'private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    @GuardedBy(\"lock\")\n    public static void bar() {\n        // ...\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告其中的保护符为非 static 字段或 `this` 的 `static` 字段或方法上的 `@GuardedBy` 注解。\n\n使用非 static 元素保护 static 元素可能会导致过度并发，多个线程可能在不同的对象上下文中锁定，以同时访问保护字段。\n\n示例：\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n        @GuardedBy(\"lock\")\n        public static void bar() {\n            // ...\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticGuardedByInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 76,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExternalizableWithoutPublicNoArgConstructor",
                "shortDescription": {
                  "text": "没有 'public' 无实参构造函数的 'Externalizable' 类"
                },
                "fullDescription": {
                  "text": "报告没有 public 无实参构造函数的 'Externalizable' 类。 在重新构造 'Externalizable' 对象时，将在调用 'readExternal' 方法前使用 public 无实参构造函数创建一个实例。 如果 public 无实参构造函数不可用，在运行时会抛出 'java.io.InvalidClassException'。",
                  "markdown": "报告没有 public 无实参构造函数的 `Externalizable` 类。\n\n在重新构造 `Externalizable` 对象时，将在调用 `readExternal` 方法前使用 public 无实参构造函数创建一个实例。 如果 public 无实参构造函数不可用，在运行时会抛出 `java.io.InvalidClassException`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExternalizableWithoutPublicNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualArrayCopy",
                "shortDescription": {
                  "text": "手动数组复制"
                },
                "fullDescription": {
                  "text": "报告可被替换为 'System.arraycopy()' 调用的数组内容的手动复制。 示例： 'for (int i = 0; i < array.length; i++) {\n    newArray[i] = array[i];\n  }' 在应用快速修复后： 'System.arraycopy(array, 0, newArray, 0, array.length);'",
                  "markdown": "报告可被替换为 `System.arraycopy()` 调用的数组内容的手动复制。\n\n**示例：**\n\n\n      for (int i = 0; i < array.length; i++) {\n        newArray[i] = array[i];\n      }\n\n在应用快速修复后：\n\n\n      System.arraycopy(array, 0, newArray, 0, array.length);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualArrayCopy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticPseudoFunctionalStyleMethod",
                "shortDescription": {
                  "text": "Guava 伪函数调用可被转换为 Stream API 调用"
                },
                "fullDescription": {
                  "text": "当 'Java Stream API' 可用时报告 Guava 伪函数代码的用法。 虽然 'Guava Iterable API' 提供类似于 'Java Streams API' 的功能，但它略有不同，可能会缺少某些功能。 特别是，'IntStream' 等基元专门化的流变体比一般变体的性能更好。 示例： 'List<String> transformedIterable = Iterables.transform(someList, someTransformFunction);//警告：伪函数样式代码' 在应用快速修复后： 'List<String> transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());' 注意：代码语义可能改变；例如 Guava 的 'Iterable.transform' 产生延迟求值的可迭代对象，但替换为及早求值。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "当 `Java Stream API` 可用时报告 Guava 伪函数代码的用法。\n\n虽然 `Guava Iterable API` 提供类似于 `Java Streams API` 的功能，但它略有不同，可能会缺少某些功能。\n特别是，`IntStream` 等基元专门化的流变体比一般变体的性能更好。\n\n**示例：**\n\n\n    List<String> transformedIterable = Iterables.transform(someList, someTransformFunction);//警告：伪函数样式代码\n\n在应用快速修复后：\n\n    List<String> transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());\n\n\n**注意** ：代码语义可能改变；例如 Guava 的 `Iterable.transform` 产生延迟求值的可迭代对象，但替换为及早求值。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticPseudoFunctionalStyleMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ControlFlowStatementWithoutBraces",
                "shortDescription": {
                  "text": "不带大括号的控制流语句"
                },
                "fullDescription": {
                  "text": "报告没有大括号的 'if'、'while'、'do' 或 'for' 语句。 一些代码样式，例如 Google Java 样式指南，要求所有控制语句都要带大括号。 在向不带大括号的控制语句添加更多语句时，重要的是不要忘记添加大括号。 在注释掉一行代码时，在不使用大括号时也必须更加小心，以免无意中使下一条语句成为控制流语句的一部分。 始终使用大括号可以更安全地插入或注释掉一行代码。 如果始终遵循使用大括号的代码样式，则很可能不会发生 goto fail 漏洞。 带大括号的控制语句使控制流更易于查看，而无需依赖于可能不正确的缩进。 示例： 'class Strange {\n    void x(boolean one, boolean two) {\n      if(one)\n        if(two)\n          foo();\n      else\n        bar();\n    }\n\n    void foo() {}\n    void bar() {}\n  }' 快速修复用大括号包装语句体： 'class Strange {\n    void x(boolean one, boolean two) {\n      if(one) {\n        if(two) {\n          foo();\n        } else {\n          bar();\n        }\n      }\n    }\n\n    void foo() {}\n    void bar() {}\n  }'",
                  "markdown": "报告没有大括号的 `if`、`while`、`do` 或 `for` 语句。 一些代码样式，例如 [Google Java 样式指南](https://google.github.io/styleguide/javaguide.html)，要求所有控制语句都要带大括号。\n\n\n在向不带大括号的控制语句添加更多语句时，重要的是不要忘记添加大括号。\n在注释掉一行代码时，在不使用大括号时也必须更加小心，以免无意中使下一条语句成为控制流语句的一部分。\n始终使用大括号可以更安全地插入或注释掉一行代码。\n\n\n如果始终遵循使用大括号的代码样式，则很可能不会发生 [goto fail 漏洞](https://www.imperialviolet.org/2014/02/22/applebug.html)。\n带大括号的控制语句使控制流更易于查看，而无需依赖于可能不正确的缩进。\n\n示例：\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one)\n            if(two)\n              foo();\n          else\n            bar();\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n\n快速修复用大括号包装语句体：\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one) {\n            if(two) {\n              foo();\n            } else {\n              bar();\n            }\n          }\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ControlFlowStatementWithoutBraces",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldInEnum",
                "shortDescription": {
                  "text": "'enum' 中的非 final 字段"
                },
                "fullDescription": {
                  "text": "报告枚举类型中的非 final 字段。 非 final 字段会引入全局可变状态，这通常会被认为不可取。 示例： 'enum Enum {\n    FIRST(\"first\"),\n    SECOND(\"second\");\n\n    public String str;\n\n    Enum(String str) {\n        this.str = str;\n    }\n  }' 在应用快速修复后： 'enum Enum {\n    FIRST(\"first\"),\n    SECOND(\"second\");\n\n    public final String str;\n\n    Enum(String str) {\n        this.str = str;\n    }\n  }' 使用“忽略不能设为 'final' 的字段”选项可以仅对可使用快速修复设为 final 的字段发出警告。",
                  "markdown": "报告枚举类型中的非 final 字段。 非 final 字段会引入全局可变状态，这通常会被认为不可取。\n\n**示例：**\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\n在应用快速修复后：\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public final String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\n使用\"忽略不能设为 'final' 的字段\"选项可以仅对可使用快速修复设为 final 的字段发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldInEnum",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LengthOneStringInIndexOf",
                "shortDescription": {
                  "text": "'String.indexOf()' 调用中的单字符字符串实参"
                },
                "fullDescription": {
                  "text": "报告在 'String.indexOf()' 和 'String.lastIndexOf()' 调用中用作实参的单字符字符串。 建议通过快速修复将此类字符串文字替换为等效的字符文字，从而获得一些性能增强。 示例： 'return s.indexOf(\"x\");' 在应用快速修复后： 'return s.indexOf('x');'",
                  "markdown": "报告在 `String.indexOf()` 和 `String.lastIndexOf()` 调用中用作实参的单字符字符串。\n\n建议通过快速修复将此类字符串文字替换为等效的字符文字，从而获得一些性能增强。\n\n**示例：**\n\n\n      return s.indexOf(\"x\");\n\n在应用快速修复后：\n\n\n      return s.indexOf('x');\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStringConcatenation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledEquals",
                "shortDescription": {
                  "text": "'equal()' 代替 'equals()'"
                },
                "fullDescription": {
                  "text": "报告带有单个形参的 'equal()' 的声明。 通常，这是拼写错误，'equals()' 实际上是有意的。 建议通过快速修复将方法重命名为 'equals'。 示例： 'class Main {\n    public boolean equal(Object obj) {\n      return true;\n    }\n  }' 在应用快速修复后： 'class Main {\n    public boolean equals(Object obj) {\n      return true;\n    }\n  }'",
                  "markdown": "报告带有单个形参的 `equal()` 的声明。 通常，这是拼写错误，`equals()` 实际上是有意的。\n\n建议通过快速修复将方法重命名为 `equals`。\n\n**示例：**\n\n\n      class Main {\n        public boolean equal(Object obj) {\n          return true;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        public boolean equals(Object obj) {\n          return true;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MisspelledEquals",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumClass",
                "shortDescription": {
                  "text": "枚举类"
                },
                "fullDescription": {
                  "text": "报告 enum 类。 Java 1.4 和更早版本的 JVM 不支持此类语句。",
                  "markdown": "报告 **enum** 类。 Java 1.4 和更早版本的 JVM 不支持此类语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EnumClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 114,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialFunctionalExpressionUsage",
                "shortDescription": {
                  "text": "函数表达式的普通用法"
                },
                "fullDescription": {
                  "text": "报告在 lambda、方法引用或匿名类的定义中直接调用的函数接口方法调用。 此类方法调用可以替换为函数接口实现体。 示例： 'boolean contains(List<String> names, String name) {\n    return ((Predicate<String>)x -> {\n      return names.contains(x);\n    }).test(name);\n  }' 应用快速修复后，方法调用变为： 'boolean contains(List<String> names, String name) {\n    return names.contains(name);\n  }'",
                  "markdown": "报告在 lambda、方法引用或匿名类的定义中直接调用的函数接口方法调用。 此类方法调用可以替换为函数接口实现体。\n\n**示例：**\n\n\n      boolean contains(List<String> names, String name) {\n        return ((Predicate<String>)x -> {\n          return names.contains(x);\n        }).test(name);\n      }\n\n应用快速修复后，方法调用变为：\n\n\n      boolean contains(List<String> names, String name) {\n        return names.contains(name);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrivialFunctionalExpressionUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousHasLambdaAlternative",
                "shortDescription": {
                  "text": "匿名类型有较短的 lambda 替代项"
                },
                "fullDescription": {
                  "text": "报告可以转换为构造函数或带有 lambda 表达式实参的工厂方法调用的匿名类。 本次检查报告以下类别： 扩展 'ThreadLocal' 的匿名类，其具有 'initialValue()' 方法（可以替换为 'ThreadLocal.withInitial'） 扩展 'Thread' 的匿名类，其具有 'run()' 方法（可以替换为 'new Thread(Runnable)'） 示例： 'new Thread() {\n    @Override\n    public void run() {\n      System.out.println(\"Hello from thread!\");\n    }\n  }.start();' 在应用快速修复后： 'new Thread(() -> {\n    System.out.println(\"Hello from thread!\");\n  }).start();' 此检查取决于 Java 功能 'ThreadLocal.withInitial()'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以转换为构造函数或带有 lambda 表达式实参的工厂方法调用的匿名类。\n\n本次检查报告以下类别：\n\n* 扩展 `ThreadLocal` 的匿名类，其具有 `initialValue()` 方法（可以替换为 `ThreadLocal.withInitial`）\n* 扩展 `Thread` 的匿名类，其具有 `run()` 方法（可以替换为 `new Thread(Runnable)`）\n\n示例：\n\n\n      new Thread() {\n        @Override\n        public void run() {\n          System.out.println(\"Hello from thread!\");\n        }\n      }.start();\n\n在应用快速修复后：\n\n\n      new Thread(() -> {\n        System.out.println(\"Hello from thread!\");\n      }).start();\n\n此检查取决于 Java 功能 'ThreadLocal.withInitial()'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousHasLambdaAlternative",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsThread",
                "shortDescription": {
                  "text": "类直接扩展 'Thread'"
                },
                "fullDescription": {
                  "text": "报告直接扩展 'java.lang.Thread' 的类。 通常建议使用组合而不是继承来创建更便于日后修改的可重用代码。 示例： 'class MainThread extends Thread {\n  }'",
                  "markdown": "报告直接扩展 `java.lang.Thread` 的类。 通常建议使用组合而不是继承来创建更便于日后修改的可重用代码。\n\n**示例：**\n\n\n      class MainThread extends Thread {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyExtendsThread",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyOptionalCallChains",
                "shortDescription": {
                  "text": "可以简化 Optional 调用链"
                },
                "fullDescription": {
                  "text": "报告可以简化的 Optional 调用链。 下面是一些简化的例子： 'optional.map(x -> true).orElse(false)' → 'optional.isPresent()' 'optional.map(x -> Optional.of(x.trim())).orElseGet(Optional::empty)' → 'optional.map(String::trim)' 'optional.map(x -> (String)x).orElse(null)' → '(String) optional.orElse(null)' 'Optional.ofNullable(optional.orElse(null))' → 'optional' 'val = optional.orElse(null); val != null ? val : defaultExpr' → 'optional.orElse(defaultExpr)' 'val = optional.orElse(null); if(val != null) expr(val)' → 'optional.ifPresent(val -> expr(val))' 2017.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以简化的 **Optional** 调用链。 下面是一些简化的例子：\n\n* `optional.map(x -> true).orElse(false)` → `optional.isPresent()`\n* `optional.map(x -> Optional.of(x.trim())).orElseGet(Optional::empty)` → `optional.map(String::trim)`\n* `optional.map(x -> (String)x).orElse(null)` → `(String) optional.orElse(null)`\n* `Optional.ofNullable(optional.orElse(null))` → `optional`\n* `val = optional.orElse(null); val != null ? val : defaultExpr ` → `optional.orElse(defaultExpr)`\n* `val = optional.orElse(null); if(val != null) expr(val) ` → `optional.ifPresent(val -> expr(val))`\n\n2017.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyOptionalCallChains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RandomDoubleForRandomInteger",
                "shortDescription": {
                  "text": "使用 'Random.nextDouble()' 获取随机整数"
                },
                "fullDescription": {
                  "text": "报告对 'java.util.Random.nextDouble()' 的调用，这些调用用于通过将调用乘以一个系数并转换为整数来创建正整数。 对于在一定范围内生成随机正整数，'java.util.Random.nextInt(int)' 更加简单和高效。 示例： 'int getRandomInt() {\n    return (int) ((new Random()).nextDouble() * SIZE);\n  }'\n 在应用快速修复后： 'int getRandomInt() {\n    return (new Random()).nextInt(SIZE);\n  }'",
                  "markdown": "报告对 `java.util.Random.nextDouble()` 的调用，这些调用用于通过将调用乘以一个系数并转换为整数来创建正整数。\n\n\n对于在一定范围内生成随机正整数，`java.util.Random.nextInt(int)` 更加简单和高效。\n\n**示例：**\n\n\n      int getRandomInt() {\n        return (int) ((new Random()).nextDouble() * SIZE);\n      }\n      \n在应用快速修复后：\n\n\n      int getRandomInt() {\n        return (new Random()).nextInt(SIZE);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UsingRandomNextDoubleForRandomInteger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousArrayCast",
                "shortDescription": {
                  "text": "可疑的数组转换"
                },
                "fullDescription": {
                  "text": "报告可疑的数组转换。 当数组转换为更具体的数组类型时，数组转换被视为可疑。 虽然此类转换在编译时是合法的，但在运行时可能会因 'ClassCastException' 而失败。 示例： 'Number[] numbers = new Number[]{1L, 2L, 4L};\n  Long[] longs = (Long[])numbers;'",
                  "markdown": "报告可疑的数组转换。 当数组转换为更具体的数组类型时，数组转换被视为可疑。 虽然此类转换在编译时是合法的，但在运行时可能会因 `ClassCastException` 而失败。\n\n**示例：**\n\n\n      Number[] numbers = new Number[]{1L, 2L, 4L};\n      Long[] longs = (Long[])numbers;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousArrayCast",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ZeroLengthArrayInitialization",
                "shortDescription": {
                  "text": "零长度数组分配"
                },
                "fullDescription": {
                  "text": "报告已知长度为零的数组的分配。 由于 Java 中的数组长度不可修改，几乎总是可以共享零长度数组，而不是重复分配新数组。 此类共享可以在程序运行时或占用空间中提供有用的优化。 请注意，检查不会报告分配为 static final 字段的零长度数组，因为会假设这些数组用于实现数组共享。",
                  "markdown": "报告已知长度为零的数组的分配。\n\n\n由于 Java 中的数组长度不可修改，几乎总是可以共享零长度数组，而不是重复分配新数组。 此类共享可以在程序运行时或占用空间中提供有用的优化。\n\n\n请注意，检查不会报告分配为 static final 字段的零长度数组，因为会假设这些数组用于实现数组共享。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ZeroLengthArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DivideByZero",
                "shortDescription": {
                  "text": "除以零"
                },
                "fullDescription": {
                  "text": "报告除以 0 或对 0 取余。 对于双精度或浮点数，此类表达式将产生 'Infinity'、'-Infinity' 或 'NaN' 结果；对于整数，则抛出 'ArithmeticException'。 当表达式的结果为 'NaN' 时，该修正会建议将除法表达式替换为 'NaN' 常量。",
                  "markdown": "报告除以 0 或对 0 取余。 对于双精度或浮点数，此类表达式将产生 `Infinity`、`-Infinity` 或 `NaN` 结果；对于整数，则抛出 `ArithmeticException`。\n\n当表达式的结果为 `NaN` 时，该修正会建议将除法表达式替换为 `NaN` 常量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "divzero",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingSerialAnnotation",
                "shortDescription": {
                  "text": "可以使用 '@Serial' 注解"
                },
                "fullDescription": {
                  "text": "报告 'Serializable' 和 'Externalizable' 类中适合使用 'java.io.Serial' 注解进行注解的方法和字段。 该快速修复会添加注解。 示例： 'class Main implements Serializable {\n  private static final long serialVersionUID = 7874493593505141603L;\n\n  private void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' 在应用快速修复后： 'class Main implements Serializable {\n    @Serial\n    private static final long serialVersionUID = 7874493593505141603L;\n\n    @Serial\n    private void writeObject(ObjectOutputStream out) throws IOException {\n    }\n}' 示例： 'class Main implements Externalizable {\n    protected Object readResolve() throws ObjectStreamException {\n      return \"SomeObject\";\n    }\n  }' 在应用快速修复后： 'class Main implements Externalizable {\n    @Serial\n    protected Object readResolve() throws ObjectStreamException {\n        return \"SomeObject\";\n    }\n  }' 有关所有可能情况的更多信息，请参阅 'java.io.Serial' 的文档。 2020.3 最新变化 此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。",
                  "markdown": "报告 `Serializable` 和 `Externalizable` 类中适合使用 `java.io.Serial` 注解进行注解的方法和字段。 该快速修复会添加注解。\n\n**示例：**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n在应用快速修复后：\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**示例：**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\n有关所有可能情况的更多信息，请参阅 `java.io.Serial` 的文档。\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingSerialAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationMissingWhitespace",
                "shortDescription": {
                  "text": "字符串串联中可能缺少空格"
                },
                "fullDescription": {
                  "text": "报告缺少空格的字符串串联，即左侧以 Unicode 字母或数字结束，右侧以 Unicode 字母或数字开始。 示例： 'String sql = \"SELECT column\" +\n               \"FROM table\";' 使用忽略具有变量字符串的串联选项，只在串联的左右两侧都为文字时报告。",
                  "markdown": "报告缺少空格的字符串串联，即左侧以 Unicode 字母或数字结束，右侧以 Unicode 字母或数字开始。\n\n**示例：**\n\n\n      String sql = \"SELECT column\" +\n                   \"FROM table\";\n\n\n使用**忽略具有变量字符串的串联**选项，只在串联的左右两侧都为文字时报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationMissingWhitespace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StandardVariableNames",
                "shortDescription": {
                  "text": "标准变量名称"
                },
                "fullDescription": {
                  "text": "报告具有与其类型不对应的“标准”名称的变量。 此类名称可能令人困惑。 特定类型有以下标准名称： i, j, k, m, n - 'int' f - 'float' d - 'double' b - 'byte' c, ch - 'char' l - 'long' s, str - 'String' 仅在编辑器中建议重命名快速修复。 使用该选项可以忽略与直接 super 方法中的形参名称相同的形参名称。",
                  "markdown": "报告具有与其类型不对应的\"标准\"名称的变量。 此类名称可能令人困惑。 特定类型有以下标准名称：\n\n* i, j, k, m, n - `int`\n* f - `float`\n* d - `double`\n* b - `byte`\n* c, ch - `char`\n* l - `long`\n* s, str - `String`\n\n仅在编辑器中建议重命名快速修复。\n\n\n使用该选项可以忽略与直接 super 方法中的形参名称相同的形参名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StandardVariableNames",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeconstructionCanBeUsed",
                "shortDescription": {
                  "text": "可以使用记录模式"
                },
                "fullDescription": {
                  "text": "报告可被替换为记录模式的模式。 示例： 'record Point(int x, int y) {}\n\n  static void printSum(Object obj) {\n    if (obj instanceof Point p) {\n      int x = p.x();\n      int y = p.y();\n      System.out.println(x + y);\n    }\n  }' 在应用快速修复后： 'record Point(int x, int y) {}\n\n  static void printSum(Object obj) {\n    if (obj instanceof Point(int x, int y)) {\n      System.out.println(x + y);\n    }\n  }' 2023.1 最新变化 此检查取决于 Java 功能 '模式保护和记录模式'，该功能自 Java 21 起可用。",
                  "markdown": "报告可被替换为记录模式的模式。\n\n示例：\n\n\n      record Point(int x, int y) {}\n\n      static void printSum(Object obj) {\n        if (obj instanceof Point p) {\n          int x = p.x();\n          int y = p.y();\n          System.out.println(x + y);\n        }\n      }\n\n在应用快速修复后：\n\n\n      record Point(int x, int y) {}\n\n      static void printSum(Object obj) {\n        if (obj instanceof Point(int x, int y)) {\n          System.out.println(x + y);\n        }\n      }\n\n2023.1 最新变化\n\n此检查取决于 Java 功能 '模式保护和记录模式'，该功能自 Java 21 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DeconstructionCanBeUsed",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 159,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionFromCatchWhichDoesntWrap",
                "shortDescription": {
                  "text": "'throw' 位于忽略已捕获异常的 'catch' 块内"
                },
                "fullDescription": {
                  "text": "报告从 'catch' 块内部抛出但不“包装”所捕获异常的异常。 当异常被抛出以响应异常时，包装初始异常可防止丢失有价值的上下文信息，如堆栈帧和行号。 示例： '...\n  catch (IOException e) {\n    closeAllConnections();\n    throw new ConnectException(\"Connection problem.\"); // 警告：'catch' 块内的 'throw' 忽略捕获的异常 'e'\n  }' 配置检查： 使用如果使用异常方法调用的结果，则忽略选项可指示检查是否应忽略实参为原始异常方法调用结果的异常，例如 'getMessage()'。 使用如果抛出的异常无法包装异常，则忽略选项可忽略在没有接受 'Throwable' 子句的构造函数的情况下抛出异常的 'throw' 语句。",
                  "markdown": "报告从 `catch` 块内部抛出但不\"包装\"所捕获异常的异常。\n\n当异常被抛出以响应异常时，包装初始异常可防止丢失有价值的上下文信息，如堆栈帧和行号。\n\n**示例：**\n\n\n      ...\n      catch (IOException e) {\n        closeAllConnections();\n        throw new ConnectException(\"Connection problem.\"); // 警告：'catch' 块内的 'throw' 忽略捕获的异常 'e'\n      }\n\n配置检查：\n\n* 使用**如果使用异常方法调用的结果，则忽略** 选项可指示检查是否应忽略实参为原始异常方法调用结果的异常，例如 `getMessage()`。\n* 使用**如果抛出的异常无法包装异常，则忽略** 选项可忽略在没有接受 `Throwable` 子句的构造函数的情况下抛出异常的 `throw` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowInsideCatchBlockWhichIgnoresCaughtException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOnlyUsedFromInnerClass",
                "shortDescription": {
                  "text": "仅在内部类中使用 private 方法"
                },
                "fullDescription": {
                  "text": "报告仅从包含该方法的类的内部类调用的 'private' 方法。 此类方法可以安全地移到该内部类中。 示例： 'public class Outer {\n  public static void main(String[] args) {\n    new Inner().run(args[0]);\n  }\n\n  static class Inner {\n    void run(String arg) {\n      // 方法 isEmpty() 仅从内部类使用\n      // 考虑将其移到内部类\n      if (!isEmpty(arg)) {\n        System.out.println(\"Argument is supplied\");\n      }\n    }\n  }\n\n  private static boolean isEmpty(String s) {\n    return s != null && s.trim().isEmpty();\n  }\n}' 使用下面的第一个复选框可忽略从匿名类或本地类调用的 'private' 方法。 使用第三个复选框可仅报告 'static' 方法。",
                  "markdown": "报告仅从包含该方法的类的内部类调用的 `private` 方法。 此类方法可以安全地移到该内部类中。\n\n示例：\n\n\n    public class Outer {\n      public static void main(String[] args) {\n        new Inner().run(args[0]);\n      }\n\n      static class Inner {\n        void run(String arg) {\n          // 方法 isEmpty() 仅从内部类使用\n          // 考虑将其移到内部类\n          if (!isEmpty(arg)) {\n            System.out.println(\"Argument is supplied\");\n          }\n        }\n      }\n\n      private static boolean isEmpty(String s) {\n        return s != null && s.trim().isEmpty();\n      }\n    }\n\n\n使用下面的第一个复选框可忽略从匿名类或本地类调用的 `private` 方法。\n\n\n使用第三个复选框可仅报告 `static` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOnlyUsedFromInnerClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparisonToNaN",
                "shortDescription": {
                  "text": "与 'Double.NaN' 或 'Float.NaN' 比较"
                },
                "fullDescription": {
                  "text": "报告任何与 'Double.NaN' 或 'Float.NaN' 的比较。 此类比较毫无意义，因为 NaN 不等于任何内容，包括不等于自身。 改用 'Double.isNaN()' 或 'Float.isNaN()' 方法。 示例： 'if (x == Double.NaN) {...}' 在应用快速修复后： 'if (Double.isNaN(x)) {...}'",
                  "markdown": "报告任何与 `Double.NaN` 或 `Float.NaN` 的比较。 此类比较毫无意义，因为 NaN 不等于任何内容，包括不等于自身。 改用 `Double.isNaN()` 或 `Float.isNaN()` 方法。\n\n**示例：**\n\n\n      if (x == Double.NaN) {...}\n\n在应用快速修复后：\n\n\n      if (Double.isNaN(x)) {...}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparisonToNaN",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MultiCatchCanBeSplit",
                "shortDescription": {
                  "text": "多 catch 可拆分为单独的 catch 块"
                },
                "fullDescription": {
                  "text": "报告多个 'catch' 部分并建议将它们拆分为单独的 'catch' 块。 示例： 'try {\n    int i = getIndex();\n  } catch (NullPointerException|IndexOutOfBoundsException e) {\n    e.printStackTrace();\n  }' 在应用快速修复后： 'try {\n    int i = getIndex();\n  } catch (NullPointerException e) {\n    e.printStackTrace();\n  } catch (IndexOutOfBoundsException e) {\n    e.printStackTrace();\n  }' 此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。",
                  "markdown": "报告多个 `catch` 部分并建议将它们拆分为单独的 `catch` 块。\n\n示例：\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException|IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\n在应用快速修复后：\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException e) {\n        e.printStackTrace();\n      } catch (IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\n此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MultiCatchCanBeSplit",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ResultSetIndexZero",
                "shortDescription": {
                  "text": "在 JDBC ResultSet 中使用索引 0"
                },
                "fullDescription": {
                  "text": "报告访问 'java.sql.ResultSet' 或 'java.sql.PreparedStatement' 的第 0 列的尝试。 由于历史原因，'java.sql.ResultSet' 和 'java.sql.PreparedStatement' 的列不是从 0 开始编号，而是从 1 开始编号，并且访问第 0 列是 JDBC 编程中的常见错误。 示例： 'String getName(ResultSet rs) {\n    return rs.getString(0);\n  }'",
                  "markdown": "报告访问 `java.sql.ResultSet` 或 `java.sql.PreparedStatement` 的第 0 列的尝试。 由于历史原因，`java.sql.ResultSet` 和 `java.sql.PreparedStatement` 的列不是从 **0** 开始编号，而是从 **1** 开始编号，并且访问第 0 列是 JDBC 编程中的常见错误。\n\n**示例：**\n\n\n      String getName(ResultSet rs) {\n        return rs.getString(0);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfIndexZeroInJDBCResultSet",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionCoveredByFurtherCondition",
                "shortDescription": {
                  "text": "条件由进一步的条件覆盖"
                },
                "fullDescription": {
                  "text": "报告由于后续条件完全覆盖而变得冗余的条件。 例如，在 'value != -1 && value > 0' 条件下，第一部分是冗余的：如果它为 false，那么第二部分也为 false。 或者在像 'obj != null && obj instanceof String' 这样的条件下，null 检查是冗余的，因为 'instanceof' 运算符意味着非 null。 2018.3 最新变化",
                  "markdown": "报告由于后续条件完全覆盖而变得冗余的条件。\n\n例如，在 `value != -1 && value > 0` 条件下，第一部分是冗余的：如果它为 false，那么第二部分也为 false。\n或者在像 `obj != null && obj instanceof String` 这样的条件下，null 检查是冗余的，因为 `instanceof` 运算符意味着非 null。\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionCoveredByFurtherCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariableHidesField",
                "shortDescription": {
                  "text": "模式变量隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的模式变量。 由于此类命名，在有意使用同名字段的情况下，您可能会误用该模式变量。 建议通过快速修复重命名该变量。 示例： 'class Pointless {\n    Point p = new Point();\n\n    public void test(Object a) {\n      if (a instanceof Point p) {\n        System.out.print(\"a is a point (\" + p.x + \", \" + p.y + ')');\n      } else {\n        System.out.print(\"p is a point (\" + p.x + \", \" + p.y + ')');\n      }\n    }\n  }' 2022.2 最新变化",
                  "markdown": "报告与周围类的字段同名的模式变量。 由于此类命名，在有意使用同名字段的情况下，您可能会误用该模式变量。\n\n\n建议通过快速修复重命名该变量。\n\n**示例：**\n\n\n      class Pointless {\n        Point p = new Point();\n\n        public void test(Object a) {\n          if (a instanceof Point p) {\n            System.out.print(\"a is a point (\" + p.x + \", \" + p.y + ')');\n          } else {\n            System.out.print(\"p is a point (\" + p.x + \", \" + p.y + ')');\n          }\n        }\n      }\n\n2022.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternVariableHidesField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JoinDeclarationAndAssignmentJava",
                "shortDescription": {
                  "text": "赋值可与声明联接"
                },
                "fullDescription": {
                  "text": "报告可以与变量声明联接的变量赋值。 示例： 'int x;\n  x = 1;' 快速修复将赋值转换为初始值设定项： 'int x = 1;' 2018.3 最新变化",
                  "markdown": "报告可以与变量声明联接的变量赋值。\n\n示例：\n\n\n      int x;\n      x = 1;\n\n快速修复将赋值转换为初始值设定项：\n\n\n      int x = 1;\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JoinDeclarationAndAssignmentJava",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerClassVariableHidesOuterClassVariable",
                "shortDescription": {
                  "text": "内部类字段隐藏外部类字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的内部类字段。 由于进行此类命名，在周围类有意使用同名字段的情况下，您可能会误用内部类的字段。 建议通过快速修复重命名该内部类字段。 示例： 'class Outer {\n    private String name;\n\n    class Inner {\n      private String name;\n    }\n  }' 使用此选项可选择此检查应报告所有名称冲突，还是只报告与内部类可见的字段的冲突。",
                  "markdown": "报告与周围类的字段同名的内部类字段。 由于进行此类命名，在周围类有意使用同名字段的情况下，您可能会误用内部类的字段。\n\n建议通过快速修复重命名该内部类字段。\n\n**示例：**\n\n\n      class Outer {\n        private String name;\n\n        class Inner {\n          private String name;\n        }\n      }\n\n\n使用此选项可选择此检查应报告所有名称冲突，还是只报告与内部类可见的字段的冲突。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerClassFieldHidesOuterClassField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MISSORTED_IMPORTS",
                "shortDescription": {
                  "text": "错误排序的 import"
                },
                "fullDescription": {
                  "text": "报告未根据当前代码样式排列的 'import' 语句（请参阅“设置|编辑|代码样式”）。 示例： 'import java.util.List;\n  import java.util.ArrayList;\n\n  public class Example {\n    List list = new ArrayList();\n  }' 在应用“优化 import”快速修复后： 'import java.util.ArrayList;\n  import java.util.List;\n\n  public class Example {\n    List list = new ArrayList();\n  }'",
                  "markdown": "报告未根据当前代码样式排列的 `import` 语句（请参阅\"设置\\|编辑\\|代码样式\"）。\n\n**示例：**\n\n\n      import java.util.List;\n      import java.util.ArrayList;\n\n      public class Example {\n        List list = new ArrayList();\n      }\n\n在应用\"优化 import\"快速修复后：\n\n\n      import java.util.ArrayList;\n      import java.util.List;\n\n      public class Example {\n        List list = new ArrayList();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MISSORTED_IMPORTS",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 14,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonThreadSafeLazyInitialization",
                "shortDescription": {
                  "text": "不安全的 'static' 字段延迟初始化"
                },
                "fullDescription": {
                  "text": "报告以非线程安全方式延迟初始化的 'static' 变量。 应该使用适当的同步构造来完成 'static' 变量的延迟初始化，以防止不同的线程执行冲突的初始化。 如果适用，建议使用引入延迟初始化容器类习惯用法的快速修复。 这个习惯用法利用了 JVM 会保证类在使用之前不会被初始化的事实。 示例： 'class X {\n    private static List<String> list;\n\n    public List<String> getList() {\n      if (list == null) {\n        list = List.of(\"one\", \"two\", \"tree\");\n      }\n      return list;\n    }\n  }' 在应用快速修复后： 'class X {\n    private static final class ListHolder {\n      static final List<String> list = List.of(\"one\", \"two\", \"tree\");\n    }\n\n    public List<String> getList() {\n      return ListHolder.list;\n    }\n  }'",
                  "markdown": "报告以非线程安全方式延迟初始化的 `static` 变量。\n\n应该使用适当的同步构造来完成 `static` 变量的延迟初始化，以防止不同的线程执行冲突的初始化。\n\n如果适用，建议使用引入[延迟初始化容器类习惯用法](https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom)的快速修复。\n这个习惯用法利用了 JVM 会保证类在使用之前不会被初始化的事实。\n\n**示例：**\n\n\n      class X {\n        private static List<String> list;\n\n        public List<String> getList() {\n          if (list == null) {\n            list = List.of(\"one\", \"two\", \"tree\");\n          }\n          return list;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class X {\n        private static final class ListHolder {\n          static final List<String> list = List.of(\"one\", \"two\", \"tree\");\n        }\n\n        public List<String> getList() {\n          return ListHolder.list;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonThreadSafeLazyInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryModifier",
                "shortDescription": {
                  "text": "不必要的修饰符"
                },
                "fullDescription": {
                  "text": "报告冗余的修饰符并建议移除它们。 结果代码会更短，但其行为和含义将保持不变。 示例 1： '// 在 Java 17 和更高版本下，所有代码都是隐式 strictfp\n  strictfp class X {\n\n    // 内部枚举为隐式 static\n    static enum Inner {\n        A, B, C\n    }\n\n    // 内部记录为隐式 static\n    static record R() {\n    }\n  }' 示例 2： 'final record R() {\n    // 所有记录均为隐式 final\n  }' 示例 3： '// 所有接口均为隐式 abstract\n  abstract interface Printer {\n\n    // 所有接口成员均为隐式 public\n    public int size();\n\n    // 接口的所有内部类均为隐式 static\n    static class Inner {}\n  }'",
                  "markdown": "报告冗余的修饰符并建议移除它们。 结果代码会更短，但其行为和含义将保持不变。\n\n**示例 1：**\n\n\n      // 在 Java 17 和更高版本下，所有代码都是隐式 strictfp\n      strictfp class X {\n\n        // 内部枚举为隐式 static\n        static enum Inner {\n            A, B, C\n        }\n\n        // 内部记录为隐式 static\n        static record R() {\n        }\n      }\n\n**示例 2：**\n\n\n      final record R() {\n        // 所有记录均为隐式 final\n      }\n\n**示例 3：**\n\n\n      // 所有接口均为隐式 abstract\n      abstract interface Printer {\n\n        // 所有接口成员均为隐式 public\n        public int size();\n\n        // 接口的所有内部类均为隐式 static\n        static class Inner {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryModifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalCanBePushedInsideExpression",
                "shortDescription": {
                  "text": "可以将条件推送到分支表达式内部"
                },
                "fullDescription": {
                  "text": "报告满足以下条件表达式：带有 'then' 和 else 分支，且足够相似，以便表达式可以移入内部。 此操作会缩短代码。 示例： 'double g(int a, int b) {\n    return a == b ? Math.cos(0) : Math.cos(1);\n  }' 在应用快速修复后： 'double g(int a, int b) {\n    return Math.cos(a == b ? 0 : 1);\n  }' 2017.2 最新变化",
                  "markdown": "报告满足以下条件表达式：带有 `then` 和 else 分支，且足够相似，以便表达式可以移入内部。 此操作会缩短代码。\n\n示例：\n\n\n      double g(int a, int b) {\n        return a == b ? Math.cos(0) : Math.cos(1);\n      }\n\n在应用快速修复后：\n\n\n      double g(int a, int b) {\n        return Math.cos(a == b ? 0 : 1);\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalCanBePushedInsideExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneInNonCloneableClass",
                "shortDescription": {
                  "text": "不可克隆类中的 'clone()' 方法"
                },
                "fullDescription": {
                  "text": "报告重写 'clone()' 方法但不实现 'Cloneable' 接口的类。 这通常表示编程错误。 使用仅对 'public' 克隆方法发出警告选项可以忽略不是 'public' 的方法。 对于设计为继承的类，您可以选择不实现 'Cloneable' 接口，而是重写 'clone()' 并将其声明为 'protected'，并决定是否在子类中实现 'Cloneable' 接口。",
                  "markdown": "报告重写 `clone()` 方法但不实现 `Cloneable` 接口的类。 这通常表示编程错误。\n\n\n使用**仅对 'public' 克隆方法发出警告** 选项可以忽略不是 `public` 的方法。\n\n对于设计为继承的类，您可以选择不实现 `Cloneable` 接口，而是重写 `clone()` 并将其声明为 `protected`，并决定是否在子类中实现 `Cloneable` 接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneInNonCloneableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 89,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8ListReplaceAll",
                "shortDescription": {
                  "text": "循环可被替换为 'List.replaceAll()'"
                },
                "fullDescription": {
                  "text": "报告可以折叠为单个 'List.replaceAll()' 调用的循环。 示例： 'for (int i = 0; i < strings.size(); i++) {\n    String str = strings.get(i).toLowerCase();\n    strings.set(i, str);\n  }' 在应用快速修复后： 'strings.replaceAll(String::toLowerCase);' 2022.1 最新变化 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以折叠为单个 `List.replaceAll()` 调用的循环。\n\n**示例：**\n\n\n      for (int i = 0; i < strings.size(); i++) {\n        String str = strings.get(i).toLowerCase();\n        strings.set(i, str);\n      }\n\n在应用快速修复后：\n\n\n      strings.replaceAll(String::toLowerCase);\n\n2022.1 最新变化\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8ListReplaceAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalLegacyMethod",
                "shortDescription": {
                  "text": "调用了 'BigDecimal' 遗留方法"
                },
                "fullDescription": {
                  "text": "报告对使用整数常量指定舍入模式的 'BigDecimal.divide()' 或 'BigDecimal.setScale()' 的调用。 自 JDK 1.5 起，可以考虑使用接受 'RoundingMode' 'enum' 形参的方法。 示例： 'new BigDecimal(\"42\").setScale(2, BigDecimal.ROUND_FLOOR);' 在应用快速修复后： 'new BigDecimal(\"42\").setScale(2, RoundingMode.FLOOR);'",
                  "markdown": "报告对使用整数常量指定舍入模式的 `BigDecimal.divide()` 或 `BigDecimal.setScale()` 的调用。 自 JDK 1.5 起，可以考虑使用接受 `RoundingMode` `enum` 形参的方法。\n\n**示例：**\n\n    new BigDecimal(\"42\").setScale(2, BigDecimal.ROUND_FLOOR);\n\n在应用快速修复后：\n\n    new BigDecimal(\"42\").setScale(2, RoundingMode.FLOOR);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalLegacyMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingPackageInfo",
                "shortDescription": {
                  "text": "缺少 'package-info.java'"
                },
                "fullDescription": {
                  "text": "报告包含类但不包含 'package-info.java' 或 'package.html' 文件并因此缺少软件包文档的软件包。 该快速修复会创建一个初始的 'package-info.java' 文件。",
                  "markdown": "报告包含类但不包含 `package-info.java` 或 `package.html` 文件并因此缺少软件包文档的软件包。\n\n该快速修复会创建一个初始的 `package-info.java` 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingPackageInfo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryConstructor",
                "shortDescription": {
                  "text": "冗余无实参构造函数"
                },
                "fullDescription": {
                  "text": "报告不必要的构造函数。 如果构造函数是类的唯一构造函数，没有形参，与其包含类具有相同的访问修饰符，并且除了显式或隐式调用不带实参的超类构造函数外，不执行任何初始化，则不需要构造函数。 此类构造函数可以安全地移除，因为即使没有指定，它也会由编译器生成。 示例： 'public class Foo {\n    public Foo() {}\n  }' 在应用快速修复后： 'public class Foo {}' 使用检查设置可以忽略具有注解的不必要的构造函数。",
                  "markdown": "报告不必要的构造函数。\n\n\n如果构造函数是类的唯一构造函数，没有形参，与其包含类具有相同的访问修饰符，并且除了显式或隐式调用不带实参的超类构造函数外，不执行任何初始化，则不需要构造函数。\n此类构造函数可以安全地移除，因为即使没有指定，它也会由编译器生成。\n\n**示例：**\n\n\n      public class Foo {\n        public Foo() {}\n      }\n\n在应用快速修复后：\n\n\n      public class Foo {}\n\n\n使用检查设置可以忽略具有注解的不必要的构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantNoArgConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferField",
                "shortDescription": {
                  "text": "'StringBuilder' 字段"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.StringBuffer' 或 'java.lang.StringBuilder' 类型的字段。 此类字段可以无限增长，并且通常会导致内存泄漏。 示例： 'public class Example {\n    private StringBuilder builder = new StringBuilder();\n\n  }'",
                  "markdown": "报告 `java.lang.StringBuffer` 或 `java.lang.StringBuilder` 类型的字段。 此类字段可以无限增长，并且通常会导致内存泄漏。\n\n**示例：**\n\n\n      public class Example {\n        private StringBuilder builder = new StringBuilder();\n\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNameSameAsAncestorName",
                "shortDescription": {
                  "text": "类名与上级名称相同"
                },
                "fullDescription": {
                  "text": "报告与其某个超类的名称相同，而其完全限定名称仍然不同的类。 这种类名可能令人困惑。 示例： 'package util;\n  abstract class Iterable<T> implements java.lang.Iterable<T> {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告与其某个超类的名称相同，而其完全限定名称仍然不同的类。 这种类名可能令人困惑。\n\n**示例：**\n\n\n      package util;\n      abstract class Iterable<T> implements java.lang.Iterable<T> {}\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNameSameAsAncestorName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 61,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantMethodOverride",
                "shortDescription": {
                  "text": "方法与其 super 方法相同"
                },
                "fullDescription": {
                  "text": "报告与其 super 方法相同的方法。 此类方法与其 super 方法的签名相同，并且要么方法体相同，要么其主体仅包含对 super 方法的调用。 这些方法冗余，可以移除。 使用下面的第一个复选框，对重写库方法的方法进行检查。 检查库方法可能会减慢检查速度。 使用下面的第二个复选框，忽略只将调用委托给其 super 方法的方法。",
                  "markdown": "报告与其 super 方法相同的方法。 此类方法与其 super 方法的签名相同，并且要么方法体相同，要么其主体仅包含对 super 方法的调用。 这些方法冗余，可以移除。\n\n\n使用下面的第一个复选框，对重写库方法的方法进行检查。\n检查库方法可能会减慢检查速度。\n\n\n使用下面的第二个复选框，忽略只将调用委托给其 super 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantMethodOverride",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatementWithLabel",
                "shortDescription": {
                  "text": "带标签的 'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告包含标签的 'continue' 语句。 'continue' 标签语句导致重构复杂化，可能令人困惑。 示例： 'void handle(List<String> strs) {\n    outer:\n    for (String s: strs) {\n      for (char ch : s.toCharArray()) {\n        if ('s' == ch) continue outer;\n        handleChar(ch);\n      }\n    }\n  }'",
                  "markdown": "报告包含标签的 `continue` 语句。\n\n`continue` 标签语句导致重构复杂化，可能令人困惑。\n\n示例：\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) continue outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatementWithLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableBooleanExpression",
                "shortDescription": {
                  "text": "可简化的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告可以简化的布尔表达式。 示例： 'void f(boolean foo, boolean bar) {\n    boolean b = !(foo ^ bar);\n  }' 在应用快速修复后： 'void f(boolean foo, boolean bar) {\n    boolean b = foo == bar;\n  }' 示例： 'void f(boolean foo, boolean bar) {\n    boolean b = (foo && bar) || !foo;\n  }' 在应用快速修复后： 'void f(boolean foo, boolean bar) {\n    boolean b = !foo || bar;\n  }'",
                  "markdown": "报告可以简化的布尔表达式。\n\n示例：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !(foo ^ bar);\n      }\n\n在应用快速修复后：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = foo == bar;\n      }\n\n示例：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = (foo && bar) || !foo;\n      }\n      \n在应用快速修复后：\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !foo || bar;\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableBooleanExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaExistingMethodCanBeUsed",
                "shortDescription": {
                  "text": "现有 static 方法体的副本"
                },
                "fullDescription": {
                  "text": "报告与现有 static 方法相同的 Java 代码段，建议重用这些 static 方法。 重用现有方法可以使代码更短、更具可读性。 示例： 'static List<String> readFileAndTrim(Path path) throws IOException {\n    List<String> lines = Files.readAllLines(path);\n    return lines.stream().map(String::trim).toList();\n  }\n  \n  static List<String> readFileAndTrim(String path) throws IOException {\n    Path p = Path.of(path);\n    List<String> lines = Files.readAllLines(p);\n    return lines.stream().map(String::trim).toList();\n  }' 这里，第二个方法与第一个方法非常相似，第一个方法可以在其实现中重用。 应用快速修复后，结果如下所示： 'static List<String> readFileAndTrim(Path path) throws IOException {\n    List<String> lines = Files.readAllLines(path);\n    return lines.stream().map(String::trim).toList();\n  }\n\n  static List<String> readFileAndTrim(String path) throws IOException {\n    Path p = Path.of(path);\n    return readFileAndTrim(p);\n  }' 2024.1 最新变化",
                  "markdown": "报告与现有 static 方法相同的 Java 代码段，建议重用这些 static 方法。 重用现有方法可以使代码更短、更具可读性。\n\n示例：\n\n\n      static List<String> readFileAndTrim(Path path) throws IOException {\n        List<String> lines = Files.readAllLines(path);\n        return lines.stream().map(String::trim).toList();\n      }\n      \n      static List<String> readFileAndTrim(String path) throws IOException {\n        Path p = Path.of(path);\n        List<String> lines = Files.readAllLines(p);\n        return lines.stream().map(String::trim).toList();\n      }\n\n这里，第二个方法与第一个方法非常相似，第一个方法可以在其实现中重用。 应用快速修复后，结果如下所示：\n\n\n      static List<String> readFileAndTrim(Path path) throws IOException {\n        List<String> lines = Files.readAllLines(path);\n        return lines.stream().map(String::trim).toList();\n      }\n\n      static List<String> readFileAndTrim(String path) throws IOException {\n        Path p = Path.of(path);\n        return readFileAndTrim(p);\n      }\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JavaExistingMethodCanBeUsed",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SignalWithoutCorrespondingAwait",
                "shortDescription": {
                  "text": "没有相应 'await()' 的 'signal()'"
                },
                "fullDescription": {
                  "text": "报告对无法为之找到相应 'Condition.await()' 调用的 'Condition.signal()' 或 'Condition.signalAll()' 的调用。 此检查仅报告以当前类的目标字段为目标的调用。 示例： 'class Queue {\n    private final Condition isEmpty = ...;\n\n    void add(Object elem) {\n      // ...\n      isEmpty.signal(); // 警告：在没有相应 'await()' 的情况下调用 'signal()'\n      // ...\n    }\n\n    void remove(Object elem) throws InterruptedException {\n      // ...\n      //      isEmpty.await();\n      // ...\n    }\n  }'",
                  "markdown": "报告对无法为之找到相应 `Condition.await()` 调用的 `Condition.signal()` 或 `Condition.signalAll()` 的调用。\n\n此检查仅报告以当前类的目标字段为目标的调用。\n\n**示例：**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          isEmpty.signal(); // 警告：在没有相应 'await()' 的情况下调用 'signal()'\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          //      isEmpty.await();\n          // ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SignalWithoutCorrespondingAwait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FoldExpressionIntoStream",
                "shortDescription": {
                  "text": "表达式可以折叠到流链中"
                },
                "fullDescription": {
                  "text": "报告所具有的重复模式可以替换为 Stream API 或 'String.join()' 的表达式。 示例： 'boolean allStartWith(String a, String b, String c, String d, String prefix) {\n    return a.startsWith(prefix) && b.startsWith(prefix) && c.startsWith(prefix) && d.startsWith(prefix);\n  }' 在应用快速修复后： 'boolean foo(String a, String b, String c, String d, String prefix) {\n    return Stream.of(a, b, c, d).allMatch(s -> s.startsWith(prefix));\n  }' 示例： 'String joinAll(String a, String b, String c, String d) {\n    return a + \",\" + b + \",\" + c + \",\" + d;\n  }' 在应用快速修复后： 'String joinAll(String a, String b, String c, String d) {\n    return String.join(\",\", a, b, c, d);\n  }' 2018.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告所具有的重复模式可以替换为 *Stream API* 或 `String.join()` 的表达式。\n\n示例：\n\n\n      boolean allStartWith(String a, String b, String c, String d, String prefix) {\n        return a.startsWith(prefix) && b.startsWith(prefix) && c.startsWith(prefix) && d.startsWith(prefix);\n      }\n\n在应用快速修复后：\n\n\n      boolean foo(String a, String b, String c, String d, String prefix) {\n        return Stream.of(a, b, c, d).allMatch(s -> s.startsWith(prefix));\n      }\n\n示例：\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return a + \",\" + b + \",\" + c + \",\" + d;\n      }\n\n在应用快速修复后：\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return String.join(\",\", a, b, c, d);\n      }\n\n2018.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FoldExpressionIntoStream",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableDeserializableClassInSecureContext",
                "shortDescription": {
                  "text": "安全上下文中的可序列化类"
                },
                "fullDescription": {
                  "text": "报告可以被序列化或反序列化的类。 如果一个类支持 'Serializable' 接口，并且它的 'readObject()' 和 'writeObject()' 方法未被定义为总是抛出异常，那么就可以被序列化。 在供安全使用的代码中，可序列化的类可能比较危险。 示例： 'class DeserializableClass implements Serializable { // 该类不包含抛出异常的 'writeObject()' 方法\n    private int sensitive = 736326;\n\n    private void readObject(ObjectInputStream in) {\n        throw new Error();\n    }\n}' 在应用快速修复后： 'class DeserializableClass implements Serializable {\n    private int sensitive = 736326;\n\n    private void readObject(ObjectInputStream in) {\n        throw new Error();\n    }\n\n    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n        throw new java.io.NotSerializableException(\"DeserializableClass\");\n    }\n  }' 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 请注意，与其忽略这些类，添加始终抛出异常的 'readObject()' 和 'writeObject()' 方法可能更安全。 是否忽略可序列化的匿名类。",
                  "markdown": "报告可以被序列化或反序列化的类。\n\n\n如果一个类支持 `Serializable` 接口，并且它的 `readObject()` 和 `writeObject()` 方法未被定义为总是抛出异常，那么就可以被序列化。 在供安全使用的代码中，可序列化的类可能比较危险。\n\n**示例：**\n\n\n      class DeserializableClass implements Serializable { // 该类不包含抛出异常的 'writeObject()' 方法\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n    }\n\n在应用快速修复后：\n\n\n      class DeserializableClass implements Serializable {\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n\n        private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n            throw new java.io.NotSerializableException(\"DeserializableClass\");\n        }\n      }\n\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。 请注意，与其忽略这些类，添加始终抛出异常的 `readObject()` 和 `writeObject()` 方法可能更安全。\n* 是否忽略可序列化的匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableDeserializableClassInSecureContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavaModuleNaming",
                "shortDescription": {
                  "text": "Java 模块名称与约定相矛盾"
                },
                "fullDescription": {
                  "text": "报告模块名称与 Java Platform Module System 建议相矛盾的情况。 其中一种建议是避免在模块名称末尾使用数字。 示例： 'module foo1.bar2 {}'",
                  "markdown": "报告模块名称与 Java Platform Module System 建议相矛盾的情况。\n\n其中一种[建议](http://mail.openjdk.org/pipermail/jpms-spec-experts/2017-March/000659.html)是避免在模块名称末尾使用数字。\n\n**示例：**\n\n\n    module foo1.bar2 {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavaModuleNaming",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnaryPlus",
                "shortDescription": {
                  "text": "一元正号"
                },
                "fullDescription": {
                  "text": "报告使用 '+' 一元运算符的情况。 一元加号通常为 null 运算，它的存在可能代表编码错误。 例如，与递增运算符（如 '+++' 中）或相等运算符（如 '=+' 中）结合使用。 示例： 'void unaryPlus(int i) {\n    int x = + +i;\n  }' 建议使用以下快速修复： 移除 'i' 变量前的 '+' 运算符： 'void unaryPlus(int i) {\n    int x = i;\n  }' 使用前缀递增运算符替换 '+' 运算符： 'void unaryPlus(int i) {\n    int x = ++i;\n  }' 使用下面的复选框可以报告与二进制或另一个一元表达式一起使用的一元加号。 这意味着检查将不会报告将一元加号表达式用于数组初始值设定项表达式或用作方法实参的情况。",
                  "markdown": "报告使用 `+` 一元运算符的情况。 一元加号通常为 null 运算，它的存在可能代表编码错误。 例如，与递增运算符（如 `+++` 中）或相等运算符（如 `=+` 中）结合使用。\n\n**示例：**\n\n\n      void unaryPlus(int i) {\n        int x = + +i;\n      }\n\n建议使用以下快速修复：\n\n* 移除 `i` 变量前的 `+` 运算符：\n\n\n        void unaryPlus(int i) {\n          int x = i;\n        }\n\n* 使用前缀递增运算符替换 `+` 运算符：\n\n\n        void unaryPlus(int i) {\n          int x = ++i;\n        }\n\n\n使用下面的复选框可以报告与二进制或另一个一元表达式一起使用的一元加号。\n这意味着检查将不会报告将一元加号表达式用于数组初始值设定项表达式或用作方法实参的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnaryPlus",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstructorCount",
                "shortDescription": {
                  "text": "构造函数过多的类"
                },
                "fullDescription": {
                  "text": "报告构造函数数量超过指定最大值的类。 具有太多构造函数的类容易出现初始化错误，通常建议将这种类建模为多个子类。 配置检查： 使用构造函数计数限制字段可指定类中允许的构造函数的最大数量。 使用忽略弃用的构造函数选项可避免将已弃用的构造函数添加到总计数中。",
                  "markdown": "报告构造函数数量超过指定最大值的类。\n\n具有太多构造函数的类容易出现初始化错误，通常建议将这种类建模为多个子类。\n\n配置检查：\n\n* 使用**构造函数计数限制**字段可指定类中允许的构造函数的最大数量。\n* 使用**忽略弃用的构造函数**选项可避免将已弃用的构造函数添加到总计数中。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncrementDecrementUsedAsExpression",
                "shortDescription": {
                  "text": "使用 '++' 或 '--' 的结果"
                },
                "fullDescription": {
                  "text": "报告嵌套在其他表达式中的增量或减量表达式。 此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。 该快速修复会将递增或递减运算提取到单独的表达式语句中。 示例： 'int i = 10;\n  while (i-- > 0) {\n    System.out.println(i);\n  }' 在应用快速修复后： 'int i = 10;\n  while (i > 0) {\n    i--;\n    System.out.println(i);\n  }\n  i--;'",
                  "markdown": "报告嵌套在其他表达式中的增量或减量表达式。 此类表达式可能令人困惑，并违反一般设计原则，即任何结构应当只发挥一种作用。\n\n该快速修复会将递增或递减运算提取到单独的表达式语句中。\n\n**示例：**\n\n\n      int i = 10;\n      while (i-- > 0) {\n        System.out.println(i);\n      }\n\n在应用快速修复后：\n\n\n      int i = 10;\n      while (i > 0) {\n        i--;\n        System.out.println(i);\n      }\n      i--;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ValueOfIncrementOrDecrementUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DisjointPackage",
                "shortDescription": {
                  "text": "具有不相交依赖关系图的软件包"
                },
                "fullDescription": {
                  "text": "报告类可以分成相互独立的子集的软件包。 此类非连续软件包表示临时打包或缺乏概念上的连通性。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告类可以分成相互独立的子集的软件包。\n\n此类非连续软件包表示临时打包或缺乏概念上的连通性。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DisjointPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 36,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverloadsParentMethod",
                "shortDescription": {
                  "text": "可能是超类方法意外重载"
                },
                "fullDescription": {
                  "text": "报告形参名称和数量与超类中的方法相同，但其中至少一个形参为不同的不兼容类型的实例方法。 在本例中，子类中的方法将重载而不是重写超类中的方法。 如果不是有意为之，可能会导致潜在错误。 示例： 'public class Foo {\n    void foo(int x) {}\n  }\n\n  public class Bar extends Foo {\n    void foo(Number x) {} // 在重写可能是有意为之的情况下，\n                          // 方法 'foo()' 重载超类的兼容方法\n  }' 使用此选项可选择该检查是否也应报告形参类型不兼容的情况。",
                  "markdown": "报告形参名称和数量与超类中的方法相同，但其中至少一个形参为不同的不兼容类型的实例方法。\n\n\n在本例中，子类中的方法将重载而不是重写超类中的方法。 如果不是有意为之，可能会导致潜在错误。\n\n**示例：**\n\n\n      public class Foo {\n        void foo(int x) {}\n      }\n\n      public class Bar extends Foo {\n        void foo(Number x) {} // 在重写可能是有意为之的情况下，\n                              // 方法 'foo()' 重载超类的兼容方法\n      }\n\n\n使用此选项可选择该检查是否也应报告形参类型不兼容的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverloadsMethodOfSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UpperCaseFieldNameNotConstant",
                "shortDescription": {
                  "text": "具有大写名称的非常量字段"
                },
                "fullDescription": {
                  "text": "报告名称全部为大写的非 'static' 非 'final' 字段。 此类字段可能会因违反通用命名约定而引起混淆，并且经常被错误使用。 示例： 'public static int THE_ANSWER = 42; // 此处警告：final 修饰符缺失' 只能在编辑器中使用重命名此类字段的快速修复。",
                  "markdown": "报告名称全部为大写的非 `static` 非 `final` 字段。\n\n此类字段可能会因违反通用命名约定而引起混淆，并且经常被错误使用。\n\n**示例：**\n\n\n      public static int THE_ANSWER = 42; // 此处警告：final 修饰符缺失\n\n只能在编辑器中使用重命名此类字段的快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonConstantFieldWithUpperCaseName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodMayBeSynchronized",
                "shortDescription": {
                  "text": "只有一个 'synchronized' 块的方法可被替换为 'synchronized' 方法"
                },
                "fullDescription": {
                  "text": "报告其主体只包含一条 'synchronized' 语句的方法。 对于实例方法，此 'synchronized' 语句的锁定表达式必须等于 'this'；对于 static 方法，必须等于 '[ClassName].class'。 为改善此类方法的可读性，可以移除 'synchronized' 包装器，并将方法标记为 'synchronized'。 示例： 'public int generateInt(int x) {\n    synchronized (this) {\n      return 1;\n    }\n  }' 在应用快速修复后： 'public synchronized int generateInt(int x) {\n    return 1;\n  }'",
                  "markdown": "报告其主体只包含一条 `synchronized` 语句的方法。 对于实例方法，此 `synchronized` 语句的锁定表达式必须等于 `this`；对于 static 方法，必须等于 `[ClassName].class`。\n\n\n为改善此类方法的可读性，可以移除 `synchronized` 包装器，并将方法标记为 `synchronized`。\n\n**示例：**\n\n\n      public int generateInt(int x) {\n        synchronized (this) {\n          return 1;\n        }\n      }\n\n在应用快速修复后：\n\n\n      public synchronized int generateInt(int x) {\n        return 1;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodMayBeSynchronized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2streamapi",
                "shortDescription": {
                  "text": "可以通过 Stream API 收起循环"
                },
                "fullDescription": {
                  "text": "报告使用 lambda 表达式替换为流 API 调用的循环。 此类替换将命令式样式更改为功能式样式，代码也变得更加紧凑。 示例： 'boolean check(List<String> data) {\n    for (String e : data) {\n      String trimmed = e.trim();\n      if (!trimmed.startsWith(\"xyz\")) {\n        return false;\n      }\n    }\n    return true;\n  }' 在应用快速修复后： 'boolean check(List<String> data) {\n    return data.stream().map(String::trim).allMatch(trimmed -> trimmed.startsWith(\"xyz\"));\n  }' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告使用 lambda 表达式替换为流 API 调用的循环。\n\n此类替换将命令式样式更改为功能式样式，代码也变得更加紧凑。\n\n示例：\n\n\n      boolean check(List<String> data) {\n        for (String e : data) {\n          String trimmed = e.trim();\n          if (!trimmed.startsWith(\"xyz\")) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n在应用快速修复后：\n\n\n      boolean check(List<String> data) {\n        return data.stream().map(String::trim).allMatch(trimmed -> trimmed.startsWith(\"xyz\"));\n      }\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "Convert2streamapi",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialPersistentFieldsWithWrongSignature",
                "shortDescription": {
                  "text": "'serialPersistentFields' 字段未被声明为 'private static final ObjectStreamField[]'"
                },
                "fullDescription": {
                  "text": "报告 'serialPersistentFields' 字段未被声明为 'private static final ObjectStreamField[]' 的 'Serializable' 类。 如果 'serialPersistentFields' 字段未使用这些修饰符进行声明，序列化行为将与根本未声明该字段如出一辙。 示例： 'class List implements Serializable {\n    private List next;\n\n    ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"next\", List.class)};\n\n  }'",
                  "markdown": "报告 `serialPersistentFields` 字段未被声明为 `private static final ObjectStreamField[]` 的 `Serializable` 类。\n\n\n如果 `serialPersistentFields` 字段未使用这些修饰符进行声明，序列化行为将与根本未声明该字段如出一辙。\n\n**示例：**\n\n\n      class List implements Serializable {\n        private List next;\n\n        ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"next\", List.class)};\n\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerialPersistentFieldsWithWrongSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorResultComparison",
                "shortDescription": {
                  "text": "compare 方法的可疑用法"
                },
                "fullDescription": {
                  "text": "报告 'Comparator.compare()' 或 'Comparable.compareTo()' 调用结果与非零常量的比较。 根据约定，这些方法可以返回任何整数（不只是 -1、0 或 1），因此与特定数字比较是一种不好的做法。 某些广泛使用的比较方法（例如 'String.compareTo()'）实际上返回 [-1..1] 范围之外的值，此类比较可能会导致不正确的程序行为。 示例： 'void validate(String s1, String s2) {\n    // 与 1 比较不正确\n    if (s1.compareTo(s2) == 1) {\n      throw new IllegalArgumentException(\"Incorrect order\");\n    }\n  }' 在应用快速修复后： 'void validate(String s1, String s2) {\n    if (s1.compareTo(s2) > 0) {\n      throw new IllegalArgumentException(\"Incorrect order\");\n    }\n  }' 2017.2 最新变化",
                  "markdown": "报告 `Comparator.compare()` 或 `Comparable.compareTo()` 调用结果与非零常量的比较。 根据约定，这些方法可以返回任何整数（不只是 -1、0 或 1），因此与特定数字比较是一种不好的做法。 某些广泛使用的比较方法（例如 `String.compareTo()`）实际上返回 \\[-1..1\\] 范围之外的值，此类比较可能会导致不正确的程序行为。\n\n示例：\n\n\n      void validate(String s1, String s2) {\n        // 与 1 比较不正确\n        if (s1.compareTo(s2) == 1) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\n在应用快速修复后：\n\n\n      void validate(String s1, String s2) {\n        if (s1.compareTo(s2) > 0) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorResultComparison",
                    "cweIds": [
                      253
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListIndexOfReplaceableByContains",
                "shortDescription": {
                  "text": "'List.indexOf()' 表达式可被替换为 'contains()'"
                },
                "fullDescription": {
                  "text": "报告可以用 'List.contains()' 方法替换的任何 'List.indexOf()' 表达式。 示例： 'boolean hasEmptyString(List<String> list) {\n    // 警告：可以简化\n    return list.indexOf(\"\") >= 0;\n  }' 提供的快速修复将 'indexOf' 调用替换为 'contains' 调用： 'boolean hasEmptyString(List<String> list) {\n    // 快速修复已应用\n    return list.contains(\"\");\n  }'",
                  "markdown": "报告可以用 `List.contains()` 方法替换的任何 `List.indexOf()` 表达式。\n\n示例：\n\n\n      boolean hasEmptyString(List<String> list) {\n        // 警告：可以简化\n        return list.indexOf(\"\") >= 0;\n      }\n\n提供的快速修复将 `indexOf` 调用替换为 `contains` 调用：\n\n\n      boolean hasEmptyString(List<String> list) {\n        // 快速修复已应用\n        return list.contains(\"\");\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListIndexOfReplaceableByContains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonStrictComparisonCanBeEquality",
                "shortDescription": {
                  "text": "非严格不等式 '>=' 或 '<=' 可被替换为 '=='"
                },
                "fullDescription": {
                  "text": "报告根据数据流分析只能对单个操作数值满足的不等条件。 此类条件可被替换为相等条件，以使代码更清晰。 示例： 'if (x >= 10) {\n    ...\n    if (x <= 10) { // can be replaced with 'x == 10'\n    }\n  }' 2022.2 最新变化",
                  "markdown": "报告根据数据流分析只能对单个操作数值满足的不等条件。 此类条件可被替换为相等条件，以使代码更清晰。\n\n示例：\n\n\n      if (x >= 10) {\n        ...\n        if (x <= 10) { // can be replaced with 'x == 10'\n        }\n      }\n\n2022.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NonStrictComparisonCanBeEquality",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryParentheses",
                "shortDescription": {
                  "text": "不必要的圆括号"
                },
                "fullDescription": {
                  "text": "报告任何不必要的圆括号。 如果移除圆括号后表达式的评估顺序保持不变，则不需要圆括号。 示例： 'int n = 3 + (9 * 8);' 在应用快速修复后： 'int n = 3 + 9 * 8;' 配置检查： 使用忽略澄清圆括号选项可忽略有助于明确二元表达式的圆括号。 圆括号澄清被括起来的表达式是一个 'instanceof' 更大表达式一部分的表达式或包含与父表达式不同运算符。 使用忽略条件表达式条件周围的圆括号选项以忽略条件表达式条件周围的任何圆括号。 一些编码标准规定所有这些条件都必须用圆括号括起来。 使用忽略单个非正式类型 lambda 形参周围的圆括号选项可忽略 lambda 表达式中单个 lambda 形参周围的圆括号。",
                  "markdown": "报告任何不必要的圆括号。\n\n如果移除圆括号后表达式的评估顺序保持不变，则不需要圆括号。\n\n示例：\n\n\n      int n = 3 + (9 * 8);\n\n在应用快速修复后：\n\n\n      int n = 3 + 9 * 8;\n\n配置检查：\n\n* 使用**忽略澄清圆括号** 选项可忽略有助于明确二元表达式的圆括号。 圆括号澄清被括起来的表达式是一个 `instanceof` 更大表达式一部分的表达式或包含与父表达式不同运算符。\n* 使用**忽略条件表达式条件周围的圆括号**选项以忽略条件表达式条件周围的任何圆括号。 一些编码标准规定所有这些条件都必须用圆括号括起来。\n* 使用**忽略单个非正式类型 lambda 形参周围的圆括号**选项可忽略 lambda 表达式中单个 lambda 形参周围的圆括号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryParentheses",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousToArrayCall",
                "shortDescription": {
                  "text": "可疑的 'Collection.toArray()' 调用"
                },
                "fullDescription": {
                  "text": "报告对 'Collection.toArray()' 的可疑调用。 以下类型的调用视为可疑： 数组实参的类型与结果被转换成的数组类型不相同。 数组实参的类型与集合声明中的类型形参不匹配。 示例： 'void m1(List list) {\n  Number[] ns = (Number[]) list.toArray(new String[0]);\n}\n\nvoid m2(List<Number> list) {\n  Number[] ns = list.toArray(new String[0]);\n}'",
                  "markdown": "报告对 `Collection.toArray()` 的可疑调用。\n\n以下类型的调用视为可疑：\n\n* 数组实参的类型与结果被转换成的数组类型不相同。\n* 数组实参的类型与集合声明中的类型形参不匹配。\n\n**示例：**\n\n\n    void m1(List list) {\n      Number[] ns = (Number[]) list.toArray(new String[0]);\n    }\n\n    void m2(List<Number> list) {\n      Number[] ns = list.toArray(new String[0]);\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousToArrayCall",
                    "cweIds": [
                      704
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringToUpperWithoutLocale",
                "shortDescription": {
                  "text": "调用无区域设置的 'String.toUpperCase()' 或 'toLowerCase()'"
                },
                "fullDescription": {
                  "text": "报告未指定 'java.util.Locale' 的 'String' 对象上的 'toUpperCase()' 或 'toLowerCase()' 调用。 这些情况下使用默认的系统区域设置，可能会在国际化环境中导致问题。 例如，代码 '\"i\".toUpperCase().equals(\"I\")' 在土耳其语和阿塞拜疆语区域设置中返回 'false'，其中带点和无点的 'i' 是单独的字母。 在土耳其语区域设置中运行时，对包含 'i' 的英文字符串调用 'toUpperCase()' 将返回不正确的结果。 或者，在处理应被视为与区域设置无关的字符串（如 HTML 标记）时，可能会导致错误。",
                  "markdown": "报告未指定 `java.util.Locale` 的 `String` 对象上的 `toUpperCase()` 或 `toLowerCase()` 调用。 这些情况下使用默认的系统区域设置，可能会在国际化环境中导致问题。\n\n\n例如，代码 `\"i\".toUpperCase().equals(\"I\")` 在土耳其语和阿塞拜疆语区域设置中返回 `false`，其中带点和无点的 'i' 是单独的字母。 在土耳其语区域设置中运行时，对包含 'i' 的英文字符串调用 `toUpperCase()` 将返回不正确的结果。 或者，在处理应被视为与区域设置无关的字符串（如 HTML 标记）时，可能会导致错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringToUpperCaseOrToLowerCaseWithoutLocale",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitToImplicitClassMigration",
                "shortDescription": {
                  "text": "显式类声明可被转换为隐式声明的类"
                },
                "fullDescription": {
                  "text": "报告可转换为隐式声明的类的普通类。 示例： 'public class Sample {\n      public static void main(String[] args) {\n          System.out.println(\"Hello, world!\");\n      }\n  }' 在应用快速修复后： 'public static void main(String[] args) {\n      System.out.println(\"Hello, world!\");\n  }' 2024.1 最新变化 此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告可转换为隐式声明的类的普通类。\n\n**示例：**\n\n\n      public class Sample {\n          public static void main(String[] args) {\n              System.out.println(\"Hello, world!\");\n          }\n      }\n\n在应用快速修复后：\n\n\n      public static void main(String[] args) {\n          System.out.println(\"Hello, world!\");\n      }\n\n2024.1 最新变化\n\n此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExplicitToImplicitClassMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 159,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedMethodCall",
                "shortDescription": {
                  "text": "嵌套方法调用"
                },
                "fullDescription": {
                  "text": "报告用作另一个方法调用的形参的方法调用。 该快速修复会引入一个变量，使代码更简单，也更易于调试。 示例： 'public int y() { return 1; }\n  public int f(int x) { return 2 * x; }\n\n  public void foo() {\n      int x = f(y());\n  }' 在应用快速修复后： 'public int y() { return 1; }\n  public int f(int x) { return 2 * x; }\n\n  public void foo() {\n      int y = y();\n      int x = f(y);\n  }' 使用检查选项可以切换以下各项的报告： 字段初始值设定项中的方法调用 对 static 方法的调用 对简单 getter 的调用",
                  "markdown": "报告用作另一个方法调用的形参的方法调用。\n\n该快速修复会引入一个变量，使代码更简单，也更易于调试。\n\n**示例：**\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int x = f(y());\n      }\n\n在应用快速修复后：\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int y = y();\n          int x = f(y);\n      }\n\n\n使用检查选项可以切换以下各项的报告：\n\n* 字段初始值设定项中的方法调用\n* 对 static 方法的调用\n* 对简单 getter 的调用"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyTransitiveDependents",
                "shortDescription": {
                  "text": "传递依赖项过多的类"
                },
                "fullDescription": {
                  "text": "报告被过多其他类直接或间接依赖的类。 对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。 仅报告顶级类。 使用最大传递依赖项数字段可指定类允许的最大直接或间接依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告被过多其他类直接或间接依赖的类。\n\n对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。\n\n仅报告顶级类。\n\n使用**最大传递依赖项数**字段可指定类允许的最大直接或间接依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyTransitiveDependents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 113,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CompareToUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'compareTo()' 中引用了非 final 字段"
                },
                "fullDescription": {
                  "text": "报告对 'compareTo()' 实现中的非 'final' 字段的访问。 此类访问可能导致 'compareTo()' 在对象生命周期的不同时刻返回不同的结果，进而可能在使用 'java.util.TreeSet' 等标准集合类时导致问题。 只有在对该字段不具备写入访问权限时，才可以通过快速修复将该字段设为 'final'，否则不建议进行修正。 示例： 'class Foo implements Comparable<Foo>{\n    private int index;\n    Foo(int idx) {\n      index = idx;\n    }\n    @Override\n    public int compareTo(Foo foo) {\n     return Integer.compare(this.index, foo.index);\n    }\n  }' 在应用快速修复后： 'class Foo implements Comparable<Foo>{\n    private final int index;\n    Foo(int idx) {\n      index = idx;\n    }\n    @Override\n    public int compareTo(Foo foo) {\n      return Integer.compare(this.index, foo.index);\n    }\n  }'",
                  "markdown": "报告对 `compareTo()` 实现中的非 `final` 字段的访问。\n\n\n此类访问可能导致 `compareTo()` 在对象生命周期的不同时刻返回不同的结果，进而可能在使用 `java.util.TreeSet` 等标准集合类时导致问题。\n\n\n只有在对该字段不具备写入访问权限时，才可以通过快速修复将该字段设为 `final`，否则不建议进行修正。\n\n**示例：**\n\n\n      class Foo implements Comparable<Foo>{\n        private int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n         return Integer.compare(this.index, foo.index);\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo implements Comparable<Foo>{\n        private final int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n          return Integer.compare(this.index, foo.index);\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CompareToUsesNonFinalVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavacQuirks",
                "shortDescription": {
                  "text": "Javac 杂项"
                },
                "fullDescription": {
                  "text": "报告现有的 Javac 问题、性能问题和不兼容性。 例如，当需要处理许多嵌套调用时，类型推断会变慢。 以下代码会触发警告，因为 vararg 方法调用包含 50 个以上的多态实参： 'Arrays.asList(\n      Arrays.asList(\"a1\", \"b1\"),\n      Arrays.asList(\"a2\", \"b2\"),\n      ...\n      Arrays.asList(\"a100\", \"b100\"));' 快速修复程序添加了显式类型实参，可以加快编译和 IDE 的速度。 '//noinspection RedundantTypeArguments\n  Arrays.<List<String>>asList(\n      Arrays.asList(\"a1\", \"b1\"),\n      Arrays.asList(\"a2\", \"b2\"),\n      ...\n      Arrays.asList(\"a100\", \"b100\"));'",
                  "markdown": "报告现有的 Javac 问题、性能问题和不兼容性。 例如，当需要处理许多嵌套调用时，类型推断会变慢。\n\n以下代码会触发警告，因为 vararg 方法调用包含 50 个以上的多态实参：\n\n\n      Arrays.asList(\n          Arrays.asList(\"a1\", \"b1\"),\n          Arrays.asList(\"a2\", \"b2\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n\n快速修复程序添加了显式类型实参，可以加快编译和 IDE 的速度。\n\n\n      //noinspection RedundantTypeArguments\n      Arrays.<List<String>>asList(\n          Arrays.asList(\"a1\", \"b1\"),\n          Arrays.asList(\"a2\", \"b2\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavacQuirks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 128,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatement",
                "shortDescription": {
                  "text": "'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句。 'switch' 语句通常（但并非总是）表明面向对象的设计欠佳。 示例： 'switch (i) {\n    // 代码\n  }'",
                  "markdown": "报告 `switch` 语句。\n\n`switch` 语句通常（但并非总是）表明面向对象的设计欠佳。\n\n示例：\n\n\n      switch (i) {\n        // 代码\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferReplaceableByString",
                "shortDescription": {
                  "text": "'StringBuilder' 可被替换为 'String'"
                },
                "fullDescription": {
                  "text": "报告可以用单个 'String' 串联替换的 'StringBuffer'、'StringBuilder' 或 'StringJoiner' 的用法。 使用 'String' 串联会使代码更短更简单。 此检查仅在建议的替换不会导致现代 JVM 的性能显著下降时报告。 在许多情况下，'String' 串联可能执行效果更好。 示例： 'StringBuilder result = new StringBuilder();\n  result.append(\"i = \");\n  result.append(i);\n  result.append(\";\");\n  return result.toString();' 在应用快速修复后： 'String result = \"i = \" + i + \";\";\n  return result;'",
                  "markdown": "报告可以用单个 `String` 串联替换的 `StringBuffer`、`StringBuilder` 或 `StringJoiner` 的用法。\n\n使用 `String` 串联会使代码更短更简单。\n\n\n此检查仅在建议的替换不会导致现代 JVM 的性能显著下降时报告。 在许多情况下，`String` 串联可能执行效果更好。\n\n**示例：**\n\n\n      StringBuilder result = new StringBuilder();\n      result.append(\"i = \");\n      result.append(i);\n      result.append(\";\");\n      return result.toString();\n\n在应用快速修复后：\n\n\n      String result = \"i = \" + i + \";\";\n      return result;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferReplaceableByString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SourceToSinkFlow",
                "shortDescription": {
                  "text": "不安全字符串被传递至安全方法"
                },
                "fullDescription": {
                  "text": "报告将非安全对象传递给带形参的方法的情况，该方法使用 '@Untainted' 注解标记、从注解的方法返回，或被分配给注解的字段、形参或局部变量。 不支持将字段的 Kotlin 'set' 和 'get' 方法作为入口点。 （相同类中的）安全对象为： 字符串文字、接口实例或枚举对象 对标记为 '@Untainted' 的方法进行调用的结果 private 字段，仅使用字符串文字赋值，并具有安全的初始值设定项 final 字段，具有安全的初始值设定项 标记为 '@Untainted' 且不是从非安全对象赋值的局部变量或形参. 此字段、局部变量或形参不得作为实参传递给方法或用作限定符，或者必须是基元、其包装器或不可变对象。 此外，static final 字段也被认为是安全的。 分析仅在一个文件内执行。 要处理来自其他类的依赖项，请使用选项。 分析会扩展到 private 或 static 方法，并且具有深度传播限值。 示例： 'void doSmth(boolean b) {\n    String s = safe();\n    String s1 = \"other\";\n    if (b) s1 = s;\n    sink(s);\n  }\n\n  String sink(@Untainted String s) {}'\n 此处没有将非安全字符串赋值给 's'，因此没有产生警告。 另一方面： 'void doSmth(boolean b) {\n    String s = safe();\n    String s1 = \"other\";\n    s1 = foo();\n    if (b) s = s1;\n    sink(s);        // 此处为警告\n  }\n  \n  String foo();\n\n  String sink(@Untainted String s) {}'\n 这里有一条警告，因为 's1' 在 'foo' 调用结果赋值后具有未知状态。 2021.2 最新变化",
                  "markdown": "报告将非安全对象传递给带形参的方法的情况，该方法使用 `@Untainted` 注解标记、从注解的方法返回，或被分配给注解的字段、形参或局部变量。 不支持将字段的 Kotlin `set` 和 `get` 方法作为入口点。\n\n\n（相同类中的）安全对象为：\n\n* 字符串文字、接口实例或枚举对象\n* 对标记为 `@Untainted` 的方法进行调用的结果\n* private 字段，仅使用字符串文字赋值，并具有安全的初始值设定项\n* final 字段，具有安全的初始值设定项\n* 标记为 `@Untainted` 且不是从非安全对象赋值的局部变量或形参.\n\n此字段、局部变量或形参不得作为实参传递给方法或用作限定符，或者必须是基元、其包装器或不可变对象。\n\n此外，static final 字段也被认为是安全的。\n\n\n分析仅在一个文件内执行。 要处理来自其他类的依赖项，请使用选项。\n分析会扩展到 private 或 static 方法，并且具有深度传播限值。\n\n\n示例：\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        if (b) s1 = s;\n        sink(s);\n      }\n\n      String sink(@Untainted String s) {}\n\n\n此处没有将非安全字符串赋值给 `s`，因此没有产生警告。 另一方面：\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        s1 = foo();\n        if (b) s = s1;\n        sink(s);        // 此处为警告\n      }\n      \n      String foo();\n\n      String sink(@Untainted String s) {}\n\n\n这里有一条警告，因为 `s1` 在 `foo` 调用结果赋值后具有未知状态。\n\n2021.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "tainting",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RecordCanBeClass",
                "shortDescription": {
                  "text": "记录可以转换为类"
                },
                "fullDescription": {
                  "text": "报告记录类并建议将它们转换为普通类。 通过将快速修复应用到此记录，此检查可以将 Java 记录移动到使用早期 Java 版本的代码库。 请注意，生成的类并不完全等同于原始记录： 结果的类不再扩展 'java.lang.Record'，因此 'instanceof Record' 返回 'false'。 'Class.isRecord()' 和 'Class.getRecordComponents()' 等反射方法会产生不同的结果。 生成的 'hashCode()' 实现可能会产生不同的结果，因为故意没有指定计算记录 'hashCode' 的公式。 记录序列化机制不同于普通类。 有关详细信息，请参阅 Java 对象序列化规范。 示例： 'record Point(int x, int y) {}' 在应用快速修复后： 'final class Point {\n    private final int x;\n    private final int y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    public int x() { return x; }\n\n    public int y() { return y; }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (obj == this) return true;\n      if (obj == null || obj.getClass() != this.getClass()) return false;\n      var that = (Point)obj;\n      return this.x == that.x &&\n             this.y == that.y;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"Point[\" +\n             \"x=\" + x + \", \" +\n             \"y=\" + y + ']';\n    }\n  }' 2020.3 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告记录类并建议将它们转换为普通类。\n\n通过将快速修复应用到此记录，此检查可以将 Java 记录移动到使用早期 Java 版本的代码库。\n\n\n请注意，生成的类并不完全等同于原始记录：\n\n* 结果的类不再扩展 `java.lang.Record`，因此 `instanceof Record` 返回 `false`。\n* `Class.isRecord()` 和 `Class.getRecordComponents()` 等反射方法会产生不同的结果。\n* 生成的 `hashCode()` 实现可能会产生不同的结果，因为故意没有指定计算记录 `hashCode` 的公式。\n* 记录序列化机制不同于普通类。 有关详细信息，请参阅 *Java 对象序列化规范*。\n\n示例：\n\n\n      record Point(int x, int y) {}\n\n在应用快速修复后：\n\n\n      final class Point {\n        private final int x;\n        private final int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        public int x() { return x; }\n\n        public int y() { return y; }\n\n        @Override\n        public boolean equals(Object obj) {\n          if (obj == this) return true;\n          if (obj == null || obj.getClass() != this.getClass()) return false;\n          var that = (Point)obj;\n          return this.x == that.x &&\n                 this.y == that.y;\n        }\n\n        @Override\n        public int hashCode() {\n          return Objects.hash(x, y);\n        }\n\n        @Override\n        public String toString() {\n          return \"Point[\" +\n                 \"x=\" + x + \", \" +\n                 \"y=\" + y + ']';\n        }\n      }\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RecordCanBeClass",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MalformedFormatString",
                "shortDescription": {
                  "text": "字符串的格式错误"
                },
                "fullDescription": {
                  "text": "报告不符合标准 Java 语法的格式字符串。 默认情况下，如果编译时常量被用作 'java.util.Formatter'、'java.lang.String'、'java.io.PrintWriter' 或 'java.io.PrintStream' 上相应方法的实参，则该检查会将其视为格式字符串。 示例： 'String.format(\"x = %d, y = %d\", 42);' 使用检查设置可以将其他类和方法标记为与字符串格式相关。 作为替代方案，您可以使用 'org.intellij.lang.annotations.PrintFormat' 注解 来标记格式字符串方法形参。 在这种情况下，格式实参形参必须紧跟在格式字符串之后，并且必须是最后一个方法形参。 示例： 'void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}' 以这种方式注解的方法也将被此检查识别。",
                  "markdown": "报告不符合标准 Java 语法的格式字符串。\n\n默认情况下，如果编译时常量被用作 `java.util.Formatter`、`java.lang.String`、`java.io.PrintWriter` 或\n`java.io.PrintStream` 上相应方法的实参，则该检查会将其视为格式字符串。\n\n**示例：**\n\n\n      String.format(\"x = %d, y = %d\", 42);\n\n使用检查设置可以将其他类和方法标记为与字符串格式相关。\n\n作为替代方案，您可以使用 `org.intellij.lang.annotations.PrintFormat` 注解\n来标记格式字符串方法形参。 在这种情况下，格式实参形参必须紧跟在格式字符串之后，并且必须是最后一个方法形参。 示例：\n\n\n      void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}\n\n\n以这种方式注解的方法也将被此检查识别。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MalformedFormatString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadYield",
                "shortDescription": {
                  "text": "调用 'Thread.yield()'"
                },
                "fullDescription": {
                  "text": "报告对 'Thread.yield()' 的调用。 'yield()' 的行为是不确定的并且依赖于平台，很少适合使用此方法。 它的使用应当与详细的分析和基准测试相结合，以确保真正达到预期效果。 示例： 'public static void main(String[] args) {\n    Runnable r = () -> {\n      for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n        Thread.yield();\n      }\n    };\n    new Thread(r).start();\n    new Thread(r).start();\n  }'",
                  "markdown": "报告对 `Thread.yield()` 的调用。\n\n\n`yield()` 的行为是不确定的并且依赖于平台，很少适合使用此方法。\n它的使用应当与详细的分析和基准测试相结合，以确保真正达到预期效果。\n\n**示例：**\n\n\n      public static void main(String[] args) {\n        Runnable r = () -> {\n          for (int i = 0; i < 10; i++) {\n            System.out.println(i);\n            Thread.yield();\n          }\n        };\n        new Thread(r).start();\n        new Thread(r).start();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadYield",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaCanBeMethodCall",
                "shortDescription": {
                  "text": "lambda 可被替换为方法调用"
                },
                "fullDescription": {
                  "text": "报告可被替换为 JDK 方法调用的 lambda 表达式。 例如，'Function<T, T>' 类型的表达式 'x -> x' 可被替换为 'Function.identity()' 调用。 2017.1 最新变化 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可被替换为 JDK 方法调用的 lambda 表达式。\n\n例如，`Function<T, T>` 类型的表达式 `x -> x` 可被替换为 `Function.identity()` 调用。\n\n2017.1 最新变化\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaCanBeMethodCall",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EndlessStream",
                "shortDescription": {
                  "text": "非短路操作消耗无限流"
                },
                "fullDescription": {
                  "text": "报告消耗无限流的非短路运算。 此类运算只能通过抛出异常来完成。 示例： 'Stream.iterate(0, i -> i + 1).collect(Collectors.toList())' 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告消耗无限流的非短路运算。 此类运算只能通过抛出异常来完成。\n\n示例：\n\n\n      Stream.iterate(0, i -> i + 1).collect(Collectors.toList())\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EndlessStream",
                    "cweIds": [
                      835
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalUtilityClass",
                "shortDescription": {
                  "text": "实用程序类不为 'final'"
                },
                "fullDescription": {
                  "text": "报告非 'final' 或 'abstract' 的实用程序类。 实用程序类将所有字段和方法声明为 'static'。 使之为 'final' 可防止意外地被子类化。 示例： 'public class UtilityClass {\n    public static void foo() {}\n  }' 在应用快速修复后： 'public final class UtilityClass {\n    public static void foo() {}\n  }'",
                  "markdown": "报告非 `final` 或 `abstract` 的实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`。\n使之为 `final` 可防止意外地被子类化。\n\n**示例：**\n\n\n      public class UtilityClass {\n        public static void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      public final class UtilityClass {\n        public static void foo() {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Singleton",
                "shortDescription": {
                  "text": "单例"
                },
                "fullDescription": {
                  "text": "报告单例类。 单例类按照只能实例化该类一个实例的方式进行声明。 单例类导致测试复杂化，存在这种情况可能表明欠缺面向对象的设计。 示例： 'class Singleton {\n    private static final Singleton ourInstance = new Singleton();\n\n    private Singleton() {\n    }\n\n    public Singleton getInstance() {\n        return ourInstance;\n    }\n  }'",
                  "markdown": "报告单例类。\n\n单例类按照只能实例化该类一个实例的方式进行声明。 单例类导致测试复杂化，存在这种情况可能表明欠缺面向对象的设计。\n\n**示例：**\n\n\n      class Singleton {\n        private static final Singleton ourInstance = new Singleton();\n\n        private Singleton() {\n        }\n\n        public Singleton getInstance() {\n            return ourInstance;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Singleton",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FuseStreamOperations",
                "shortDescription": {
                  "text": "后续步骤可以融合到Stream API链中"
                },
                "fullDescription": {
                  "text": "检测 Stream API 链之外的可以合并到其中的转换。 示例： 'List<String> list = stream.collect(Collectors.toList());\n  list.sort(null);\n  return list.toArray(new String[list.size()]);' 转换后： 'return stream.sorted().toArray(String[]::new);' 请注意，有时转换后的 Stream 链可能会将显式 'ArrayList' 替换为 'Collectors.toList()' 或将显式 'HashSet' 替换为 'Collectors.toSet()'。 当前库实现会在内部使用这些集合。 但是，这种方法不是很可靠，将来可能会更改代码的语义。 如果您对此感到担心，请使用不建议使用 'toList()' 或 'toSet()' 收集器选项来建议使用 'Collectors.toCollection()' 而不是 'toList' 和 'toSet' 收集器。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "检测 Stream API 链之外的可以合并到其中的转换。\n\n示例：\n\n\n      List<String> list = stream.collect(Collectors.toList());\n      list.sort(null);\n      return list.toArray(new String[list.size()]);\n\n转换后：\n\n\n      return stream.sorted().toArray(String[]::new);\n\n\n请注意，有时转换后的 Stream 链可能会将显式 `ArrayList` 替换为 `Collectors.toList()` 或将显式 `HashSet` 替换为 `Collectors.toSet()`。 当前库实现会在内部使用这些集合。 但是，这种方法不是很可靠，将来可能会更改代码的语义。\n\n如果您对此感到担心，请使用**不建议使用 'toList()' 或 'toSet()' 收集器** 选项来建议使用 `Collectors.toCollection()` 而不是 `toList` 和 `toSet` 收集器。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FuseStreamOperations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DefaultNotLastCaseInSwitch",
                "shortDescription": {
                  "text": "'default' 不是 'switch' 中的最后一个 case"
                },
                "fullDescription": {
                  "text": "报告其中的 'default' 分支位于另一个 case 前面的 'switch' 语句或表达式。 此类构造会造成不必要的困惑。 如果可能，可以通过快速修复将 'default' 分支移到最后位置。 示例： 'switch (n) {\n      default:\n          System.out.println();\n          break;\n      case 1:\n          break;\n  }' 在应用快速修复后： 'switch (n) {\n    case 1:\n        break;\n    default:\n        System.out.println();\n        break;\n  }'",
                  "markdown": "报告其中的 `default` 分支位于另一个 case 前面的 `switch` 语句或表达式。 此类构造会造成不必要的困惑。 如果可能，可以通过快速修复将 `default` 分支移到最后位置。\n\n**示例：**\n\n\n      switch (n) {\n          default:\n              System.out.println();\n              break;\n          case 1:\n              break;\n      }\n\n在应用快速修复后：\n\n\n      switch (n) {\n        case 1:\n            break;\n        default:\n            System.out.println();\n            break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DefaultNotLastCaseInSwitch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullThrown",
                "shortDescription": {
                  "text": "已抛出 'null'"
                },
                "fullDescription": {
                  "text": "报告用作 'throw' 语句实参的 'null' 文字。 此类结构会产生通常不应以编程方式抛出的 'java.lang.NullPointerException'。",
                  "markdown": "报告用作 `throw` 语句实参的 `null` 文字。\n\n此类结构会产生通常不应以编程方式抛出的 `java.lang.NullPointerException`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NullThrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalCanBeFinal",
                "shortDescription": {
                  "text": "局部变量或形参可以是 'final'"
                },
                "fullDescription": {
                  "text": "报告可能在其声明中添加了 'final' 修饰符的形参或局部变量。 示例： 'ArrayList<Integer> list = new ArrayList();\n  fill(list);\n  return list;' 在应用快速修复后： 'final ArrayList<Integer> list = new ArrayList();\n  fill(list);\n  return list;' 使用该检查的选项可定义是否应报告形参或局部变量。",
                  "markdown": "报告可能在其声明中添加了 `final` 修饰符的形参或局部变量。\n\n示例：\n\n\n      ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\n在应用快速修复后：\n\n\n      final ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\n\n使用该检查的选项可定义是否应报告形参或局部变量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalCanBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldMayBeStatic",
                "shortDescription": {
                  "text": "字段可以为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以安全地设为 'static' 的实例变量。 如果字段被声明为 'final' 并用常量初始化，则该字段可以为 static 字段。 示例： 'public final String str = \"sample\";' 该检查不会报告可以隐式写入的 final 字段。 使用“注解”按钮修改假定隐式字段写入的注解列表。",
                  "markdown": "报告可以安全地设为 `static` 的实例变量。 如果字段被声明为 `final` 并用常量初始化，则该字段可以为 static 字段。\n\n**示例：**\n\n\n      public final String str = \"sample\";\n\n\n该检查不会报告可以隐式写入的 final 字段。 使用\"注解\"按钮修改假定隐式字段写入的注解列表。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayEquals",
                "shortDescription": {
                  "text": "在数组上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告可以比较两个数组的 'equals()' 调用。 对数组调用 'equals()' 可以比较同一性，相当于使用 '=='。 使用 'Arrays.equals()' 比较两个数组的内容，或使用 'Arrays.deepEquals()' 比较多维数组的内容。 示例： 'void sample(int[] first, int[] second){\n    if (first.equals(second)) return;\n  }' 在应用快速修复后： 'void sample(int[] first, int[] second){\n    if (Arrays.equals(first, second)) return;\n  }'",
                  "markdown": "报告可以比较两个数组的 `equals()` 调用。\n\n对数组调用 `equals()` 可以比较同一性，相当于使用 `==`。\n使用 `Arrays.equals()` 比较两个数组的内容，或使用 `Arrays.deepEquals()` 比较多维数组的内容。\n\n**示例：**\n\n\n      void sample(int[] first, int[] second){\n        if (first.equals(second)) return;\n      }\n\n在应用快速修复后：\n\n\n      void sample(int[] first, int[] second){\n        if (Arrays.equals(first, second)) return;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProblematicVarargsMethodOverride",
                "shortDescription": {
                  "text": "非 vararg 方法重写 vararg 方法"
                },
                "fullDescription": {
                  "text": "报告重写可变 arity（亦称 vararg）方法但将可变 arity 形参替换为数组形参的方法。 尽管这段代码有效，但它可能令人困惑，因而应当避免。",
                  "markdown": "报告重写可变 arity（亦称 vararg）方法但将可变 arity 形参替换为数组形参的方法。 尽管这段代码有效，但它可能令人困惑，因而应当避免。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProblematicVarargsMethodOverride",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledHeader",
                "shortDescription": {
                  "text": "未知或拼写错误的标头名称"
                },
                "fullDescription": {
                  "text": "报告任何未知的和可能拼写错误的标头名称，并提供可能的变体。",
                  "markdown": "报告任何未知的和可能拼写错误的标头名称，并提供可能的变体。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MisspelledHeader",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "清单",
                      "index": 90,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AtomicFieldUpdaterIssues",
                "shortDescription": {
                  "text": "'AtomicFieldUpdater' 声明不一致"
                },
                "fullDescription": {
                  "text": "报告 'AtomicLongFieldUpdater'、'AtomicIntegerFieldUpdater' 或 'AtomicReferenceFieldUpdater' 字段（'java.util.concurrent.atomic' 软件包）的问题。 报告的问题与原子字段更新程序可能发生的运行时问题相同：找不到指定字段、指定字段不可访问、指定字段类型错误等。 示例： 'class A {\n    private static volatile int value = 0;\n    private static final AtomicIntegerFieldUpdater updater =\n    AtomicIntegerFieldUpdater.newUpdater((A.class), \"value\"); // 警告：字段 'value' 具有 'static' 修饰符\n  }' 'class B {\n    private static final AtomicIntegerFieldUpdater updater =\n      AtomicIntegerFieldUpdater.newUpdater(B.class, \"value\"); // 警告：在类 'B' 中找不到名为 'Value' 的字段\n  }'",
                  "markdown": "报告 `AtomicLongFieldUpdater`、`AtomicIntegerFieldUpdater` 或 `AtomicReferenceFieldUpdater` 字段（`java.util.concurrent.atomic` 软件包）的问题。\n\n报告的问题与原子字段更新程序可能发生的运行时问题相同：找不到指定字段、指定字段不可访问、指定字段类型错误等。\n\n**示例：**\n\n*\n\n\n        class A {\n          private static volatile int value = 0;\n          private static final AtomicIntegerFieldUpdater updater =\n          AtomicIntegerFieldUpdater.newUpdater((A.class), \"value\"); // 警告：字段 'value' 具有 'static' 修饰符\n        }\n        \n*\n\n\n        class B {\n          private static final AtomicIntegerFieldUpdater updater =\n            AtomicIntegerFieldUpdater.newUpdater(B.class, \"value\"); // 警告：在类 'B' 中找不到名为 'Value' 的字段\n        }\n        \n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AtomicFieldUpdaterIssues",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageNamingConvention",
                "shortDescription": {
                  "text": "软件包命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的软件包。 示例： 'package io;' 使用选项可以指定软件包名称的最小长度和最大长度，以及匹配有效软件包名称的正则表达式（正则表达式采用标准 'java.util.regex' 格式）。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的软件包。\n\n**示例：**\n\n\n      package io;\n\n\n使用选项可以指定软件包名称的最小长度和最大长度，以及匹配有效软件包名称的正则表达式（正则表达式采用标准 `java.util.regex` 格式）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowableNotThrown",
                "shortDescription": {
                  "text": "'Throwable' 未抛出"
                },
                "fullDescription": {
                  "text": "当创建的 'Throwable' 从未真正抛出时，报告 'Throwable' 或其子类的实例化。 此外，当方法调用的结果未抛出时，此检查会报告返回 'Throwable' 或其子类实例的方法调用。 不会报告对使用 Error Prone 或 AssertJ 的 '@CanIgnoreReturnValue' 注解进行注解的方法的调用。 示例： 'void check(String s) {\n        if (s == null) {\n            new NullPointerException(\"s\");\n        }\n        // ...\n    }'",
                  "markdown": "当创建的 `Throwable` 从未真正抛出时，报告 `Throwable` 或其子类的实例化。 此外，当方法调用的结果未抛出时，此检查会报告返回 `Throwable` 或其子类实例的方法调用。\n\n不会报告对使用 Error Prone 或 AssertJ 的 `@CanIgnoreReturnValue` 注解进行注解的方法的调用。\n\n**示例：**\n\n\n        void check(String s) {\n            if (s == null) {\n                new NullPointerException(\"s\");\n            }\n            // ...\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableNotThrown",
                    "cweIds": [
                      390,
                      703
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CapturingCleaner",
                "shortDescription": {
                  "text": "清理器捕获对象引用"
                },
                "fullDescription": {
                  "text": "报告正在对传递给 'Cleaner.register()' 捕获引用的 'Runnable' 进行注册的情况。 如果引用被捕获，它将永远不是虚可达的，且永远不会调用清理操作。 此问题的可能来源： 使用非 static 方法、字段或 'this' 本身的 lambda 非 static 内部类（匿名与否）在 Java 18 及更低版本中始终捕获此引用 实例方法引用 从非 static 内部类访问外部类非 static 成员 将报告的代码示例： 'int fileDescriptor;\n  Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -> {\n    System.out.println(\"adsad\");\n    //this 通过 fileDescriptor 捕获\n    fileDescriptor = 0;\n  });' 仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。 2018.1 最新变化",
                  "markdown": "报告正在对传递给 `Cleaner.register()` 捕获引用的 `Runnable` 进行注册的情况。 如果引用被捕获，它将永远不是虚可达的，且永远不会调用清理操作。\n\n此问题的可能来源：\n\n* 使用非 static 方法、字段或 `this` 本身的 lambda\n* 非 static 内部类（匿名与否）在 Java 18 及更低版本中始终捕获此引用\n* 实例方法引用\n* 从非 static 内部类访问外部类非 static 成员\n\n将报告的代码示例：\n\n\n      int fileDescriptor;\n      Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -> {\n        System.out.println(\"adsad\");\n        //this 通过 fileDescriptor 捕获\n        fileDescriptor = 0;\n      });\n\n仅当项目或模块的语言级别为 9 或更高时，此检查才会报告。\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CapturingCleaner",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadStartInConstruction",
                "shortDescription": {
                  "text": "对象构造期间调用 'Thread.start()'"
                },
                "fullDescription": {
                  "text": "报告对象构造过程中在 'java.lang.Thread' 或其任何子类上对 'start()' 的调用。 虽然此类结构偶尔有用，但由于继承问题，应避免使用。 在对象构造期间启动线程的类的子类在线程启动前不会完成自身的任何初始化逻辑。 如果启动线程的类被声明为 'final'，此检查不会报告。 示例： 'class MyThread extends Thread {\n    MyThread() {\n      start();\n    }\n  }'",
                  "markdown": "报告对象构造过程中在 `java.lang.Thread` 或其任何子类上对 `start()` 的调用。\n\n\n虽然此类结构偶尔有用，但由于继承问题，应避免使用。\n在对象构造期间启动线程的类的子类在线程启动前不会完成自身的任何初始化逻辑。\n\n如果启动线程的类被声明为 `final`，此检查不会报告。\n\n**示例：**\n\n\n      class MyThread extends Thread {\n        MyThread() {\n          start();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadStartDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "最大 'switch' 分支"
                },
                "fullDescription": {
                  "text": "报告 'case' 标签太多的 'switch' 语句或表达式。 如此之长的 switch 语句可能令人困惑，或许应进行重构。 有时这并非问题（例如一个域非常复杂，并且有包含大量常量的枚举）。 示例： 'switch (x) {\n        case 1 -> {}\n        case 2 -> {}\n        case 3 -> {}\n        case 4 -> {}\n        case 5 -> {}\n        case 6 -> {}\n        case 7 -> {}\n        case 8 -> {}\n        case 9 -> {}\n        case 10 -> {}\n        case 11,12,13 -> {}\n        default -> {}\n    }' 使用最大分支数字段可以指定 'case' 标签的预期最大数量。",
                  "markdown": "报告 `case` 标签太多的 `switch` 语句或表达式。\n\n如此之长的 switch 语句可能令人困惑，或许应进行重构。\n有时这并非问题（例如一个域非常复杂，并且有包含大量常量的枚举）。\n\n示例：\n\n\n        switch (x) {\n            case 1 -> {}\n            case 2 -> {}\n            case 3 -> {}\n            case 4 -> {}\n            case 5 -> {}\n            case 6 -> {}\n            case 7 -> {}\n            case 8 -> {}\n            case 9 -> {}\n            case 10 -> {}\n            case 11,12,13 -> {}\n            default -> {}\n        }\n\n使用**最大分支数** 字段可以指定 `case` 标签的预期最大数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopConditionNotUpdatedInsideLoop",
                "shortDescription": {
                  "text": "循环变量未在循环内更新"
                },
                "fullDescription": {
                  "text": "报告在循环条件中使用且未在循环内更新的任何变量和形参。 此类变量和形参通常被错误使用，因为如果执行它们可能会导致无限循环。 示例： 'void loopDoesNotLoop(boolean b) {\n    while (b) {\n      System.out.println();\n      break;\n    }\n  }' 配置检查： 如果条件可以间接更新（例如，通过调用的方法或从另一个线程并发更新），请使用 忽略可能的非本地更改 选项来禁用此检查。",
                  "markdown": "报告在循环条件中使用且未在循环内更新的任何变量和形参。\n\n此类变量和形参通常被错误使用，因为如果执行它们可能会导致无限循环。\n\n示例：\n\n\n      void loopDoesNotLoop(boolean b) {\n        while (b) {\n          System.out.println();\n          break;\n        }\n      }\n\n配置检查：\n\n\n如果条件可以间接更新（例如，通过调用的方法或从另一个线程并发更新），请使用 **忽略可能的非本地更改** 选项来禁用此检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopConditionNotUpdatedInsideLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoubleCheckedLocking",
                "shortDescription": {
                  "text": "双重检查锁定"
                },
                "fullDescription": {
                  "text": "报告双重检查锁定。 双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。 遗憾的是，在未被声明为 'volatile' 的字段上使用时，它不具备线程安全。 在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 'volatile' 字段也不起作用。 阅读上面的链接文章，了解该问题的详细说明。 不正确的双重检查锁定示例： 'class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n      if (helper == null)\n        synchronized(this) {\n          if (helper == null) helper = new Helper();\n        }\n        return helper;\n      }\n    }\n    // 其他函数和成员…\n  }'",
                  "markdown": "报告[双重检查锁定](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)。\n\n\n双重检查锁定会尝试以线程安全的方式按需初始化字段，同时避免同步的开销。\n遗憾的是，在未被声明为 `volatile` 的字段上使用时，它不具备线程安全。\n在使用 Java 1.4 或更早的版本时，双重检查锁定即便对 `volatile` 字段也不起作用。\n阅读上面的链接文章，了解该问题的详细说明。\n\n不正确的双重检查锁定示例：\n\n\n      class Foo {\n        private Helper helper = null;\n        public Helper getHelper() {\n          if (helper == null)\n            synchronized(this) {\n              if (helper == null) helper = new Helper();\n            }\n            return helper;\n          }\n        }\n        // 其他函数和成员...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoubleCheckedLocking",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MisspelledMethodName",
                "shortDescription": {
                  "text": "方法名称仅大小写不同"
                },
                "fullDescription": {
                  "text": "报告一个类的多个方法的名称仅大小写不同的情况。 此类名称可能非常令人困惑。 示例： 'public int hashcode() { // 已报告，可能应为 hashCode？\n    return 0;\n  }' 只能在编辑器中使用重命名此类方法的快速修复。 使用忽略方法重写/实现 super 方法选项，可以忽略重写或实现超类中方法的方法。",
                  "markdown": "报告一个类的多个方法的名称仅大小写不同的情况。 此类名称可能非常令人困惑。\n\n**示例：**\n\n\n      public int hashcode() { // 已报告，可能应为 hashCode？\n        return 0;\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。\n\n使用**忽略方法重写/实现 super 方法**选项，可以忽略重写或实现超类中方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNamesDifferingOnlyByCase",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableObjectBoundToHttpSession",
                "shortDescription": {
                  "text": "不可序列化的对象被绑定到了 'HttpSession'"
                },
                "fullDescription": {
                  "text": "报告未实现用作 'javax.servlet.http.HttpSession.setAttribute()' 或 'javax.servlet.http.HttpSession.putValue()' 实参的 'java.io.Serializable' 的类对象。 如果 'HttpSession' 被钝化或迁移，则不会序列化此类对象，并且可能导致难以诊断的错误。 此检查假定 'java.util.Collection' 和 'java.util.Map' 类型的对象为 'Serializable'，除非类型形参为非 'Serializable'。 示例： 'void foo(HttpSession session) {\n      session.setAttribute(\"foo\", new NonSerializable());\n  }\n  static class NonSerializable {}'",
                  "markdown": "报告未实现用作 `javax.servlet.http.HttpSession.setAttribute()` 或 `javax.servlet.http.HttpSession.putValue()` 实参的 `java.io.Serializable` 的类对象。\n\n\n如果 `HttpSession` 被钝化或迁移，则不会序列化此类对象，并且可能导致难以诊断的错误。\n\n\n此检查假定 `java.util.Collection` 和\n`java.util.Map` 类型的对象为 `Serializable`，除非类型形参为非 `Serializable`。\n\n**示例：**\n\n\n      void foo(HttpSession session) {\n          session.setAttribute(\"foo\", new NonSerializable());\n      }\n      static class NonSerializable {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableObjectBoundToHttpSession",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadLocalNotStaticFinal",
                "shortDescription": {
                  "text": "'ThreadLocal' 字段未被声明为 'static final'"
                },
                "fullDescription": {
                  "text": "报告未被声明为 'static final' 的 'java.lang.ThreadLocal' 类型的字段。 在最常见的情况下，'java.lang.ThreadLocal' 实例会将状态与线程关联。 非 static、非 final 'java.lang.ThreadLocal' 字段会将状态与实例线程组合关联。 这通常是不必要的，而且通常是可能导致内存泄漏和行为不正确的错误。 建议通过快速修复将该字段设为 'static final'。 示例： 'private ThreadLocal tl = ThreadLocal.withInitial(() -> Boolean.TRUE);'",
                  "markdown": "报告未被声明为 `static final` 的 `java.lang.ThreadLocal` 类型的字段。\n\n\n在最常见的情况下，`java.lang.ThreadLocal` 实例会将状态与线程关联。\n非 static、非 final `java.lang.ThreadLocal` 字段会将状态与实例线程组合关联。\n这通常是不必要的，而且通常是可能导致内存泄漏和行为不正确的错误。\n\n\n建议通过快速修复将该字段设为 `static final`。\n\n\n**示例：**\n\n\n      private ThreadLocal tl = ThreadLocal.withInitial(() -> Boolean.TRUE);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThreadLocalNotStaticFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessStaticViaInstance",
                "shortDescription": {
                  "text": "通过实例引用访问 static 成员"
                },
                "fullDescription": {
                  "text": "报告通过类实例而非类本身对 'static' 方法和字段的引用。 虽然 Java 语言规范允许使用实例变量引用 static 成员，但读者可能会误认为该方法依赖于实例，从而使代码令人困惑。 该快速修复会将实例变量替换为类名。 示例： 'String s1 = s.valueOf(0);' 在应用快速修复后： 'String s = String.valueOf(0);'",
                  "markdown": "报告通过类实例而非类本身对 `static` 方法和字段的引用。\n\n虽然 Java 语言规范允许使用实例变量引用 static 成员，但读者可能会误认为该方法依赖于实例，从而使代码令人困惑。\n\n该快速修复会将实例变量替换为类名。\n\n示例：\n\n\n      String s1 = s.valueOf(0);\n\n在应用快速修复后：\n\n\n      String s = String.valueOf(0);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessStaticViaInstance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallToNativeMethodWhileLocked",
                "shortDescription": {
                  "text": "锁定时调用 'native' 方法"
                },
                "fullDescription": {
                  "text": "报告 'synchronized' 块或方法中的调用 'native' 方法。 如果可能，最好将对 'native' 方法的调用排除在同步上下文之外，因为此类调用会导致开销巨大的上下文切换，并且可能导致性能问题。 示例： 'native void nativeMethod();\n\n  void example(){\n    synchronized (lock){\n      nativeMethod();//警告\n    }\n  }'",
                  "markdown": "报告 `synchronized` 块或方法中的调用 `native` 方法。\n\n\n如果可能，最好将对 `native` 方法的调用排除在同步上下文之外，因为此类调用会导致开销巨大的上下文切换，并且可能导致性能问题。\n\n**示例：**\n\n\n      native void nativeMethod();\n\n      void example(){\n        synchronized (lock){\n          nativeMethod();//警告\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNativeMethodWhileLocked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Dependency",
                "shortDescription": {
                  "text": "非法的软件包依赖项"
                },
                "fullDescription": {
                  "text": "根据指定依赖关系规则报告范围之间的非法依赖关系。 依赖关系规则可用于禁止从一个范围到另一个范围的用法。 使用下面的配置依赖关系规则按钮可以自定义验证规则。",
                  "markdown": "根据指定依赖关系规则报告范围之间的非法依赖关系。 依赖关系规则可用于禁止从一个范围到另一个范围的用法。\n\n使用下面的**配置依赖关系规则**按钮可以自定义验证规则。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Dependency",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestingDepth",
                "shortDescription": {
                  "text": "过度嵌套的方法"
                },
                "fullDescription": {
                  "text": "报告主体包含嵌套过深语句的方法。 语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。 使用嵌套深度限制字段可指定方法允许的最大嵌套深度。",
                  "markdown": "报告主体包含嵌套过深语句的方法。\n\n语句嵌套过深的方法可能令人困惑，并且表明可能有必要重构。\n\n使用**嵌套深度限制**字段可指定方法允许的最大嵌套深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyNestedMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantExplicitChronoField",
                "shortDescription": {
                  "text": "可以简化对带有显式 'ChronoField' 或 'ChronoUnit' 实参的 'java.time' 方法的调用"
                },
                "fullDescription": {
                  "text": "当将 'java.time.temporal.ChronoField' 和 'java.time.temporal.ChronoUnit' 作为实参的 'java.time' 方法调用可被替换为更具体的方法时，报告这些调用。 示例： 'LocalTime localTime = LocalTime.now();\nint minute = localTime.get(ChronoField.MINUTE_OF_HOUR);' 在应用快速修复后： 'LocalTime localTime = LocalTime.now();\nint minute = localTime.getMinute();' 2023.2 最新变化",
                  "markdown": "当将 `java.time.temporal.ChronoField` 和 `java.time.temporal.ChronoUnit` 作为实参的 `java.time` 方法调用可被替换为更具体的方法时，报告这些调用。\n\n示例：\n\n\n    LocalTime localTime = LocalTime.now();\n    int minute = localTime.get(ChronoField.MINUTE_OF_HOUR);\n\n在应用快速修复后：\n\n\n    LocalTime localTime = LocalTime.now();\n    int minute = localTime.getMinute();\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantExplicitChronoField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WriteOnlyObject",
                "shortDescription": {
                  "text": "只写入对象"
                },
                "fullDescription": {
                  "text": "报告已修改但从未查询的对象。 该检查依赖于方法突变协定，对于某些库方法，可以推断或预先注解突变协定。 此检查不报告集合、映射和字符串构建器，因为其他更精准的检查会报告这些类型。 示例： 'AtomicReference<String> ref = new AtomicReference<>();\n  ref.set(\"hello\"); // ref 不再使用' 使用忽略不纯的构造函数选项可以控制是否处理由构造函数或纯度未知的方法创建的对象。 如果在构造过程中故意泄漏对象引用，取消选中该选项可能会引起某些误报。 2021.2 最新变化",
                  "markdown": "报告已修改但从未查询的对象。\n\n该检查依赖于方法突变协定，对于某些库方法，可以推断或预先注解突变协定。 此检查不报告集合、映射和字符串构建器，因为其他更精准的检查会报告这些类型。\n\n示例：\n\n\n      AtomicReference<String> ref = new AtomicReference<>();\n      ref.set(\"hello\"); // ref 不再使用\n\n\n使用**忽略不纯的构造函数**选项可以控制是否处理由构造函数或纯度未知的方法创建的对象。\n如果在构造过程中故意泄漏对象引用，取消选中该选项可能会引起某些误报。\n**2021.2 最新变化**"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WriteOnlyObject",
                    "cweIds": [
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SocketResource",
                "shortDescription": {
                  "text": "套接字已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的套接字资源。 此检查报告的套接字资源包括 'java.net.Socket'、'java.net.DatagramSocket' 和 'java.net.ServerSocket'。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'byte[] getMessage(ServerSocket socket) throws IOException {\n    Socket client = socket.accept(); //套接字未关闭\n    return client.getInputStream().readAllBytes();\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开套接字。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的套接字资源。 此检查报告的套接字资源包括 `java.net.Socket`、`java.net.DatagramSocket` 和 `java.net.ServerSocket`。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      byte[] getMessage(ServerSocket socket) throws IOException {\n        Socket client = socket.accept(); //套接字未关闭\n        return client.getInputStream().readAllBytes();\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开套接字。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SocketOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterHidesVisibleType",
                "shortDescription": {
                  "text": "类型形参隐藏可见类型"
                },
                "fullDescription": {
                  "text": "报告与当前范围中的可见类型名称相同的类型形参。 此类形参名称可能令人困惑。 示例： 'abstract class MyList<T> extends AbstractList<T> {\n    private List<T> elements;\n    // 类型形参 'T' 隐藏类型形参 'T'\n    public <T> T[] toArray(T[] array) {\n        return elements.toArray(array);\n    }\n}'",
                  "markdown": "报告与当前范围中的可见类型名称相同的类型形参。 此类形参名称可能令人困惑。\n\n示例：\n\n\n      abstract class MyList<T> extends AbstractList<T> {\n        private List<T> elements;\n        // 类型形参 'T' 隐藏类型形参 'T'\n        public <T> T[] toArray(T[] array) {\n            return elements.toArray(array);\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterHidesVisibleType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MaskedAssertion",
                "shortDescription": {
                  "text": "断言通过 'catch' 禁止"
                },
                "fullDescription": {
                  "text": "报告被周围的 catch 块禁止的 'assert' 语句和测试框架断言。 此类断言永远不会失败，因为将捕获并无提示地忽略抛出的 'AssertionError'。 示例 1： 'void javaAssertion() {\n    try {\n      ...\n      assert 1 == 2;\n    } catch (AssertionError e) {\n      // 该断言被无提示地忽略\n    }\n  }' 示例 2： '@Test\n  void testWithAssertJ() {\n    try {\n      ...\n      assertThat(1).as(\"test\").isEqualTo(2);\n    } catch (AssertionError e) {\n      // 该断言被无提示地忽略\n    }\n  }' 示例 3： '@Test\n  void testWithJunit() {\n    try {\n      ...\n      assertEquals(1, 2);\n    } catch (AssertionError e) {\n      // 该断言被无提示地忽略\n    }\n  }' 2020.3 最新变化",
                  "markdown": "报告被周围的 catch 块禁止的 `assert` 语句和测试框架断言。 此类断言永远不会失败，因为将捕获并无提示地忽略抛出的 `AssertionError`。\n\n**示例 1：**\n\n\n      void javaAssertion() {\n        try {\n          ...\n          assert 1 == 2;\n        } catch (AssertionError e) {\n          // 该断言被无提示地忽略\n        }\n      }\n\n**示例 2：**\n\n\n      @Test\n      void testWithAssertJ() {\n        try {\n          ...\n          assertThat(1).as(\"test\").isEqualTo(2);\n        } catch (AssertionError e) {\n          // 该断言被无提示地忽略\n        }\n      }\n\n**示例 3：**\n\n\n      @Test\n      void testWithJunit() {\n        try {\n          ...\n          assertEquals(1, 2);\n        } catch (AssertionError e) {\n          // 该断言被无提示地忽略\n        }\n      }\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MaskedAssertion",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 98,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTokenizerDelimiter",
                "shortDescription": {
                  "text": "'StringTokenizer' 中的分隔符重复"
                },
                "fullDescription": {
                  "text": "报告在分隔符实参中包含重复字符的 'StringTokenizer()' 构造函数调用或 'nextToken()' 方法调用。 示例： 'void printTokens(String text) {\n    StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\\n\");\n    while (tokenizer.hasMoreTokens()) {\n      System.out.println(tokenizer.nextToken());\n    }\n  }' 在应用快速修复后： 'void printTokens(String text) {\n    StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\");\n    while (tokenizer.hasMoreTokens()) {\n      System.out.println(tokenizer.nextToken());\n    }\n  }'",
                  "markdown": "报告在分隔符实参中包含重复字符的 `StringTokenizer()` 构造函数调用或 `nextToken()` 方法调用。\n\n**示例：**\n\n\n      void printTokens(String text) {\n        StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\\n\");\n        while (tokenizer.hasMoreTokens()) {\n          System.out.println(tokenizer.nextToken());\n        }\n      }\n\n在应用快速修复后：\n\n\n      void printTokens(String text) {\n        StringTokenizer tokenizer = new StringTokenizer(text, \"\\n\");\n        while (tokenizer.hasMoreTokens()) {\n          System.out.println(tokenizer.nextToken());\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringTokenizerDelimiter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReflectionForUnavailableAnnotation",
                "shortDescription": {
                  "text": "对仅源注解的反射访问"
                },
                "fullDescription": {
                  "text": "报告对非运行时注解的存在与否执行反射性检查的尝试。 使用 'Class.isAnnotationPresent()' 测试保留策略设置为 'SOURCE' 或 'CLASS'（默认值）的注解是否始终得到否定结果。 此错误很容易被忽视。 示例： '{\n    getClass().isAnnotationPresent(SourceAnnotation.class); //始终为 false\n  }\n\n  @Retention(RetentionPolicy.SOURCE)\n  @interface SourceAnnotation {}' 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告对非运行时注解的存在与否执行反射性检查的尝试。\n\n使用 `Class.isAnnotationPresent()` 测试保留策略设置为 `SOURCE` 或 `CLASS`（默认值）的注解是否始终得到否定结果。 此错误很容易被忽视。\n\n**示例：**\n\n\n      {\n        getClass().isAnnotationPresent(SourceAnnotation.class); //始终为 false\n      }\n\n      @Retention(RetentionPolicy.SOURCE)\n      @interface SourceAnnotation {}\n\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReflectionForUnavailableAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstantiatingObjectToGetClassObject",
                "shortDescription": {
                  "text": "实例化对象以获取 'Class' 对象"
                },
                "fullDescription": {
                  "text": "报告实例化类以获取其类对象的代码。 直接按名称访问类对象时的性能更好。 示例： 'Class<?> c = new Sample().getClass();' 在应用快速修复后： 'Class<?> c = Sample.class;'",
                  "markdown": "报告实例化类以获取其类对象的代码。\n\n直接按名称访问类对象时的性能更好。\n\n**示例：**\n\n\n      Class<?> c = new Sample().getClass();\n\n在应用快速修复后：\n\n\n      Class<?> c = Sample.class;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiatingObjectToGetClassObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithMultipleLoggers",
                "shortDescription": {
                  "text": "具有多个记录器的类"
                },
                "fullDescription": {
                  "text": "报告声明了多个记录器的类。 为应用程序提供统一的日志记录实现的一大重要步骤，是确保每个类都有一个专用的记录器。 示例： 'public class Critical {\n    protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n    protected static final Logger myLogger = Logger.getLogger(getClass());\n  }' 使用下表可指定 Logger 类名。 此检查将报告声明多个字段具有所指定类的类型之一的类。",
                  "markdown": "报告声明了多个记录器的类。 为应用程序提供统一的日志记录实现的一大重要步骤，是确保每个类都有一个专用的记录器。\n\n示例：\n\n\n      public class Critical {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        protected static final Logger myLogger = Logger.getLogger(getClass());\n      }\n\n\n使用下表可指定 Logger 类名。\n此检查将报告声明多个字段具有所指定类的类型之一的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithMultipleLoggers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/记录",
                      "index": 57,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ShiftOutOfRange",
                "shortDescription": {
                  "text": "按不当常量进行移位运算"
                },
                "fullDescription": {
                  "text": "报告移位值为超出合理范围的常量的移位运算。 报告 '0..31' 范围以外的整数移位运算以及 '0..63' 范围以外的长移位运算。 负值或过大值移位几乎肯定表明存在编码错误。 示例： 'int shiftSize = 32;\n  // 警告：移动 32 位相当于移动 0 位，所以根本没有移位。\n  int mask = (1 << shiftSize) - 1;'",
                  "markdown": "报告移位值为超出合理范围的常量的移位运算。\n\n报告 `0..31` 范围以外的整数移位运算以及 `0..63` 范围以外的长移位运算。 负值或过大值移位几乎肯定表明存在编码错误。\n\n**示例：**\n\n\n      int shiftSize = 32;\n      // 警告：移动 32 位相当于移动 0 位，所以根本没有移位。\n      int mask = (1 << shiftSize) - 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ShiftOutOfRange",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/按位运算问题",
                      "index": 162,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadRun",
                "shortDescription": {
                  "text": "调用 'Thread.run()'"
                },
                "fullDescription": {
                  "text": "报告对 'java.lang.Thread' 或其任何子类进行的 'run()' 调用。 虽然偶尔是有意为之，但这通常表明有错误，因为 'run()' 不会启动新线程。 要在单独的线程中执行代码，应使用 'start()'。",
                  "markdown": "报告对 `java.lang.Thread` 或其任何子类进行的 `run()` 调用。\n\n\n虽然偶尔是有意为之，但这通常表明有错误，因为 `run()` 不会启动新线程。\n要在单独的线程中执行代码，应使用 `start()`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadRun",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AutoBoxing",
                "shortDescription": {
                  "text": "自动装箱"
                },
                "fullDescription": {
                  "text": "报告受自动装箱转换（将基元值自动包装为对象）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。 示例： 'Integer x = 42;' 该快速修复会将转换设为显式： 'Integer x = Integer.valueOf(42);' 自动装箱在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告受自动装箱转换（将基元值自动包装为对象）影响的表达式。 尽量不使用对象，而是使用基元。 它可能会显著影响性能。\n\n**示例：**\n\n    Integer x = 42;\n\n该快速修复会将转换设为显式：\n\n    Integer x = Integer.valueOf(42);\n\n\n*自动装箱*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AutoBoxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsThrowable",
                "shortDescription": {
                  "text": "类直接扩展 'Throwable'"
                },
                "fullDescription": {
                  "text": "报告直接扩展 'java.lang.Throwable' 的类。 直接扩展 'java.lang.Throwable' 通常被认为是一种不好的做法。 通常扩展 'java.lang.RuntimeException'、'java.lang.Exception' 或在特殊情况下扩展 'java.lang.Error' 就足够了。 示例： 'class EnigmaThrowable extends Throwable {} // 警告：'EnigmaThrowable' 类会直接扩展 'java.lang.Throwable''",
                  "markdown": "报告直接扩展 `java.lang.Throwable` 的类。\n\n直接扩展 `java.lang.Throwable` 通常被认为是一种不好的做法。\n通常扩展 `java.lang.RuntimeException`、`java.lang.Exception` 或在特殊情况下扩展 `java.lang.Error` 就足够了。\n\n**示例：**\n\n\n      class EnigmaThrowable extends Throwable {} // 警告：'EnigmaThrowable' 类会直接扩展 'java.lang.Throwable'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtendsThrowable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceNeverImplemented",
                "shortDescription": {
                  "text": "没有具体子类的接口"
                },
                "fullDescription": {
                  "text": "报告没有具体子类的接口。 配置检查： 使用下面的列表可以添加注解。 该检查将忽略使用其中一种注解声明的接口。 使用下面的复选框可以忽略仅声明常量字段的接口。 即使没有实现，仍然可以使用此类接口。",
                  "markdown": "报告没有具体子类的接口。\n\n配置检查：\n\n* 使用下面的列表可以添加注解。 该检查将忽略使用其中一种注解声明的接口。\n* 使用下面的复选框可以忽略仅声明常量字段的接口。 即使没有实现，仍然可以使用此类接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceNeverImplemented",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadDeathRethrown",
                "shortDescription": {
                  "text": "'ThreadDeath' 未重新抛出"
                },
                "fullDescription": {
                  "text": "报告捕获 'java.lang.ThreadDeath' 并且不重新抛出异常的 'try' 语句。 示例： 'try {\n    executeInParallel(request);\n  } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown\n    return false;\n  }'",
                  "markdown": "报告捕获 `java.lang.ThreadDeath` 并且不重新抛出异常的 `try` 语句。\n\n**示例：**\n\n\n      try {\n        executeInParallel(request);\n      } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown\n        return false;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThreadDeathNotRethrown",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryModuleDependencyInspection",
                "shortDescription": {
                  "text": "不必要的模块依赖"
                },
                "fullDescription": {
                  "text": "报告对未使用的模块的依赖。 该快速修复可以安全移除这些未使用的依赖项。",
                  "markdown": "报告对未使用的模块的依赖。 该快速修复可以安全移除这些未使用的依赖项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryModuleDependencyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneCallsConstructors",
                "shortDescription": {
                  "text": "'clone()' 用构造函数实例化对象"
                },
                "fullDescription": {
                  "text": "报告对 'clone()' 方法中的对象构造函数的调用。 与其直接创建这些对象来支持后续的子类，不如调用 'clone()' 来实例化 'clone()' 方法中的对象。 此检查不会报告被声明为 'final' 的 'clone()' 方法或者'final' 类上的 'clone()' 方法。",
                  "markdown": "报告对 `clone()` 方法中的对象构造函数的调用。\n\n与其直接创建这些对象来支持后续的子类，不如调用 `clone()` 来实例化 `clone()` 方法中的对象。\n此检查不会报告被声明为 `final` 的 `clone()` 方法或者`final` 类上的 `clone()` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneCallsConstructors",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 89,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArraysAsListWithZeroOrOneArgument",
                "shortDescription": {
                  "text": "'Arrays.asList()' 调用的实参过少"
                },
                "fullDescription": {
                  "text": "报告对最多包含一个实参的 'Arrays.asList()' 的调用。 在 JDK 9 及更高版本中，此类调用可以替换为 'Collections.singletonList()'、'Collections.emptyList()' 或 'List.of()'，从而节省内存。 特别是，无实参的 'Collections.emptyList()' 和 'List.of()' 总是返回共享实例，而无实参的 'Arrays.asList()' 每次调用时都会创建一个新对象。 注意：'Collections.singletonList()' 和 'List.of()' 返回的列表不可变，而列表返回的 'Arrays.asList()' 允许调用 'set()' 方法。 这在极少数情况下可能会破坏代码。 示例： 'List<String> empty = Arrays.asList();\n  List<String> one = Arrays.asList(\"one\");' 在应用快速修复后： 'List<String> empty = Collections.emptyList();\n  List<String> one = Collections.singletonList(\"one\");'",
                  "markdown": "报告对最多包含一个实参的 `Arrays.asList()` 的调用。\n\n\n在 JDK 9 及更高版本中，此类调用可以替换为 `Collections.singletonList()`、`Collections.emptyList()` 或 `List.of()`，从而节省内存。\n\n特别是，无实参的 `Collections.emptyList()` 和 `List.of()` 总是返回共享实例，而无实参的 `Arrays.asList()` 每次调用时都会创建一个新对象。\n\n注意：`Collections.singletonList()` 和 `List.of()` 返回的列表不可变，而列表返回的 `Arrays.asList()` 允许调用 `set()` 方法。\n这在极少数情况下可能会破坏代码。\n\n**示例：**\n\n\n      List<String> empty = Arrays.asList();\n      List<String> one = Arrays.asList(\"one\");\n\n在应用快速修复后：\n\n\n      List<String> empty = Collections.emptyList();\n      List<String> one = Collections.singletonList(\"one\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArraysAsListWithZeroOrOneArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnstableApiUsage",
                "shortDescription": {
                  "text": "不稳定的 API 用法"
                },
                "fullDescription": {
                  "text": "报告使用一个注解标记为不稳定的 API 的用法。 将来的版本中可能更改或移除此类 API，从而破坏使用这些 API 的代码。 用于标记不稳定 API 的注解显示在以下列表中。 默认情况下，如果不稳定 API 的声明位于同一项目源中，该检查会忽略这些 API 的用法。 在此类情况下，更改 API 时可以更新用法。 但是，如果项目很大，则可能不太方便，因此，您可以关闭忽略此项目中声明的 API 选项，从而报告在项目源和库中均已声明的不稳定 API。",
                  "markdown": "报告使用一个注解标记为不稳定的 API 的用法。 将来的版本中可能更改或移除此类 API，从而破坏使用这些 API 的代码。\n\n用于标记不稳定 API 的注解显示在以下列表中。\n\n默认情况下，如果不稳定 API 的声明位于同一项目源中，该检查会忽略这些 API 的用法。 在此类情况下，更改 API 时可以更新用法。\n但是，如果项目很大，则可能不太方便，因此，您可以关闭**忽略此项目中声明的 API** 选项，从而报告在项目源和库中均已声明的不稳定 API。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnstableApiUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaUnfriendlyMethodOverload",
                "shortDescription": {
                  "text": "方法重载对 lambda 不友好"
                },
                "fullDescription": {
                  "text": "报告采用的函数接口存在抽象方法签名冲突的重载方法。 此类重载会引入歧义，并要求调用方将 lambda 转换为特定类型或显式指定 lambda 形参类型。 最好为重载方法赋予不同的名称，以消除歧义。 示例： 'interface MyExecutor {\n    void execute(Supplier<?> supplier);\n    void execute(Callable<?> callable);\n  }' 这里的 'Supplier' 和 'Callable' 为函数接口，其单抽象方法不接受任何形参并返回非 void 值。 因此，除非使用显式转换，否则无法在调用点推断 lambda 的类型。",
                  "markdown": "报告采用的函数接口存在抽象方法签名冲突的重载方法。\n\n此类重载会引入歧义，并要求调用方将 lambda 转换为特定类型或显式指定 lambda 形参类型。\n最好为重载方法赋予不同的名称，以消除歧义。\n\n示例：\n\n\n      interface MyExecutor {\n        void execute(Supplier<?> supplier);\n        void execute(Callable<?> callable);\n      }\n\n\n这里的 `Supplier` 和 `Callable` 为函数接口，其单抽象方法不接受任何形参并返回非 void 值。\n因此，除非使用显式转换，否则无法在调用点推断 lambda 的类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaUnfriendlyMethodOverload",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableRecordContainsIgnoredMembers",
                "shortDescription": {
                  "text": "'record' 包含被忽略的成员"
                },
                "fullDescription": {
                  "text": "报告在 'record' 类中定义的序列化方法或字段。 序列化方法包括 'writeObject()'、'readObject()'、'readObjectNoData()'、'writeExternal()' 和 'readExternal()'，以及字段 'serialPersistentFields'。 这些成员不用于记录的序列化或反序列化，因此不必要使用。 示例： 'record R1() implements Serializable {\n    // 该字段在记录序列化期间被忽略\n    @Serial\n    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n\n    // 该方法在记录序列化期间被忽略\n    @Serial\n    private void writeObject(ObjectOutputStream out) throws IOException {\n    }\n  }' 'record R2() implements Externalizable {\n    // 该方法在记录序列化期间被忽略\n    @Override\n    public void writeExternal(ObjectOutput out) throws IOException {\n    }\n\n    // 该方法在记录序列化期间被忽略\n    @Override\n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n    }\n  }' 2020.3 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告在 `record` 类中定义的序列化方法或字段。 序列化方法包括 `writeObject()`、`readObject()`、`readObjectNoData()`、`writeExternal()` 和 `readExternal()`，以及字段 `serialPersistentFields`。 这些成员不用于记录的序列化或反序列化，因此不必要使用。\n\n**示例：**\n\n\n      record R1() implements Serializable {\n        // 该字段在记录序列化期间被忽略\n        @Serial\n        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n\n        // 该方法在记录序列化期间被忽略\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n      }\n\n\n      record R2() implements Externalizable {\n        // 该方法在记录序列化期间被忽略\n        @Override\n        public void writeExternal(ObjectOutput out) throws IOException {\n        }\n\n        // 该方法在记录序列化期间被忽略\n        @Override\n        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        }\n      }\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableRecordContainsIgnoredMembers",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessarilyQualifiedInnerClassAccess",
                "shortDescription": {
                  "text": "不必要的限定内部类访问"
                },
                "fullDescription": {
                  "text": "报告对不必要地用封闭类的名称进行了限定的内部类的任何引用。 此类限定可以安全地移除，这有时会为内部类添加导入。 示例： 'class X {\n     X.Y foo;\n     class Y{}\n  }' 在应用快速修复后： 'class X {\n     Y foo;\n     class Y{}\n  }' 使用忽略需要导入的引用选项可忽略对内部类的引用，其中移除限定会添加导入。",
                  "markdown": "报告对不必要地用封闭类的名称进行了限定的内部类的任何引用。\n\n此类限定可以安全地移除，这有时会为内部类添加导入。\n\n示例：\n\n\n      class X {\n         X.Y foo;\n         class Y{}\n      }\n\n在应用快速修复后：\n\n\n      class X {\n         Y foo;\n         class Y{}\n      }\n\n使用**忽略需要导入的引用**选项可忽略对内部类的引用，其中移除限定会添加导入。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessarilyQualifiedInnerClassAccess",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JavadocLinkAsPlainText",
                "shortDescription": {
                  "text": "指定为纯文本的链接"
                },
                "fullDescription": {
                  "text": "报告 Javadoc 注释中的纯文本链接。 该快速修复会建议使用 '<a>' 标记包装链接。 示例： 'class Main {\n   /**\n    * https://en.wikipedia.org/\n    */\n    void foo() {}\n  }' 在应用快速修复后： 'class Main {\n   /**\n    * <a href=\"https://en.wikipedia.org/\">https://en.wikipedia.org/</a>\n    */\n    void foo() {}\n  }' 2022.1 最新变化",
                  "markdown": "报告 Javadoc 注释中的纯文本链接。\n\n\n该快速修复会建议使用 `<a>` 标记包装链接。\n\n**示例：**\n\n\n      class Main {\n       /**\n        * https://en.wikipedia.org/\n        */\n        void foo() {}\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n       /**\n        * <a href=\"https://en.wikipedia.org/\">https://en.wikipedia.org/</a>\n        */\n        void foo() {}\n      }\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JavadocLinkAsPlainText",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WhileCanBeDoWhile",
                "shortDescription": {
                  "text": "'while' 可被替换为 'do while'"
                },
                "fullDescription": {
                  "text": "报告可以更有效地编写为 'do-while' 循环的 'while' 循环。 存在循环之前的代码与循环主体中的代码相同的 'while' 循环。 替换为 'do-while' 循环会移除重复的代码。 对于没有此类重复代码的 'while' 循环，编辑器中也提供了快速修复，但没有高亮显示。 示例： 'foo();\n  while (x) {\n      foo();\n  }' 可以替换为： 'do {\n    foo();\n  } while (x);' 2024.1 最新变化",
                  "markdown": "报告可以更有效地编写为 `do-while` 循环的 `while` 循环。\n存在循环之前的代码与循环主体中的代码相同的 `while` 循环。\n替换为 `do-while` 循环会移除重复的代码。\n对于没有此类重复代码的 `while` 循环，编辑器中也提供了快速修复，但没有高亮显示。\n\n**示例：**\n\n\n      foo();\n      while (x) {\n          foo();\n      }\n\n可以替换为：\n\n\n      do {\n        foo();\n      } while (x);\n\n\n2024.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WhileCanBeDoWhile",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SharedThreadLocalRandom",
                "shortDescription": {
                  "text": "'ThreadLocalRandom' 实例可能是共享的"
                },
                "fullDescription": {
                  "text": "报告可能在线程之间共享的 'java.util.concurrent.ThreadLocalRandom' 实例。 'ThreadLocalRandom' 不应在线程之间共享，因为不具备线程安全。 该检查可以报告分配给用作方法实参的字段，或分配给局部变量并在匿名类或嵌套类中使用的实例，因为它们可能在线程之间共享。 'ThreadLocalRandom' 的用法通常应类似于'ThreadLocalRandom.current().nextInt(...)'（或 'nextDouble(...)' 等）。 当所有用法都采取这种形式时，'ThreadLocalRandom' 实例就不会被多个线程误用。 示例： 'class Main {\n      void printRandomNumbersAsync() {\n        ThreadLocalRandom random = ThreadLocalRandom.current();\n        CompletableFuture.supplyAsync(() -> generateNumbers(random))\n          .thenAccept(numbers -> System.out.println(Arrays.toString(numbers)));\n      }\n\n      private int[] generateNumbers(Random random) {\n        return random.ints(1000, 0, 100).toArray();\n      }\n    }' 使用这些选项可以列出能够作为实参传递给 'ThreadLocalRandom' 实例的方法。 可以将正则表达式用于方法名称。",
                  "markdown": "报告可能在线程之间共享的 `java.util.concurrent.ThreadLocalRandom` 实例。\n\n\n`ThreadLocalRandom` 不应在线程之间共享，因为不具备线程安全。\n该检查可以报告分配给用作方法实参的字段，或分配给局部变量并在匿名类或嵌套类中使用的实例，因为它们可能在线程之间共享。\n\n\n`ThreadLocalRandom` 的用法通常应类似于`ThreadLocalRandom.current().nextInt(...)`（或 `nextDouble(...)` 等）。\n当所有用法都采取这种形式时，`ThreadLocalRandom` 实例就不会被多个线程误用。\n\n**示例：**\n\n\n        class Main {\n          void printRandomNumbersAsync() {\n            ThreadLocalRandom random = ThreadLocalRandom.current();\n            CompletableFuture.supplyAsync(() -> generateNumbers(random))\n              .thenAccept(numbers -> System.out.println(Arrays.toString(numbers)));\n          }\n\n          private int[] generateNumbers(Random random) {\n            return random.ints(1000, 0, 100).toArray();\n          }\n        }\n      \n\n使用这些选项可以列出能够作为实参传递给 `ThreadLocalRandom` 实例的方法。\n可以将正则表达式用于方法名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SharedThreadLocalRandom",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodOverridesConcreteMethod",
                "shortDescription": {
                  "text": "abstract 方法重写具体方法"
                },
                "fullDescription": {
                  "text": "报告重写具体 super 方法的 'abstract' 方法。 此检查不会报告从 'java.lang.Object' 重写的方法。",
                  "markdown": "报告重写具体 super 方法的 `abstract` 方法。\n\n此检查不会报告从 `java.lang.Object` 重写的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodOverridesConcreteMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CodeBlock2Expr",
                "shortDescription": {
                  "text": "语句 lambda 可被替换为表达式 lambda"
                },
                "fullDescription": {
                  "text": "当可以使用表达式样式的主体时，报告包含代码块主体的 lambda 表达式。 转换的结果更短更清晰。 示例： 'Comparable<String> c = o -> {return 0;};' 在应用快速修复后： 'Comparable<String> c = o -> 0;' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "当可以使用表达式样式的主体时，报告包含代码块主体的 lambda 表达式。 转换的结果更短更清晰。\n\n示例：\n\n\n      Comparable<String> c = o -> {return 0;};\n\n在应用快速修复后：\n\n\n      Comparable<String> c = o -> 0;\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CodeBlock2Expr",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyForEach",
                "shortDescription": {
                  "text": "可简化的 forEach() 调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为更简洁的方法或可以从中提取中间步骤的 'forEach()' 调用。 示例： 'List<String> findNStrings(List<String> list, int n) {\n    List<String> other = new ArrayList<>();\n    list.forEach(s -> {\n      if(s.length() > n) other.add(s);\n    });\n    return other;\n  }' 在应用快速修复后： 'List<String> findNStrings(List<String> list, int n) {\n    List<String> other = list.stream()\n      .filter(s -> s.length() > n)\n      .collect(Collectors.toList());\n    return other;\n  }' 2017.3 最新变化 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为更简洁的方法或可以从中提取中间步骤的 `forEach()` 调用。\n\n**示例：**\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = new ArrayList<>();\n        list.forEach(s -> {\n          if(s.length() > n) other.add(s);\n        });\n        return other;\n      }\n\n在应用快速修复后：\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = list.stream()\n          .filter(s -> s.length() > n)\n          .collect(Collectors.toList());\n        return other;\n      }\n\n2017.3 最新变化\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifyForEach",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Since15",
                "shortDescription": {
                  "text": "使用在配置的语言级别下不可用的 API"
                },
                "fullDescription": {
                  "text": "报告在所配置的语言级别不可用的 API 的用法。 此检查有 3 种作用： 当语言级别低于 Java 7 时，高亮显示泛化类的用法。 当默认方法未被重写且语言级别低于 Java 8 时高亮显示。 当语言级别低于在文档中使用 '@since' 标记标记的级别时，高亮显示 API 的用法。 使用禁止使用 API 选项，禁止在项目或自定义语言级别使用 API。",
                  "markdown": "报告在所配置的语言级别不可用的 API 的用法。 此检查有 3 种作用：\n\n* 当语言级别低于 Java 7 时，高亮显示泛化类的用法。\n* 当默认方法未被重写且语言级别低于 Java 8 时高亮显示。\n* 当语言级别低于在文档中使用 `@since` 标记标记的级别时，高亮显示 API 的用法。\n\n\n使用**禁止使用 API** 选项，禁止在项目或自定义语言级别使用 API。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Since15",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantFieldInitialization",
                "shortDescription": {
                  "text": "冗余字段初始化"
                },
                "fullDescription": {
                  "text": "报告显式初始化为其默认值的字段。 示例： 'class Foo {\n    int foo = 0;\n    List bar = null;\n  }' 在应用快速修复后： 'class Foo {\n    int foo;\n    List bar;\n  }' 使用检查设置可以仅报告显式 'null' 初始化，例如： 'class Foo {\n    int foo = 0;     // 无警告\n    List bar = null; // 冗余字段初始化警告\n  }'",
                  "markdown": "报告显式初始化为其默认值的字段。\n\n**示例：**\n\n\n      class Foo {\n        int foo = 0;\n        List bar = null;\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        int foo;\n        List bar;\n      }\n\n\n使用检查设置可以仅报告显式 `null` 初始化，例如：\n\n\n      class Foo {\n        int foo = 0;     // 无警告\n        List bar = null; // 冗余字段初始化警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantFieldInitialization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReadObjectInitialization",
                "shortDescription": {
                  "text": "实例字段可能无法被 'readObject()' 初始化"
                },
                "fullDescription": {
                  "text": "报告在 'readObject()' 方法反序列化对象后不保证被初始化的字段。 该检查不报告 transient 字段。 注意：此检查使用非常保守的控制流算法，可能会将字段误报告为未初始化。 示例： 'class DataObject implements Serializable {\n  String s; // s 在 readObject 中未初始化\n  int i;\n\n  private void readObject(ObjectInputStream stream) throws IOException {\n    i = stream.readInt();\n  }\n}'",
                  "markdown": "报告在 `readObject()` 方法反序列化对象后不保证被初始化的字段。\n\n该检查不报告 transient 字段。\n\n\n注意：此检查使用非常保守的控制流算法，可能会将字段误报告为未初始化。\n\n**示例：**\n\n\n    class DataObject implements Serializable {\n      String s; // s 在 readObject 中未初始化\n      int i;\n\n      private void readObject(ObjectInputStream stream) throws IOException {\n        i = stream.readInt();\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableMayNotBeInitializedByReadObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonAtomicOperationOnVolatileField",
                "shortDescription": {
                  "text": "'volatile' 字段上的非原子操作"
                },
                "fullDescription": {
                  "text": "报告对 volatile 字段的非原子操作。 非原子操作的示例之一是使用增量运算符更新字段。 由于操作涉及读写，并且在此之间可能发生其他修改，因此可能损坏数据。 使用 'synchronized' 块进行环绕，或使用 'java.util.concurrent.atomic' 软件包中的一个类，可以使该项操作成为原子操作。 示例： 'private volatile int v = 1;\n\n  void foo() {\n    v = 2 * v;\n  }'",
                  "markdown": "报告对 volatile 字段的非原子操作。\n\n\n非原子操作的示例之一是使用增量运算符更新字段。\n由于操作涉及读写，并且在此之间可能发生其他修改，因此可能损坏数据。\n使用 `synchronized` 块进行环绕，或使用 `java.util.concurrent.atomic` 软件包中的一个类，可以使该项操作成为原子操作。\n\n**示例：**\n\n\n      private volatile int v = 1;\n\n      void foo() {\n        v = 2 * v;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonAtomicOperationOnVolatileField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QuestionableName",
                "shortDescription": {
                  "text": "可疑名称"
                },
                "fullDescription": {
                  "text": "报告名称有问题，而不是真正的描述性名称的变量、方法或类。 此类名称无助于理解代码，而且很可能是临时创建，但后来被遗忘了。 示例： 'int aa = 42;' 仅在编辑器中建议重命名快速修复。 使用该选项可以列出应被报告的名称。",
                  "markdown": "报告名称有问题，而不是真正的描述性名称的变量、方法或类。 此类名称无助于理解代码，而且很可能是临时创建，但后来被遗忘了。\n\n**示例：**\n\n\n      int aa = 42;\n\n仅在编辑器中建议重命名快速修复。\n\n\n使用该选项可以列出应被报告的名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "QuestionableName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantLengthCheck",
                "shortDescription": {
                  "text": "冗余的数组长度检查"
                },
                "fullDescription": {
                  "text": "报告数组迭代后不必要的数组长度检查。 当数组长度为零时，迭代将被跳过，因此没有必要显式地检查长度。 示例： 'void f(String[] array) {\n    if (array.length != 0) { // 不必要的检查\n      for (String str : array) {\n        System.out.println(str);\n      }\n    }\n  }' 建议使用快速修复来解包或移除长度检查： 'void f(String[] array) {\n    for (String str : array) {\n      System.out.println(str);\n    }\n  }' 2022.3 最新变化",
                  "markdown": "报告数组迭代后不必要的数组长度检查。 当数组长度为零时，迭代将被跳过，因此没有必要显式地检查长度。\n\n示例：\n\n\n      void f(String[] array) {\n        if (array.length != 0) { // 不必要的检查\n          for (String str : array) {\n            System.out.println(str);\n          }\n        }\n      }\n\n建议使用快速修复来解包或移除长度检查：\n\n\n      void f(String[] array) {\n        for (String str : array) {\n          System.out.println(str);\n        }\n      }\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantLengthCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UNCHECKED_WARNING",
                "shortDescription": {
                  "text": "未检查的警告"
                },
                "fullDescription": {
                  "text": "报告 javac 编译器发出未检查的警告的代码。 每个未检查的警告都可能在运行时触发 'ClassCastException'。 示例： 'List items = Arrays.asList(\"string\", \"string\");\n  List<Integer> numbers = Collections.unmodifiableList(items); // 未检查的赋值'",
                  "markdown": "报告 javac 编译器发出未检查的警告的代码。 每个未检查的警告都可能在运行时触发 `ClassCastException`。\n\n示例：\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // 未检查的赋值\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unchecked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 128,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DataFlowIssue",
                "shortDescription": {
                  "text": "为 null 性和数据流问题"
                },
                "fullDescription": {
                  "text": "根据数据流分析，报告始终违反为 null 性约定、可能抛出异常或只是冗余的代码结构。 示例： 'if (array.length < index) {\n  System.out.println(array[index]);\n} // 数组索引始终超出界限\n\nif (str == null) System.out.println(\"str is null\");\nSystem.out.println(str.trim());\n// 最后一个语句可能会抛出 NPE\n\n@NotNull\nInteger square(@Nullable Integer input) {\n    // 违反方法约定\n    return input == null ? null : input * input;\n}' 检查行为可能由许多注解控制，例如为 null 性注解、'@Contract' 注解、'@Range' 注解等。 配置检查： 使用对可 null 值的方法/字段/形参建议使用 @Nullable 注解选项可以在以下情况下发出警告：null 值作为实参传递给具有非注解形参的方法时，存储到非注解字段时，或从非注解方法返回时。 在这种情况下，该检查将建议传播 '@Nullable' 注解。 您还可以使用配置注解按钮配置可 null 性注解。 使用将未注解的成员和形参视为 @Nullable 选项可假设非注解成员可以为 null，因此不得在非 null 上下文中使用。 使用报告使用 null 文字实参用法的非 null 必需形参>选项可以报告不能为 null（例如在方法体中立即取消引用），但存在传递 'null' 文字的调用点的方法形参。 使用报告始终返回非 null 值的可 null 方法选项，可报告注解为 '@Nullable' 但始终返回非 null 值的方法。 在这种情况下，建议您将注解更改为 '@NotNull'。 使用忽略 assert 语句选项可控制检查如何处理 'assert' 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。 使用报告仅在某些代码路径上发生的问题选项可控制是否报告仅在某些代码路径上发生的问题。 如果禁用此选项，则不会报告 exception is possible 等警告。 该检查只会报告类似 exception will definitely occur 的警告。 这种模式可以大大减少误报的数量，特别是如果代码没有一致地使用可 null 性和约定注解进行注解。 这就是为什么它对于查找传统代码库中最重要的问题很有用。 在 IntelliJ IDEA 2022.3 版本之前，此检查为“常量条件和异常”检查的一部分。 现在，它被拆分成两个检查：“常量值”和“为 null 性和数据流问题”。",
                  "markdown": "根据数据流分析，报告始终违反为 null 性约定、可能抛出异常或只是冗余的代码结构。\n\n示例：\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // 数组索引始终超出界限\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // 最后一个语句可能会抛出 NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // 违反方法约定\n        return input == null ? null : input * input;\n    }\n\n\n检查行为可能由许多注解控制，例如[为 null 性](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html)注解、[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) 注解、`@Range` 注解等。\n\n配置检查：\n\n* 使用**对可 null 值的方法/字段/形参建议使用 @Nullable 注解** 选项可以在以下情况下发出警告：null 值作为实参传递给具有非注解形参的方法时，存储到非注解字段时，或从非注解方法返回时。 在这种情况下，该检查将建议传播 `@Nullable` 注解。 您还可以使用**配置注解**按钮配置可 null 性注解。\n* 使用**将未注解的成员和形参视为 @Nullable** 选项可假设非注解成员可以为 null，因此不得在非 null 上下文中使用。\n* 使用**报告使用 null 文字实参用法的非 null 必需形参** \\>选项可以报告不能为 null（例如在方法体中立即取消引用），但存在传递 `null` 文字的调用点的方法形参。\n* 使用**报告始终返回非 null 值的可 null 方法** 选项，可报告注解为 `@Nullable` 但始终返回非 null 值的方法。 在这种情况下，建议您将注解更改为 `@NotNull`。\n* 使用**忽略 assert 语句** 选项可控制检查如何处理 `assert` 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。\n* 使用**报告仅在某些代码路径上发生的问题** 选项可控制是否报告仅在某些代码路径上发生的问题。 如果禁用此选项，则不会报告 *exception is possible* 等警告。 该检查只会报告类似 *exception will definitely occur* 的警告。 这种模式可以大大减少误报的数量，特别是如果代码没有一致地使用可 null 性和约定注解进行注解。 这就是为什么它对于查找传统代码库中最重要的问题很有用。\n\n\n在 IntelliJ IDEA 2022.3 版本之前，此检查为\"常量条件和异常\"检查的一部分。\n现在，它被拆分成两个检查：\"常量值\"和\"为 null 性和数据流问题\"。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DataFlowIssue",
                    "cweIds": [
                      129,
                      252,
                      253,
                      394,
                      395,
                      476,
                      570,
                      571,
                      690
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterCanBeLocal",
                "shortDescription": {
                  "text": "从不读取作为形参传递的值"
                },
                "fullDescription": {
                  "text": "报告可以用局部变量替换的冗余方法形参。 如果一个形参的所有局部用法都紧跟对该形参的赋值，则可以移除该形参，并且将其用法替换为局部变量。 拥有此类形参是没有意义的，因为传递给它的值会被重写。 此问题通常是重构的结果。 示例： 'void test(int p) {\n    p = 1;\n    System.out.print(p);\n  }' 在应用快速修复后： 'void test() {\n    int p = 1;\n    System.out.print(p);\n  }'",
                  "markdown": "报告可以用局部变量替换的冗余方法形参。\n\n如果一个形参的所有局部用法都紧跟对该形参的赋值，则可以移除该形参，并且将其用法替换为局部变量。\n拥有此类形参是没有意义的，因为传递给它的值会被重写。\n此问题通常是重构的结果。\n\n示例：\n\n\n      void test(int p) {\n        p = 1;\n        System.out.print(p);\n      }\n\n在应用快速修复后：\n\n\n      void test() {\n        int p = 1;\n        System.out.print(p);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterCanBeLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementDensity",
                "shortDescription": {
                  "text": "'switch' 语句的分支密度过低"
                },
                "fullDescription": {
                  "text": "报告 switch 标签与可执行语句的比率太低的 'switch' 语句或表达式。 此类 'switch' 语句可能令人困惑，或许应对其进行重构。 示例： 'switch (i) { // 1 个 case，5 个可执行语句 -> 20% 的密度\n        case 1:\n            System.out.println(\"1\");\n            System.out.println(\"2\");\n            System.out.println(\"3\");\n            System.out.println(\"4\");\n            System.out.println(\"5\");\n            break;\n    }' 使用分支的最小密度字段可以指定 switch 标签与可执行语句的允许比率。",
                  "markdown": "报告 switch 标签与可执行语句的比率太低的 `switch` 语句或表达式。\n\n此类 `switch` 语句可能令人困惑，或许应对其进行重构。\n\n示例：\n\n\n        switch (i) { // 1 个 case，5 个可执行语句 -> 20% 的密度\n            case 1:\n                System.out.println(\"1\");\n                System.out.println(\"2\");\n                System.out.println(\"3\");\n                System.out.println(\"4\");\n                System.out.println(\"5\");\n                break;\n        }\n\n\n使用**分支的最小密度**字段可以指定 switch 标签与可执行语句的允许比率。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementDensity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedJavadocCode",
                "shortDescription": {
                  "text": "Javadoc 和代码不匹配"
                },
                "fullDescription": {
                  "text": "报告用英语编写的与方法声明冲突的方法规范部分。 这包括： 方法被指定为返回 'true' 或 'false'，但其返回值类型不是布尔。 方法被指定为返回 'null'，但被注解为 '@NotNull' 或其返回值类型为基元。 方法被指定为返回列表，但其返回值类型为集合或数组。 以此类推。 示例： '/**\n   * @return true if user is found, false otherwise\n   */\n  User findUser(String name);' 请注意，误报是可能的，因为此检查会试图解释一种人类语言。 然而，如果检查不正确报告，描述仍然可能令人困惑，应该重写。 2022.3 最新变化",
                  "markdown": "报告用英语编写的与方法声明冲突的方法规范部分。 这包括：\n\n* 方法被指定为返回 `true` 或 `false`，但其返回值类型不是布尔。\n* 方法被指定为返回 `null`，但被注解为 `@NotNull` 或其返回值类型为基元。\n* 方法被指定为返回列表，但其返回值类型为集合或数组。\n* 以此类推。\n\n**示例：**\n\n\n      /**\n       * @return true if user is found, false otherwise\n       */\n      User findUser(String name);\n\n\n请注意，误报是可能的，因为此检查会试图解释一种人类语言。 然而，如果检查不正确报告，描述仍然可能令人困惑，应该重写。\n\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedJavadocCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableAnnotation",
                "shortDescription": {
                  "text": "可简化注解"
                },
                "fullDescription": {
                  "text": "报告可以简化为单元素或标记速记形式的注解。 已报告的问题： 注解名称-值对中的冗余 'value=' 将仅包含单个值的数组值括起来的冗余大括号 @ 符号与注解名称之间的冗余空格 注解名称与形参列表之间的冗余空格 不带任何形参的注解中的冗余圆括号 示例： '@interface Foo { String[] value(); }\n\n  @ Foo({\"foo\"})\n  public String name;' 在应用快速修复后： '@interface Foo { String[] value(); }\n\n  @Foo(\"foo\")\n  public String name;'",
                  "markdown": "报告可以简化为单元素或标记速记形式的注解。\n\n\n已报告的问题：\n\n* 注解名称-值对中的冗余 `value=`\n* 将仅包含单个值的数组值括起来的冗余大括号\n* @ 符号与注解名称之间的冗余空格\n* 注解名称与形参列表之间的冗余空格\n* 不带任何形参的注解中的冗余圆括号\n\n**示例：**\n\n\n      @interface Foo { String[] value(); }\n\n      @ Foo({\"foo\"})\n      public String name;\n\n在应用快速修复后：\n\n\n      @interface Foo { String[] value(); }\n\n      @Foo(\"foo\")\n      public String name;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifiableAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Guava",
                "shortDescription": {
                  "text": "Guava 的函数基元可被替换为 Java"
                },
                "fullDescription": {
                  "text": "报告可以迁移到标准 Java API 调用的 Guava 函数基元的用法。 例如，该检查会报告类和接口（如 'FluentIterable'、'Optional'、'Function'、'Predicate' 或 'Supplier'）的用法。 示例： 'ImmutableList<String> results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();' 在应用快速修复后： 'List<String> results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());' 该快速修复可能会改变语义。 Guava 的一些惰性求值的可迭代对象可以转换为预求值的可迭代对象。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以迁移到标准 Java API 调用的 Guava 函数基元的用法。\n\n例如，该检查会报告类和接口（如 `FluentIterable`、`Optional`、`Function`、`Predicate` 或 `Supplier`）的用法。\n\n示例：\n\n\n      ImmutableList<String> results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();\n\n在应用快速修复后：\n\n\n      List<String> results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());\n\n\n该快速修复可能会改变语义。 Guava 的一些惰性求值的可迭代对象可以转换为预求值的可迭代对象。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Guava",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoopMethodInAbstractClass",
                "shortDescription": {
                  "text": "'abstract' 类中的无运算方法"
                },
                "fullDescription": {
                  "text": "报告 'abstract' 类中的 no-op（表示“无运算”）方法。 更好的设计通常是将此类方法设为 'abstract'，以便继承这些方法的类提供实现。 示例： 'abstract class Test {\n    protected void doTest() {\n    }\n  }'",
                  "markdown": "报告 `abstract` 类中的 no-op（表示\"无运算\"）方法。\n\n更好的设计通常是将此类方法设为 `abstract`，以便继承这些方法的类提供实现。\n\n**示例：**\n\n\n      abstract class Test {\n        protected void doTest() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NoopMethodInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverridableMethodCallDuringObjectConstruction",
                "shortDescription": {
                  "text": "对象构造期间调用的可重写方法"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对当前类的可重写方法的调用。 如果方法位于以下位置，则会在对象构造期间调用： 构造函数 非 static 实例初始值设定项 非 static 字段初始值设定项 'clone()' 方法 'readObject()' 方法 'readObjectNoData()' 方法 如果方法未被声明为 'final'、'static' 或 'private'，则该方法可重写。 即使可重写，package-local 方法也被认为是安全的。 此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。 示例： 'class Parent {\n    void someMethod() { }\n  }\n\n  class Child extends Parent {\n    Child() {\n      someMethod();\n    }\n  }' 此检查与以下检查共享功能： 对象构造期间调用的 abstract 方法 在对象构造期间调用的重写的方法 一次只能启用一个检查，以防止警告重复。",
                  "markdown": "报告在对象构造期间对当前类的可重写方法的调用。\n\n如果方法位于以下位置，则会在对象构造期间调用：\n\n* 构造函数\n* 非 static 实例初始值设定项\n* 非 static 字段初始值设定项\n* `clone()` 方法\n* `readObject()` 方法\n* `readObjectNoData()` 方法\n\n如果方法未被声明为 `final`、`static` 或 `private`，则该方法可重写。\n即使可重写，package-local 方法也被认为是安全的。 此类调用可能会导致难以捉摸的错误，因为对象初始化可能发生在方法调用之前。\n\n**示例：**\n\n\n      class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n      }\n\n此检查与以下检查共享功能：\n\n* 对象构造期间调用的 abstract 方法\n* 在对象构造期间调用的重写的方法\n\n一次只能启用一个检查，以防止警告重复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverridableMethodCallDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingDeprecatedAnnotation",
                "shortDescription": {
                  "text": "缺少 '@Deprecated' 注解"
                },
                "fullDescription": {
                  "text": "报告具有 '@deprecated' Javadoc 标记但没有 '@java.lang.Deprecated' 注解的模块声明、类、字段或方法。 示例： '/**\n   * @deprecated use {@code example()} instead\n   */\n  void sample(){ }' 在应用快速修复后： '/**\n   * @deprecated use {@code example()} instead\n   */\n  @Deprecated\n  void sample(){ }' 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。 使用下面的复选框，报告使用 '@Deprecated' 注解但在 Javadoc '@deprecated' 标记中没有解释的成员。 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告具有 `@deprecated` Javadoc 标记但没有 `@java.lang.Deprecated` 注解的模块声明、类、字段或方法。\n\n**示例：**\n\n\n      /**\n       * @deprecated use {@code example()} instead\n       */\n      void sample(){ }\n\n在应用快速修复后：\n\n\n      /**\n       * @deprecated use {@code example()} instead\n       */\n      @Deprecated\n      void sample(){ }\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。\n\n\n使用下面的复选框，报告使用 `@Deprecated` 注解但在 Javadoc `@deprecated` 标记中没有解释的成员。\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MissingDeprecatedAnnotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitCallToSuper",
                "shortDescription": {
                  "text": "隐式调用 'super()'"
                },
                "fullDescription": {
                  "text": "报告不以调用 \"super\" 构造函数或同一类的另一个构造函数开头的构造函数。 可以认为是此类构造函数隐式地从调用 'super()' 开始。 某些编码标准倾向于显式地调用 'super()'。 示例： 'class Foo {\n    Foo() {}\n  }' 在应用快速修复后： 'class Foo {\n    Foo() {\n      super();\n    }\n  }' 使用检查设置可以忽略直接从 'Object' 扩展的类。 例如： 'class Foo {\n    Foo() {} // 未报告\n  }\n\n  class Bar extends Foo {\n    Bar() {} // 对 'super()' 的隐式调用\n  }'",
                  "markdown": "报告不以调用 \"super\" 构造函数或同一类的另一个构造函数开头的构造函数。\n\n可以认为是此类构造函数隐式地从调用 `super()` 开始。 某些编码标准倾向于显式地调用 `super()`。\n\n**示例：**\n\n\n      class Foo {\n        Foo() {}\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\n\n使用检查设置可以忽略直接从 `Object` 扩展的类。\n例如：\n\n\n      class Foo {\n        Foo() {} // 未报告\n      }\n\n      class Bar extends Foo {\n        Bar() {} // 对 'super()' 的隐式调用\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitCallToSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTemplateMigration",
                "shortDescription": {
                  "text": "可以使用字符串模板"
                },
                "fullDescription": {
                  "text": "报告可以通过替换为字符串模板简化的 'String' 串联。 示例： 'String name = \"Bob\";\n  String greeting = \"Hello, \" + name + \". You are \" + 29 + \" years old.\";' 在应用快速修复后： 'String name = \"Bob\";\n  String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";' 2023.3 最新变化 此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告可以通过替换为字符串模板简化的 `String` 串联。\n\n**示例：**\n\n\n      String name = \"Bob\";\n      String greeting = \"Hello, \" + name + \". You are \" + 29 + \" years old.\";\n\n在应用快速修复后：\n\n\n      String name = \"Bob\";\n      String greeting = STR.\"Hello, \\{name}. You are 29 years old.\";\n\n2023.3 最新变化\n\n此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringTemplateMigration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 159,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MustAlreadyBeRemovedApi",
                "shortDescription": {
                  "text": "API 必须已移除"
                },
                "fullDescription": {
                  "text": "报告使用应从当前版本的声明库中移除的 '@ApiStatus.ScheduledForRemoval' 标记的声明。 它会将计划移除的指定版本与可在下面设置的版本进行比较。 以点分隔字符串指定版本，可选择加上 'alpha'、'beta'、'snapshot' 或 'eap' 后缀。 有效版本示例：'1.0'、'2.3.1'、'2018.1'、'7.5-snapshot'、'3.0-eap'。 版本比较非常直观，例如：'1.0 < 2.0'、'1.0-eap < 1.0'、'2.3-snapshot < 2.3' 等。 有关详细比较逻辑，请参阅 VersionComparatorUtil 的实现。",
                  "markdown": "报告使用应从当前版本的声明库中移除的 `@ApiStatus.ScheduledForRemoval` 标记的声明。\n\n它会将计划移除的指定版本与可在下面设置的版本进行比较。\n\n\n以点分隔字符串指定版本，可选择加上\n`alpha`、`beta`、`snapshot` 或 `eap` 后缀。\n\n有效版本示例：`1.0`、`2.3.1`、`2018.1`、`7.5-snapshot`、`3.0-eap`。\n\n\n版本比较非常直观，例如：`1.0 < 2.0`、`1.0-eap < 1.0`、`2.3-snapshot < 2.3` 等。\n有关详细比较逻辑，请参阅 [VersionComparatorUtil](https://github.com/JetBrains/intellij-community/blob/master/platform/util-rt/src/com/intellij/util/text/VersionComparatorUtil.java) 的实现。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MustAlreadyBeRemovedApi",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CachedNumberConstructorCall",
                "shortDescription": {
                  "text": "数字构造函数调用具有基元实参"
                },
                "fullDescription": {
                  "text": "报告具有基元 'long'、'integer'、'short' 或 'byte' 实参的新 'Long'、'Integer'、'Short' 或 'Byte' 对象的实例化。 建议使用 Java 5 中引入的 static 方法 'valueOf()' 默认情况下，此方法缓存值介于 -128 到 127（包含）之间的对象。 示例： 'Integer i = new Integer(1);\n  Long l = new Long(1L);' 应用快速修复后，代码变为： 'Integer i = Integer.valueOf(1);\n  Long l = Long.valueOf(1L);' 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。 使用忽略具有字符串实参的新数字表达式选项可以忽略对包含 'String' 实参的数字构造函数的调用。 使用仅在构造函数为 @Deprecated 时报告选项，仅报告对弃用的构造函数的调用。 'Long'、'Integer'、'Short' 和 'Byte' 构造函数自 JDK 9 起已被弃用。",
                  "markdown": "报告具有基元 `long`、`integer`、`short` 或 `byte` 实参的新 `Long`、`Integer`、`Short` 或 `Byte` 对象的实例化。\n\n建议使用 Java 5 中引入的 static 方法 `valueOf()` 默认情况下，此方法缓存值介于 -128 到 127（包含）之间的对象。\n\n**示例：**\n\n\n      Integer i = new Integer(1);\n      Long l = new Long(1L);\n\n应用快速修复后，代码变为：\n\n\n      Integer i = Integer.valueOf(1);\n      Long l = Long.valueOf(1L);\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。\n\n\n使用**忽略具有字符串实参的新数字表达式** 选项可以忽略对包含 `String` 实参的数字构造函数的调用。\n\n\n使用**仅在构造函数为 @Deprecated 时报告** 选项，仅报告对弃用的构造函数的调用。\n`Long`、`Integer`、`Short` 和 `Byte` 构造函数自 JDK 9 起已被弃用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CachedNumberConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldHidesSuperclassField",
                "shortDescription": {
                  "text": "子类字段隐藏超类字段"
                },
                "fullDescription": {
                  "text": "报告派生类中与超类的字段同名的字段。 Java 字段无法在派生类中重写，因此派生类中的字段将对超类隐藏该字段。 由于进行此类命名，在基类有意使用同名字段的情况下，您可能会误用派生类的字段。 建议通过快速修复重命名派生类中的字段。 示例： 'class Parent {\n  Parent parent;\n}\nclass Child extends Parent {\n  Child parent;\n}' 您可以为此检查配置以下选项： 忽略不可访问字段 - 指示此检查应报告所有名称冲突，还是只报告与子类可见的字段的冲突。 忽略隐藏 static 字段的 static 字段 - 忽略隐藏基类中的 'static' 字段的 'static' 字段。",
                  "markdown": "报告派生类中与超类的字段同名的字段。 Java 字段无法在派生类中重写，因此派生类中的字段将对超类隐藏该字段。\n\n\n由于进行此类命名，在基类有意使用同名字段的情况下，您可能会误用派生类的字段。\n\n建议通过快速修复重命名派生类中的字段。\n\n**示例：**\n\n    class Parent {\n      Parent parent;\n    }\n    class Child extends Parent {\n      Child parent;\n    }\n\n\n您可以为此检查配置以下选项：\n\n1. **忽略不可访问字段** - 指示此检查应报告所有名称冲突，还是只报告与子类可见的字段的冲突。\n2. **忽略隐藏 static 字段的 static 字段** - 忽略隐藏基类中的 `static` 字段的 `static` 字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNameHidesFieldInSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimpleDateFormatWithoutLocale",
                "shortDescription": {
                  "text": "无区域设置的 'SimpleDateFormat'"
                },
                "fullDescription": {
                  "text": "报告未指定 'java.util.Locale' 的 'java.util.SimpleDateFormat' 或 'java.time.format.DateTimeFormatter' 的实例化。 这些调用将使用平台默认区域设置，具体取决于操作系统设置。 当代码在不同的平台上运行或操作系统设置被更改时，这可能会导致意外行为。 '示例：' 'new SimpleDateFormat(\"yyyy\");\n  DateTimeFormatter.ofPattern(\"d/M/y\");'",
                  "markdown": "报告未指定 `java.util.Locale` 的 `java.util.SimpleDateFormat` 或 `java.time.format.DateTimeFormatter` 的实例化。 这些调用将使用平台默认区域设置，具体取决于操作系统设置。 当代码在不同的平台上运行或操作系统设置被更改时，这可能会导致意外行为。\n\n`示例：`\n\n\n      new SimpleDateFormat(\"yyyy\");\n      DateTimeFormatter.ofPattern(\"d/M/y\");\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimpleDateFormatWithoutLocale",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnnotationClass",
                "shortDescription": {
                  "text": "注解接口"
                },
                "fullDescription": {
                  "text": "报告注解接口。 Java 1.4 和更早版本不支持此类接口。",
                  "markdown": "报告注解接口。 Java 1.4 和更早版本不支持此类接口。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnnotationClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 114,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Finalize",
                "shortDescription": {
                  "text": "'finalize()' 不应被重写"
                },
                "fullDescription": {
                  "text": "报告重写 'Object.finalize()' 方法。 根据 'Object.finalize()' 文档： 终结机制本身就有问题。 终结可能导致性能问题、死锁和挂起。 终结器中的错误可能导致资源泄漏；如果不再需要，那么无从取消终结；并且对不同对象的 'finalize' 方法的调用之间没有指定顺序。 此外，关于终结时机也没有任何保证。 'finalize' 方法只能在不确定的延迟之后才对可终结的对象调用（如果有）。 配置检查： 使用对普通 'finalize()' 实现忽略选项可以忽略具有空方法体或仅包含具有计算结果为 'false' 的条件并且是编译时常量的 'if' 语句的方法体的 'finalize()' 实现。 出于性能原因，在子类中使用空实现重写非普通 'finalize()' 可能会有好处。 空的 final 'finalize()' 实现也可以用来防止子类被重写。",
                  "markdown": "报告重写 `Object.finalize()` 方法。\n\n根据 `Object.finalize()` 文档：\n>\n> 终结机制本身就有问题。 终结可能导致性能问题、死锁和挂起。 终结器中的错误可能导致资源泄漏；如果不再需要，那么无从取消终结；并且对不同对象的 `finalize` 方法的调用之间没有指定顺序。 此外，关于终结时机也没有任何保证。 `finalize` 方法只能在不确定的延迟之后才对可终结的对象调用（如果有）。\n\n配置检查：\n\n* 使用**对普通 'finalize()' 实现忽略** 选项可以忽略具有空方法体或仅包含具有计算结果为 `false` 的条件并且是编译时常量的 `if` 语句的方法体的 `finalize()` 实现。 出于性能原因，在子类中使用空实现重写非普通 `finalize()` 可能会有好处。 空的 final `finalize()` 实现也可以用来防止子类被重写。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/完成",
                      "index": 56,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessArithmeticExpression",
                "shortDescription": {
                  "text": "无意义的算术表达式"
                },
                "fullDescription": {
                  "text": "报告无意义的算术表达式。 此类表达式包括加 0、减 0、乘以 0 或 1 以及除以 1。 此类表达式可能是自动重构所致，不太可能是开发者的本意。 该快速修复会简化此类表达式。 示例： 'void f(int a) {\n    int x = a - a;\n    int y = a + 0;\n    int res = x / x;\n  }' 在应用快速修复后： 'void f(int a) {\n    int x = 0;\n    int y = a;\n    int res = 1;\n  }' 请注意，在极少数情况下，建议的替换可能不完全等同于所有可能输入的原始代码。 例如，该检查会建议将 'x / x' 替换为 '1'。 但是，如果 'x' 为零，原始代码将抛出 'ArithmeticException' 或导致 'NaN'。 另外，如果 'x' 为 'NaN'，则结果也是 'NaN'。 此类行为不太可能出于本意。",
                  "markdown": "报告无意义的算术表达式。 此类表达式包括加 0、减 0、乘以 0 或 1 以及除以 1。\n\n此类表达式可能是自动重构所致，不太可能是开发者的本意。\n\n该快速修复会简化此类表达式。\n\n**示例：**\n\n\n      void f(int a) {\n        int x = a - a;\n        int y = a + 0;\n        int res = x / x;\n      }\n\n在应用快速修复后：\n\n\n      void f(int a) {\n        int x = 0;\n        int y = a;\n        int res = 1;\n      }\n\n\n请注意，在极少数情况下，建议的替换可能不完全等同于所有可能输入的原始代码。 例如，该检查会建议将 `x / x` 替换为 `1`。\n但是，如果 `x` 为零，原始代码将抛出 `ArithmeticException` 或导致 `NaN`。\n另外，如果 `x` 为 `NaN`，则结果也是 `NaN`。 此类行为不太可能出于本意。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyLargePrimitiveArrayInitializer",
                "shortDescription": {
                  "text": "原始类型数组的过大初始值设定项"
                },
                "fullDescription": {
                  "text": "报告包含过多元素的基元数组的数组初始值设定项表达式。 此类初始值设定项可能会导致过大的类文件，因为必须生成代码才能初始化每个数组元素。 在内存或带宽受限的环境中，从资源文件加载大型基元数组可能更高效。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 使用该选项可以指定基元数组初始值设定项中允许的最大元素数。",
                  "markdown": "报告包含过多元素的基元数组的数组初始值设定项表达式。 此类初始值设定项可能会导致过大的类文件，因为必须生成代码才能初始化每个数组元素。 在内存或带宽受限的环境中，从资源文件加载大型基元数组可能更高效。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n\n使用该选项可以指定基元数组初始值设定项中允许的最大元素数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyLargePrimitiveArrayInitializer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectNotify",
                "shortDescription": {
                  "text": "调用 'notify()' 而不是 'notifyAll()'"
                },
                "fullDescription": {
                  "text": "报告对 'Object.notify()' 的调用。 虽然偶尔有用，但在几乎所有情况下，'Object.notifyAll()' 都是更好的选择，因为调用 'Object.notify()' 可能导致死锁。 有关讨论，请参阅 Doug Lea 的 Concurrent Programming in Java。",
                  "markdown": "报告对 `Object.notify()` 的调用。 虽然偶尔有用，但在几乎所有情况下，`Object.notifyAll()` 都是更好的选择，因为调用 `Object.notify()` 可能导致死锁。 有关讨论，请参阅 Doug Lea 的 *Concurrent Programming in Java*。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNotifyInsteadOfNotifyAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceVariableUninitializedUse",
                "shortDescription": {
                  "text": "实例字段在初始化前使用"
                },
                "fullDescription": {
                  "text": "报告在初始化之前读取的实例变量。 该检查会忽略 'null' 的相等检查。 示例： 'class Foo {\n    int bar;\n\n    Foo() {\n      System.out.println(bar);\n    }\n  }' 请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的字段。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在初始化之前读取的实例变量。\n\n该检查会忽略 `null` 的相等检查。\n\n**示例：**\n\n\n      class Foo {\n        int bar;\n\n        Foo() {\n          System.out.println(bar);\n        }\n      }\n\n请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行注解的字段。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableUsedBeforeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExpressionMayBeFactorized",
                "shortDescription": {
                  "text": "表达式可以因式分解"
                },
                "fullDescription": {
                  "text": "报告可以分解（即重组以提取公因数）的表达式。 这减少了冗余，可以提高代码的可读性。 示例： 'a && b || a && c' 在应用快速修复后： 'a && (b || c)' 2021.3 最新变化",
                  "markdown": "报告可以分解（即重组以提取公因数）的表达式。 这减少了冗余，可以提高代码的可读性。\n\n**示例：**\n\n\n      a && b || a && c\n\n在应用快速修复后：\n\n\n      a && (b || c)\n\n2021.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExpressionMayBeFactorized",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ListRemoveInLoop",
                "shortDescription": {
                  "text": "在循环中调用了 'List.remove()'"
                },
                "fullDescription": {
                  "text": "报告在循环中调用的可以替换为 'List.subList().clear()' 的 'List.remove(index)'。 在删除多个元素的情况下，此替换对于大多数 'List' 实现更有效。 示例： 'void removeRange(List<String> list, int from, int to) {\n    for (int i = from; i < to; i++) {\n        list.remove(from);\n    }\n  }' 在应用快速修复后： 'void removeRange(List<String> list, int from, int to) {\n    if (to > from) {\n      list.subList(from, to).clear();\n    }\n  }' 该快速修复会自动添加范围检查，以防止在最小值大于最大值时可能出现的 'IndexOutOfBoundsException'。 如果代码中不可能出现这种情况，则可将其移除。 2018.2 最新变化",
                  "markdown": "报告在循环中调用的可以替换为 `List.subList().clear()` 的 `List.remove(index)`。\n\n在删除多个元素的情况下，此替换对于大多数 `List` 实现更有效。\n\n示例：\n\n\n      void removeRange(List<String> list, int from, int to) {\n        for (int i = from; i < to; i++) {\n            list.remove(from);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void removeRange(List<String> list, int from, int to) {\n        if (to > from) {\n          list.subList(from, to).clear();\n        }\n      }\n\n\n该快速修复会自动添加范围检查，以防止在最小值大于最大值时可能出现的 `IndexOutOfBoundsException`。 如果代码中不可能出现这种情况，则可将其移除。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ListRemoveInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissingOverrideAnnotation",
                "shortDescription": {
                  "text": "缺少 '@Override' 注解"
                },
                "fullDescription": {
                  "text": "报告重写超类方法但未使用 '@java.lang.Override' 注解的方法。 由于表明了意图，使用 '@java.lang.Override' 注解方法提高了代码可读性。 此外，在被重写的方法的签名与超类方法不匹配时，编译器会报错。 示例： 'class X {\n      public String toString() {\n        return \"hello world\";\n      }\n    }' 在应用快速修复后： 'class X {\n      @Override\n      public String toString() {\n        return \"hello world\";\n      }\n    }' 配置检查： 使用忽略 'equals()'、'hashCode()' 和 'toString()' 选项可以忽略这些 'java.lang.Object' 方法：'equals()'、'hashCode()' 和 'toString()'。 由于 '@Override' 注解而使得这些方法消失且代码不再编译的风险相对较小。 使用忽略匿名类中的方法选项可以忽略匿名类中的方法。 禁用当方法的重写方法并非全部具有 '@Override' 注解时，高亮显示该方法选项，可以仅就缺少 '@Override' 注解的方法发出警告，而不就其一个或多个后代缺少 '@Override' 注解的被重写方法发出警告。 此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。",
                  "markdown": "报告重写超类方法但未使用 `@java.lang.Override` 注解的方法。\n\n\n由于表明了意图，使用 `@java.lang.Override` 注解方法提高了代码可读性。\n此外，在被重写的方法的签名与超类方法不匹配时，编译器会报错。\n\n**示例：**\n\n\n        class X {\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \n在应用快速修复后：\n\n\n        class X {\n          @Override\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \n配置检查：\n\n* 使用**忽略 'equals()'、'hashCode()' 和 'toString()'** 选项可以忽略这些 `java.lang.Object` 方法：`equals()`、`hashCode()` 和 `toString()`。 由于 `@Override` 注解而使得这些方法消失且代码不再编译的风险相对较小。\n* 使用**忽略匿名类中的方法**选项可以忽略匿名类中的方法。\n* 禁用**当方法的重写方法并非全部具有 '@Override' 注解时，高亮显示该方法** 选项，可以仅就缺少 `@Override` 注解的方法发出警告，而不就其一个或多个后代缺少 `@Override` 注解的被重写方法发出警告。\n\n此检查取决于 Java 功能 '注解'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "override",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharUsedInArithmeticContext",
                "shortDescription": {
                  "text": "在算术上下文中使用 'char' 表达式"
                },
                "fullDescription": {
                  "text": "报告用于加法或减法表达式的 'char' 类型的表达式。 此类代码不一定是问题，但可能会导致错误（例如，如果需要字符串）。 示例：'int a = 'a' + 42;' 应用该快速修复后：'int a = (int) 'a' + 42;' 对于 'String' 上下文： 'int i1 = 1;\nint i2 = 2;\nSystem.out.println(i2 + '-' + i1 + \" = \" + (i2 - i1));' 在应用快速修复后： 'System.out.println(i2 + \"-\" + i1 + \" = \" + (i2 - i1));'",
                  "markdown": "报告用于加法或减法表达式的 `char` 类型的表达式。\n\n此类代码不一定是问题，但可能会导致错误（例如，如果需要字符串）。\n\n**示例** ：`int a = 'a' + 42;`\n\n应用该快速修复后：`int a = (int) 'a' + 42;`\n\n对于 `String` 上下文：\n\n    int i1 = 1;\n    int i2 = 2;\n    System.out.println(i2 + '-' + i1 + \" = \" + (i2 - i1));\n\n在应用快速修复后：\n`System.out.println(i2 + \"-\" + i1 + \" = \" + (i2 - i1));`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharUsedInArithmeticContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringEqualsCharSequence",
                "shortDescription": {
                  "text": "使用 'CharSequence' 实参调用了 'String.equals()'"
                },
                "fullDescription": {
                  "text": "报告对 'CharSequence' 作为实参的 'String.equals()' 的调用。 对于 'String' 实参，'String.equals()' 只能返回 'true'。 要比较包含非 'String' 'CharSequence' 实参的 'String' 的内容，请使用 'contentEquals()' 方法。 示例： 'boolean equals(String s, CharSequence ch) {\n    return s.equals(ch);\n  }' 在应用快速修复后： 'boolean equals(String s, CharSequence ch) {\n    return s.contentEquals(ch);\n  }' 2017.3 最新变化",
                  "markdown": "报告对 `CharSequence` 作为实参的 `String.equals()` 的调用。\n\n\n对于 `String` 实参，`String.equals()` 只能返回 `true`。\n要比较包含非 `String` `CharSequence` 实参的 `String` 的内容，请使用 `contentEquals()` 方法。\n\n**示例：**\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.equals(ch);\n      }\n\n在应用快速修复后：\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.contentEquals(ch);\n      }\n\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringEqualsCharSequence",
                    "cweIds": [
                      597
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestFailedLine",
                "shortDescription": {
                  "text": "测试中失败的行"
                },
                "fullDescription": {
                  "text": "报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。 示例： '@Test\n  fun foo() {\n    assertEquals(1, 0) // 高亮显示\n  }'",
                  "markdown": "报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。\n\n**示例：**\n\n\n      @Test\n      fun foo() {\n        assertEquals(1, 0) // 高亮显示\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestFailedLine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicStaticCollectionField",
                "shortDescription": {
                  "text": "'public static' 集合字段"
                },
                "fullDescription": {
                  "text": "报告可修改的 'public' 'static' 集合字段。 尽管这些字段经常用于存储常量值集合，但它们仍然代表着安全隐患，因为即使字段被声明为 'final'，它们的内容仍可能被修改。 示例： 'public static final List<String> EVENTS = new ArrayList<>();'\n 使用选项部分中的表可指定返回不可修改集合的方法。 将不会报告使用这些方法初始化的 'public' 'static' 集合字段。",
                  "markdown": "报告可修改的 `public` `static` 集合字段。\n\n尽管这些字段经常用于存储常量值集合，但它们仍然代表着安全隐患，因为即使字段被声明为 `final`，它们的内容仍可能被修改。\n\n**示例：**\n\n\n      public static final List<String> EVENTS = new ArrayList<>();\n      \n\n使用**选项** 部分中的表可指定返回不可修改集合的方法。\n将不会报告使用这些方法初始化的 `public` `static` 集合字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicStaticCollectionField",
                    "cweIds": [
                      732
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsConcreteCollection",
                "shortDescription": {
                  "text": "类显式扩展 'Collection' 类"
                },
                "fullDescription": {
                  "text": "报告扩展 'java.util.Collection' 或 'java.util.Map' 类的具体子类的类。 一种常见但欠佳的做法是对具体集合类型进行子类化。 它比委托集合调用要脆弱得多。",
                  "markdown": "报告扩展 `java.util.Collection` 或 `java.util.Map` 类的具体子类的类。\n\n\n一种常见但欠佳的做法是对具体集合类型进行子类化。 它比委托集合调用要脆弱得多。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExtendsConcreteCollection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectInstantiationInEqualsHashCode",
                "shortDescription": {
                  "text": "'equals()' 或 'hashCode()' 内部的对象实例化"
                },
                "fullDescription": {
                  "text": "报告 'equals()'、'hashCode()'、'compareTo()' 和 'Comparator.compare()' 方法内（临时）新对象的构造。 除了构造函数调用之外，还可以通过在 'foreach' 语句中自动装箱或迭代器创建来创建新对象。 这可能会导致性能问题，例如，将对象添加到 'Set' 或 'Map' 时，这些方法将在这些地方被经常调用。 当在 'throw' 或 'assert' 语句中创建对象时，该检查将不会报告。 示例： 'class Person {\n    private String name;\n    private int age;\n\n    public boolean equals(Object o) {\n      return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});\n    }\n\n    public int hashCode() {\n      return (name + age).hashCode();\n    }\n  }' 在此示例中，在 'equals()' 内部创建了两个额外的数组，'age' 字段的用法需要装箱，而 'name + age' 隐式地创建了一个新字符串。",
                  "markdown": "报告 `equals()`、`hashCode()`、`compareTo()` 和 `Comparator.compare()` 方法内（临时）新对象的构造。\n\n\n除了构造函数调用之外，还可以通过在 `foreach` 语句中自动装箱或迭代器创建来创建新对象。\n这可能会导致性能问题，例如，将对象添加到 `Set` 或 `Map` 时，这些方法将在这些地方被经常调用。\n\n\n当在 `throw` 或 `assert` 语句中创建对象时，该检查将不会报告。\n\n**示例：**\n\n\n      class Person {\n        private String name;\n        private int age;\n\n        public boolean equals(Object o) {\n          return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});\n        }\n\n        public int hashCode() {\n          return (name + age).hashCode();\n        }\n      }\n\n\n在此示例中，在 `equals()` 内部创建了两个额外的数组，`age` 字段的用法需要装箱，而 `name + age` 隐式地创建了一个新字符串。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectInstantiationInEqualsHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnconditionalWait",
                "shortDescription": {
                  "text": "无条件的 'wait()' 调用"
                },
                "fullDescription": {
                  "text": "报告在同步上下文中无条件调用的 'wait()'。 'wait()' 通常用于在某个条件为 true 前阻塞线程。 如果是无条件调用 'wait()'，它通常表示在获取锁定之前检查了条件。 在这种情况下可能会发生数据竞争，条件在得到检查和获取锁定之间变为 true。 虽然此检查发现的结构未必不正确，但肯定值得检查。 示例： 'class Bar {\n      void foo() throws InterruptedException {\n          synchronized (this) {\n              wait(); // 警告\n          }\n      }\n  }'",
                  "markdown": "报告在同步上下文中无条件调用的 `wait()`。\n\n\n`wait()` 通常用于在某个条件为 true 前阻塞线程。 如果是无条件调用 `wait()`，它通常表示在获取锁定之前检查了条件。 在这种情况下可能会发生数据竞争，条件在得到检查和获取锁定之间变为 true。\n\n\n虽然此检查发现的结构未必不正确，但肯定值得检查。\n\n**示例：**\n\n\n      class Bar {\n          void foo() throws InterruptedException {\n              synchronized (this) {\n                  wait(); // 警告\n              }\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnconditionalWait",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverridesInaccessibleMethodOfSuper",
                "shortDescription": {
                  "text": "方法重写了超类不可访问的方法"
                },
                "fullDescription": {
                  "text": "报告与超类的不可访问方法包含相同签名的方法， 例如，另一个软件包中的超类的 private 方法或 package-private 方法。 此类方法名称可能令人困惑，因为子类中的方法看似重写，实则隐藏了超类不可访问的方法。 此外，如果此方法在超类中的可见性日后发生变化，可能会静默地更改子类的语义，否则会导致编译错误。 建议通过快速修复重命名该方法。 示例： 'public class Super {\n    private void test() {\n    }\n  }\n\n  public class Sub extends Super {\n    void test() { // 将 'Super.test()' 设为 public 将导致编译错误\n                  // 将 'Super.test()' 设为 package-private 会使 'Sub.test()' 变成重写\n    }\n  }'",
                  "markdown": "报告与超类的不可访问方法包含相同签名的方法， 例如，另一个软件包中的超类的 private 方法或 package-private 方法。\n\n\n此类方法名称可能令人困惑，因为子类中的方法看似重写，实则隐藏了超类不可访问的方法。\n此外，如果此方法在超类中的可见性日后发生变化，可能会静默地更改子类的语义，否则会导致编译错误。\n\n建议通过快速修复重命名该方法。\n\n**示例：**\n\n\n      public class Super {\n        private void test() {\n        }\n      }\n\n      public class Sub extends Super {\n        void test() { // 将 'Super.test()' 设为 public 将导致编译错误\n                      // 将 'Super.test()' 设为 package-private 会使 'Sub.test()' 变成重写\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverridesInaccessibleMethodOfSuper",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntLiteralMayBeLongLiteral",
                "shortDescription": {
                  "text": "转换为 'long' 可以是 'long' 文字"
                },
                "fullDescription": {
                  "text": "报告立即转换为 'long' 的 'int' 文字表达式。 此类文字表达式可以替换为等效的 'long' 文字。 示例： 'Long l = (long)42;' 在应用快速修复后： 'Long l = 42L;'",
                  "markdown": "报告立即转换为 `long` 的 `int` 文字表达式。\n\n此类文字表达式可以替换为等效的 `long` 文字。\n\n**示例：**\n\n    Long l = (long)42;\n\n在应用快速修复后：\n\n    Long l = 42L;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntLiteralMayBeLongLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 109,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleCharacterStartsWith",
                "shortDescription": {
                  "text": "单个字符 'startsWith()' 或 'endsWith()'"
                },
                "fullDescription": {
                  "text": "报告对 'String.startsWith()' 和 'String.endsWith()' 的调用，其中单字符字符串文字会作为实参传递。 建议通过快速修复，使用更高效实现的 'String.charAt()' 替换此类调用。 然而，由于额外的非零长度检查，此类更改的性能增益很小并且会降低代码的可读性，建议仅在紧密循环内应用该快速修复。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'boolean startsWithX(String s) {\n    return s.startsWith(\"x\");\n  }' 在应用快速修复后： 'boolean startsWithX(String s) {\n    return !s.isEmpty() && s.charAt(0) == 'x';\n  }'",
                  "markdown": "报告对 `String.startsWith()` 和 `String.endsWith()` 的调用，其中单字符字符串文字会作为实参传递。\n\n\n建议通过快速修复，使用更高效实现的 `String.charAt()` 替换此类调用。\n\n\n然而，由于额外的非零长度检查，此类更改的性能增益很小并且会降低代码的可读性，建议仅在紧密循环内应用该快速修复。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      boolean startsWithX(String s) {\n        return s.startsWith(\"x\");\n      }\n\n在应用快速修复后：\n\n\n      boolean startsWithX(String s) {\n        return !s.isEmpty() && s.charAt(0) == 'x';\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SingleCharacterStartsWith",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassCanBeEnum",
                "shortDescription": {
                  "text": "实用程序类可以是 'enum'"
                },
                "fullDescription": {
                  "text": "报告可转换为枚举的实用程序类。 某些编码样式准则要求将实用程序类作为枚举实现，以避免 'private' 构造函数中的代码覆盖率问题。 示例： 'class StringUtils {\n    public static final String EMPTY = \"\";\n  }' 在应用快速修复后： 'enum StringUtils {\n    ;\n    public static final String EMPTY = \"\";\n  }' 此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。",
                  "markdown": "报告可转换为枚举的实用程序类。\n\n某些编码样式准则要求将实用程序类作为枚举实现，以避免 `private` 构造函数中的代码覆盖率问题。\n\n**示例：**\n\n\n      class StringUtils {\n        public static final String EMPTY = \"\";\n      }\n\n在应用快速修复后：\n\n\n      enum StringUtils {\n        ;\n        public static final String EMPTY = \"\";\n      }\n\n此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassCanBeEnum",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsObject",
                "shortDescription": {
                  "text": "类显式扩展 'Object'"
                },
                "fullDescription": {
                  "text": "报告一个明确声明要扩展'java.lang.Object' 的类。 这种声明是冗余的，可以安全地删除。 示例： 'class MyClass extends Object {\n  }' 快速修复删除了冗余的 'extends Object' 子句： 'class MyClass {\n  }'",
                  "markdown": "报告一个明确声明要扩展` java.lang.Object` 的类。\n\n这种声明是冗余的，可以安全地删除。\n\n示例：\n\n\n      class MyClass extends Object {\n      }\n\n快速修复删除了冗余的 `extends Object` 子句：\n\n\n      class MyClass {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassExplicitlyExtendsObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReassignedVariable",
                "shortDescription": {
                  "text": "重新分配的变量"
                },
                "fullDescription": {
                  "text": "报告会使阅读和理解代码变得复杂的重新赋值的变量。 示例： 'int value = 2 * (height + width);\n  System.out.println(\"perimeter: \" + value);\n\n  value = height * width;\n  System.out.println(\"area: \" + value);'",
                  "markdown": "报告会使阅读和理解代码变得复杂的重新赋值的变量。\n\n示例：\n\n\n      int value = 2 * (height + width);\n      System.out.println(\"perimeter: \" + value);\n\n      value = height * width;\n      System.out.println(\"area: \" + value);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReassignedVariable",
                    "ideaSeverity": "TEXT ATTRIBUTES",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodNameSameAsClassName",
                "shortDescription": {
                  "text": "方法名称与类名相同"
                },
                "fullDescription": {
                  "text": "报告与其类同名的方法。 虽然 Java 语言允许此类命名，但按照约定，它被保留用于定义构造函数。 将它用于方法可能是一种错误或不好的做法。 示例： 'class MyClass {\n    int val;\n\n    // 方法 MyClass 的名称与其包含类相同。\n    // 可能是错误添加了 'void'。\n    void MyClass(int val) {\n      this.val = val;\n    }\n  }' 在适当的情况下，可以通过快速修复将方法转换为构造函数： 'class MyClass {\n    int val;\n\n    MyClass(int val) {\n      this.val = val;\n    }\n  }' 可以通过另一种快速修复重命名该方法。",
                  "markdown": "报告与其类同名的方法。 虽然 Java 语言允许此类命名，但按照约定，它被保留用于定义构造函数。 将它用于方法可能是一种错误或不好的做法。\n\n**示例：**\n\n\n      class MyClass {\n        int val;\n\n        // 方法 MyClass 的名称与其包含类相同。\n        // 可能是错误添加了 'void'。\n        void MyClass(int val) {\n          this.val = val;\n        }\n      }\n\n在适当的情况下，可以通过快速修复将方法转换为构造函数：\n\n\n      class MyClass {\n        int val;\n\n        MyClass(int val) {\n          this.val = val;\n        }\n      }\n\n可以通过另一种快速修复重命名该方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNameSameAsClassName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableNamingConvention",
                "shortDescription": {
                  "text": "局部变量命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的局部变量。 示例：如果在默认设置下启用该检查，其中变量名称应以小写字母开头，则报告 'int X = 42;'。 配置检查： 使用选项部分中的字段可指定局部变量名称的最小长度、最大长度以及预期的正则表达式。 指定 0 以便不检查名称的长度。 正则表达式应以标准 java.util.regex 格式指定。 使用复选框来忽略 'for' 循环和 'catch' 部分的形参。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的局部变量。\n\n**示例** ：如果在默认设置下启用该检查，其中变量名称应以小写字母开头，则报告 `int X = 42;`。\n\n配置检查：\n\n\n使用**选项** 部分中的字段可指定局部变量名称的最小长度、最大长度以及预期的正则表达式。\n指定 **0** 以便不检查名称的长度。 正则表达式应以标准 **java.util.regex** 格式指定。\n\n使用复选框来忽略 `for` 循环和 `catch` 部分的形参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryJavaDocLink",
                "shortDescription": {
                  "text": "不必要的 Javadoc 链接"
                },
                "fullDescription": {
                  "text": "报告引用拥有注释的方法、拥有注释的方法的 super 方法或包含注释的类的 Javadoc '@see'、'{@link}' 和 '{@linkplain}' 标记。 此类链接不必要，可以通过此检查的快速修复安全移除。 如果标记是唯一内容，快速修复将移除整个 Javadoc 注释。 示例： 'class Example {\n    /**\n     * @see Example#method\n     */\n    public void method() { }\n  }' 在应用快速修复后： 'class Example {\n  public void method() { }\n}' 使用下面的复选框可以忽略指向 super 方法的内联链接（'{@link}' 和 '{@linkplain}'）。 尽管 Javadoc 工具会自动添加指向所有 super 方法的链接，但有时在 Javadoc 注释的文本中可能需要指向 super 方法的内联链接。",
                  "markdown": "报告引用拥有注释的方法、拥有注释的方法的 super 方法或包含注释的类的 Javadoc `@see`、`{@link}` 和 `{@linkplain}` 标记。\n\n此类链接不必要，可以通过此检查的快速修复安全移除。 如果标记是唯一内容，快速修复将移除整个 Javadoc 注释。\n\n**示例：**\n\n\n      class Example {\n        /**\n         * @see Example#method\n         */\n        public void method() { }\n      }\n\n在应用快速修复后：\n\n\n    class Example {\n      public void method() { }\n    }\n\n\n使用下面的复选框可以忽略指向 super 方法的内联链接（`{@link}` 和 `{@linkplain}`）。 尽管 Javadoc 工具会自动添加指向所有 super 方法的链接，但有时在 Javadoc 注释的文本中可能需要指向 super 方法的内联链接。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryJavaDocLink",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedSwitchStatement",
                "shortDescription": {
                  "text": "嵌套 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'switch' 语句或表达式。 嵌套的 'switch' 语句可能导致代码格外令人困惑。 这些语句可以提取到一个单独的方法中。 示例： 'int res = switch (i) {\n            case 0 -> 0;\n            default -> switch (i) {\n                case 100 -> 0;\n                default -> i;\n            };\n        };'",
                  "markdown": "报告嵌套的 `switch` 语句或表达式。\n\n嵌套的 `switch` 语句可能导致代码格外令人困惑。 这些语句可以提取到一个单独的方法中。\n\n示例：\n\n\n      int res = switch (i) {\n                case 0 -> 0;\n                default -> switch (i) {\n                    case 100 -> 0;\n                    default -> i;\n                };\n            };\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedSwitchStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyTryBlock",
                "shortDescription": {
                  "text": "空 'try' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'try' 块，包括 try-with-resources 语句。 包含注释的 'try' 块视为空块。 此检查不报告在 JSP 文件中发现的空 'try' 块。",
                  "markdown": "报告空的 `try` 块，包括 try-with-resources 语句。\n\n包含注释的 `try` 块视为空块。\n\n\n此检查不报告在 JSP 文件中发现的空 `try` 块。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyTryBlock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CollectionsFieldAccessReplaceableByMethodCall",
                "shortDescription": {
                  "text": "对空集合字段的引用可被替换为方法调用"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Collections' 字段的用法：'EMPTY_LIST'、'EMPTY_MAP' 或 'EMPTY_SET'。 这些字段用法可以替换为以下方法调用：'emptyList()'、'emptyMap()' 或 'emptySet()'。 此类方法调用会防止编译器发出未检查的警告，因为可以推断出类型形参。 示例： 'List<Integer> emptyList = Collections.EMPTY_LIST;' 在应用快速修复后： 'List<Integer> emptyList = Collections.emptyList();' 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告 `java.util.Collections` 字段的用法：`EMPTY_LIST`、`EMPTY_MAP` 或 `EMPTY_SET`。 这些字段用法可以替换为以下方法调用：`emptyList()`、`emptyMap()` 或 `emptySet()`。 此类方法调用会防止编译器发出未检查的警告，因为可以推断出类型形参。\n\n**示例：**\n\n\n      List<Integer> emptyList = Collections.EMPTY_LIST;\n\n在应用快速修复后：\n\n\n      List<Integer> emptyList = Collections.emptyList();\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CollectionsFieldAccessReplaceableByMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertWithSideEffects",
                "shortDescription": {
                  "text": "具有副作用的 'assert' 语句"
                },
                "fullDescription": {
                  "text": "报告导致副作用的 'assert' 语句。 由于断言可能关闭，无法保证这些副作用，这可能导致难以捉摸的错误。 此检查检测到的不受欢迎的常见副作用是变量和字段修改。 涉及到方法调用时，将对它们进行一级深入分析。 示例： 'assert i++ < 10;'",
                  "markdown": "报告导致副作用的 `assert` 语句。\n\n\n由于断言可能关闭，无法保证这些副作用，这可能导致难以捉摸的错误。 此检查检测到的不受欢迎的常见副作用是变量和字段修改。 涉及到方法调用时，将对它们进行一级深入分析。\n\n**示例：**\n\n\n      assert i++ < 10;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertWithSideEffects",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WaitOrAwaitWithoutTimeout",
                "shortDescription": {
                  "text": "无超时的 'wait()' 或 'await()'"
                },
                "fullDescription": {
                  "text": "报告对未指定超时的 'Object.wait()' 或 'Condition.await()' 的调用。 在高可用性程序中，此类调用可能很危险，因为如果从未调用 'notify()'/'notifyAll()' 或 'signal()'/'signalAll()'，那么一个组件中的故障可能会导致等待的组件发生阻塞。 示例： 'void foo(Object bar) throws InterruptedException {\n    bar.wait();\n  }'",
                  "markdown": "报告对未指定超时的 `Object.wait()` 或 `Condition.await()` 的调用。\n\n\n在高可用性程序中，此类调用可能很危险，因为如果从未调用 `notify()`/`notifyAll()` 或 `signal()`/`signalAll()`，那么一个组件中的故障可能会导致等待的组件发生阻塞。\n\n**示例：**\n\n\n      void foo(Object bar) throws InterruptedException {\n        bar.wait();\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WaitOrAwaitWithoutTimeout",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalClass",
                "shortDescription": {
                  "text": "类禁止继承"
                },
                "fullDescription": {
                  "text": "报告被声明为 'final' 的类。 不报告扩展 'sealed' 类或接口的 final 类。 这种类不能被继承，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 'final' 类。 示例： 'public final class Main {\n  }' 在应用快速修复后： 'public class Main {\n  }'",
                  "markdown": "报告被声明为 `final` 的类。 不报告扩展 `sealed` 类或接口的 final 类。 这种类不能被继承，并且可能表明缺乏面向对象的设计。 某些编码标准不鼓励 `final` 类。\n\n**示例：**\n\n\n      public final class Main {\n      }\n\n在应用快速修复后：\n\n\n      public class Main {\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LiteralAsArgToStringEquals",
                "shortDescription": {
                  "text": "字符串文字可以为 'equals()' 限定符"
                },
                "fullDescription": {
                  "text": "报告包含字符串文字实参的 'String.equals()' 或 'String.equalsIgnoreCase()' 调用。 某些编码标准指定字符串文字应当为 'equals()' 的限定符而不是实参，从而最大限度减少 'NullPointerException'。 可以通过快速修复交换文字和表达式。 示例： 'boolean isFoo(String value) {\n    return value.equals(\"foo\");\n  }' 在应用快速修复后： 'boolean isFoo(String value) {\n    return \"foo\".equals(value);\n  }'",
                  "markdown": "报告包含字符串文字实参的 `String.equals()` 或 `String.equalsIgnoreCase()` 调用。\n\n某些编码标准指定字符串文字应当为 `equals()` 的限定符而不是实参，从而最大限度减少 `NullPointerException`。\n\n可以通过快速修复交换文字和表达式。\n\n**示例：**\n\n\n      boolean isFoo(String value) {\n        return value.equals(\"foo\");\n      }\n\n在应用快速修复后：\n\n\n      boolean isFoo(String value) {\n        return \"foo\".equals(value);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LiteralAsArgToStringEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryEmptyArrayUsage",
                "shortDescription": {
                  "text": "不必要的零长度数组用法"
                },
                "fullDescription": {
                  "text": "报告数组元素类型的类中有常量时已知长度为零的数组分配。 由于零长度数组不可变，您可以重用相同的数组实例来节省内存。 示例： 'class Item {\n    // 可重用的 public 零长度数组常量 \n    public static final Item[] EMPTY_ARRAY = new Item[0];\n  }\n  class EmptyNode {\n    Item[] getChildren() {\n      // 不必要的零长度数组创建\n      return new Item[0];\n    }\n  }' 在应用快速修复后： 'class EmptyNode {\n    Item[] getChildren() {\n      return Item.EMPTY_ARRAY;\n    }\n  }'",
                  "markdown": "报告数组元素类型的类中有常量时已知长度为零的数组分配。 由于零长度数组不可变，您可以重用相同的数组实例来节省内存。\n\n**示例：**\n\n\n      class Item {\n        // 可重用的 public 零长度数组常量 \n        public static final Item[] EMPTY_ARRAY = new Item[0];\n      }\n      class EmptyNode {\n        Item[] getChildren() {\n          // 不必要的零长度数组创建\n          return new Item[0];\n        }\n      }\n\n在应用快速修复后：\n\n\n      class EmptyNode {\n        Item[] getChildren() {\n          return Item.EMPTY_ARRAY;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantForZeroLengthArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateExpressions",
                "shortDescription": {
                  "text": "同一表达式存在多个匹配项"
                },
                "fullDescription": {
                  "text": "如果表达式的结果可以重用，则报告同一表达式在方法（或构造函数，或类初始值设定项）中的多次等效匹配项。 如果表达式没有副作用并且其结果始终相同（就 'Object.equals()' 而言），则会报告该表达式。 此类表达式的示例是 'a + b'、'Math.max(a, b)'、'a.equals(b)'、's.substring(a,b)'。 为确保结果始终相同，已验证表达式中使用的变量在表达式匹配项之间不会更改其值。 此类表达式可能包含不可变的类（如 'String'、'BigDecimal' 等）和实用程序类（如 'Objects'、'Math'，'random()' 除外）的方法。 'Object.equals()'、'Object.hashCode()'、'Object.toString()'、 'Comparable.compareTo()' 和 'Comparator.compare()' 等常用方法也可以使用，因为没有任何可见的副作用。 使用表达式复杂性阈值选项可指定最小表达复杂性阈值。 指定更大的数字将移除关于短表达式的报告。 如果 'Path.of' 和 'Paths.get' 调用具有相同的实参，则被视为等效调用。 无论其实参有多复杂，这些调用始终会被报告。 使用不同的复杂性阈值可以调整这种行为。 2018.3 最新变化",
                  "markdown": "如果表达式的结果可以重用，则报告同一表达式在方法（或构造函数，或类初始值设定项）中的多次等效匹配项。\n\n\n如果表达式没有副作用并且其结果始终相同（就 `Object.equals()` 而言），则会报告该表达式。\n此类表达式的示例是 `a + b`、`Math.max(a, b)`、`a.equals(b)`、` s.substring(a,b)`。 为确保结果始终相同，已验证表达式中使用的变量在表达式匹配项之间不会更改其值。\n\n\n此类表达式可能包含不可变的类（如 `String`、`BigDecimal` 等）和实用程序类（如 `Objects`、`Math`，`random()` 除外）的方法。\n`Object.equals() `、` Object.hashCode() `、` Object.toString() `、\n`Comparable.compareTo()` 和 `Comparator.compare()` 等常用方法也可以使用，因为没有任何可见的副作用。\n\n\n使用**表达式复杂性阈值**选项可指定最小表达复杂性阈值。 指定更大的数字将移除关于短表达式的报告。\n\n\n如果 `Path.of` 和 `Paths.get` 调用具有相同的实参，则被视为等效调用。 无论其实参有多复杂，这些调用始终会被报告。 使用不同的复杂性阈值可以调整这种行为。\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DuplicateExpressions",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanConstructor",
                "shortDescription": {
                  "text": "布尔构造函数调用"
                },
                "fullDescription": {
                  "text": "报告 'Boolean' 对象的创建情况。 基本不必要创建新的 'Boolean' 对象，如果经常这样做，可能会导致性能问题。 此外，'Boolean' 构造函数自 Java 9 起已弃用，在未来的 Java 版本中可能会被移除或变得无法访问。 示例： 'Boolean b1 = new Boolean(true);\n  Boolean b2 = new Boolean(str);' 在应用快速修复后： 'Boolean b1 = Boolean.TRUE;\n  Boolean b2 = Boolean.valueOf(str);'",
                  "markdown": "报告 `Boolean` 对象的创建情况。\n\n\n基本不必要创建新的 `Boolean` 对象，如果经常这样做，可能会导致性能问题。 此外，`Boolean` 构造函数自 Java 9 起已弃用，在未来的 Java 版本中可能会被移除或变得无法访问。\n\n**示例：**\n\n\n      Boolean b1 = new Boolean(true);\n      Boolean b2 = new Boolean(str);\n\n在应用快速修复后：\n\n\n      Boolean b1 = Boolean.TRUE;\n      Boolean b2 = Boolean.valueOf(str);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TooBroadScope",
                "shortDescription": {
                  "text": "变量作用域过宽"
                },
                "fullDescription": {
                  "text": "报告任何可以移动到更小范围的变量声明。 这种检查对于方法开头的 Pascal 样式声明特别有用。 此外，范围太广的变量在重构后也通常会被留下。 示例： 'StringBuilder sb = new StringBuilder();\n  System.out.println();\n  sb.append(1);' 在应用快速修复后： 'System.out.println();\n  StringBuilder sb = new StringBuilder();\n  sb.append(1);' 配置检查： 使用仅报告可移入内部块的变量选项可只报告那些可以移动到更深代码块中的变量。 例如，启用该选项时，将不建议对上面的 'sb' 变量进行移动。 但是，建议将其用于以下代码： 'StringBuilder sb = new StringBuilder(a);\n  if (flag) {\n    sb.append(1);\n  }' 使用报告使用新表达式作为初始值设定项的变量(可能不安全) 选项可以报告使用新表达式初始化的变量。 这使得当构造函数具有非本地副作用时，检查可能会不安全。 例如，启用该选项时，将建议对 'foo' 变量进行移动： 'class Foo {\n    static List<Foo> fooList = new ArrayList<>();\n    String bar;\n\n    Foo(String bar) {\n        this.bar = bar;\n        fooList.add(this);\n    }\n\n    public static void main(String[] args) {\n      // 虽不安全，但也可以移动\n      Foo foo = new Foo(\"bar\");\n      System.out.println(fooList.size());\n      System.out.println(foo.bar);\n    }\n  }'",
                  "markdown": "报告任何可以移动到更小范围的变量声明。\n\n这种检查对于方法开头的 *Pascal 样式*声明特别有用。 此外，范围太广的变量在重构后也通常会被留下。\n\n**示例：**\n\n\n      StringBuilder sb = new StringBuilder();\n      System.out.println();\n      sb.append(1);\n\n在应用快速修复后：\n\n\n      System.out.println();\n      StringBuilder sb = new StringBuilder();\n      sb.append(1);\n\n配置检查：\n\n* 使用**仅报告可移入内部块的变量** 选项可只报告那些可以移动到更深代码块中的变量。 例如，启用该选项时，将不建议对上面的 `sb` 变量进行移动。 但是，建议将其用于以下代码：\n\n\n        StringBuilder sb = new StringBuilder(a);\n        if (flag) {\n          sb.append(1);\n        }\n\n* 使用**报告使用新表达式作为初始值设定项的变量(可能不安全)** 选项可以报告使用新表达式初始化的变量。 这使得当构造函数具有非本地副作用时，检查可能会不安全。 例如，启用该选项时，将建议对 `foo` 变量进行移动：\n\n\n        class Foo {\n          static List<Foo> fooList = new ArrayList<>();\n          String bar;\n\n          Foo(String bar) {\n              this.bar = bar;\n              fooList.add(this);\n          }\n\n          public static void main(String[] args) {\n            // 虽不安全，但也可以移动\n            Foo foo = new Foo(\"bar\");\n            System.out.println(fooList.size());\n            System.out.println(foo.bar);\n          }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TooBroadScope",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowableSupplierOnlyThrowException",
                "shortDescription": {
                  "text": "Throwable 供应商从不返回值"
                },
                "fullDescription": {
                  "text": "报告抛出异常而不是返回异常的 'Optional.orElseThrow()'调用中的 'Supplier' lambda。 示例： 'optional.orElseThrow(() -> {\n    throw new RuntimeException();\n});' 在应用快速修复后： 'optional.orElseThrow(() -> new RuntimeException());' 2023.1 最新变化",
                  "markdown": "报告抛出异常而不是返回异常的 `Optional.orElseThrow()`调用中的 `Supplier` lambda。\n\n**示例：**\n\n\n    optional.orElseThrow(() -> {\n        throw new RuntimeException();\n    });\n\n在应用快速修复后：\n\n\n    optional.orElseThrow(() -> new RuntimeException());\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowableSupplierOnlyThrowException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementMissingBreakInLoop",
                "shortDescription": {
                  "text": "在 'if' 条件下提前退出循环"
                },
                "fullDescription": {
                  "text": "报告包含 'if' 语句并且以 'break' 结尾但又不改变语义的循环。 这可以防止冗余的循环迭代。 示例： 'boolean found = false;\n  for (int i = 0; i < arr.length; i++) {\n    if (Objects.equals(value, arr[i])) {\n      found = true;\n    }\n  }' 在应用快速修复后： 'boolean found = false;\n  for (int i = 0; i < arr.length; i++) {\n    if (Objects.equals(value, arr[i])) {\n      found = true;\n      break;\n    }\n  }' 2019.2 最新变化",
                  "markdown": "报告包含 `if` 语句并且以 `break` 结尾但又不改变语义的循环。 这可以防止冗余的循环迭代。\n\n**示例：**\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n        }\n      }\n\n在应用快速修复后：\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n          break;\n        }\n      }\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementMissingBreakInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantStreamOptionalCall",
                "shortDescription": {
                  "text": "'Stream' 或 'Optional' 调用链中存在冗余步骤"
                },
                "fullDescription": {
                  "text": "报告冗余的 'Stream' 或 'Optional' 调用（例如 'map(x -> x)'、'filter(x -> true)'）或冗余的 'sorted()' 或 'distinct()' 调用。 请注意，代码中 'streamOfIntegers.map(Integer::valueOf)' 之类的映射操作效果与 'requireNonNull()' 检查相同：如果该流包含 'null'，它将抛出 'NullPointerException'，因此并非绝对冗余。 如果不希望报告此类情况，请禁用报告 Stream.map() 中的冗余装箱选项。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告冗余的 `Stream` 或 `Optional` 调用（例如 `map(x -> x)`、`filter(x -> true)`）或冗余的 `sorted()` 或 `distinct()` 调用。\n\n请注意，代码中 `streamOfIntegers.map(Integer::valueOf)` 之类的映射操作效果与 `requireNonNull()` 检查相同：如果该流包含 `null`，它将抛出 `NullPointerException`，因此并非绝对冗余。\n如果不希望报告此类情况，请禁用**报告 Stream.map() 中的冗余装箱**选项。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantStreamOptionalCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadPriority",
                "shortDescription": {
                  "text": "调用 'Thread.setPriority()'"
                },
                "fullDescription": {
                  "text": "报告对 'Thread.setPriority()' 的调用。 修改线程的优先级本质上是不可移植的操作，因为 Java 规范中没有保证如何在调度线程中使用优先级，甚至没有保证是否使用优先级。",
                  "markdown": "报告对 `Thread.setPriority()` 的调用。 修改线程的优先级本质上是不可移植的操作，因为 Java 规范中没有保证如何在调度线程中使用优先级，甚至没有保证是否使用优先级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadSetPriority",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonFinalFieldOfException",
                "shortDescription": {
                  "text": "'Exception' 类的非 final 字段"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.Exception' 的子类中未被声明为 'final' 的字段。 不应修改异常对象上的数据，因为这可能会导致丢失可供以后调试和记录的错误上下文。 示例： 'public class EditorException extends Exception {\n    private String message; // 警告：异常类的非 final 字段 'message'\n  }'",
                  "markdown": "报告 `java.lang.Exception` 的子类中未被声明为 `final` 的字段。\n\n不应修改异常对象上的数据，因为这可能会导致丢失可供以后调试和记录的错误上下文。\n\n**示例：**\n\n\n      public class EditorException extends Exception {\n        private String message; // 警告：异常类的非 final 字段 'message'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldOfException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantStringFormatCall",
                "shortDescription": {
                  "text": "冗余调用 'String.format()'"
                },
                "fullDescription": {
                  "text": "报告对 'format()' 和 'printf()' 等可以安全移除或简化的方法的调用。 示例： 'System.out.println(String.format(\"Total count: %d\", 42));' 在应用快速修复后： 'System.out.printf(\"Total count: %d%n\", 42);'",
                  "markdown": "报告对 `format()` 和 `printf()` 等可以安全移除或简化的方法的调用。\n\n**示例：**\n\n\n      System.out.println(String.format(\"Total count: %d\", 42));\n\n在应用快速修复后：\n\n\n      System.out.printf(\"Total count: %d%n\", 42);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantStringFormatCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessNullCheck",
                "shortDescription": {
                  "text": "方法调用前出现不必要的 'null' 检查"
                },
                "fullDescription": {
                  "text": "报告后接传递 'null' 时必定返回 'false' 的方法调用的 'null' 检查（例如，'Class.isInstance'）。 在这种情况下，方法调用总是返回 'false'，此类检查似乎有些多余。 示例： 'if (x != null && myClass.isInstance(x)) { ... }' 在应用快速修复后： 'if (myClass.isInstance(x)) { ... }'",
                  "markdown": "报告后接传递 `null` 时必定返回 `false` 的方法调用的 `null` 检查（例如，`Class.isInstance`）。\n\n在这种情况下，方法调用总是返回 `false`，此类检查似乎有些多余。\n\n**示例：**\n\n\n      if (x != null && myClass.isInstance(x)) { ... }\n\n在应用快速修复后：\n\n\n      if (myClass.isInstance(x)) { ... }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodOverridesStaticMethod",
                "shortDescription": {
                  "text": "方法尝试重写超类的 'static' 方法"
                },
                "fullDescription": {
                  "text": "报告签名与超类的 'static' 方法相同的 'static' 方法。 此类方法可能看似重写，但实则它对超类隐藏了该方法，因为 Java 中的 'static' 方法不能被重写。 示例： 'class Parent {\n    static void method(){}\n  }\n\n  class Example extends Parent {\n    static void method(){} //警告\n  }'",
                  "markdown": "报告签名与超类的 `static` 方法相同的 `static` 方法。 此类方法可能看似重写，但实则它对超类隐藏了该方法，因为 Java 中的 `static` 方法不能被重写。\n\n**示例：**\n\n\n      class Parent {\n        static void method(){}\n      }\n\n      class Example extends Parent {\n        static void method(){} //警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodOverridesStaticMethodOfSuperclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCompareToJavaTime",
                "shortDescription": {
                  "text": "带有 'java.time' 'compareTo()' 调用的表达式可以简化"
                },
                "fullDescription": {
                  "text": "报告 'java.time' 与 'compareTo()' 调用（可被替换为 'isAfter()'、'isBefore()' 或 'isEqual()' 调用）的比较。 示例： 'LocalDate date1 = LocalDate.now();\n  LocalDate date2 = LocalDate.now();\n  boolean t = date1.compareTo(date2) > 0;' 在应用快速修复后： 'LocalDate date1 = LocalDate.now();\n  LocalDate date2 = LocalDate.now();\n  boolean t = date1.isAfter(date2);' 2022.3 最新变化",
                  "markdown": "报告 `java.time` 与 `compareTo()` 调用（可被替换为 `isAfter()`、`isBefore()` 或 `isEqual()` 调用）的比较。\n\n示例：\n\n\n      LocalDate date1 = LocalDate.now();\n      LocalDate date2 = LocalDate.now();\n      boolean t = date1.compareTo(date2) > 0;\n\n在应用快速修复后：\n\n\n      LocalDate date1 = LocalDate.now();\n      LocalDate date2 = LocalDate.now();\n      boolean t = date1.isAfter(date2);\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCompareToJavaTime",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnclearBinaryExpression",
                "shortDescription": {
                  "text": "具有不同优先级的多个运算符"
                },
                "fullDescription": {
                  "text": "报告由不带圆括号的不同运算符组成的二元、条件或 'instanceof' 表达式。 由于运算符的优先级规则不同，此类表达式的可读性可能较低。 示例： 'int n = 3 + 9 * 8 + 1;' 在应用快速修复后： 'int n = 3 + (9 * 8) + 1;'",
                  "markdown": "报告由不带圆括号的不同运算符组成的二元、条件或 `instanceof` 表达式。 由于运算符的优先级规则不同，此类表达式的可读性可能较低。\n\n示例：\n\n\n      int n = 3 + 9 * 8 + 1;\n\n在应用快速修复后：\n\n\n      int n = 3 + (9 * 8) + 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnclearExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedMethodCall",
                "shortDescription": {
                  "text": "链式方法调用"
                },
                "fullDescription": {
                  "text": "报告目标是另一个方法调用的方法调用。 该快速修复会建议引入局部变量。 示例： 'class X {\n    int foo(File f) {\n      return f.getName().length();\n    }\n  }' 在应用快速修复后： 'class X {\n    int foo(File f) {\n      final String name = f.getName();\n      return name.length();\n    }\n  }' 使用检查选项来切换以下各项的警告： 字段初始值设定项中的链式方法调用，例如 'private final int i = new Random().nextInt();' 在相同的类型上运算的链式方法调用，例如，'new StringBuilder().append(\"x: \").append(new X()).append(\"y: \").append(new Y()).toString();'。",
                  "markdown": "报告目标是另一个方法调用的方法调用。 该快速修复会建议引入局部变量。\n\n**示例：**\n\n\n      class X {\n        int foo(File f) {\n          return f.getName().length();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class X {\n        int foo(File f) {\n          final String name = f.getName();\n          return name.length();\n        }\n      }\n\n使用检查选项来切换以下各项的警告：\n\n*\n  字段初始值设定项中的链式方法调用，例如 `private final int i = new Random().nextInt();`\n\n*\n  在相同的类型上运算的链式方法调用，例如，`new StringBuilder().append(\"x: \").append(new X()).append(\"y: \").append(new Y()).toString();`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UtilityClassWithoutPrivateConstructor",
                "shortDescription": {
                  "text": "实用程序类没有 'private' 构造函数"
                },
                "fullDescription": {
                  "text": "报告不包含 'private' 构造函数的实用程序类。 实用程序类将所有字段和方法声明为 'static'。 在实用程序类中创建 'private' 构造函数可防止它们被意外实例化。 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行标记的类。 使用忽略仅具有主方法的类选项，可以忽略除主方法外再无其他方法的类。",
                  "markdown": "报告不包含 `private` 构造函数的实用程序类。\n\n实用程序类将所有字段和方法声明为 `static`。 在实用程序类中创建 `private` 构造函数可防止它们被意外实例化。\n\n\n使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略使用其中一种注解进行标记的类。\n\n\n使用**忽略仅具有主方法的类**选项，可以忽略除主方法外再无其他方法的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UtilityClassWithoutPrivateConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtendsUtilityClass",
                "shortDescription": {
                  "text": "类扩展实用程序类"
                },
                "fullDescription": {
                  "text": "报告扩展实用类的类。 实用类是非空类，其中所有字段和方法都为 static。 扩展实用类还允许无意中对实用类进行对象实例化，因为不能为了允许扩展而将构造函数设置为 private。 配置检查： 使用如果重写类为实用程序类，则忽略选项可以忽略任何重写实用程序类但本身也是实用程序类的类。",
                  "markdown": "报告扩展实用类的类。\n\n\n实用类是非空类，其中所有字段和方法都为 static。\n扩展实用类还允许无意中对实用类进行对象实例化，因为不能为了允许扩展而将构造函数设置为 private。\n\n\n配置检查：\n\n* 使用**如果重写类为实用程序类，则忽略**选项可以忽略任何重写实用程序类但本身也是实用程序类的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtendsUtilityClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertMessageNotString",
                "shortDescription": {
                  "text": "'assert' 消息不是字符串"
                },
                "fullDescription": {
                  "text": "报告非 'java.lang.String' 类型的 'assert' 消息。 使用字符串可以提供更多信息，有助于诊断失败或断言原因。 示例： 'void foo(List<Integer> myList) {\n    assert myList.isEmpty() : false;\n  }' 使用仅当 'assert' 消息为 'boolean' 或 'java.lang.Boolean' 时发出警告选项可以仅在 'assert' 消息类型为 'boolean' 或 'java.lang.Boolean' 时发出警告。 'boolean' 详细消息不太可能提供有关断言失败的其他信息，可能是由于错误输入 ':' 而不是 '&' 所致。",
                  "markdown": "报告非 `java.lang.String` 类型的 `assert` 消息。\n\n使用字符串可以提供更多信息，有助于诊断失败或断言原因。\n\n**示例：**\n\n\n      void foo(List<Integer> myList) {\n        assert myList.isEmpty() : false;\n      }\n\n\n使用**仅当 `assert` 消息为 'boolean' 或 'java.lang.Boolean' 时发出警告** 选项可以仅在 `assert` 消息类型为 `boolean` 或 `java.lang.Boolean` 时发出警告。\n`boolean` 详细消息不太可能提供有关断言失败的其他信息，可能是由于错误输入 `:` 而不是 `&` 所致。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertMessageNotString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PatternVariableCanBeUsed",
                "shortDescription": {
                  "text": "可以使用模式变量"
                },
                "fullDescription": {
                  "text": "报告可以替换为模式变量的局部变量声明，模式变量通常更紧凑。 示例： 'if (obj instanceof String) {\n    String str = (String) obj;\n    System.out.println(str);\n  }' 可以替换为： 'if (obj instanceof String str) {\n    System.out.println(str);\n  }' 2020.1 最新变化 此检查取决于 Java 功能 ''instanceof' 中的模式'，该功能自 Java 16 起可用。",
                  "markdown": "报告可以替换为模式变量的局部变量声明，模式变量通常更紧凑。\n\n**示例：**\n\n\n      if (obj instanceof String) {\n        String str = (String) obj;\n        System.out.println(str);\n      }\n\n可以替换为：\n\n\n      if (obj instanceof String str) {\n        System.out.println(str);\n      }\n\n2020.1 最新变化\n\n此检查取决于 Java 功能 ''instanceof' 中的模式'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PatternVariableCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 16",
                      "index": 153,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitToExplicitClassBackwardMigration",
                "shortDescription": {
                  "text": "隐式声明的类可被替换为普通类"
                },
                "fullDescription": {
                  "text": "报告隐式声明的类，并建议用常规类替换它们。 示例（在文件 Sample.java 中）： 'public static void main() {\n      System.out.println(\"Hello, world!\");\n  }' 在应用快速修复后： 'public class Sample {\n    public static void main() {\n        System.out.println(\"Hello, world!\");\n    }\n}' 此检查有助于为向后兼容早期 Java 版本而降级。 2024.1 最新变化 此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告隐式声明的类，并建议用常规类替换它们。\n\n**示例（在文件 Sample.java 中）：**\n\n\n      public static void main() {\n          System.out.println(\"Hello, world!\");\n      }\n\n在应用快速修复后：\n\n\n    public class Sample {\n        public static void main() {\n            System.out.println(\"Hello, world!\");\n        }\n    }\n\n\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2024.1 最新变化\n\n此检查取决于 Java 功能 '隐式声明的类'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ImplicitToExplicitClassBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 159,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousClassVariableHidesContainingMethodVariable",
                "shortDescription": {
                  "text": "匿名类变量隐藏包含方法中的变量"
                },
                "fullDescription": {
                  "text": "报告匿名类中名称与包含方法或 lambda 表达式的局部变量或形参相同的字段。 由于进行此类命名，在包含方法中有意使用同名变量或形参的情况下，您可能会误用匿名类字段。 建议通过快速修复重命名该字段。 示例： 'class Test {\n    public Test(String value) {\n      Object foo = new Object() {\n        private String value = \"TEST\";\n        public void foo() {\n          System.out.println(value); //访问的是字段，而不是形参\n        }\n      };\n    }\n  }'",
                  "markdown": "报告匿名类中名称与包含方法或 lambda 表达式的局部变量或形参相同的字段。\n\n\n由于进行此类命名，在包含方法中有意使用同名变量或形参的情况下，您可能会误用匿名类字段。\n\n建议通过快速修复重命名该字段。\n\n**示例：**\n\n\n      class Test {\n        public Test(String value) {\n          Object foo = new Object() {\n            private String value = \"TEST\";\n            public void foo() {\n              System.out.println(value); //访问的是字段，而不是形参\n            }\n          };\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousClassVariableHidesContainingMethodVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodRefCanBeReplacedWithLambda",
                "shortDescription": {
                  "text": "方法引用可被替换为 lambda"
                },
                "fullDescription": {
                  "text": "报告方法引用，例如 'MyClass::myMethod' 和 'myObject::myMethod'，并建议将它们替换为等效的 lambda 表达式。 Lambda 表达式比方法引用更容易修改。 示例： 'System.out::println' 在应用快速修复后： 's -> System.out.println(s)' 默认情况下，此检查不会高亮显示编辑器中的代码，而仅提供快速修复。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告方法引用，例如 `MyClass::myMethod` 和 `myObject::myMethod`，并建议将它们替换为等效的 lambda 表达式。\n\nLambda 表达式比方法引用更容易修改。\n\n示例：\n\n\n      System.out::println\n\n在应用快速修复后：\n\n\n      s -> System.out.println(s)\n\n默认情况下，此检查不会高亮显示编辑器中的代码，而仅提供快速修复。\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MethodRefCanBeReplacedWithLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedSynchronizedStatement",
                "shortDescription": {
                  "text": "嵌套 'synchronized' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'synchronized' 语句。 建议尽量避免嵌套同步，因为在某些情况下，嵌套同步可能会导致死锁。 示例： 'synchronized (lockA){\n    //线程 1 在等待 lockB\n    synchronized (lockB){ //警告\n    }\n  }\n  ...\n  synchronized (lockB) {\n    //线程 2 在等待 lockA\n    synchronized (lockA) { //警告\n    }\n  }'",
                  "markdown": "报告嵌套的 `synchronized` 语句。 建议尽量避免嵌套同步，因为在某些情况下，嵌套同步可能会导致死锁。\n\n**示例：**\n\n\n      synchronized (lockA){\n        //线程 1 在等待 lockB\n        synchronized (lockB){ //警告\n        }\n      }\n      ...\n      synchronized (lockB) {\n        //线程 2 在等待 lockA\n        synchronized (lockA) { //警告\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedSynchronizedStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectDateTimeFormat",
                "shortDescription": {
                  "text": "不正确的 'DateTimeFormat' 模式"
                },
                "fullDescription": {
                  "text": "报告错误的日期时间格式模式。 报告以下错误： 不支持的模式字母，如 \"TT\" 使用保留字符，如 \"#\" 不正确的填充用法 不平衡的中括号 连续模式字母的数量不正确 示例： 'DateTimeFormatter.ofPattern(\"[][]]\"); // 右 ']' 之前没有左 '['\n  DateTimeFormatter.ofPattern(\"TT\"); // 非法的模式字母 'T'\n  DateTimeFormatter.ofPattern(\"{\"); // 使用了保留字符 '{'\n  DateTimeFormatter.ofPattern(\"MMMMMM\"); // 过多的连续模式字母 'M'' 2022.3 最新变化",
                  "markdown": "报告错误的日期时间格式模式。\n\n报告以下错误：\n\n* 不支持的模式字母，如 \"TT\"\n* 使用保留字符，如 \"#\"\n* 不正确的填充用法\n* 不平衡的中括号\n* 连续模式字母的数量不正确\n\n示例：\n\n\n      DateTimeFormatter.ofPattern(\"[][]]\"); // 右 ']' 之前没有左 '['\n      DateTimeFormatter.ofPattern(\"TT\"); // 非法的模式字母 'T'\n      DateTimeFormatter.ofPattern(\"{\"); // 使用了保留字符 '{'\n      DateTimeFormatter.ofPattern(\"MMMMMM\"); // 过多的连续模式字母 'M'\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncorrectDateTimeFormat",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryFullyQualifiedName",
                "shortDescription": {
                  "text": "不必要的完全限定名称"
                },
                "fullDescription": {
                  "text": "报告可以缩短的完全限定类名。 快速修复会缩短完全限定名称并在必要时添加导入语句。 示例： 'class ListWrapper {\n    java.util.List<Integer> l;\n  }' 在应用快速修复后： 'import java.util.List;\n  class ListWrapper {\n    List<Integer> l;\n  }' 配置检查： 使用 在 Java 9 模块语句中忽略 选项忽略 Java 9 'provides' 和 'uses' 模块语句中的完全限定名称。 在设置| 编辑器 | 代码样式 | Java | 导入 中，请使用以下选项配置检查： 如果应使用外部类限定对内部类的引用，请使用 为内部类插入导入 选项。 使用在 JavaDoc 中使用完全限定类名 选项允许在 Javadoc 中使用完全限定名称。",
                  "markdown": "报告可以缩短的完全限定类名。\n\n快速修复会缩短完全限定名称并在必要时添加导入语句。\n\n示例：\n\n\n      class ListWrapper {\n        java.util.List<Integer> l;\n      }\n\n在应用快速修复后：\n\n\n      import java.util.List;\n      class ListWrapper {\n        List<Integer> l;\n      }\n\n配置检查：\n\n\n使用 **在 Java 9 模块语句中忽略** 选项忽略 Java 9 `provides` 和 `uses` 模块语句中的完全限定名称。\n\n\n在[设置\\| 编辑器 \\| 代码样式 \\| Java \\| 导入](settings://preferences.sourceCode.Java?JavaDoc%20Inner) 中，请使用以下选项配置检查：\n\n* 如果应使用外部类限定对内部类的引用，请使用 **为内部类插入导入** 选项。\n* 使用**在 JavaDoc 中使用完全限定类名** 选项允许在 Javadoc 中使用完全限定名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryFullyQualifiedName",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedConditional",
                "shortDescription": {
                  "text": "具有否定条件的条件表达式"
                },
                "fullDescription": {
                  "text": "报告条件被否定的条件表达式。 翻转条件表达式分支的顺序通常会增加此类语句的清晰度。 使用忽略 '!= null' 比较和忽略 '!= 0' 比较选项可以忽略 'obj != null' 或 'num != 0' 形式的比较。 由于 'obj != null' 实际上意味着 \"obj exists\"，整个表达式的含义不涉及任何否定，所以易于理解。 同样的推理也适用于 'num !=0' 表达式，在使用位掩码时更是如此。 这些形式还有另外的好处，即先提及有趣的情况。 在大多数情况下，'== null' 分支的值为 'null' 本身，如以下示例所示： 'static String getName(Person p) {\n        return p != null ? p.getName() : null;\n    }\n\n    static String getExecutableString(int fileMode) {\n        return (fileMode & 0b001001001) != 0 ? \"executable\" : \"non-executable\";\n    }'",
                  "markdown": "报告条件被否定的条件表达式。\n\n翻转条件表达式分支的顺序通常会增加此类语句的清晰度。\n\n\n使用**忽略 '!= null' 比较** 和**忽略 '!= 0' 比较** 选项可以忽略 `obj != null` 或 `num != 0` 形式的比较。\n由于 `obj != null` 实际上意味着 \"obj exists\"，整个表达式的含义不涉及任何否定，所以易于理解。\n\n\n同样的推理也适用于 `num !=0` 表达式，在使用位掩码时更是如此。\n\n\n这些形式还有另外的好处，即先提及有趣的情况。\n在大多数情况下，`== null` 分支的值为 `null` 本身，如以下示例所示：\n\n\n        static String getName(Person p) {\n            return p != null ? p.getName() : null;\n        }\n\n        static String getExecutableString(int fileMode) {\n            return (fileMode & 0b001001001) != 0 ? \"executable\" : \"non-executable\";\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionWithNegatedCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BooleanParameter",
                "shortDescription": {
                  "text": "'public' 方法具有 'boolean' 形参"
                },
                "fullDescription": {
                  "text": "报告接受 'boolean' 形参的 public 方法。 如果某个 public 方法（API 的一部分）不是 setter，则向该方法添加 'boolean' 形参几乎始终是一种不好的做法。 使用此类方法读取代码时，如果不查看源代码或文档，会很难理解 'boolean' 的含义。 此问题也被称为布尔陷阱。 'boolean' 形参通常可以替换为 'enum'。 示例： '// 警告：在查看对此方法的\n  // 调用时，很难理解\n  // 布尔形参的含义\n  public boolean setPermission(File f,\n                               int access,\n                               boolean enable,\n                               boolean ownerOnly) {\n    // ...\n  }' 使用仅报告具有多个布尔形参的方法选项可以仅在一个方法包含多个布尔形参时发出警告。",
                  "markdown": "报告接受 `boolean` 形参的 public 方法。\n\n如果某个 public 方法（API 的一部分）不是 setter，则向该方法添加 `boolean` 形参几乎始终是一种不好的做法。\n使用此类方法读取代码时，如果不查看源代码或文档，会很难理解 `boolean` 的含义。\n\n此问题也被称为[布尔陷阱](https://ariya.io/2011/08/hall-of-api-shame-boolean-trap)。\n`boolean` 形参通常可以替换为 `enum`。\n\n示例：\n\n\n      // 警告：在查看对此方法的\n      // 调用时，很难理解\n      // 布尔形参的含义\n      public boolean setPermission(File f,\n                                   int access,\n                                   boolean enable,\n                                   boolean ownerOnly) {\n        // ...\n      }\n\n\n使用**仅报告具有多个布尔形参的方法**选项可以仅在一个方法包含多个布尔形参时发出警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BooleanParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestInProductSource",
                "shortDescription": {
                  "text": "产品源中的测试"
                },
                "fullDescription": {
                  "text": "报告位于生产源树中的测试类和测试方法。 这很可能表示有错误，并且可能导致测试代码被投入生产。",
                  "markdown": "报告位于生产源树中的测试类和测试方法。 这很可能表示有错误，并且可能导致测试代码被投入生产。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestInProductSource",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CopyConstructorMissesField",
                "shortDescription": {
                  "text": "复制缺少字段的构造函数"
                },
                "fullDescription": {
                  "text": "报告不复制该类所有字段的复制构造函数。 带有初始值设定项的 'final' 字段和 'transient' 字段被视为不必复制。 示例： 'class Point {\n\n    private int x;\n    private int y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    Point(Point other) {\n      // 字段 x 和 y 未初始化\n    }\n  }' 2018.1 最新变化",
                  "markdown": "报告不复制该类所有字段的复制构造函数。\n\n\n带有初始值设定项的 `final` 字段和 `transient` 字段被视为不必复制。\n\n**示例：**\n\n\n      class Point {\n\n        private int x;\n        private int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        Point(Point other) {\n          // 字段 x 和 y 未初始化\n        }\n      }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CopyConstructorMissesField",
                    "cweIds": [
                      665
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastCanBeRemovedNarrowingVariableType",
                "shortDescription": {
                  "text": "太弱的变量类型导致不必要的转换"
                },
                "fullDescription": {
                  "text": "如果将变量类型范围缩小到转换类型，则报告可以移除的类型转换。 示例： 'Object x = \"  string  \";\n  System.out.println(((String)x).trim());' 在这里，将 'x' 的类型更改为 'String' 使转换变得冗余。 建议的快速修复会更新变量类型并移除该变量上的所有冗余转换： 'String x = \"  string  \";\n  System.out.println(x.trim());' 2018.2 最新变化",
                  "markdown": "如果将变量类型范围缩小到转换类型，则报告可以移除的类型转换。\n\n示例：\n\n\n      Object x = \"  string  \";\n      System.out.println(((String)x).trim());\n\n\n在这里，将 `x` 的类型更改为 `String` 使转换变得冗余。 建议的快速修复会更新变量类型并移除该变量上的所有冗余转换：\n\n\n      String x = \"  string  \";\n      System.out.println(x.trim());\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CastCanBeRemovedNarrowingVariableType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToStaticFieldFromInstanceMethod",
                "shortDescription": {
                  "text": "从实例上下文赋值给 static 字段"
                },
                "fullDescription": {
                  "text": "报告对实例方法中 'static' 字段的赋值或修改。 虽然合法，但此类赋值很难安全完成，并且通常是无意中将字段标记为 'static' 的结果。 示例： 'class Counter {\n    private static int count = 0;\n\n    void increment() {\n      // 警告：从实例方法\n      // 更新 static 字段\n      count++;\n    }\n  }'",
                  "markdown": "报告对实例方法中 `static` 字段的赋值或修改。\n\n虽然合法，但此类赋值很难安全完成，并且通常是无意中将字段标记为 `static` 的结果。\n\n**示例：**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // 警告：从实例方法\n          // 更新 static 字段\n          count++;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToStaticFieldFromInstanceMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassWithOnlyOneDirectInheritor",
                "shortDescription": {
                  "text": "只有一个直接继承者的抽象类"
                },
                "fullDescription": {
                  "text": "报告仅具有一个直接继承者的 abstract 类。 虽然这种类可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将抽象类与其继承者合并。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'abstract class Base {} // 将被报告\n\n  class Inheritor extends Base {}'",
                  "markdown": "报告仅具有一个直接继承者的 abstract 类。 虽然这种类可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将抽象类与其继承者合并。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      abstract class Base {} // 将被报告\n\n      class Inheritor extends Base {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassWithOnlyOneDirectInheritor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnsecureRandomNumberGeneration",
                "shortDescription": {
                  "text": "不安全的随机数生成"
                },
                "fullDescription": {
                  "text": "报告任何使用 'java.lang.Random' 或 'java.lang.Math.random()' 的情况。 在安全环境中，'java.secure.SecureRandom' 是更好的选择，因为它提供加密安全的随机数生成。 示例： 'long token = new Random().nextLong();'",
                  "markdown": "报告任何使用 `java.lang.Random` 或 `java.lang.Math.random()` 的情况。\n\n\n在安全环境中，`java.secure.SecureRandom` 是更好的选择，因为它提供加密安全的随机数生成。\n\n**示例：**\n\n\n      long token = new Random().nextLong();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnsecureRandomNumberGeneration",
                    "cweIds": [
                      330
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullableProblems",
                "shortDescription": {
                  "text": "@NotNull/@Nullable 问题"
                },
                "fullDescription": {
                  "text": "报告与可 null 性注解相关的问题。 示例： 重写方法未注解： 'abstract class A {\n  @NotNull abstract String m();\n}\nclass B extends A {\n    String m() { return \"empty string\"; }\n}' 注解的基元类型：'@NotNull int myFoo;' '@Nullable' 和 '@NotNull' 位于同一成员上：'@Nullable @NotNull String myFooString;' 可 null 元素的集合被分配到非 null 元素的集合中： 'void testList(List<@Nullable String> nullableList) {\n   List<@NotNull String> list2 = nullableList;\n}' 使用配置注解按钮可指定可 null 性注解，使用复选框可细调该检查提供警告的位置。 仅当项目或模块的语言级别为 5 或更高，并且类路径上提供可 null 性注解时，此检查才会报告。",
                  "markdown": "报告与可 null 性注解相关的问题。\n\n**示例：**\n\n* 重写方法未注解：\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* 注解的基元类型：`@NotNull int myFoo;`\n* `@Nullable` 和 `@NotNull` 位于同一成员上：`@Nullable @NotNull String myFooString;`\n* 可 null 元素的集合被分配到非 null 元素的集合中：\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \n使用**配置注解**按钮可指定可 null 性注解，使用复选框可细调该检查提供警告的位置。\n\n仅当项目或模块的语言级别为 5 或更高，并且类路径上提供可 null 性注解时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NullableProblems",
                    "cweIds": [
                      476,
                      754
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug/为 null 性问题",
                      "index": 141,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsBetweenInconvertibleTypes",
                "shortDescription": {
                  "text": "'equals()' 位于不可转换类型的对象之间"
                },
                "fullDescription": {
                  "text": "报告对目标和实参的类型不兼容的 'equals()' 的调用。 虽然此类调用理论上可能有用，但很可能是错误。 示例： 'new HashSet<String>().equals(new TreeSet<Integer>());'",
                  "markdown": "报告对目标和实参的类型不兼容的 `equals()` 的调用。\n\n虽然此类调用理论上可能有用，但很可能是错误。\n\n**示例：**\n\n\n      new HashSet<String>().equals(new TreeSet<Integer>());\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsBetweenInconvertibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnGetClass",
                "shortDescription": {
                  "text": "在 'getClass()' 上同步"
                },
                "fullDescription": {
                  "text": "报告对 'getClass()' 的调用上的同步。 如果包含同步的类被子类化，子类将在不同的类对象上同步。 对 'getClass()' 的调用通常可以替换为类的文字表达式，例如 'String.class'。 一种更好的解决办法是在 'private static final' 锁对象上同步，从而完全控制对该对象的访问。 示例： 'synchronized(getClass()) {}'",
                  "markdown": "报告对 `getClass()` 的调用上的同步。\n\n\n如果包含同步的类被子类化，子类将在不同的类对象上同步。 对 `getClass()` 的调用通常可以替换为类的文字表达式，例如 `String.class`。 一种更好的解决办法是在 `private static final` 锁对象上同步，从而完全控制对该对象的访问。\n\n**示例：**\n\n     synchronized(getClass()) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnGetClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateCondition",
                "shortDescription": {
                  "text": "条件重复"
                },
                "fullDescription": {
                  "text": "报告 '&&' 和 '||' 表达式以及 'if' 语句分支中的重复条件。 这些重复的条件有时是有意为之，但通常是因为疏忽大意所致。 示例： 'boolean result = digit1 != digit2 || digit1 != digit2;' 要忽略可能产生副作用的条件，请使用忽略有副作用的条件 选项。 禁用此选项可能会导致误报，例如，当同一方法在后续调用中返回不同的值时。 示例： 'native boolean unknownMethod();\n  \n  ...\n  \n  if (unknownMethod() || unknownMethod()) {\n    System.out.println(\"Got it\");\n  }' 由于 'unknownMethod()' 可能存在副作用（在示例中），只有在禁用 忽略有副作用的条件 选项时才会触发警告。",
                  "markdown": "报告 `&&` 和 `||` 表达式以及 `if` 语句分支中的重复条件。 这些重复的条件有时是有意为之，但通常是因为疏忽大意所致。\n\n示例：\n\n\n      boolean result = digit1 != digit2 || digit1 != digit2;\n\n\n要忽略可能产生副作用的条件，请使用**忽略有副作用的条件** 选项。\n禁用此选项可能会导致误报，例如，当同一方法在后续调用中返回不同的值时。\n\n示例：\n\n\n      native boolean unknownMethod();\n      \n      ...\n      \n      if (unknownMethod() || unknownMethod()) {\n        System.out.println(\"Got it\");\n      }\n\n由于 `unknownMethod()` 可能存在副作用（在示例中），只有在禁用 **忽略有副作用的条件** 选项时才会触发警告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrownExceptionsPerMethod",
                "shortDescription": {
                  "text": "方法声明的异常过多"
                },
                "fullDescription": {
                  "text": "报告在 'throws' 列表中具有过多异常类型的方法。 声明了太多异常的方法是错误处理代码变得过于复杂的标志。 使用异常抛出限制字段可指定方法在其 'throws' 列表中允许的最大异常类型数。",
                  "markdown": "报告在 `throws` 列表中具有过多异常类型的方法。\n\n声明了太多异常的方法是错误处理代码变得过于复杂的标志。\n\n使用**异常抛出限制** 字段可指定方法在其 `throws` 列表中允许的最大异常类型数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithTooExceptionsDeclared",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantThrows",
                "shortDescription": {
                  "text": "冗余 'throws' 子句"
                },
                "fullDescription": {
                  "text": "报告在方法签名中声明但方法本身或其实现和重写方法从未抛出的异常。 该检查会忽略与序列化相关的方法，例如方法 'readObject()' 和 'writeObject()'。 示例： 'void method() throws InterruptedException {\n    System.out.println();\n  }' 该快速修复会移除声明中不必要的异常，并规范化冗余的 'try'-'catch' 语句： 'void method() {\n    System.out.println();\n  }' 注意：由于性能原因，在编辑器中高亮显示时可能不会报告某些异常。 要查看所有结果，请从主菜单中选择代码 | 检查代码或代码 | 分析代码 | 按名称运行检查来运行检查。 使用忽略由入口点方法抛出的异常选项可以不报告由 'main()' 等方法抛出的异常。 可以在 Java | 声明冗余 | 未使用的声明检查的设置中配置入口点方法。",
                  "markdown": "报告在方法签名中声明但方法本身或其实现和重写方法从未抛出的异常。\n\n该检查会忽略与序列化相关的方法，例如方法 `readObject()` 和 `writeObject()`。\n\n**示例：**\n\n\n      void method() throws InterruptedException {\n        System.out.println();\n      }\n\n该快速修复会移除声明中不必要的异常，并规范化冗余的 `try`-`catch` 语句：\n\n\n      void method() {\n        System.out.println();\n      }\n\n\n**注意** ：由于性能原因，在编辑器中高亮显示时可能不会报告某些异常。\n要查看所有结果，请从主菜单中选择**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**来运行检查。\n\n使用**忽略由入口点方法抛出的异常** 选项可以不报告由 `main()` 等方法抛出的异常。\n可以在 [Java \\| 声明冗余 \\| 未使用的声明](settings://Errors?Unused%20Declaration%20entry%20point)检查的设置中配置入口点方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantThrows",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfAnotherObjectsPrivateField",
                "shortDescription": {
                  "text": "访问另一个对象的非 public 字段"
                },
                "fullDescription": {
                  "text": "报告对另一个对象的 'private' 或 'protected' 字段的访问。 Java 允许访问与当前对象属于同一类的对象的此类字段，但某些编码样式不鼓励这种用法。 此外，这种对 'private' 字段的直接访问在面向组件的架构（例如 Spring 或 Hibernate）中可能会失败，它们期望对其他对象的所有访问都通过方法调用进行，以便框架可以使用代理调解访问。 示例： 'public class Base {\n    protected int bar;\n\n    void increment(Base base) {\n      bar++;\n      base.bar++; // warning: direct access to another object's non-public field\n    }\n  }' 可以通过快速修复封装该字段。 配置检查： 使用忽略来自同一类的访问选项可忽略来自同一类的访问，只报告来自内部或外部类的访问。 要忽略来自内部类的访问，请使用嵌套的忽略来自内部类的访问。 使用忽略来自 'equals()' 方法的访问可忽略来自 'equals()' 方法的访问。",
                  "markdown": "报告对另一个对象的 `private` 或 `protected` 字段的访问。 Java 允许访问与当前对象属于同一类的对象的此类字段，但某些编码样式不鼓励这种用法。 此外，这种对 `private` 字段的直接访问在面向组件的架构（例如 Spring 或 Hibernate）中可能会失败，它们期望对其他对象的所有访问都通过方法调用进行，以便框架可以使用代理调解访问。\n\n**示例：**\n\n\n      public class Base {\n        protected int bar;\n\n        void increment(Base base) {\n          bar++;\n          base.bar++; // warning: direct access to another object's non-public field\n        }\n      }\n\n可以通过快速修复封装该字段。\n\n配置检查：\n\n* 使用**忽略来自同一类的访问** 选项可忽略来自同一类的访问，只报告来自内部或外部类的访问。\n\n  要忽略来自内部类的访问，请使用嵌套的**忽略来自内部类的访问**。\n* 使用**忽略来自 'equals()' 方法的访问** 可忽略来自 `equals()` 方法的访问。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessingNonPublicFieldOfAnotherObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBitwiseExpression",
                "shortDescription": {
                  "text": "无意义的按位表达式"
                },
                "fullDescription": {
                  "text": "报告无意义的按位表达式。 此类表达式包括对给定类型的最大值应用 '&' 运算符，对零以及移零应用 'or' 运算符。 出现此类表达式，可能是因为自动重构没有一直持续到完成，而且不太可能是出于原本的意图。 示例： '// 警告：运算毫无意义，可以替换为 `flags`\n  // 0xFFFF_FFFF 是一个整数的最大值，并且这两个文字都被视为\n  // 32 位整数文字。\n  int bits = flags & 0xFFFF_FFFF;\n\n  // 警告：运算毫无意义，可以替换为 `bits`\n  // 包含 0 的 OR 运算始终输出另一个操作数。\n  int or = bits | 0x0;\n\n  // 警告：运算毫无意义，结果始终为 0\n  int xor = or ^ or;'",
                  "markdown": "报告无意义的按位表达式。\n\n\n此类表达式包括对给定类型的最大值应用 `&` 运算符，对零以及移零应用 `or` 运算符。 出现此类表达式，可能是因为自动重构没有一直持续到完成，而且不太可能是出于原本的意图。\n\n**示例：**\n\n\n      // 警告：运算毫无意义，可以替换为 `flags`\n      // 0xFFFF_FFFF 是一个整数的最大值，并且这两个文字都被视为\n      // 32 位整数文字。\n      int bits = flags & 0xFFFF_FFFF;\n\n      // 警告：运算毫无意义，可以替换为 `bits`\n      // 包含 0 的 OR 运算始终输出另一个操作数。\n      int or = bits | 0x0;\n\n      // 警告：运算毫无意义，结果始终为 0\n      int xor = or ^ or;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBitwiseExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/按位运算问题",
                      "index": 162,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateThrows",
                "shortDescription": {
                  "text": "重复抛出"
                },
                "fullDescription": {
                  "text": "报告方法 'throws' 列表中的重复异常。 示例： 'void f() throws Exception, Exception {}' 在应用快速修复后： 'void f() throws Exception {}' 使用忽略子类化其他异常的异常选项可以忽略子类化其他异常的异常。",
                  "markdown": "报告方法 `throws` 列表中的重复异常。\n\n示例：\n\n\n      void f() throws Exception, Exception {}\n\n在应用快速修复后：\n\n\n      void f() throws Exception {}\n\n\n使用**忽略子类化其他异常的异常**选项可以忽略子类化其他异常的异常。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateThrows",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnstableTypeUsedInSignature",
                "shortDescription": {
                  "text": "签名中使用了不稳定的类型"
                },
                "fullDescription": {
                  "text": "报告在签名中引用不稳定 API 类型，但没有使用相同的不稳定注解进行标记的类、方法和字段的声明。 此检查可以确保公共 API 的签名不会公开任何不稳定（内部、实验性）类型。 例如，如果方法返回实验性类，则会将该方法视为实验性方法， 因为对类型的不兼容更改（删除或移到另一个软件包）会导致不兼容的方法签名更改。 使用下面的列表可以指定标记不稳定 API 的注解。",
                  "markdown": "报告在签名中引用不稳定 API 类型，但没有使用相同的不稳定注解进行标记的类、方法和字段的声明。\n\n\n此检查可以确保公共 API 的签名不会公开任何*不稳定* （内部、实验性）类型。\n例如，如果方法返回*实验性* 类，则会将该方法视为*实验性*方法，\n因为对类型的不兼容更改（删除或移到另一个软件包）会导致不兼容的方法签名更改。\n\n使用下面的列表可以指定标记不稳定 API 的注解。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnstableTypeUsedInSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrivateMemberAccessBetweenOuterAndInnerClass",
                "shortDescription": {
                  "text": "合成访问器调用"
                },
                "fullDescription": {
                  "text": "报告从嵌套类到外部类的非常量 'private' 成员的引用。 对于此类引用，javac 将生成 package-private 合成访问器方法，这可能会危及安全性，因为看似为 private 的成员实际上可以从整个软件包中访问。 嵌套类及其外部类会被编译为单独的类文件。 Java 虚拟机通常会禁止从一个类访问另一个类的 private 字段和方法。 为了实现从嵌套类访问外部类的 private 成员，javac 创建了一个 package-private 合成访问器方法。 通过将 'private' 成员设为 package-private，实际的可访问性变成了显式。 这也会节省少量内存，可能会在资源受限的环境中提高性能。 仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。 在 Java 11 和更高版本中，由于基于嵌套的访问控制 (JEP 181)，不再生成访问器方法。 示例： 'class Outer {\n    private void x() {}\n\n    class Inner {\n      void y() {\n        x();\n      }\n    }\n  }' 在应用快速修复后： 'class Outer {\n    void x() {}\n\n    class Inner {\n      void y() {\n        x();\n      }\n    }\n  }'",
                  "markdown": "报告从嵌套类到外部类的非常量 `private` 成员的引用。 对于此类引用，javac 将生成 package-private 合成访问器方法，这可能会危及安全性，因为看似为 private 的成员实际上可以从整个软件包中访问。\n\n\n嵌套类及其外部类会被编译为单独的类文件。 Java 虚拟机通常会禁止从一个类访问另一个类的 private 字段和方法。 为了实现从嵌套类访问外部类的 private 成员，javac 创建了一个 package-private 合成访问器方法。\n\n\n通过将 `private` 成员设为 package-private，实际的可访问性变成了显式。\n这也会节省少量内存，可能会在资源受限的环境中提高性能。\n\n\n仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。\n在 Java 11 和更高版本中，由于基于嵌套的访问控制 ([JEP 181](https://openjdk.org/jeps/181))，不再生成访问器方法。\n\n**示例：**\n\n\n      class Outer {\n        private void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Outer {\n        void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SyntheticAccessorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemRunFinalizersOnExit",
                "shortDescription": {
                  "text": "调用 'System.runFinalizersOnExit()'"
                },
                "fullDescription": {
                  "text": "报告对 'System.runFinalizersOnExit()' 的调用。 此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。 在 JDK 11 中已被弃用并移除，强烈建议不要使用。 仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。",
                  "markdown": "报告对 `System.runFinalizersOnExit()` 的调用。\n\n\n此调用是 Java 语言中最危险的调用之一。 它本质上为非线程安全，可能导致数据损坏、死锁，并可能影响远离调用点的程序部分。\n在 JDK 11 中已被弃用并移除，强烈建议不要使用。\n\n仅当项目或模块的语言级别为 10 或更低时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemRunFinalizersOnExit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassIndependentOfModule",
                "shortDescription": {
                  "text": "独立于其模块的类"
                },
                "fullDescription": {
                  "text": "报告符合以下情况的类： 不依赖于其模块中的任何其他类 不是其模块中任何其他类的依赖项 这种类表示临时或不连贯的模块化策略，并且通常可以有利地移动。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告符合以下情况的类：\n\n* 不依赖于其模块中的任何其他类\n* 不是其模块中任何其他类的依赖项\n\n这种类表示临时或不连贯的模块化策略，并且通常可以有利地移动。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassIndependentOfModule",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterTypePreventsOverriding",
                "shortDescription": {
                  "text": "形参类型阻止重写"
                },
                "fullDescription": {
                  "text": "报告与相应 super 方法的形参类型同名但属于不同软件包的子类方法的形参类型。 在这些情况下，子类方法不能重写 super 方法。 示例： 'public class A {\n public void method(Object o) {}\n}\n\npublic class B extends A {\n public void method(Object o) {} // 对形参类型发出警告\n class Object {}\n}' 在应用快速修复后： 'public class A {\n public void method(Object o) {}\n}\n\npublic class B extends A {\n public void method(java.lang.Object o) {} // 新形参类型\n class Object {}\n}'",
                  "markdown": "报告与相应 super 方法的形参类型同名但属于不同软件包的子类方法的形参类型。 在这些情况下，子类方法不能重写 super 方法。\n\n**示例：**\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(Object o) {} // 对形参类型发出警告\n     class Object {}\n    }\n\n在应用快速修复后：\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(java.lang.Object o) {} // 新形参类型\n     class Object {}\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterTypePreventsOverriding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceInefficientStreamCount",
                "shortDescription": {
                  "text": "以 count() 结尾的低效 Stream API 调用链"
                },
                "fullDescription": {
                  "text": "报告可以优化并且以 'count()' 运算结束的 Stream API 调用链。 以下调用链替换为此检查： 'Collection.stream().count()' → 'Collection.size()'. 在 Java 8 中，'Collection.stream().count()' 实际上是通过迭代集合元素来进行计数，而 'Collection.size()' 对于大多数集合来说速度要快得多。 'Stream.flatMap(Collection::stream).count()' → 'Stream.mapToLong(Collection::size).sum()'. 同样，不需要遍历所有嵌套集合。 相反，它们的大小可以相加。 'Stream.filter(o -> ...).count() > 0' → 'Stream.anyMatch(o -> ...)'. 与初始调用不同，一旦找到匹配元素后 'anyMatch()' 就可以立即停止计算。 'Stream.filter(o -> ...).count() == 0' → 'Stream.noneMatch(o -> ...)'. 与以上相似。 请注意，如果替换涉及 'anyMatch()' 等短路操作，那么中间流操作产生副作用时，可能会出现明显的行为变化。 在 Stream API 调用中通常应避免副作用。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以优化并且以 `count()` 运算结束的 Stream API 调用链。\n\n\n以下调用链替换为此检查：\n\n* `Collection.stream().count()` → `Collection.size()`. 在 Java 8 中，`Collection.stream().count()` 实际上是通过迭代集合元素来进行计数，而 `Collection.size()` 对于大多数集合来说速度要快得多。\n* `Stream.flatMap(Collection::stream).count()` → `Stream.mapToLong(Collection::size).sum()`. 同样，不需要遍历所有嵌套集合。 相反，它们的大小可以相加。\n* `Stream.filter(o -> ...).count() > 0` → `Stream.anyMatch(o -> ...)`. 与初始调用不同，一旦找到匹配元素后 `anyMatch()` 就可以立即停止计算。\n* `Stream.filter(o -> ...).count() == 0` → `Stream.noneMatch(o -> ...)`. 与以上相似。\n\n\n请注意，如果替换涉及 `anyMatch()` 等短路操作，那么中间流操作产生副作用时，可能会出现明显的行为变化。 在 Stream API 调用中通常应避免副作用。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceInefficientStreamCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExtractMethodRecommender",
                "shortDescription": {
                  "text": "方法可以提取"
                },
                "fullDescription": {
                  "text": "建议将代码段提取到单独的方法中，以使代码更加清晰。 此检查有许多启发来选择好的提取候选项，包括以下几个。 提取的片段没有非本地控制流 提取的片段有且只有一个输出变量 在提取的片段内部和外部没有使用类似的输出变量 提取的片段只有很少的输入形参（默认情况下不超过三个；通过检查选项配置） 提取的片段不小于配置的长度（默认为 500 个字符），但不大于所包含方法体的 60%",
                  "markdown": "建议将代码段提取到单独的方法中，以使代码更加清晰。 此检查有许多启发来选择好的提取候选项，包括以下几个。\n\n* 提取的片段没有非本地控制流\n* 提取的片段有且只有一个输出变量\n* 在提取的片段内部和外部没有使用类似的输出变量\n* 提取的片段只有很少的输入形参（默认情况下不超过三个；通过检查选项配置）\n* 提取的片段不小于配置的长度（默认为 500 个字符），但不大于所包含方法体的 60%"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExtractMethodRecommender",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringOperationCanBeSimplified",
                "shortDescription": {
                  "text": "冗余的 'String' 操作"
                },
                "fullDescription": {
                  "text": "报告对 'toString()' 或 'substring()' 等可被替换为更简单表达式的 'String' 构造函数和方法的冗余调用。 例如，在 '\"string\".substring(0)'、'\"string\".toString()' 或 'new StringBuilder().toString().substring(1,3)' 等代码中，可以安全移除对这些方法的调用。 示例： 'System.out.println(new String(\"message\"));' 在应用快速修复后： 'System.out.println(\"message\");' 请注意，该快速修复会移除冗余的构造函数调用，这可能会影响 'String' 引用相等。 即使被认为是一种不好的做法，如果您仍需要保留，请禁止警告或使用检查设置来忽略冗余的 'String' 构造函数调用。 使用下方的不报告 String 构造函数调用选项可以不报告如上例所示的代码。 这将避免在使用 'new String()' 调用保证不同对象相等性的代码中应用快速修复后改变与 '==' 或 '!=' 进行字符串比较的结果。 2018.1 最新变化",
                  "markdown": "报告对 `toString()` 或 `substring()` 等可被替换为更简单表达式的 `String` 构造函数和方法的冗余调用。\n\n例如，在 `\"string\".substring(0)`、`\"string\".toString()` 或\n`new StringBuilder().toString().substring(1,3)` 等代码中，可以安全移除对这些方法的调用。\n\n示例：\n\n\n      System.out.println(new String(\"message\"));\n\n在应用快速修复后：\n\n\n      System.out.println(\"message\");\n\n\n请注意，该快速修复会移除冗余的构造函数调用，这可能会影响 `String` 引用相等。\n即使被认为是一种不好的做法，如果您仍需要保留，请禁止警告或使用检查设置来忽略冗余的 `String` 构造函数调用。\n\n\n使用下方的**不报告 String 构造函数调用** 选项可以不报告如上例所示的代码。\n这将避免在使用 `new String()` 调用保证不同对象相等性的代码中应用快速修复后改变与 `==` 或 `!=` 进行字符串比较的结果。\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringOperationCanBeSimplified",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassReferencesSubclass",
                "shortDescription": {
                  "text": "类引用其子类之一"
                },
                "fullDescription": {
                  "text": "报告包含对其中一个子类进行了引用的类。 此类引用可能令人困惑，并违反面向对象设计的多条规则。 示例： 'class Entity {\n    // 警告：该类引用了其子类\n    void compare(SimpleEntity entity) {\n      ...\n    }\n  }\n  class SimpleEntity extends Entity {\n    ...\n  }'",
                  "markdown": "报告包含对其中一个子类进行了引用的类。 此类引用可能令人困惑，并违反面向对象设计的多条规则。\n\n示例：\n\n\n      class Entity {\n        // 警告：该类引用了其子类\n        void compare(SimpleEntity entity) {\n          ...\n        }\n      }\n      class SimpleEntity extends Entity {\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassReferencesSubclass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DateToString",
                "shortDescription": {
                  "text": "调用 'Date.toString()'"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Date' 对象上的 'toString()' 调用。 在国际化环境中，此类调用通常是不正确的。",
                  "markdown": "报告 `java.util.Date` 对象上的 `toString()` 调用。 在国际化环境中，此类调用通常是不正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToDateToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IterableUsedAsVararg",
                "shortDescription": {
                  "text": "可迭代对象用作 vararg"
                },
                "fullDescription": {
                  "text": "报告 vararg 方法调用中 'Collection' 或 'Iterable' 的可疑用法。 例如，在以下方法中： '<T> boolean contains(T needle, T... haystack) {...}' 像下面这样的调用 'if(contains(\"item\", listOfStrings)) {...}' 看起来很可疑，因为列表将被包装成一个元素数组。 此类代码可以被成功编译并且很可能会无异常地运行，但它可能被错误地使用。 2019.2 最新变化 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告 vararg 方法调用中 `Collection` 或 `Iterable` 的可疑用法。\n\n例如，在以下方法中：\n\n\n      <T> boolean contains(T needle, T... haystack) {...}\n\n像下面这样的调用\n\n\n      if(contains(\"item\", listOfStrings)) {...}\n\n看起来很可疑，因为列表将被包装成一个元素数组。\n此类代码可以被成功编译并且很可能会无异常地运行，但它可能被错误地使用。\n\n2019.2 最新变化\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IterableUsedAsVararg",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodNameSameAsParentName",
                "shortDescription": {
                  "text": "方法名称与父类名相同"
                },
                "fullDescription": {
                  "text": "报告与此方法的类的超类同名的方法，因为此类方法名称可能令人困惑。 此检查不会检查层次结构深处的接口或超类。 示例： 'class Parent {}\n  class Child extends Parent {\n     public Parent Parent() {\n       return null;\n     }\n  }' 只能在编辑器中使用重命名此类方法的快速修复。",
                  "markdown": "报告与此方法的类的超类同名的方法，因为此类方法名称可能令人困惑。\n\n此检查不会检查层次结构深处的接口或超类。\n\n**示例：**\n\n\n      class Parent {}\n      class Child extends Parent {\n         public Parent Parent() {\n           return null;\n         }\n      }\n\n只能在编辑器中使用重命名此类方法的快速修复。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodNameSameAsParentName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterNamingConvention",
                "shortDescription": {
                  "text": "lambda 形参命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的 lambda 形参。 示例：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 'Function<String, String> id = X -> X;'。 配置检查： 使用选项部分中的字段可指定 lambda 形参名称的最小长度、最大长度以及预期的正则表达式。 指定 0 以便不检查名称的长度。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的 lambda 形参。\n\n**示例** ：如果使用默认设置（其中形参名称应以小写字母开头）启用检查，则应报告 `Function<String, String> id = X -> X;`。\n\n配置检查：\n\n\n使用**选项** 部分中的字段可指定 lambda 形参名称的最小长度、最大长度以及预期的正则表达式。\n指定 **0** 以便不检查名称的长度。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaParameterNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LawOfDemeter",
                "shortDescription": {
                  "text": "迪米特法则"
                },
                "fullDescription": {
                  "text": "报告违反迪米特法则的情况。 迪米特法则并非真正的法则，但它指定了一种样式准则：绝不调用从另一个调用中获取的对象的方法。 遵循此准则的代码更容易维护、调整和重构，方法之间的耦合更少，重复更少，信息隐藏得更好。 另一方面，您可能需要编写许多包装器方法才能满足这一准则。 示例： 'boolean pay(Customer c, Invoice invoice) {\n    int dollars = c.getWallet().contents; // 违规\n    if (dollars >= invoice.getAmount()) {\n      Wallet w = c.getWallet();\n      w.subtract(invoice.getAmount()); // 违规\n      return true;\n    }\n    return false;\n  }' 上面的示例可以更好地实现为 'Customer' 中的 'payInvoice(Invoice invoice)' 方法。 使用忽略对库方法的调用和对库字段的访问选项可以忽略不更改库就无法修正的违反迪米特法则的情况。",
                  "markdown": "报告违反[迪米特法则](https://en.wikipedia.org/wiki/Law_of_Demeter)的情况。\n\n\n迪米特法则并非真正的法则，但它指定了一种样式准则：绝不调用从另一个调用中获取的对象的方法。\n遵循此准则的代码更容易维护、调整和重构，方法之间的耦合更少，重复更少，信息隐藏得更好。 另一方面，您可能需要编写许多包装器方法才能满足这一准则。\n\n**示例：**\n\n\n      boolean pay(Customer c, Invoice invoice) {\n        int dollars = c.getWallet().contents; // 违规\n        if (dollars >= invoice.getAmount()) {\n          Wallet w = c.getWallet();\n          w.subtract(invoice.getAmount()); // 违规\n          return true;\n        }\n        return false;\n      }\n\n上面的示例可以更好地实现为 `Customer` 中的 `payInvoice(Invoice invoice)` 方法。\n\n\n使用**忽略对库方法的调用和对库字段的访问**选项可以忽略不更改库就无法修正的违反迪米特法则的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LawOfDemeter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousFieldAccess",
                "shortDescription": {
                  "text": "对继承字段的访问类似于对周围代码中元素的访问"
                },
                "fullDescription": {
                  "text": "如果在类周围的代码中存在同名的局部变量、形参或字段，则报告从匿名类、内部类或局部类对超类字段的访问。 在这种情况下，看似访问了来自周围代码的元素，而实际上访问的是来自超类的字段。 为阐明代码的意图，建议对字段访问添加显式 'super' 限定符。 示例： 'class First {\n      protected String ambiguous;\n    }\n    class Second {\n      void foo(String ambiguous) {\n        new First() {\n          {\n            System.out.println(ambiguous); // 访问的是字段，而不是形参\n          }\n        };\n      }\n    }' 在应用快速修复后： 'class First {\n      protected String ambiguous;\n    }\n    class Second {\n      void foo(String ambiguous) {\n        new First() {\n          {\n            System.out.println(super.ambiguous);\n          }\n        };\n      }\n    }'",
                  "markdown": "如果在类周围的代码中存在同名的局部变量、形参或字段，则报告从匿名类、内部类或局部类对超类字段的访问。 在这种情况下，看似访问了来自周围代码的元素，而实际上访问的是来自超类的字段。\n\n\n为阐明代码的意图，建议对字段访问添加显式 `super` 限定符。\n\n**示例：**\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(ambiguous); // 访问的是字段，而不是形参\n              }\n            };\n          }\n        }\n\n在应用快速修复后：\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(super.ambiguous);\n              }\n            };\n          }\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousFieldAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonProtectedConstructorInAbstractClass",
                "shortDescription": {
                  "text": "抽象类中的 public 构造函数"
                },
                "fullDescription": {
                  "text": "报告 'abstract' 类的 'public' 构造函数。 'abstract' 类的构造函数只能从其子类的构造函数进行调用，将其声明为 'public' 可能令人困惑。 该快速修复会将此类构造函数设为 protected。 示例： 'public abstract class Foo {\n    public Foo () { // 警告：有 'public' 修饰符\n        /* ... */\n    }\n  }' 在应用快速修复后： 'public abstract class Foo {\n    protected Foo () {\n        /* ... */\n    }\n  }' 配置检查： 使用下面的忽略非 public 类选项可以忽略非 public 类中的 'public' 构造函数。",
                  "markdown": "报告 `abstract` 类的 `public` 构造函数。\n\n\n`abstract` 类的构造函数只能从其子类的构造函数进行调用，将其声明为 `public` 可能令人困惑。\n\n该快速修复会将此类构造函数设为 protected。\n\n**示例：**\n\n\n      public abstract class Foo {\n        public Foo () { // 警告：有 'public' 修饰符\n            /* ... */\n        }\n      }\n\n在应用快速修复后：\n\n\n      public abstract class Foo {\n        protected Foo () {\n            /* ... */\n        }\n      }\n\n配置检查：\n\n使用下面的**忽略非 public 类** 选项可以忽略非 public 类中的 `public` 构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstructorNotProtectedInAbstractClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparableImplementedButEqualsNotOverridden",
                "shortDescription": {
                  "text": "已实现 'Comparable'，但 'equals()' 未被重写"
                },
                "fullDescription": {
                  "text": "报告实现 'java.lang.Comparable' 但不重写 'equals()' 的类。 如果未重写 'equals()'，'equals()' 实现与 'compareTo()' 实现将不一致。 如果将这种类的对象添加到 'java.util.SortedSet' 等集合，该集合将违反根据 'equals()' 定义的 'java.util.Set' 的约定。 示例： 'class Length implements Comparable<Length> {\n    private int cm = 0;\n\n    @Override\n    public int compareTo(@NotNull Length o) {\n      if (cm == o.cm) return 0;\n      return cm < o.cm ? -1 : 1;\n    }\n  }' 在应用快速修复后： 'class Length implements Comparable<Length> {\n    private int cm = 0;\n\n    @Override\n    public int compareTo(@NotNull Length o) {\n      if (cm == o.cm) return 0;\n      return cm < o.cm ? -1 : 1;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      return o instanceof Length && compareTo((Length) o) == 0;\n    }\n  }'",
                  "markdown": "报告实现 `java.lang.Comparable` 但不重写 `equals()` 的类。\n\n\n如果未重写 `equals()`，`equals()` 实现与 `compareTo()` 实现将不一致。 如果将这种类的对象添加到 `java.util.SortedSet` 等集合，该集合将违反根据 `equals()` 定义的 `java.util.Set` 的约定。\n\n**示例：**\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n          return o instanceof Length && compareTo((Length) o) == 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparableImplementedButEqualsNotOverridden",
                    "cweIds": [
                      697
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MapReplaceableByEnumMap",
                "shortDescription": {
                  "text": "'Map' 可被替换为 'EnumMap'"
                },
                "fullDescription": {
                  "text": "报告键类型为枚举类的 'java.util.Map' 对象的实例化。 此类 'java.util.Map' 对象可以替换为 'java.util.EnumMap' 对象。 'java.util.EnumMap' 实现可以更加高效，因为底层数据结构是简单的数组。 示例： 'Map<MyEnum, String> myEnums = new HashMap<>();' 在应用快速修复后： 'Map<MyEnum, String> myEnums = new EnumMap<>(MyEnum.class);'",
                  "markdown": "报告键类型为枚举类的 `java.util.Map` 对象的实例化。 此类 `java.util.Map` 对象可以替换为 `java.util.EnumMap` 对象。\n\n\n`java.util.EnumMap` 实现可以更加高效，因为底层数据结构是简单的数组。\n\n**示例：**\n\n\n      Map<MyEnum, String> myEnums = new HashMap<>();\n\n在应用快速修复后：\n\n\n      Map<MyEnum, String> myEnums = new EnumMap<>(MyEnum.class);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MapReplaceableByEnumMap",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnNull",
                "shortDescription": {
                  "text": "返回 'null'"
                },
                "fullDescription": {
                  "text": "报告返回值为 'null' 的 'return' 语句。 虽然偶尔有用，但此结构可能导致代码因更容易出现 'NullPointerException' 而失败。 如果方法设计为返回 'null'，建议使用 '@Nullable' 注解来标记 - 此类方法将被此检查忽略。 示例： 'class Person {\n    public String getName () {\n      return null;\n    }\n  }' 在应用快速修复后： 'class Person {\n    @Nullable\n    public String getName () {\n      return null;\n    }\n  }' 如果返回类型为 'java.util.Optional'，建议使用另一个快速修复将 'null' 转换为 'Optional.empty()'。 使用以下选项配置检查： 是否忽略 'private' 方法。 这也将忽略从匿名类和 lambda 返回的 'null'。 应报告数组返回的 'null' 值、集合对象返回的值、普通对象返回的值还是三者的组合。 总是报告返回类型为 'java.util.Optional' 的方法中返回的 'null'。 点击配置注解以指定哪些注解应视为 'nullable'。",
                  "markdown": "报告返回值为 `null` 的 `return` 语句。 虽然偶尔有用，但此结构可能导致代码因更容易出现 `NullPointerException` 而失败。\n\n\n如果方法设计为返回 `null`，建议使用 `@Nullable` 注解来标记 - 此类方法将被此检查忽略。\n\n**示例：**\n\n\n      class Person {\n        public String getName () {\n          return null;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Person {\n        @Nullable\n        public String getName () {\n          return null;\n        }\n      }\n\n\n如果返回类型为 `java.util.Optional`，建议使用另一个快速修复将 `null` 转换为 `Optional.empty()`。\n\n\n使用以下选项配置检查：\n\n* 是否忽略 `private` 方法。 这也将忽略从匿名类和 lambda 返回的 `null`。\n* 应报告数组返回的 `null` 值、集合对象返回的值、普通对象返回的值还是三者的组合。 总是报告返回类型为 `java.util.Optional` 的方法中返回的 `null`。\n* 点击**配置注解**以指定哪些注解应视为 'nullable'。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnOfNull",
                    "cweIds": [
                      252,
                      476
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug/为 null 性问题",
                      "index": 141,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoggingStringTemplateAsArgument",
                "shortDescription": {
                  "text": "字符串模板作为日志记录调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作 SLF4J 和 Log4j 2 日志记录方法的实参的字符串模板。 方法 'org.apache.logging.log4j.Logger.log()' 及其重载仅支持所有日志级别选项。 即使在没有记录日志消息的情况下，也会在运行时评估字符串模板；这可能会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。 示例（针对 Kotlin）： 'val variable1 = getVariable()\n      logger.info(\"variable1: $variable1\")' 在应用快速修复之后（针对 Kotlin）： 'val variable1 = getVariable()\n      logger.info(\"variable1: {}\", variable1)' 请注意，建议的替换可能不等同于原始代码，例如，当字符串模板包含方法调用或赋值表达式时。 使用警告对象列表可以忽略某些更高的日志记录级别。 可以始终启用更高的日志记录级别，并且将始终对实参求值。 使用当仅包含具有基元类型的表达式、其包装器或字符串时不发出警告选项可以忽略仅包含具有基元类型、其包装器或字符串的表达式的字符串模板。 例如，它可能有助于防止加载延迟集合。 请注意，在运行时即使只使用具有基元类型、其包装器或字符串的表达式创建字符串，也会对性能产生负面影响。 2023.1 最新变化",
                  "markdown": "报告用作 **SLF4J** 和 **Log4j 2** 日志记录方法的实参的字符串模板。 方法 `org.apache.logging.log4j.Logger.log()` 及其重载仅支持**所有日志级别** 选项。 即使在没有记录日志消息的情况下，也会在运行时评估字符串模板；这可能会对性能产生负面影响。 建议改用形参化日志消息，禁用日志记录时不会对其进行评估。\n\n**示例（针对 Kotlin）：**\n\n\n          val variable1 = getVariable()\n          logger.info(\"variable1: $variable1\")\n\n**在应用快速修复之后（针对 Kotlin）：**\n\n\n          val variable1 = getVariable()\n          logger.info(\"variable1: {}\", variable1)\n\n\n请注意，建议的替换可能不等同于原始代码，例如，当字符串模板包含方法调用或赋值表达式时。\n\n* 使用**警告对象**列表可以忽略某些更高的日志记录级别。 可以始终启用更高的日志记录级别，并且将始终对实参求值。\n* 使用**当仅包含具有基元类型的表达式、其包装器或字符串时不发出警告**选项可以忽略仅包含具有基元类型、其包装器或字符串的表达式的字符串模板。 例如，它可能有助于防止加载延迟集合。 请注意，在运行时即使只使用具有基元类型、其包装器或字符串的表达式创建字符串，也会对性能产生负面影响。\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoggingStringTemplateAsArgument",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/日志记录",
                      "index": 40,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnpredictableBigDecimalConstructorCall",
                "shortDescription": {
                  "text": "不可预知的 'BigDecimal' 构造函数调用"
                },
                "fullDescription": {
                  "text": "报告对接受 'double' 值的 'BigDecimal' 构造函数的调用。 这些构造函数生成正好等于提供的 'double' 值的 'BigDecimal'。 但是，由于 double 是以 IEEE 754 64 位双精度二进制浮点格式进行编码，确切值可能出乎意料。 例如，'new BigDecimal(0.1)' 会生成一个 'BigDecimal' 对象。 它的值为 '0.1000000000000000055511151231257827021181583404541015625'，这是最接近 0.1 的数字，可以表示为 double。 要获取存储的值与源代码中编写的值相同的 'BigDecimal'，请使用 'new BigDecimal(\"0.1\")' 或 'BigDecimal.valueOf(0.1)'。 示例： 'class Constructor {\n    void foo() {\n      new BigDecimal(0.1);\n    }\n  }' 在应用快速修复后： 'class Constructor {\n    void foo() {\n      new BigDecimal(\"0.1\");\n    }\n  }'",
                  "markdown": "报告对接受 `double` 值的 `BigDecimal` 构造函数的调用。 这些构造函数生成正好等于提供的 `double` 值的 `BigDecimal`。 但是，由于 double 是以 IEEE 754 64 位双精度二进制浮点格式进行编码，确切值可能出乎意料。\n\n例如，`new BigDecimal(0.1)` 会生成一个 `BigDecimal` 对象。 它的值为 `0.1000000000000000055511151231257827021181583404541015625`，这是最接近 0.1 的数字，可以表示为 double。\n要获取存储的值与源代码中编写的值相同的 `BigDecimal`，请使用 `new BigDecimal(\"0.1\")` 或 `BigDecimal.valueOf(0.1)`。\n\n**示例：**\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(0.1);\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(\"0.1\");\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnpredictableBigDecimalConstructorCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IntegerDivisionInFloatingPointContext",
                "shortDescription": {
                  "text": "浮点上下文中的整数除法"
                },
                "fullDescription": {
                  "text": "报告结果用作浮点数时的整数除法。 此类除法通常表明有错误，并且由于在整数除法中出现截断，可能会产生意想不到的结果。 示例： 'float x = 3.0F + 3 * 2 / 5;' 在应用快速修复后： 'float x = 3.0F + ((float) (3 * 2)) /5;'",
                  "markdown": "报告结果用作浮点数时的整数除法。 此类除法通常表明有错误，并且由于在整数除法中出现截断，可能会产生意想不到的结果。\n\n**示例：**\n\n\n      float x = 3.0F + 3 * 2 / 5;\n\n在应用快速修复后：\n\n\n      float x = 3.0F + ((float) (3 * 2)) /5;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IntegerDivisionInFloatingPointContext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssertWithoutMessage",
                "shortDescription": {
                  "text": "断言上缺少消息"
                },
                "fullDescription": {
                  "text": "报告对没有错误消息字符串实参的 'assertXXX()' 或 'fail()' 的调用。 有关断言失败的错误消息可能有助于澄清测试用例的意图。 示例： 'assertTrue(checkValid());' 在应用快速修复后： 'assertTrue(checkValid(), \"|\");' 消息实参根据所使用的断言框架添加到现有实参前面或后面。",
                  "markdown": "报告对没有错误消息字符串实参的 `assertXXX()` 或 `fail()` 的调用。 有关断言失败的错误消息可能有助于澄清测试用例的意图。\n\n**示例：**\n\n\n      assertTrue(checkValid());\n\n在应用快速修复后：\n\n    assertTrue(checkValid(), \"|\");\n\n\n消息实参根据所使用的断言框架添加到现有实参前面或后面。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssertWithoutMessage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/测试框架",
                      "index": 98,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalBreakInInfiniteLoop",
                "shortDescription": {
                  "text": "循环内条件中断"
                },
                "fullDescription": {
                  "text": "报告在循环开始或结束处的条件中断，并建议改为添加循环条件来缩短代码。 示例： 'while (true) {\n    if (i  == 23) break;\n    i++;\n  }' 在应用快速修复后： 'while (i != 23) {\n    i++;\n  }'",
                  "markdown": "报告在循环开始或结束处的条件中断，并建议改为添加循环条件来缩短代码。\n\n示例：\n\n\n      while (true) {\n        if (i  == 23) break;\n        i++;\n      }\n\n在应用快速修复后：\n\n\n      while (i != 23) {\n        i++;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalBreakInInfiniteLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedInnerClassAccess",
                "shortDescription": {
                  "text": "非限定内部类访问"
                },
                "fullDescription": {
                  "text": "报告对未使用封闭类名称限定的内部类的引用。 示例： 'import foo.Foo.Bar;\n\n  class Foo {\n    class Bar {}\n  }\n\n  class Baz {\n    void f(Bar bar) {}\n  }' 在应用快速修复后： 'class Foo {\n    class Bar {}\n  }\n\n  class Baz {\n    void f(Foo.Bar bar) {}\n  }' 使用检查设置可以忽略对同一类中的内部类的引用，因此这些类不需要导入。",
                  "markdown": "报告对未使用封闭类名称限定的内部类的引用。\n\n**示例：**\n\n\n      import foo.Foo.Bar;\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Bar bar) {}\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Foo.Bar bar) {}\n      }\n\n\n使用检查设置可以忽略对同一类中的内部类的引用，因此这些类不需要导入。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedInnerClassAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantClassCall",
                "shortDescription": {
                  "text": "冗余的 'isInstance()' 或 'cast()' 调用"
                },
                "fullDescription": {
                  "text": "报告 'java.lang.Class' 方法的冗余调用。 例如，'Xyz.class.isInstance(object)' 可以替换为 'object instanceof Xyz'。 首选 instanceof 检查：尽管性能与这些方法可能并无本质区别，但它们更好地指示了静态检查。 2018.2 最新变化",
                  "markdown": "报告 `java.lang.Class` 方法的冗余调用。\n\n例如，`Xyz.class.isInstance(object)` 可以替换为 `object instanceof Xyz`。\n首选 instanceof 检查：尽管性能与这些方法可能并无本质区别，但它们更好地指示了静态检查。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantClassCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryStringEscape",
                "shortDescription": {
                  "text": "不必要的转义字符"
                },
                "fullDescription": {
                  "text": "报告 'String' 和 'char' 文字（可选）中不必要的转义字符。 不会报告转义的制表符字符 '\\t'，因为制表符字符不可见。 示例： 'String s = \"\\'Scare\\' quotes\";\n  String t = \"\"\"\n    All you need is\\n\\tLove\\n\"\"\";' 在应用快速修复后： 'String s = \"'Scare' quotes\";\n  String t = \"\"\"\n    All you need is\n    \\tLove\n  \"\"\";' 2019.3 最新变化",
                  "markdown": "报告 `String` 和 `char` 文字（可选）中不必要的转义字符。\n\n不会报告转义的制表符字符 `\\t`，因为制表符字符不可见。\n\n示例：\n\n\n      String s = \"\\'Scare\\' quotes\";\n      String t = \"\"\"\n        All you need is\\n\\tLove\\n\"\"\";\n\n在应用快速修复后：\n\n\n      String s = \"'Scare' quotes\";\n      String t = \"\"\"\n        All you need is\n        \\tLove\n      \"\"\";\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryStringEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldCanBeLocal",
                "shortDescription": {
                  "text": "可以为本地字段"
                },
                "fullDescription": {
                  "text": "报告可以用局部变量替换的冗余类字段。 如果一个字段的所有局部用法都紧跟对该字段的赋值，则可以删除该字段，并且可以将其用法替换为局部变量。",
                  "markdown": "报告可以用局部变量替换的冗余类字段。\n\n如果一个字段的所有局部用法都紧跟对该字段的赋值，则可以删除该字段，并且可以将其用法替换为局部变量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldCanBeLocal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UrlHashCode",
                "shortDescription": {
                  "text": "在 'URL' 对象上调用 'equals()' 或 'hashCode()'"
                },
                "fullDescription": {
                  "text": "报告在 'java.net.URL' 对象上的 'hashCode()' 和 'equals()' 调用，以及将 'URL' 对象添加到映射和集合的调用。 'URL' 的 'equals()' 和 'hashCode()' 方法可以执行 DNS 查找来解析主机名。 这可能会导致重大延迟，具体取决于网络和 DNS 服务器的可用性和速度。 使用 'java.net.URI' 代替 'java.net.URL' 将避免 DNS 查找。 示例： 'boolean urlEquals(URL url1, URL url2) {\n      return url1.equals(url2);\n  }'",
                  "markdown": "报告在 `java.net.URL` 对象上的 `hashCode()` 和 `equals()` 调用，以及将 `URL` 对象添加到映射和集合的调用。\n\n\n`URL` 的 `equals()` 和 `hashCode()` 方法可以执行 DNS 查找来解析主机名。\n这可能会导致重大延迟，具体取决于网络和 DNS 服务器的可用性和速度。\n使用 `java.net.URI` 代替 `java.net.URL` 将避免 DNS 查找。\n\n**示例：**\n\n\n      boolean urlEquals(URL url1, URL url2) {\n          return url1.equals(url2);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UrlHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithIdenticalBranches",
                "shortDescription": {
                  "text": "'if' 语句的分支相同"
                },
                "fullDescription": {
                  "text": "报告可以从分支中提取通用部分的 'if' 语句。 这些通用部分独立于条件并使 'if' 语句更难理解。 示例： 'if (x > 12) {\n    doSomethingBefore();\n    doSomethingDifferent1();\n    doSomethingAfter();\n  } else {\n    doSomethingBefore();\n    doSomethingDifferent2();\n    doSomethingAfter();\n  }' 在应用快速修复后： 'doSomethingBefore();\n  if (x > 12) {\n    doSomethingDifferent1();\n  } else {\n    doSomethingDifferent2();\n  }\n  doSomethingAfter();' 这是 2018.1 更新的功能",
                  "markdown": "报告可以从分支中提取通用部分的 `if` 语句。\n\n这些通用部分独立于条件并使 `if` 语句更难理解。\n\n示例：\n\n\n      if (x > 12) {\n        doSomethingBefore();\n        doSomethingDifferent1();\n        doSomethingAfter();\n      } else {\n        doSomethingBefore();\n        doSomethingDifferent2();\n        doSomethingAfter();\n      }\n\n在应用快速修复后：\n\n\n      doSomethingBefore();\n      if (x > 12) {\n        doSomethingDifferent1();\n      } else {\n        doSomethingDifferent2();\n      }\n      doSomethingAfter();\n\n这是 2018.1 更新的功能"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IfStatementWithIdenticalBranches",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InterfaceWithOnlyOneDirectInheritor",
                "shortDescription": {
                  "text": "只有一个直接继承者的接口"
                },
                "fullDescription": {
                  "text": "报告仅具有一个直接继承者的接口。 虽然此类接口可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将接口与其继承者合并。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。",
                  "markdown": "报告仅具有一个直接继承者的接口。 虽然此类接口可能会在内存受限或带宽受限的环境中提供令人钦佩的设计清晰度，但它们不必要地增加了应用程序的总占用空间。 请考虑将接口与其继承者合并。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InterfaceWithOnlyOneDirectInheritor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofChain",
                "shortDescription": {
                  "text": "'instanceof' 检查链"
                },
                "fullDescription": {
                  "text": "报告所有语句条件均为 'instanceof' 表达式或类等式表达式（例如与 'String.class' 比较）的 'if'-'else' 语句的任何链。 此类结构通常表明面向对象的设计失败，面向对象的设计要求此类基于类型的调度应通过多态方法调用而不是类型测试的显式链来完成。 示例： 'double getArea(Shape shape) {\n    // 警告：抽象失败。\n    // 最好在 shape 接口中\n    // 声明 getArea() 抽象方法，\n    // 并在每个继承者中实现。\n    if (shape instanceof Point) {\n      return 0;\n    }\n    if (shape instanceof Circle) {\n      return Math.PI *\n        Math.pow(((Circle) shape).radius(), 2);\n    }\n    if (shape instanceof Rectangle) {\n      return ((Rectangle) shape).width() *\n        ((Rectangle) shape).height();\n    }\n    throw new IllegalArgumentException();\n  }' 使用下面的复选框可忽略库类中的 'instanceof' 表达式。",
                  "markdown": "报告所有语句条件均为 `instanceof` 表达式或类等式表达式（例如与 `String.class` 比较）的 `if`-`else` 语句的任何链。 此类结构通常表明面向对象的设计失败，面向对象的设计要求此类基于类型的调度应通过多态方法调用而不是类型测试的显式链来完成。\n\n示例：\n\n\n      double getArea(Shape shape) {\n        // 警告：抽象失败。\n        // 最好在 shape 接口中\n        // 声明 getArea() 抽象方法，\n        // 并在每个继承者中实现。\n        if (shape instanceof Point) {\n          return 0;\n        }\n        if (shape instanceof Circle) {\n          return Math.PI *\n            Math.pow(((Circle) shape).radius(), 2);\n        }\n        if (shape instanceof Rectangle) {\n          return ((Rectangle) shape).width() *\n            ((Rectangle) shape).height();\n        }\n        throw new IllegalArgumentException();\n      }\n\n\n使用下面的复选框可忽略库类中的 `instanceof` 表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainOfInstanceofChecks",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BlockMarkerComments",
                "shortDescription": {
                  "text": "块标记注释"
                },
                "fullDescription": {
                  "text": "报告用作代码块标记的注释。 该快速修复会移除此类注释。 示例： 'while (i < 10) {\n    i++;\n  } // end while' 在应用快速修复后： 'while (i < 10) {\n    i++;\n  }'",
                  "markdown": "报告用作代码块标记的注释。 该快速修复会移除此类注释。\n\n示例：\n\n\n      while (i < 10) {\n        i++;\n      } // end while\n\n在应用快速修复后：\n\n\n      while (i < 10) {\n        i++;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BlockMarkerComments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerializableHasSerializationMethods",
                "shortDescription": {
                  "text": "不带 'readObject()' 和 'writeObject()' 的可序列化类"
                },
                "fullDescription": {
                  "text": "报告不实现 'readObject()' 和 'writeObject()' 方法的 'Serializable' 类。 如果没有实现 'readObject()' 和 'writeObject()' 方法，将使用默认的序列化算法，在许多环境中，这对于性能和兼容性而言或许是次优选择。 使用以下选项配置检查： 列出此检查不应报告其继承者的类。 这适用于从超类继承 'Serializable' 但不用于序列化的类。 是否忽略没有非 static 字段的 'Serializable' 类。 是否忽略 'Serializable' 匿名类。",
                  "markdown": "报告不实现 `readObject()` 和 `writeObject()` 方法的 `Serializable` 类。\n\n\n如果没有实现 `readObject()` 和 `writeObject()` 方法，将使用默认的序列化算法，在许多环境中，这对于性能和兼容性而言或许是次优选择。\n\n\n使用以下选项配置检查：\n\n* 列出此检查不应报告其继承者的类。 这适用于从超类继承 `Serializable` 但不用于序列化的类。\n* 是否忽略没有非 static 字段的 `Serializable` 类。\n* 是否忽略 `Serializable` 匿名类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SerializableHasSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IdempotentLoopBody",
                "shortDescription": {
                  "text": "幂等循环体"
                },
                "fullDescription": {
                  "text": "报告除了第一次迭代中产生的副作用外，在第二次和后续迭代中不产生其他副作用的循环，这可能表示编程错误。 此类循环可能只迭代零次、一次或无限次。 如果不存在无限循环的情况，则可以将其替换为 'if' 语句。 否则，程序可能会卡住。 示例： 'public void foo(String baseName, String names) {\n        int suffix = 1;\n        String name = baseName;\n        while (names.contains(name)) {\n            // 错误：suffix 未更新，导致循环体幂等\n            name = baseName + suffix;\n        }\n    }' 2018.1 最新变化",
                  "markdown": "报告除了第一次迭代中产生的副作用外，在第二次和后续迭代中不产生其他副作用的循环，这可能表示编程错误。\n\n此类循环可能只迭代零次、一次或无限次。\n如果不存在无限循环的情况，则可以将其替换为 ` if ` 语句。\n否则，程序可能会卡住。\n\n示例：\n\n\n        public void foo(String baseName, String names) {\n            int suffix = 1;\n            String name = baseName;\n            while (names.contains(name)) {\n                // 错误：suffix 未更新，导致循环体幂等\n                name = baseName + suffix;\n            }\n        }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IdempotentLoopBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantImplements",
                "shortDescription": {
                  "text": "冗余接口声明"
                },
                "fullDescription": {
                  "text": "报告类的 'implements' 列表或接口的 'extends' 列表中已经由超类实现或由超接口扩展的接口。 此类声明不必要，并且可以安全移除。 示例： 'class X implements One, Two {\n  }\n  interface One {}\n  interface Two extends One {}' 在应用快速修复后： 'class X implements Two {\n  }\n  interface One {}\n  interface Two extends One {}' 使用该选项可以不报告 'extends' 或 'implements' 列表中的 'Serializable' 或 'Externalizable'。",
                  "markdown": "报告类的 `implements` 列表或接口的 `extends` 列表中已经由超类实现或由超接口扩展的接口。 此类声明不必要，并且可以安全移除。\n\n**示例：**\n\n\n      class X implements One, Two {\n      }\n      interface One {}\n      interface Two extends One {}\n\n在应用快速修复后：\n\n\n      class X implements Two {\n      }\n      interface One {}\n      interface Two extends One {}\n\n\n使用该选项可以不报告 `extends` 或 `implements` 列表中的 `Serializable` 或 `Externalizable`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantInterfaceDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FrequentlyUsedInheritorInspection",
                "shortDescription": {
                  "text": "类可以扩展常用的基类"
                },
                "fullDescription": {
                  "text": "报告可以替换为更具体的常用类或接口的实现或扩展的类或接口。 为进行此检查，超类需位于项目源文件中，并且项目需要使用 IntelliJ IDEA 构建系统。 示例： 'class MyInheritor implements A {} // B 针对 A 引用提供建议\n\n  interface A {}\n\n  abstract class B implements A {}\n\n  abstract class C1 extends B {}\n  abstract class C2 extends B {}\n  abstract class C3 extends B {}\n  abstract class C4 extends B {}\n  abstract class C5 extends B {}' 默认情况下，此检查不会在编辑器中高亮显示问题，而是只提供快速修复。 2017.2 最新变化",
                  "markdown": "报告可以替换为更具体的常用类或接口的实现或扩展的类或接口。\n\n为进行此检查，超类需位于项目源文件中，并且项目需要使用 IntelliJ IDEA 构建系统。\n\n**示例：**\n\n\n      class MyInheritor implements A {} // B 针对 A 引用提供建议\n\n      interface A {}\n\n      abstract class B implements A {}\n\n      abstract class C1 extends B {}\n      abstract class C2 extends B {}\n      abstract class C3 extends B {}\n      abstract class C4 extends B {}\n      abstract class C5 extends B {}\n\n默认情况下，此检查不会在编辑器中高亮显示问题，而是只提供快速修复。\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FrequentlyUsedInheritorInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldNamingConvention",
                "shortDescription": {
                  "text": "字段命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不遵循指定正则表达式模式的字段。 示例：如果对常量启用了检查，并且字段名称的最小指定长度为 5（默认值），由于以下常量的名称长度为 3，即小于 5，因此将生成警告：'public static final int MAX = 42;'。 只能在编辑器中使用重命名此类字段的快速修复。 配置检查： 使用选项部分中的列表来指定应检查哪些字段。 取消选中要为之跳过检查的字段对应的复选框。 对于每种字段类型，请使用所提供的输入字段指定字段名称的最小长度、最大长度和正则表达式。 在长度字段中指定 0 可跳过相应检查。 正则表达式应以标准 'java.util.regex' 格式指定。",
                  "markdown": "报告名称太短、太长或不遵循指定正则表达式模式的字段。\n\n**示例** ：如果对常量启用了检查，并且字段名称的最小指定长度为 5（默认值），由于以下常量的名称长度为 3，即小于 5，因此将生成警告：`public static final int MAX = 42;`。\n\n只能在编辑器中使用重命名此类字段的快速修复。\n\n配置检查：\n\n使用**选项**部分中的列表来指定应检查哪些字段。 取消选中要为之跳过检查的字段对应的复选框。\n\n对于每种字段类型，请使用所提供的输入字段指定字段名称的最小长度、最大长度和正则表达式。\n在长度字段中指定 **0** 可跳过相应检查。\n\n正则表达式应以标准 `java.util.regex` 格式指定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定",
                      "index": 60,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassNamePrefixedWithPackageName",
                "shortDescription": {
                  "text": "使用软件包名称作为前缀的类名"
                },
                "fullDescription": {
                  "text": "报告名称前缀为其软件包名称并忽略大写差异的类。 虽然偶尔使用此类名称是合理的，但通常是由于欠佳的命名方案而使用，可能冗余并且令人生厌。 示例： 'package byteCode;\n  class ByteCodeAnalyzer {}' 只能在编辑器中采用快速修复来重命名这种类。",
                  "markdown": "报告名称前缀为其软件包名称并忽略大写差异的类。\n\n虽然偶尔使用此类名称是合理的，但通常是由于欠佳的命名方案而使用，可能冗余并且令人生厌。\n\n**示例：**\n\n\n      package byteCode;\n      class ByteCodeAnalyzer {}\n\n只能在编辑器中采用快速修复来重命名这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassNamePrefixedWithPackageName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/类",
                      "index": 61,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantConditionalExpression",
                "shortDescription": {
                  "text": "常量条件表达式"
                },
                "fullDescription": {
                  "text": "报告条件为 'true' 或 'false' 常量的条件表达式。 这些表达式有时是自动重构的结果，并且可以被简化。 示例： 'return true ? \"Yes\" : \"No\";' 在应用快速修复后： 'return \"Yes\";'",
                  "markdown": "报告条件为 `true` 或 `false` 常量的条件表达式。 这些表达式有时是自动重构的结果，并且可以被简化。\n\n示例：\n\n\n      return true ? \"Yes\" : \"No\";\n\n在应用快速修复后：\n\n\n      return \"Yes\";\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantConditionalExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SameParameterValue",
                "shortDescription": {
                  "text": "方法形参始终具有相同的值"
                },
                "fullDescription": {
                  "text": "报告始终具有相同常量值的方法形参。 示例： 'static void printPoint(int x, int y) { // x 始终为 0\n    System.out.println(x + \", \" + y);\n  }\n\n  public static void main(String[] args) {\n    printPoint(0, 1);\n    printPoint(0, 2);\n  }' 该快速修复会内联常量值。 这可能会简化方法实现。 在以下情况下，使用当无法提供快速修复时忽略选项来禁止检查： 形参在方法内部被修改 传递的形参值是对不可访问字段的引用（仅限 Java） 形参为 vararg（仅限 Java） 使用最大方法可见性选项可以控制要报告的方法的最大可见性。 使用要报告形参的最小方法用法计数字段可以指定具有相同形参值的最小方法用法数。",
                  "markdown": "报告始终具有相同常量值的方法形参。\n\n示例：\n\n\n      static void printPoint(int x, int y) { // x 始终为 0\n        System.out.println(x + \", \" + y);\n      }\n\n      public static void main(String[] args) {\n        printPoint(0, 1);\n        printPoint(0, 2);\n      }\n\n该快速修复会内联常量值。 这可能会简化方法实现。\n\n\n在以下情况下，使用**当无法提供快速修复时忽略**选项来禁止检查：\n\n* 形参在方法内部被修改\n* 传递的形参值是对不可访问字段的引用（仅限 Java）\n* 形参为 vararg（仅限 Java）\n\n\n使用**最大方法可见性**选项可以控制要报告的方法的最大可见性。\n\n\n使用**要报告形参的最小方法用法计数**字段可以指定具有相同形参值的最小方法用法数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SameParameterValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CatchMayIgnoreException",
                "shortDescription": {
                  "text": "catch 块可能会忽略异常"
                },
                "fullDescription": {
                  "text": "报告空的或可能忽略异常的 'catch' 块。 虽然偶尔是有意为之，但空的 'catch' 块可能导致调试复杂化。 此外，忽略 'catch' 形参可能是错误的。 最后，静态代码分析器会报告是否检测到 'catch' 块可能无提示地忽略重要的 VM 异常，如 'NullPointerException'。 忽略此类异常（不记录或重新抛出）可能会隐藏错误。 该检查不会报告任何命名为 'ignore' 或 'ignored' 的 'catch' 形参。 相反，它将对真正在使用的命名为 'ignore' 或 'ignored' 的 'catch' 形参发出警告。 此外，该检查不会报告命名为 'expected' 或 'ok' 的测试源中的 'catch' 形参。 您可以使用快速修复将异常名称更改为 'ignored'。 对于空的 catch 块，建议使用其他快速修复来生成 catch 主体。 您可以在设置 | 编辑器 | 文件和代码模板中的“代码”标签页上修改 \"Catch Statement Body\" 模板。 示例： 'try {\n    throwingMethod();\n  } catch (IOException ex) {\n\n  }' 在应用快速修复后： 'try {\n    System.out.println(System.in.read());\n  } catch (IOException ignored) {\n\n  }' 配置检查： 使用当 'catch' 块包含注释时不发出警告选项可以忽略包含注释的 'catch' 块。 使用当 'catch' 块不为空时不发出警告选项可以忽略其中包含语句或注释但又不使用变量本身的 'catch' 块。 使用当名称为 'ignore(d)' 的异常实际上未被忽略时不发出警告选项可以忽略使用中名称为 'ignored' 的变量。 2018.1 最新变化",
                  "markdown": "报告空的或可能忽略异常的 `catch` 块。\n\n虽然偶尔是有意为之，但空的 `catch` 块可能导致调试复杂化。\n此外，忽略 `catch` 形参可能是错误的。\n最后，静态代码分析器会报告是否检测到 `catch` 块可能无提示地忽略重要的 VM 异常，如 `NullPointerException`。 忽略此类异常（不记录或重新抛出）可能会隐藏错误。\n\n\n该检查不会报告任何命名为 `ignore` 或 `ignored` 的 `catch` 形参。\n相反，它将对真正在使用的命名为 `ignore` 或 `ignored` 的 `catch` 形参发出警告。\n此外，该检查不会报告命名为 `expected` 或 `ok` 的测试源中的 `catch` 形参。\n\n\n您可以使用快速修复将异常名称更改为 `ignored`。\n对于空的 **catch** 块，建议使用其他快速修复来生成 **catch** 主体。\n您可以在[设置 \\| 编辑器 \\| 文件和代码模板](settings://fileTemplates)中的\"代码\"标签页上修改 \"Catch Statement Body\" 模板。\n\n**示例：**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\n在应用快速修复后：\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\n配置检查：\n\n* 使用**当 'catch' 块包含注释时不发出警告** 选项可以忽略包含注释的 `catch` 块。\n* 使用**当 'catch' 块不为空时不发出警告** 选项可以忽略其中包含语句或注释但又不使用变量本身的 `catch` 块。\n* 使用**当名称为 'ignore(d)' 的异常实际上未被忽略时不发出警告** 选项可以忽略使用中名称为 `ignored` 的变量。\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CatchMayIgnoreException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithTooManyDependents",
                "shortDescription": {
                  "text": "依赖项过多的类"
                },
                "fullDescription": {
                  "text": "报告被过多其他类直接依赖的类。 对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。 仅报告顶级类。 使用下面的字段可指定类的最大允许依赖项数。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告被过多其他类直接依赖的类。\n\n对这种类的任何修改都可能需要更改许多其他类，这可能开销巨大。\n\n仅报告顶级类。\n\n使用下面的字段可指定类的最大允许依赖项数。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyDependents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/依赖性问题",
                      "index": 113,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrongPackageStatement",
                "shortDescription": {
                  "text": "错误的 package 语句"
                },
                "fullDescription": {
                  "text": "检测与项目目录结构不对应的 'package' 语句。 此外，如果不包含 'package' 语句的类不是直接位于源根目录中，则报告这种类。 虽然 Java 语言没有严格规定，但最好将软件包 'com.example.myapp' 中的类直接保存在源根下的 'com/example/myapp' 目录中。 如果不这样做，可能会导致代码读取器混淆，某些工具也无法正确工作。",
                  "markdown": "检测与项目目录结构不对应的 `package` 语句。 此外，如果不包含 `package` 语句的类不是直接位于源根目录中，则报告这种类。\n\n虽然 Java 语言没有严格规定，但最好将软件包 `com.example.myapp` 中的类直接保存在源根下的 `com/example/myapp` 目录中。 如果不这样做，可能会导致代码读取器混淆，某些工具也无法正确工作。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "WrongPackageStatement",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldNotUsedInToString",
                "shortDescription": {
                  "text": "字段未在 'toString()' 方法中使用"
                },
                "fullDescription": {
                  "text": "报告在类的 'toString()' 方法中未使用的字段。 帮助发现在 'toString()' 方法上次更新后添加的字段。 该快速修复会重新生成 'toString()' 方法。 在 生成 | toString() 对话框中，可以从此检查中排除字段。 如果在代码生成中启用 getter 选项，则此检查还将检查 getter 方法是否存在问题。 示例： 'public class Relevant {\n    private String name; // 未在 toString() 中使用\n    private int index;\n    private int length;\n\n    @Override\n    public String toString() {\n        return \"Relevant{\" + \"index=\" + index +\n          \", length=\" + length + '}';\n    }\n  }' 在应用快速修复后： 'public class Relevant {\n    private String name;\n    private int index;\n    private int length;\n\n    @Override\n    public String toString() {\n        return \"Relevant{\" + \"name='\" + name + '\\'' +\n          \", index=\" + index + \", length=\" + length + '}';\n    }\n  }'",
                  "markdown": "报告在类的 `toString()` 方法中未使用的字段。\n\n帮助发现在 `toString()` 方法上次更新后添加的字段。\n该快速修复会重新生成 `toString()` 方法。\n\n\n在 **生成 \\| toString()** 对话框中，可以从此检查中排除字段。\n如果*在代码生成中启用 getter* 选项，则此检查还将检查 getter 方法是否存在问题。\n\n示例：\n\n\n      public class Relevant {\n        private String name; // 未在 toString() 中使用\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"index=\" + index +\n              \", length=\" + length + '}';\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Relevant {\n        private String name;\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"name='\" + name + '\\'' +\n              \", index=\" + index + \", length=\" + length + '}';\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldNotUsedInToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/toString() 问题",
                      "index": 165,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CovariantEquals",
                "shortDescription": {
                  "text": "协变 'equals()'"
                },
                "fullDescription": {
                  "text": "如果包含类没有将 'java.lang.Object' 作为其实参类型的其他 'equals()' 重载，则报告采用 'java.lang.Object' 以外的实参类型的 'equals()' 方法。 'equals()' 的协变版本不会重写 'Object.equals(Object)' 方法。 它可能会在运行时导致意外行为。 例如，如果该类用于构造一个标准集合类，该集合类预期会重写 'Object.equals(Object)' 方法。 示例： 'class Foo {\n      public boolean equals(Foo foo) {  // 警告\n          return false;\n      }\n  }\n  class Bar {\n      public boolean equals(Bar bar) {  // 此处无警告\n          return false;\n      }\n      @Override\n      public boolean equals(Object obj) {\n          return false;\n      }\n  }'",
                  "markdown": "如果包含类没有将 `java.lang.Object` 作为其实参类型的其他 `equals()` 重载，则报告采用 `java.lang.Object` 以外的实参类型的 `equals()` 方法。\n\n\n`equals()` 的协变版本不会重写 `Object.equals(Object)` 方法。 它可能会在运行时导致意外行为。 例如，如果该类用于构造一个标准集合类，该集合类预期会重写 `Object.equals(Object)` 方法。\n\n**示例：**\n\n\n      class Foo {\n          public boolean equals(Foo foo) {  // 警告\n              return false;\n          }\n      }\n      class Bar {\n          public boolean equals(Bar bar) {  // 此处无警告\n              return false;\n          }\n          @Override\n          public boolean equals(Object obj) {\n              return false;\n          }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CovariantEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2Lambda",
                "shortDescription": {
                  "text": "匿名类型可被替换为 lambda"
                },
                "fullDescription": {
                  "text": "报告可以替换为 lambda 表达式的匿名类。 示例： 'new Thread(new Runnable() {\n    @Override\n    public void run() {\n      // 运行线程\n    }\n  });' 在应用快速修复后： 'new Thread(() -> {\n    // 运行线程\n  });' 请注意，如果将匿名类转换为无状态 lambda，则 Java 运行时可以在后续调用期间重用相同的 lambda 对象。 另一方面，当使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 'HashMap' 键时。 使用在接口未使用 @FunctionalInterface 注解时报告选项可忽略匿名类实现没有 '@FunctionalInterface' 注解的接口的情况。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为 lambda 表达式的匿名类。\n\n示例：\n\n\n      new Thread(new Runnable() {\n        @Override\n        public void run() {\n          // 运行线程\n        }\n      });\n\n在应用快速修复后：\n\n\n      new Thread(() -> {\n        // 运行线程\n      });\n\n\n请注意，如果将匿名类转换为无状态 lambda，则 Java 运行时可以在后续调用期间重用相同的 lambda 对象。 另一方面，当使用匿名类时，每次都会创建单独的对象。 因此，在极少数情况下，应用该快速修复可能会导致语义发生变化，例如，当匿名类实例用作 `HashMap` 键时。\n\n\n使用**在接口未使用 @FunctionalInterface 注解时报告** 选项可忽略匿名类实现没有 `@FunctionalInterface` 注解的接口的情况。\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2Lambda",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifiableIfStatement",
                "shortDescription": {
                  "text": "'if' 语句可被替换为条件或布尔表达式"
                },
                "fullDescription": {
                  "text": "报告可以替换为使用 '&&'、'||'、'=='、'!=' 或 '?:' 运算符的条件的 'if' 语句 。 结果通常更短，但并不总是更清晰，因此不建议在每种情况下都应用此修复程序。 示例： 'if (condition) return true; else return foo;' 在应用快速修复后： 'return condition || foo;' 配置检查： 当建议使用 '?:' 运算符时，请使用 不建议使用 '?:' 运算符 选项禁用警告。 在这种情况下，只会突出显示 '&&'、'||'、'==' 和 '!=' 建议。 快速修复仍将在编辑器中可用。 使用 忽略链式 'if' 语句 选项禁用 'if-else' 链的警告 快速修复仍将在编辑器中可用。 2018.2 最新变化",
                  "markdown": "报告可以替换为使用 `&&`、`||`、`==`、`!=` 或 `?:` 运算符的条件的 `if` 语句 。\n\n结果通常更短，但并不总是更清晰，因此不建议在每种情况下都应用此修复程序。\n\n示例：\n\n\n      if (condition) return true; else return foo;\n\n在应用快速修复后：\n\n\n      return condition || foo;\n\n配置检查：\n\n* 当建议使用 `?:` 运算符时，请使用 **不建议使用 '?:' 运算符** 选项禁用警告。 在这种情况下，只会突出显示 `&&`、`||`、`==` 和 `!=` 建议。 快速修复仍将在编辑器中可用。\n* 使用 **忽略链式 'if' 语句** 选项禁用 `if-else` 链的警告 快速修复仍将在编辑器中可用。\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SimplifiableIfStatement",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowCaughtLocally",
                "shortDescription": {
                  "text": "通过包含 'try' 语句捕获 'throw'"
                },
                "fullDescription": {
                  "text": "报告异常始终可以通过包含 'try' 语句捕获的 'throw' 语句。 使用 'throw' 语句作为 \"goto\" 来更改局部控制流会令人困惑并导致性能不佳。 示例： 'try {\n    if (!Files.isDirectory(PROJECTS)) {\n        throw new IllegalStateException(\"Directory not found.\"); // 警告：'throw' 被所包含的 'try' 语句捕获\n    }\n    ...\n  } catch (Exception e) {\n      LOG.error(\"run failed\");\n  }' 使用忽略重新抛出的异常选项可忽略重新抛出的异常。",
                  "markdown": "报告异常始终可以通过包含 `try` 语句捕获的 `throw` 语句。\n\n使用 `throw` 语句作为 \"goto\" 来更改局部控制流会令人困惑并导致性能不佳。\n\n**示例：**\n\n\n      try {\n        if (!Files.isDirectory(PROJECTS)) {\n            throw new IllegalStateException(\"Directory not found.\"); // 警告：'throw' 被所包含的 'try' 语句捕获\n        }\n        ...\n      } catch (Exception e) {\n          LOG.error(\"run failed\");\n      }\n\n使用**忽略重新抛出的异常**选项可忽略重新抛出的异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowCaughtLocally",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnValueBasedClass",
                "shortDescription": {
                  "text": "基于值的警告"
                },
                "fullDescription": {
                  "text": "报告尝试在基于值的类的实例上进行同步的情况，从 Java 16 开始，这些实例会生成编译时警告并引发运行时异常。 例如，'java.lang.Double' 用 'jdk.internal.ValueBased' 注解，因此以下代码会产生编译时警告： 'Double d = 20.0;\nsynchronized (d) { ... } // javac 警告' 2021.1 最新变化",
                  "markdown": "报告尝试在基于值的类的实例上进行同步的情况，从 Java 16 开始，这些实例会生成编译时警告并引发运行时异常。\n\n\n例如，`java.lang.Double` 用 `jdk.internal.ValueBased` 注解，因此以下代码会产生编译时警告：\n\n\n    Double d = 20.0;\n    synchronized (d) { ... } // javac 警告\n\n2021.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "synchronization",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/编译器问题",
                      "index": 128,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableWithSerialVersionUIDField",
                "shortDescription": {
                  "text": "具有 'serialVersionUID' 的不可序列化类"
                },
                "fullDescription": {
                  "text": "报告定义 'serialVersionUID' 字段的非 'Serializable' 类。 该上下文中的 'serialVersionUID' 字段通常表明有错误，因为该字段将被忽略，且该类将不会被序列化。 示例： 'public class IWantToSerializeThis {\n    private static final long serialVersionUID = 2669293150219020249L;\n  }'",
                  "markdown": "报告定义 `serialVersionUID` 字段的非 `Serializable` 类。 该上下文中的 `serialVersionUID` 字段通常表明有错误，因为该字段将被忽略，且该类将不会被序列化。\n\n**示例：**\n\n\n      public class IWantToSerializeThis {\n        private static final long serialVersionUID = 2669293150219020249L;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableClassWithSerialVersionUID",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementsWithoutDefault",
                "shortDescription": {
                  "text": "不带 'default' 分支的 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告不包含 'default' 标签的 'switch' 语句。 添加 'default' 标签可确保涵盖所有可能的场景，从而更容易对程序的当前状态作出假设。 请注意，默认情况下，如果用于枚举或 'sealed' 类的情况都被覆盖，则检查不会报告 'switch' 语句。 如果您想改变这种行为，请使用忽略详尽的 switch 语句选项。",
                  "markdown": "报告不包含 `default` 标签的 `switch` 语句。\n\n添加 `default` 标签可确保涵盖所有可能的场景，从而更容易对程序的当前状态作出假设。\n\n\n请注意，默认情况下，如果用于枚举或 `sealed` 类的情况都被覆盖，则检查不会报告 `switch` 语句。\n如果您想改变这种行为，请使用**忽略详尽的 switch 语句**选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithoutDefaultBranch",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncompatibleMask",
                "shortDescription": {
                  "text": "不兼容的按位掩码运算"
                },
                "fullDescription": {
                  "text": "报告确保评估为 'true' 或 'false' 的按位掩码表达式。 该检查将检查 '(var & constant1) == constant2' 或 '(var | constant1) == constant2' 形式的表达式，其中 'constant1' 和 'constant2' 是不兼容的位掩码常量。 示例： '// 不兼容的掩码：由于掩码以 00 结尾，\n  // 结果可能是 0x1200，但不是 0x1234\n  if ((mask & 0xFF00) == 0x1234) {...}'",
                  "markdown": "报告确保评估为 `true` 或 `false` 的按位掩码表达式。\n\n\n该检查将检查 `(var & constant1) == constant2` 或 `(var | constant1) == constant2` 形式的表达式，其中 `constant1` 和 `constant2` 是不兼容的位掩码常量。\n\n**示例：**\n\n      // 不兼容的掩码：由于掩码以 00 结尾，\n      // 结果可能是 0x1200，但不是 0x1234\n      if ((mask & 0xFF00) == 0x1234) {...}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncompatibleBitwiseMaskOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/按位运算问题",
                      "index": 162,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExplicitArgumentCanBeLambda",
                "shortDescription": {
                  "text": "显式实参可以是 lambda"
                },
                "fullDescription": {
                  "text": "报告接受非普通表达式的方法调用，这些方法调用可以替换为接受 lambda 的等效方法调用。 将表达式转换为 lambda 可确保不会评估方法中未使用的表达式。 例如，'optional.orElse(createDefaultValue())' 可以转换为 'optional.orElseGet(this::createDefaultValue)'。 2018.1 最新变化 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告接受非普通表达式的方法调用，这些方法调用可以替换为接受 lambda 的等效方法调用。\n\n\n将表达式转换为 lambda 可确保不会评估方法中未使用的表达式。 例如，`optional.orElse(createDefaultValue())` 可以转换为 `optional.orElseGet(this::createDefaultValue)`。\n\n2018.1 最新变化\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ExplicitArgumentCanBeLambda",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsCalledOnEnumConstant",
                "shortDescription": {
                  "text": "对枚举值调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告枚举常量上的 'equals()' 调用。 此类调用可以替换为同一性比较 ('==')，因为只有两个枚举常量具备相同的同一性时，它们才相等。 可以通过快速修复将该调用更改为比较。 示例： 'boolean foo(MyEnum value) {\n    return value.equals(MyEnum.FOO);\n  }' 在应用快速修复后： 'boolean foo(MyEnum value) {\n    return value == MyEnum.FOO;\n  }'",
                  "markdown": "报告枚举常量上的 `equals()` 调用。\n\n此类调用可以替换为同一性比较 (`==`)，因为只有两个枚举常量具备相同的同一性时，它们才相等。\n\n可以通过快速修复将该调用更改为比较。\n\n**示例：**\n\n\n      boolean foo(MyEnum value) {\n        return value.equals(MyEnum.FOO);\n      }\n\n在应用快速修复后：\n\n\n      boolean foo(MyEnum value) {\n        return value == MyEnum.FOO;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsCalledOnEnumConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HardcodedLineSeparators",
                "shortDescription": {
                  "text": "硬编码行分隔符"
                },
                "fullDescription": {
                  "text": "报告字符串文字、字符文字或文本块中使用的换行 ('\\n') 和回车 ('\\r') 字符转义序列。 这些字符通常用作行分隔符，如果它们被硬编码，可移植性可能会受到影响。 示例： 'String count = \"first\\nsecond\\rthird\";'",
                  "markdown": "报告字符串文字、字符文字或文本块中使用的换行 (`\\n`) 和回车 (`\\r`) 字符转义序列。 这些字符通常用作行分隔符，如果它们被硬编码，可移植性可能会受到影响。\n\n**示例：**\n\n\n      String count = \"first\\nsecond\\rthird\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HardcodedLineSeparator",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryConstantArrayCreationExpression",
                "shortDescription": {
                  "text": "常量数组创建中的冗余 'new' 表达式"
                },
                "fullDescription": {
                  "text": "报告可以替换为数组初始值设定项的常量新数组表达式。 数组初始值设定项可以省略类型，因为它已在赋值的左侧指定。 示例： 'int[] foo = new int[] {42};' 在应用快速修复后： 'int[] foo = {42};'",
                  "markdown": "报告可以替换为数组初始值设定项的常量新数组表达式。 数组初始值设定项可以省略类型，因为它已在赋值的左侧指定。\n\n**示例：**\n\n\n      int[] foo = new int[] {42};\n\n在应用快速修复后：\n\n\n      int[] foo = {42};\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryConstantArrayCreationExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LabeledStatement",
                "shortDescription": {
                  "text": "标记语句"
                },
                "fullDescription": {
                  "text": "报告可能导致重构和方法控制流复杂化的语句。 示例： 'label:\n  while (true) {\n      // 代码\n  }'",
                  "markdown": "报告可能导致重构和方法控制流复杂化的语句。\n\n示例：\n\n\n      label:\n      while (true) {\n          // 代码\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LabeledStatement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousNameCombination",
                "shortDescription": {
                  "text": "可疑的变量/形参名称组合"
                },
                "fullDescription": {
                  "text": "报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值和函数调用。 示例 1： 'int x = 0;\n  int y = x; // x 用作 y 坐标' 示例 2： 'int x = 0, y = 0;\n  // x 用作 y 坐标，y 用作 x 坐标\n  Rectangle rc = new Rectangle(y, x, 20, 20);' 配置检查： 使用名称组区域可以指定不应一起使用的名称：如果形参名称或赋值目标名称包含一个组中的字词，而赋值或传递的变量名称包含另一个组中的字词，就会报告错误。 使用忽略方法区域可以指定不应检查但名称可能存疑的方法。 例如，'Integer.compare()' 形参被命名为 'x' 和 'y'，但与坐标无关。",
                  "markdown": "报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值和函数调用。\n\n示例 1：\n\n\n      int x = 0;\n      int y = x; // x 用作 y 坐标\n      \n示例 2：\n\n\n      int x = 0, y = 0;\n      // x 用作 y 坐标，y 用作 x 坐标\n      Rectangle rc = new Rectangle(y, x, 20, 20);\n\n配置检查：\n\n使用**名称组**区域可以指定不应一起使用的名称：如果形参名称或赋值目标名称包含一个组中的字词，而赋值或传递的变量名称包含另一个组中的字词，就会报告错误。\n\n使用**忽略方法** 区域可以指定不应检查但名称可能存疑的方法。\n例如，`Integer.compare()` 形参被命名为 `x` 和 `y`，但与坐标无关。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousNameCombination",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ImplicitDefaultCharsetUsage",
                "shortDescription": {
                  "text": "隐式平台默认字符集"
                },
                "fullDescription": {
                  "text": "报告隐式使用平台默认字符集的方法和构造函数调用。 此类调用可能会在使用不同默认字符集的系统上产生不同的结果，并可能导致意外行为。 示例： 'void foo(byte[] bytes) {\n  String s = new String(bytes);\n}'\n 如果相应的重载方法可用，则可以采用指定显式 UTF-8 字符集的快速修复。 在应用快速修复后： 'void foo(byte[] bytes) {\n  String s = new String(bytes, StandardCharsets.UTF_8);\n}'",
                  "markdown": "报告隐式使用平台默认字符集的方法和构造函数调用。 此类调用可能会在使用不同默认字符集的系统上产生不同的结果，并可能导致意外行为。\n\n**示例：**\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes);\n    }\n\n如果相应的重载方法可用，则可以采用指定显式 UTF-8 字符集的快速修复。\n在应用快速修复后：\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes, StandardCharsets.UTF_8);\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ImplicitDefaultCharsetUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DesignForExtension",
                "shortDescription": {
                  "text": "为扩展设计"
                },
                "fullDescription": {
                  "text": "报告非 'static'、'private'、'final' 或 'abstract'，且其语句体不为空的方法。 使用避免此类方法的样式进行编码可以保护类的约定不会被它们的子类破坏。 这种样式的好处是子类不会因为忘记调用 super 方法而破坏超类的状态。 代价是子类的灵活性受到限制，特别是它们不能阻止超类中代码的执行。 使用该快速修复可以添加缺失的修饰符。 示例： 'class Foo {\n    public boolean equals(Object o) { return true; }\n  }' 在应用快速修复后： 'class Foo {\n    public final boolean equals(Object o) { return true; }\n  }' 此检查适用于将在安全环境中使用的代码，可能不适合限制较少的环境。",
                  "markdown": "报告非 `static`、`private`、`final` 或 `abstract`，且其语句体不为空的方法。\n\n\n使用避免此类方法的样式进行编码可以保护类的约定不会被它们的子类破坏。 这种样式的好处是子类不会因为忘记调用 super 方法而破坏超类的状态。 代价是子类的灵活性受到限制，特别是它们不能阻止超类中代码的执行。 使用该快速修复可以添加缺失的修饰符。\n\n**示例：**\n\n\n      class Foo {\n        public boolean equals(Object o) { return true; }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        public final boolean equals(Object o) { return true; }\n      }\n\n此检查适用于将在安全环境中使用的代码，可能不适合限制较少的环境。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DesignForExtension",
                    "cweIds": [
                      668
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SimplifyStreamApiCallChains",
                "shortDescription": {
                  "text": "可以简化 Stream API 调用链"
                },
                "fullDescription": {
                  "text": "报告可以简化的流 API 调用链。 简化通常会在集合遍历期间避免一些临时对象创建操作。 该检查将替换以下调用链： 'collection.stream().forEach()' → 'collection.forEach()' 'collection.stream().collect(toList/toSet/toCollection())' → 'new CollectionType<>(collection)' 'collection.stream().toArray()' → 'collection.toArray()' 'Arrays.asList().stream()' → 'Arrays.stream()' or 'Stream.of()' 'IntStream.range(0, array.length).mapToObj(idx -> array[idx])' → 'Arrays.stream(array)' 'IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))' → 'list.stream()' 'Collections.singleton().stream()' → 'Stream.of()' 'Collections.emptyList().stream()' → 'Stream.empty()' 'stream.filter().findFirst().isPresent()' → 'stream.anyMatch()' 'stream.collect(counting())' → 'stream.count()' 'stream.collect(maxBy())' → 'stream.max()' 'stream.collect(mapping())' → 'stream.map().collect()' 'stream.collect(reducing())' → 'stream.reduce()' 'stream.collect(summingInt())' → 'stream.mapToInt().sum()' 'stream.mapToObj(x -> x)' → 'stream.boxed()' 'stream.map(x -> {...; return x;})' → 'stream.peek(x -> ...)' '!stream.anyMatch()' → 'stream.noneMatch()' '!stream.anyMatch(x -> !(...))' → 'stream.allMatch()' 'stream.map().anyMatch(Boolean::booleanValue)' → 'stream.anyMatch()' 'IntStream.range(expr1, expr2).mapToObj(x -> array[x])' → 'Arrays.stream(array, expr1, expr2)' 'Collection.nCopies(count, ...)' → 'Stream.generate().limit(count)' 'stream.sorted(comparator).findFirst()' → 'Stream.min(comparator)' 'optional.orElseGet(() -> { throw new ...; })' → 'optional.orElseThrow()' 请注意，在某些情况下，替换语义可能略有差异。 例如，'Collections.synchronizedList(...).stream().forEach()' 不同步，而 'Collections.synchronizedList(...).forEach()' 同步。 另外，如果得到的元素为 'null'，而 'Stream.max()' 在本例中抛出 'NullPointerException'，则 'collect(Collectors.maxBy())' 返回空的 'Optional'。 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以简化的流 API 调用链。 简化通常会在集合遍历期间避免一些临时对象创建操作。\n\n\n该检查将替换以下调用链：\n\n* `collection.stream().forEach()` → `collection.forEach()`\n* `collection.stream().collect(toList/toSet/toCollection())` → `new CollectionType<>(collection)`\n* `collection.stream().toArray()` → `collection.toArray()`\n* `Arrays.asList().stream()` → `Arrays.stream()` or `Stream.of()`\n* `IntStream.range(0, array.length).mapToObj(idx -> array[idx])` → `Arrays.stream(array)`\n* `IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))` → `list.stream()`\n* `Collections.singleton().stream()` → `Stream.of()`\n* `Collections.emptyList().stream()` → `Stream.empty()`\n* `stream.filter().findFirst().isPresent()` → `stream.anyMatch()`\n* `stream.collect(counting())` → `stream.count()`\n* `stream.collect(maxBy())` → `stream.max()`\n* `stream.collect(mapping())` → `stream.map().collect()`\n* `stream.collect(reducing())` → `stream.reduce()`\n* `stream.collect(summingInt())` → `stream.mapToInt().sum()`\n* `stream.mapToObj(x -> x)` → `stream.boxed()`\n* `stream.map(x -> {...; return x;})` → `stream.peek(x -> ...)`\n* `!stream.anyMatch()` → `stream.noneMatch()`\n* `!stream.anyMatch(x -> !(...))` → `stream.allMatch()`\n* `stream.map().anyMatch(Boolean::booleanValue)` → `stream.anyMatch()`\n* `IntStream.range(expr1, expr2).mapToObj(x -> array[x])` → `Arrays.stream(array, expr1, expr2)`\n* `Collection.nCopies(count, ...)` → `Stream.generate().limit(count)`\n* `stream.sorted(comparator).findFirst()` → `Stream.min(comparator)`\n* `optional.orElseGet(() -> { throw new ...; })` → `optional.orElseThrow()`\n\n\n请注意，在某些情况下，替换语义可能略有差异。 例如，`Collections.synchronizedList(...).stream().forEach()` 不同步，而 `Collections.synchronizedList(...).forEach()` 同步。\n另外，如果得到的元素为 `null`，而 `Stream.max()` 在本例中抛出 `NullPointerException`，则 `collect(Collectors.maxBy())` 返回空的 `Optional`。\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SimplifyStreamApiCallChains",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnknownGuard",
                "shortDescription": {
                  "text": "未知 '@GuardedBy' 字段"
                },
                "fullDescription": {
                  "text": "报告其中指定的保护字段未知的 '@GuardedBy' 注解。 示例： 'private Object state;\n\n    @GuardedBy(\"lock\") //未知的保护引用\n    public void bar() {\n        state = new Object();\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告其中指定的保护字段未知的 `@GuardedBy` 注解。\n\n示例：\n\n\n        private Object state;\n\n        @GuardedBy(\"lock\") //未知的保护引用\n        public void bar() {\n            state = new Object();\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnknownGuard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 76,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassExtendsConcreteClass",
                "shortDescription": {
                  "text": "抽象类扩展具体类"
                },
                "fullDescription": {
                  "text": "报告扩展具体类的 'abstract' 类。",
                  "markdown": "报告扩展具体类的 `abstract` 类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassExtendsConcreteClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8CollectionRemoveIf",
                "shortDescription": {
                  "text": "循环可被替换为 'Collection.removeIf()'"
                },
                "fullDescription": {
                  "text": "报告可以折叠为单个 'Collection.removeIf' 调用的循环。 示例： 'for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {\n    String aValue = it.next();\n    if(shouldBeRemoved(aValue)) {\n      it.remove();\n    }\n  }' 在应用快速修复后： 'collection.removeIf(aValue -> shouldBeRemoved(aValue));' 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以折叠为单个 `Collection.removeIf` 调用的循环。\n\n示例：\n\n\n      for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {\n        String aValue = it.next();\n        if(shouldBeRemoved(aValue)) {\n          it.remove();\n        }\n      }\n\n在应用快速修复后：\n\n\n      collection.removeIf(aValue -> shouldBeRemoved(aValue));\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8CollectionRemoveIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SafeVarargsDetector",
                "shortDescription": {
                  "text": "形参化 vararg 类型可能导致堆污染"
                },
                "fullDescription": {
                  "text": "报告所有包含可变 arity 且可以注解为 '@SafeVarargs' 的方法。 '@SafeVarargs' 注解禁止有关在调用点创建形参化数组的未检查的警告。 示例： 'public class Foo<T> {\n    private List<T> list = new ArrayList<>();\n\n    public final void safeVarargs(T... elements) {\n      Collections.addAll(list, elements);\n    }\n  }' 在应用快速修复后： 'public class Foo<T> {\n    private List<T> list = new ArrayList<>();\n\n    @SafeVarargs\n    public final void safeVarargs(T... elements) {\n      Collections.addAll(list, elements);\n    }\n  }' Java 1.6 或更早版本的 JVM 不支持此注解。",
                  "markdown": "报告所有包含可变 arity 且可以注解为 `@SafeVarargs` 的方法。 `@SafeVarargs` 注解禁止有关在调用点创建形参化数组的未检查的警告。\n\n**示例：**\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        @SafeVarargs\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\n\nJava 1.6 或更早版本的 JVM 不支持此注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "unchecked",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 127,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComparatorMethodParameterNotUsed",
                "shortDescription": {
                  "text": "可疑的 'Comparator.compare()' 实现"
                },
                "fullDescription": {
                  "text": "报告 'Comparator.compare()' 和 'Comparable.compareTo()' 实现中的问题。 将报告以下情况： 未使用形参。 很可能这是拼写错误，另一个形参与本身相比较，或者未正确实现方法。 显然，对于相同的元素，该方法不会返回 '0'。 这种比较方法违反了约定，当遇到相同的元素时，可能会产生不可预测的结果。 特别是，某些数据可能会出现异常而导致排序失败。 比较方法从不返回正值或负值。 为了履行约定，如果比较方法返回正值，那么如果以相反的顺序提供实参，它也应该返回负值。 比较方法返回 'Integer.MIN_VALUE'。 虽然约定允许，但它可能容易出错，因为一些调用站点可能会错误地使用一元减号来反转比较方法的返回值。 'Integer.MIN_VALUE' 的求反值为 'Integer.MIN_VALUE'。 示例： 'Comparator<String> lambda =\n    (a, b) -> a.length() > b.length()\n              ? 0\n              : Math.random() > 0.5 ? -1 : 1;'",
                  "markdown": "报告 `Comparator.compare()` 和 `Comparable.compareTo()` 实现中的问题。\n\n将报告以下情况：\n\n* 未使用形参。 很可能这是拼写错误，另一个形参与本身相比较，或者未正确实现方法。\n* 显然，对于相同的元素，该方法不会返回 `0`。 这种比较方法违反了约定，当遇到相同的元素时，可能会产生不可预测的结果。 特别是，某些数据可能会出现异常而导致排序失败。\n* 比较方法从不返回正值或负值。 为了履行约定，如果比较方法返回正值，那么如果以相反的顺序提供实参，它也应该返回负值。\n* 比较方法返回 `Integer.MIN_VALUE`。 虽然约定允许，但它可能容易出错，因为一些调用站点可能会错误地使用一元减号来反转比较方法的返回值。 `Integer.MIN_VALUE` 的求反值为 `Integer.MIN_VALUE`。\n\n**示例：**\n\n\n      Comparator<String> lambda =\n        (a, b) -> a.length() > b.length()\n                  ? 0\n                  : Math.random() > 0.5 ? -1 : 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComparatorMethodParameterNotUsed",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Annotation",
                "shortDescription": {
                  "text": "注解"
                },
                "fullDescription": {
                  "text": "报告注解。 Java 1.4 和更早版本的 JVM 不支持注解。",
                  "markdown": "报告注解。 Java 1.4 和更早版本的 JVM 不支持注解。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Annotation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 114,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnicodeEscape",
                "shortDescription": {
                  "text": "不必要的 Unicode 转义序列"
                },
                "fullDescription": {
                  "text": "报告不必要的 unicode 转义序列。 例如，当文件编码可以在不转义的情况下处理字符时。 此检查不报告 Unicode 控制字符（换行符和制表符除外）。 示例： 'String s = \"\\u0062\";'",
                  "markdown": "报告不必要的 unicode 转义序列。 例如，当文件编码可以在不转义的情况下处理字符时。 此检查不报告 Unicode 控制字符（换行符和制表符除外）。\n\n**示例：**\n\n    String s = \"\\u0062\";\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnicodeEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PrimitiveArrayArgumentToVariableArgMethod",
                "shortDescription": {
                  "text": "引起混淆的 vararg 方法基元数组实参"
                },
                "fullDescription": {
                  "text": "报告对可变 arity 方法的任何调用，其中该调用在 arity 形参位置有基元数组（例如 'System.out.printf(\"%s\", new int[]{1, 2, 3})'）。 此类基元数组实参可能令人困惑，因为它将被包装为单一元素数组，而不是像预期的那样将每个单独的元素装箱。 示例： 'String.format(\"%s\", new int[]{1, 2, 3});' 在应用快速修复后： 'String.format(\"%s\", (Object) new int[]{1, 2, 3});' 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告对可变 arity 方法的任何调用，其中该调用在 arity 形参位置有基元数组（例如 `System.out.printf(\"%s\", new int[]{1, 2, 3})`）。 此类基元数组实参可能令人困惑，因为它将被包装为单一元素数组，而不是像预期的那样将每个单独的元素装箱。\n\n**示例：**\n\n\n      String.format(\"%s\", new int[]{1, 2, 3});\n\n在应用快速修复后：\n\n\n      String.format(\"%s\", (Object) new int[]{1, 2, 3});\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PrimitiveArrayArgumentToVarargsMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringTokenizer",
                "shortDescription": {
                  "text": "使用 'StringTokenizer'"
                },
                "fullDescription": {
                  "text": "报告 'StringTokenizer' 类的用法。 在国际化环境中，过度使用 'StringTokenizer' 是不正确的。",
                  "markdown": "报告 `StringTokenizer` 类的用法。 在国际化环境中，过度使用 `StringTokenizer` 是不正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfStringTokenizer",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseBulkOperation",
                "shortDescription": {
                  "text": "可以使用批量操作代替迭代"
                },
                "fullDescription": {
                  "text": "报告循环内部可以替换为批量方法的单一运算。 批量方法不仅更短，而且有时性能也更好。 示例： 'void test(Collection<Integer> numbers) {\n    List<Integer> result = new ArrayList<>();\n    for (Integer i : numbers) {\n      result.add(i);\n    }\n  }' 应用修正后： 'void test(Collection<Integer> numbers) {\n    List<Integer> result = new ArrayList<>();\n    result.addAll(numbers);\n  }' 即便批量方法需要集合，使用 Arrays.asList() 包装数组选项也使您能够报告数组。 在本例中，该快速修复会自动将数组包装在 'Arrays.asList()' 调用中。 2017.1 最新变化",
                  "markdown": "报告循环内部可以替换为批量方法的单一运算。\n\n\n批量方法不仅更短，而且有时性能也更好。\n\n**示例：**\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer i : numbers) {\n          result.add(i);\n        }\n      }\n\n应用修正后：\n\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        result.addAll(numbers);\n      }\n\n\n即便批量方法需要集合，**使用 Arrays.asList() 包装数组** 选项也使您能够报告数组。\n在本例中，该快速修复会自动将数组包装在 `Arrays.asList()` 调用中。\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseBulkOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AccessToNonThreadSafeStaticFieldFromInstance",
                "shortDescription": {
                  "text": "非线程安全的 'static' 字段访问"
                },
                "fullDescription": {
                  "text": "报告对非线程安全类型的 'static' 字段的访问。 从实例方法或非同步块访问 'static' 字段时，多个线程都可以访问该字段。 这可能导致未指明的副作用，例如异常和不正确的结果。 示例： 'class Sample {\n    private static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n    String method() {\n      return df.format(\"\");\n    }\n  }' 您可以指定哪些类型应被视为非线程安全。 仅报告具有这些确切类型或使用这些确切类型进行初始化的字段，因为可能存在这些类型的线程安全子类。",
                  "markdown": "报告对非线程安全类型的 `static` 字段的访问。\n\n\n从实例方法或非同步块访问 `static` 字段时，多个线程都可以访问该字段。\n这可能导致未指明的副作用，例如异常和不正确的结果。\n\n**示例：**\n\n\n      class Sample {\n        private static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n        String method() {\n          return df.format(\"\");\n        }\n      }\n\n\n您可以指定哪些类型应被视为非线程安全。\n仅报告具有这些确切类型或使用这些确切类型进行初始化的字段，因为可能存在这些类型的线程安全子类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AccessToNonThreadSafeStaticField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalEquals",
                "shortDescription": {
                  "text": "在 'BigDecimal' 上调用了 'equals()'"
                },
                "fullDescription": {
                  "text": "报告比较两个 'java.math.BigDecimal' 数字的 'equals()' 调用。 这通常会是错误，因为两个 'java.math.BigDecimal' 数字只有在值和比例上都相等时才相等。 示例： 'if (new BigDecimal(\"2.0\").equals(\n    new BigDecimal(\"2.00\"))) {} // false' 在应用快速修复后： 'if (new BigDecimal(\"2.0\").compareTo(\n    new BigDecimal(\"2.00\")) == 0) {} // true'",
                  "markdown": "报告比较两个 `java.math.BigDecimal` 数字的 `equals()` 调用。 这通常会是错误，因为两个 `java.math.BigDecimal` 数字只有在值和比例上都相等时才相等。\n\n**示例：**\n\n\n      if (new BigDecimal(\"2.0\").equals(\n        new BigDecimal(\"2.00\"))) {} // false\n\n在应用快速修复后：\n\n\n      if (new BigDecimal(\"2.0\").compareTo(\n        new BigDecimal(\"2.00\")) == 0) {} // true\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalEquals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToCatchBlockParameter",
                "shortDescription": {
                  "text": "赋值给 'catch' 块形参"
                },
                "fullDescription": {
                  "text": "报告对 'catch' 块形参的赋值。 更改 'catch' 块形参很容易令人困惑，不建议使用。 该快速修复会添加新变量的声明。 示例： 'void processFile(String fileName) throws Exception {\n    try {\n      doProcessFile(fileName);\n    } catch(Exception ex) {\n      if (ex instanceof UncheckedIOException) {\n        // Warning: catch block parameter reassigned\n        ex = ((UncheckedIOException) ex).getCause();\n      }\n      throw ex;\n    }\n  }' 在应用快速修复后： 'void processFile(String fileName) throws Exception {\n    try {\n      doProcessFile(fileName);\n    } catch(Exception ex) {\n      Exception unwrapped = ex;\n      if (unwrapped instanceof UncheckedIOException) {\n        unwrapped = ((UncheckedIOException)\n          unwrapped).getCause();\n      }\n      throw unwrapped;\n    }\n  }'",
                  "markdown": "报告对 `catch` 块形参的赋值。\n\n更改 `catch` 块形参很容易令人困惑，不建议使用。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          if (ex instanceof UncheckedIOException) {\n            // Warning: catch block parameter reassigned\n            ex = ((UncheckedIOException) ex).getCause();\n          }\n          throw ex;\n        }\n      }\n\n在应用快速修复后：\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          Exception unwrapped = ex;\n          if (unwrapped instanceof UncheckedIOException) {\n            unwrapped = ((UncheckedIOException)\n              unwrapped).getCause();\n          }\n          throw unwrapped;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToCatchBlockParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractMethodOverridesAbstractMethod",
                "shortDescription": {
                  "text": "abstract 方法重写 abstract 方法"
                },
                "fullDescription": {
                  "text": "报告重写 'abstract' 方法的 'abstract' 方法。 此类方法毫无意义，因为任何具体的子类都必须实现抽象方法。 此检查不会报告返回类型、异常声明、注解或修饰符与被重写方法不同的方法。 配置检查： 使用忽略 Javadoc 与其 super 方法不同的方法选项，以忽略 Javadoc 注释与其 super 方法不同的任何抽象方法。",
                  "markdown": "报告重写 `abstract` 方法的 `abstract` 方法。\n\n此类方法毫无意义，因为任何具体的子类都必须实现抽象方法。\n\n\n此检查不会报告返回类型、异常声明、注解或修饰符与被重写方法不同的方法。\n\n\n配置检查：\n\n* 使用**忽略 Javadoc 与其 super 方法不同的方法**选项，以忽略 Javadoc 注释与其 super 方法不同的任何抽象方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractMethodOverridesAbstractMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopStatementsThatDontLoop",
                "shortDescription": {
                  "text": "不循环的循环语句"
                },
                "fullDescription": {
                  "text": "报告其语句体最多执行一次的 'for'、'while' 和 'do' 语句的任何实例。 通常，这表明存在错误。 使用忽略增强型 for 循环选项可忽略 foreach 循环。 它们有时用于以紧凑的方式仅对可迭代对象的第一个条目执行操作。 示例： 'for (String s : stringIterable) {\n    doSomethingOnFirstString(s);\n    break;\n  }'",
                  "markdown": "报告其语句体最多执行一次的 `for`、`while` 和 `do` 语句的任何实例。 通常，这表明存在错误。\n\n\n使用**忽略增强型 for 循环**选项可忽略 foreach 循环。\n它们有时用于以紧凑的方式仅对可迭代对象的第一个条目执行操作。\n\n示例：\n\n\n      for (String s : stringIterable) {\n        doSomethingOnFirstString(s);\n        break;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopStatementThatDoesntLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayCreationWithoutNewKeyword",
                "shortDescription": {
                  "text": "创建不带 'new' 表达式的数组"
                },
                "fullDescription": {
                  "text": "报告没有 'new' 数组表达式的数组初始化器并建议添加它们。 示例： 'int[] a = {42}' 在应用快速修复后： 'int[] a = new int[]{42}'",
                  "markdown": "报告没有 `new` 数组表达式的数组初始化器并建议添加它们。\n\n示例：\n\n\n      int[] a = {42}\n\n在应用快速修复后：\n\n\n      int[] a = new int[]{42}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ArrayCreationWithoutNewKeyword",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingOctalEscape",
                "shortDescription": {
                  "text": "引起混淆的八进制转义序列"
                },
                "fullDescription": {
                  "text": "报告包含紧跟数字的八进制转义序列的字符串文字。 此类字符串可能令人困惑，并且通常是转义码创建错误的结果。 示例： 'System.out.println(\"\\1234\"); // 紧跟数字的八进制转义序列 '\\123''",
                  "markdown": "报告包含紧跟数字的八进制转义序列的字符串文字。\n\n此类字符串可能令人困惑，并且通常是转义码创建错误的结果。\n\n**示例：**\n\n\n      System.out.println(\"\\1234\"); // 紧跟数字的八进制转义序列 '\\123'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingOctalEscapeSequence",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaParameterHidingMemberVariable",
                "shortDescription": {
                  "text": "lambda 形参隐藏字段"
                },
                "fullDescription": {
                  "text": "报告与周围类的字段同名的 lambda 形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用 lambda 形参。 建议通过快速修复重命名该 lambda 形参。 示例： 'public class MyClass {\n    public Object foo;\n\n    void sort(List<Integer> list) {\n      list.sort((foo, bar) -> foo - bar);\n    }\n  }' 使用此选项可选择是否忽略对 lambda 表达式不可见的字段。 例如，超类的 private 字段。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告与周围类的字段同名的 lambda 形参。 由于进行此类命名，在有意使用同名字段的情况下，您可能会误用 lambda 形参。\n\n建议通过快速修复重命名该 lambda 形参。\n\n**示例：**\n\n\n      public class MyClass {\n        public Object foo;\n\n        void sort(List<Integer> list) {\n          list.sort((foo, bar) -> foo - bar);\n        }\n      }\n\n\n使用此选项可选择是否忽略对 lambda 表达式不可见的字段。\n例如，超类的 private 字段。\n\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LambdaParameterHidesMemberVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantMathCall",
                "shortDescription": {
                  "text": "对 'Math' 的常量调用"
                },
                "fullDescription": {
                  "text": "报告对可被替换为简单的编译时常量的 'java.lang.Math' 或 'java.lang.StrictMath' 方法的调用。 示例： 'double v = Math.sin(0.0);' 在应用快速修复后： 'double v = 0.0;'",
                  "markdown": "报告对可被替换为简单的编译时常量的 `java.lang.Math` 或 `java.lang.StrictMath` 方法的调用。\n\n**示例：**\n\n    double v = Math.sin(0.0);\n\n在应用快速修复后：\n\n    double v = 0.0;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantMathCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MissortedModifiers",
                "shortDescription": {
                  "text": "错位修饰符"
                },
                "fullDescription": {
                  "text": "报告修饰符不符合规范首选顺序（如 Java 语言规范中所述）的声明。 示例： 'class Foo {\n    native public final void foo();\n  }' 在应用快速修复后： 'class Foo {\n    public final native void foo();\n  }' 使用检查设置可以： 切换位置错误的注解的报告： （带有 'ElementType.TYPE_USE' 的不紧接在类型之前和修饰符关键字之后的注解，或其他不在修饰符关键字之前的注解）。 禁用此选项后，任何注解都可以放置在修饰符关键字之前或之后。 将始终报告在修饰符关键字之间带有注解的修饰符列表。 指定 'ElementType.TYPE_USE' 注解是否应直接置于类型之前，即使该注解指定了其他目标。",
                  "markdown": "报告修饰符不符合规范首选顺序（如 Java 语言规范中所述）的声明。\n\n**示例：**\n\n\n      class Foo {\n        native public final void foo();\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        public final native void foo();\n      }\n\n使用检查设置可以：\n\n*\n  切换位置错误的注解的报告：\n  （带有 `ElementType.TYPE_USE` 的*不* 紧接在类型之前和修饰符关键字之后的注解，或其他*不*在修饰符关键字之前的注解）。\n  禁用此选项后，任何注解都可以放置在修饰符关键字之前或之后。\n  将始终报告在修饰符关键字之间带有注解的修饰符列表。\n\n*\n  指定 `ElementType.TYPE_USE` 注解是否应直接置于类型之前，即使该注解指定了其他目标。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MissortedModifiers",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TransientFieldInNonSerializableClass",
                "shortDescription": {
                  "text": "不可序列化类中存在 transient 字段"
                },
                "fullDescription": {
                  "text": "报告未实现 'java.io.Serializable' 的类中的 'transient' 字段。 示例： 'public class NonSerializableClass {\n    private transient String password;\n  }' 在应用快速修复后： 'public class NonSerializableClass {\n    private String password;\n  }'",
                  "markdown": "报告未实现 `java.io.Serializable` 的类中的 `transient` 字段。\n\n**示例：**\n\n\n      public class NonSerializableClass {\n        private transient String password;\n      }\n\n在应用快速修复后：\n\n\n      public class NonSerializableClass {\n        private String password;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TransientFieldInNonSerializableClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SlowListContainsAll",
                "shortDescription": {
                  "text": "对 'list.containsAll(collection)' 的调用可能具有较差性能"
                },
                "fullDescription": {
                  "text": "报告 'java.util.List' 上对 'containsAll()' 的调用。 此方法调用的时间复杂度为 O(n·m)，其中 n 是调用该方法的列表中的元素数，m 是作为形参传递至该方法的集合中的元素数。 当列表很大时，这可能是一项开销巨大的操作。 该快速修复会将列表包装在 'new java.util.HashSet<>()' 中，因为从 'java.util.List' 创建 'java.util.HashSet' 并在 'java.util.HashSet' 上执行 'containsAll()' 的所需时间为 O(n+m)。 示例： 'public boolean check(List<String> list, Collection<String> collection) {\n    // O(n·m) 复杂度\n    return list.containsAll(collection);\n  }' 在应用快速修复后： 'public boolean check(List<String> list, Collection<String> collection) {\n    // O(n+m) 复杂度\n    return new HashSet<>(list).containsAll(collection);\n  }' 2022.1 最新变化",
                  "markdown": "报告 `java.util.List` 上对 `containsAll()` 的调用。\n\n\n此方法调用的时间复杂度为 O(n·m)，其中 n 是调用该方法的列表中的元素数，m 是作为形参传递至该方法的集合中的元素数。\n当列表很大时，这可能是一项开销巨大的操作。\n\n\n该快速修复会将列表包装在 `new java.util.HashSet<>()` 中，因为从 `java.util.List` 创建\n`java.util.HashSet` 并在 `java.util.HashSet` 上执行 `containsAll()` 的所需时间为 O(n+m)。\n\n**示例：**\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(n·m) 复杂度\n        return list.containsAll(collection);\n      }\n\n在应用快速修复后：\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(n+m) 复杂度\n        return new HashSet<>(list).containsAll(collection);\n      }\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SlowListContainsAll",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionPackage",
                "shortDescription": {
                  "text": "异常软件包"
                },
                "fullDescription": {
                  "text": "报告仅包含直接或间接扩展 'java.lang.Throwable' 的类的软件包。 尽管异常的实现通常不依赖于其他类，但它们通常不会单独使用。 更好的设计通常会将异常与使用它们的类放在同一个软件包中。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告仅包含直接或间接扩展 `java.lang.Throwable` 的类的软件包。\n\n尽管异常的实现通常不依赖于其他类，但它们通常不会单独使用。\n更好的设计通常会将异常与使用它们的类放在同一个软件包中。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExceptionPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 36,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeParameterExtendsObject",
                "shortDescription": {
                  "text": "类型形参显式扩展 'Object'"
                },
                "fullDescription": {
                  "text": "报告显式声明为扩展 'java.lang.Object' 的类型形参和通配符类型实参。 此类 'extends' 子句是冗余的，因为 'java.lang.Object' 是所有类的父类型。 示例： 'class ClassA<T extends Object> {}' 如果由于注解而需保留 'extends Object' 子句，请禁用注解 java.lang.Object 时忽略选项。 这可能会有用，例如在您使用空值分析器并且 'extends Object' 子句包含 '@Nullable'/'@NotNull' 注解时。 示例： 'class MyClass<T extends @NotNull Object> {}'",
                  "markdown": "报告显式声明为扩展 `java.lang.Object` 的类型形参和通配符类型实参。\n\n此类 'extends' 子句是冗余的，因为 `java.lang.Object` 是所有类的父类型。\n\n**示例：**\n\n      class ClassA<T extends Object> {}\n\n\n如果由于注解而需保留 'extends Object' 子句，请禁用**注解 java.lang.Object 时忽略** 选项。\n这可能会有用，例如在您使用空值分析器并且 'extends Object' 子句包含 `@Nullable`/`@NotNull` 注解时。\n\n**示例：**\n\n      class MyClass<T extends @NotNull Object> {}\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeParameterExplicitlyExtendsObject",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringConcatenationInsideStringBufferAppend",
                "shortDescription": {
                  "text": "字符串串联作为 'StringBuilder.append()' 调用的实参"
                },
                "fullDescription": {
                  "text": "报告用作 'StringBuffer.append()'、'StringBuilder.append()' 或 'Appendable.append()' 的实参的 'String' 串联。 此类调用可以有利地转变为现有 'StringBuffer/Builder/Appendable' 中的链式追加调用，从而节省额外的 'StringBuffer/Builder' 分配成本。 此检查将忽略编译时求值的 'String' 串联，在这种情况下，转换只会降低性能。 示例： 'void bar(StringBuilder builder, String name) {\n    builder.append(\"Hello,\" + name);    //警告\n    builder.append(\"Hello,\" + \"world\"); //无警告\n  }'",
                  "markdown": "报告用作 `StringBuffer.append()`、`StringBuilder.append()` 或 `Appendable.append()` 的实参的 `String` 串联。\n\n\n此类调用可以有利地转变为现有 `StringBuffer/Builder/Appendable` 中的链式追加调用，从而节省额外的 `StringBuffer/Builder` 分配成本。\n此检查将忽略编译时求值的 `String` 串联，在这种情况下，转换只会降低性能。\n\n**示例：**\n\n\n      void bar(StringBuilder builder, String name) {\n        builder.append(\"Hello,\" + name);    //警告\n        builder.append(\"Hello,\" + \"world\"); //无警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringConcatenationInsideStringBufferAppend",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FeatureEnvy",
                "shortDescription": {
                  "text": "特性依恋"
                },
                "fullDescription": {
                  "text": "报告特性依恋代码异味。 当方法调用另一个类的方法三次或更多次时，将抛出警告。 对库类、父类、包含类的调用不计入此检查。 特性依恋通常表明该功能位于错误的类中。 示例： 'class JobManager {\n    // 警告：此方法调用 Job 类的\n    // 三个方法\n    // 最好将此调用链\n    // 移至 Job 类本身。\n    void performJob(Job job) {\n      job.beforeStart();\n      job.process();\n      job.afterProcessing();\n    }\n  }'",
                  "markdown": "报告*特性依恋* 代码异味。 当方法调用另一个类的方法三次或更多次时，将抛出警告。 对库类、父类、包含类的调用不计入此检查。 特性依恋通常表明该功能位于错误的类中。\n\n示例：\n\n\n      class JobManager {\n        // 警告：此方法调用 Job 类的\n        // 三个方法\n        // 最好将此调用链\n        // 移至 Job 类本身。\n        void performJob(Job job) {\n          job.beforeStart();\n          job.process();\n          job.afterProcessing();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FeatureEnvy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BoxingBoxedValue",
                "shortDescription": {
                  "text": "装箱已装箱的值"
                },
                "fullDescription": {
                  "text": "报告已装箱值的装箱。 这是冗余的操作，因为任何装箱的值都会先自动拆箱，然后再次对该值装箱。 如果在内部循环中进行，此类代码可能会导致性能问题。 示例： 'Integer value = 1;\n  method(Integer.valueOf(value));' 在应用快速修复后： 'Integer value = 1;\n  method(value);'",
                  "markdown": "报告已装箱值的装箱。\n\n\n这是冗余的操作，因为任何装箱的值都会先自动拆箱，然后再次对该值装箱。 如果在内部循环中进行，此类代码可能会导致性能问题。\n\n**示例：**\n\n\n      Integer value = 1;\n      method(Integer.valueOf(value));\n\n在应用快速修复后：\n\n\n      Integer value = 1;\n      method(value);\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BoxingBoxedValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCollectionOperation",
                "shortDescription": {
                  "text": "冗余的 'Collection' 操作"
                },
                "fullDescription": {
                  "text": "报告有更简单的替代方案的过于复杂的集合操作。 示例： 'void f(String[] array, Collection<String> collection) {\n    String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);\n    boolean contains = collection.containsAll(Collections.singletonList(\"x\"));\n  }' 在应用快速修复后： 'void f(String[] array, Collection<String> collection) {\n    String[] strings = Arrays.copyOf(array, 10);\n    boolean contains = collection.contains(\"x\");\n  }' 2018.1 最新变化",
                  "markdown": "报告有更简单的替代方案的过于复杂的集合操作。\n\n示例：\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);\n        boolean contains = collection.containsAll(Collections.singletonList(\"x\"));\n      }\n\n在应用快速修复后：\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.copyOf(array, 10);\n        boolean contains = collection.contains(\"x\");\n      }\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCollectionOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverriddenMethodCallDuringObjectConstruction",
                "shortDescription": {
                  "text": "重写的方法在对象构造期间调用"
                },
                "fullDescription": {
                  "text": "报告在对象构造期间对当前类的重写方法的任何调用。 如果对象构造在内部，则会发生这种情况： 构造函数 非 static 实例初始值设定项 非 static 字段初始值设定项 'clone()' 'readObject()' 'readObjectNoData()' 此类调用可能会导致难以捉摸的错误，因为不能保证对象在方法调用发生之前被初始化。 示例： 'abstract class Parent {\n    void someMethod() { }\n  }\n\n  class Child extends Parent {\n    Child() {\n      someMethod();\n    }\n\n    @Override\n    void someMethod() { }\n  }' 此检查与以下各项共享其功能： 对象构造期间调用的 abstract 方法检查 对象构造期间调用的可重写方法检查 一次只应启用一个检查，以防止重复警告。",
                  "markdown": "报告在对象构造期间对当前类的重写方法的任何调用。 如果对象构造在内部，则会发生这种情况：\n\n* 构造函数\n* 非 static 实例初始值设定项\n* 非 static 字段初始值设定项\n* `clone()`\n* `readObject()`\n* `readObjectNoData()`\n\n此类调用可能会导致难以捉摸的错误，因为不能保证对象在方法调用发生之前被初始化。\n\n示例：\n\n\n      abstract class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n\n        @Override\n        void someMethod() { }\n      }\n\n此检查与以下各项共享其功能：\n\n* **对象构造期间调用的 abstract 方法**检查\n* **对象构造期间调用的可重写方法**检查\n\n一次只应启用一个检查，以防止重复警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverriddenMethodCallDuringObjectConstruction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AbstractClassWithoutAbstractMethods",
                "shortDescription": {
                  "text": "没有 'abstract' 方法的抽象类"
                },
                "fullDescription": {
                  "text": "报告没有任何 'abstract' 方法的 'abstract' 类。 在大多数情况下，没有任何 'abstract' 方法的 'abstract' 类没有意义，并且可以从该类中移除 'abstract' 修饰符。 如果类被声明为 'abstract' 以防止实例化，则使用 'private' 构造函数来防止实例化通常是更好的选择。 示例： 'abstract class Example {\n    public String getName() {\n      return \"IntelliJ IDEA\";\n    }\n  }' 使用该选项可以忽略实用程序类。",
                  "markdown": "报告没有任何 `abstract` 方法的 `abstract` 类。 在大多数情况下，没有任何 `abstract` 方法的 `abstract` 类没有意义，并且可以从该类中移除 `abstract` 修饰符。 如果类被声明为 `abstract` 以防止实例化，则使用 `private` 构造函数来防止实例化通常是更好的选择。\n\n**示例：**\n\n\n      abstract class Example {\n        public String getName() {\n          return \"IntelliJ IDEA\";\n        }\n      }\n\n使用该选项可以忽略实用程序类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AbstractClassWithoutAbstractMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastThatLosesPrecision",
                "shortDescription": {
                  "text": "损失精度的数字转换"
                },
                "fullDescription": {
                  "text": "报告可能导致精度损失的基元数值类型之间的转换运算。 此类转换不一定是问题，但如果意外造成精度损失，则可能会导致难以跟踪错误。 示例： 'int a = 420;\n  byte b = (byte) a;' 使用忽略从 int 到 char 的转换选项可以忽略从 'int' 到 'char' 的转换。 在实现 I/O 操作时经常使用这种类型的转换，因为 'java.io.Reader' 类的 'read()' 方法会返回一个 'int'。 使用忽略从 int 128-255 到字节的转换选项可以忽略从 'int' 到 'byte' 的常量值 (128-255) 的转换。 此类值将溢出到仍能容纳在一个字节内的负数。",
                  "markdown": "报告可能导致精度损失的基元数值类型之间的转换运算。\n\n此类转换不一定是问题，但如果意外造成精度损失，则可能会导致难以跟踪错误。\n\n**示例：**\n\n\n      int a = 420;\n      byte b = (byte) a;\n\n使用**忽略从 int 到 char 的转换** 选项可以忽略从 `int` 到 `char` 的转换。\n在实现 I/O 操作时经常使用这种类型的转换，因为 `java.io.Reader` 类的 `read()` 方法会返回一个 `int`。\n\n使用**忽略从 int 128-255 到字节的转换** 选项可以忽略从 `int` 到 `byte` 的常量值 (128-255) 的转换。\n此类值将溢出到仍能容纳在一个字节内的负数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NumericCastThatLosesPrecision",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题/转换",
                      "index": 109,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SameReturnValue",
                "shortDescription": {
                  "text": "方法始终返回相同的值"
                },
                "fullDescription": {
                  "text": "报告始终返回相同常量的方法和方法层次结构。 该检查在批处理模式（与代码 | 检查代码或代码 | 分析代码 | 按名称运行检查）和在编辑器中动态运行时的工作方式不同： 在批处理模式中，该检查会报告始终返回相同常量的方法和方法层次结构。 在编辑器中，该检查仅会报告有多条 'return' 语句、没有 super 方法，以及无法被重写的方法。 如果一个方法重写或实现了一个方法，约定可能会要求它返回一个特定的常量，但同时，我们可能希望有多个出口点。 如果一个方法可以被重写，则可能在子类中返回不同的值。 示例： 'class X {\n                // 仅在批处理模式下发出警告：\n    int xxx() { // 方法 'xxx()' 及其所有重写方法始终返回 '0'\n      return 0;\n    }\n  }\n\n  class Y extends X {\n    @Override\n    int xxx() {\n        return 0;\n    }\n\n                // 仅在批处理模式下发出警告：\n    int yyy() { // 方法 'yyy()' 始终返回 '0'\n        return 0;\n    }\n\n                                  // 在批处理模式下和动态运行时均发出警告：\n    final int zzz(boolean flag) { // 方法 'zzz()' 始终返回 '0'\n        if (Math.random() > 0.5) {\n            return 0;\n        }\n        return 0;\n    }\n  }'",
                  "markdown": "报告始终返回相同常量的方法和方法层次结构。\n\n\n该检查在批处理模式（与**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**）和在编辑器中动态运行时的工作方式不同：\n\n* 在批处理模式中，该检查会报告始终返回相同常量的方法和方法层次结构。\n* 在编辑器中，该检查仅会报告有多条 `return` 语句、没有 super 方法，以及无法被重写的方法。 如果一个方法重写或实现了一个方法，约定可能会要求它返回一个特定的常量，但同时，我们可能希望有多个出口点。 如果一个方法可以被重写，则可能在子类中返回不同的值。\n\n**示例：**\n\n\n      class X {\n                    // 仅在批处理模式下发出警告：\n        int xxx() { // 方法 'xxx()' 及其所有重写方法始终返回 '0'\n          return 0;\n        }\n      }\n\n      class Y extends X {\n        @Override\n        int xxx() {\n            return 0;\n        }\n\n                    // 仅在批处理模式下发出警告：\n        int yyy() { // 方法 'yyy()' 始终返回 '0'\n            return 0;\n        }\n\n                                      // 在批处理模式下和动态运行时均发出警告：\n        final int zzz(boolean flag) { // 方法 'zzz()' 始终返回 '0'\n            if (Math.random() > 0.5) {\n                return 0;\n            }\n            return 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SameReturnValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferMustHaveInitialCapacity",
                "shortDescription": {
                  "text": "没有初始容量的 'StringBuilder'"
                },
                "fullDescription": {
                  "text": "报告对新 'StringBuffer' 或 'StringBuilder' 对象进行实例化而不指定其初始容量的尝试。 如果未指定初始容量，则使用默认容量，这很少是最佳选择。 如果在超出初始容量时需要重新分配空间并复制内存，则未指定 'StringBuffer' 的初始容量可能会导致性能问题。 示例： '// 未指定容量\n  var sb = new StringBuilder();'",
                  "markdown": "报告对新 `StringBuffer` 或 `StringBuilder` 对象进行实例化而不指定其初始容量的尝试。\n\n\n如果未指定初始容量，则使用默认容量，这很少是最佳选择。\n如果在超出初始容量时需要重新分配空间并复制内存，则未指定 `StringBuffer` 的初始容量可能会导致性能问题。\n\n示例：\n\n\n      // 未指定容量\n      var sb = new StringBuilder();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferWithoutInitialCapacity",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowablePrintStackTrace",
                "shortDescription": {
                  "text": "调用 'printStackTrace()'"
                },
                "fullDescription": {
                  "text": "报告对无实参的 'Throwable.printStackTrace()' 的调用。 此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。",
                  "markdown": "报告对无实参的 `Throwable.printStackTrace()` 的调用。\n\n此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToPrintStackTrace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadWithDefaultRunMethod",
                "shortDescription": {
                  "text": "使用默认的 'run()' 方法实例化 'Thread'"
                },
                "fullDescription": {
                  "text": "报告在不指定 'Runnable' 形参或重写 'run()' 方法的情况下 'Thread' 或其继承者的实例化。 此类线程没有任何用处。 示例： 'new Thread().start();'",
                  "markdown": "报告在不指定 `Runnable` 形参或重写 `run()` 方法的情况下 `Thread` 或其继承者的实例化。 此类线程没有任何用处。\n\n**示例：**\n\n\n      new Thread().start();\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstantiatingAThreadWithDefaultRunMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreeNegationsPerMethod",
                "shortDescription": {
                  "text": "具有三个以上否定的方法"
                },
                "fullDescription": {
                  "text": "报告有三个或更多否定的方法。 此类方法可能令人困惑。 示例： 'void doSmth(int a, int b, boolean flag1, boolean flag2) {\n    if (!flag && !flag2) {\n      if (a != b) {\n        doOther();\n      }\n    }\n  }' 没有否定，该方法变得更容易理解： 'void doSmth(int a, int b, boolean flag1, boolean flag2) {\n    if (flag1 || flag2 || a == b) return;\n    doOther();\n  }' 配置检查： 使用忽略 'equals()' 方法中的否定选项可禁用 'equals()' 方法中的检查。 使用忽略 'assert' 语句中的否定可禁用 'assert' 语句中的检查。",
                  "markdown": "报告有三个或更多否定的方法。 此类方法可能令人困惑。\n\n**示例：**\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (!flag && !flag2) {\n          if (a != b) {\n            doOther();\n          }\n        }\n      }\n\n没有否定，该方法变得更容易理解：\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (flag1 || flag2 || a == b) return;\n        doOther();\n      }\n\n配置检查：\n\n* 使用**忽略 'equals()' 方法中的否定** 选项可禁用 `equals()` 方法中的检查。\n* 使用**忽略 'assert' 语句中的否定** 可禁用 `assert` 语句中的检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMoreThanThreeNegations",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Java8MapApi",
                "shortDescription": {
                  "text": "可简化的 'Map' 运算"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Map' 常见的使用模式，并建议将其替换为： 'getOrDefault()'、'computeIfAbsent()'、'putIfAbsent()'、'merge()' 或 'replaceAll( )'。 示例： 'map.containsKey(key) ? map.get(key) : \"default\";' 在应用快速修复后： 'map.getOrDefault(key, \"default\");' 示例： 'List<String> list = map.get(key);\n  if (list == null) {\n    list = new ArrayList<>();\n    map.put(key, list);\n  }' 在应用快速修复后： 'map.computeIfAbsent(key, localKey -> new ArrayList<>());' 示例： 'Integer val = map.get(key);\n  if (val == null) map.put(key, 1);\n  else map.put(key, val + 1);' 在应用快速修复后： 'map.merge(key, 1, (localKey, localValue) -> localValue + 1);' 示例： 'for (Map.Entry<String, String> entry : map.entrySet()) {\n    map.put(entry.getKey(), transform(entry.getValue()));\n  }' 在应用快速修复后： 'map.replaceAll((localKey, localValue) -> transform(localValue));' 请注意，如果提取到 lambda 表达式的代码修改了相同的 'Map'，对于某些 'Map'，替换为 'computeIfAbsent()' 或 'merge()' 可能无法正常使用。 在默认情况下，如果这段代码有副作用，则不会出现警告。 如有必要，启用建议替换，即使 lambda 可能有副作用选项，以始终显示警告。 此外，由于 'put()' 等旧方法和 'computeIfAbsent()' 或 'merge()' 等新方法中对 'null' 值的不同处理，语义可能会改变，如果将 'null' 值存储到给定的 'Map' 中很重要，您需要考虑这一点。 当值是静态已知为 null 时，该检查不会建议进行替换。但对于可 null 性未知的值，仍然建议进行替换。 在这些情况下，我们建议禁止警告并添加说明注释。 此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。",
                  "markdown": "报告 `java.util.Map` 常见的使用模式，并建议将其替换为： `getOrDefault()`、`computeIfAbsent()`、`putIfAbsent()`、`merge()` 或 `replaceAll( )`。\n\n示例：\n\n\n      map.containsKey(key) ? map.get(key) : \"default\";\n\n在应用快速修复后：\n\n\n      map.getOrDefault(key, \"default\");\n\n示例：\n\n\n      List<String> list = map.get(key);\n      if (list == null) {\n        list = new ArrayList<>();\n        map.put(key, list);\n      }\n\n在应用快速修复后：\n\n\n      map.computeIfAbsent(key, localKey -> new ArrayList<>());\n\n示例：\n\n\n      Integer val = map.get(key);\n      if (val == null) map.put(key, 1);\n      else map.put(key, val + 1);\n\n在应用快速修复后：\n\n\n      map.merge(key, 1, (localKey, localValue) -> localValue + 1);\n\n示例：\n\n\n      for (Map.Entry<String, String> entry : map.entrySet()) {\n        map.put(entry.getKey(), transform(entry.getValue()));\n      }\n\n在应用快速修复后：\n\n\n      map.replaceAll((localKey, localValue) -> transform(localValue));\n\n请注意，如果提取到 lambda 表达式的代码修改了相同的 `Map`，对于某些 `Map`，替换为 `computeIfAbsent()` 或 `merge()` 可能无法正常使用。 在默认情况下，如果这段代码有副作用，则不会出现警告。 如有必要，启用**建议替换，即使 lambda 可能有副作用**选项，以始终显示警告。\n\n此外，由于 `put()` 等旧方法和 `computeIfAbsent()` 或 `merge()` 等新方法中对 `null` 值的不同处理，语义可能会改变，如果将 `null` 值存储到给定的 `Map` 中很重要，您需要考虑这一点。 当值是静态已知为 null 时，该检查不会建议进行替换。但对于可 null 性未知的值，仍然建议进行替换。 在这些情况下，我们建议禁止警告并添加说明注释。\n\n此检查取决于 Java 功能 '集合中的 Lambda 方法'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Java8MapApi",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 8",
                      "index": 93,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TestOnlyProblems",
                "shortDescription": {
                  "text": "生产代码中的纯测试用法"
                },
                "fullDescription": {
                  "text": "报告生产代码中使用的 '@TestOnly' 和 '@VisibleForTesting' 注解的方法和类。 还报告将 '@TestOnly' '@VisibleForTesting' 应用于同一元素的用法。 如果引用了以下位置中的方法或类，则不报告这些问题： Test Sources 文件夹下的代码 测试类 (JUnit/TestNG) 另一个 '@TestOnly' 注解的方法 （生产代码中的）示例： '@TestOnly\n  fun foo() { ... }\n\n  fun main () {\n    foo()\n  }'",
                  "markdown": "报告生产代码中使用的 `@TestOnly` 和 `@VisibleForTesting` 注解的方法和类。 还报告将 `@TestOnly` `@VisibleForTesting` 应用于同一元素的用法。\n\n如果引用了以下位置中的方法或类，则不报告这些问题：\n\n* **Test Sources** 文件夹下的代码\n* 测试类 (JUnit/TestNG)\n* 另一个 `@TestOnly` 注解的方法\n\n**（生产代码中的）示例：**\n\n\n      @TestOnly\n      fun foo() { ... }\n\n      fun main () {\n        foo()\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TestOnlyProblems",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言/测试框架",
                      "index": 94,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MeaninglessRecordAnnotationInspection",
                "shortDescription": {
                  "text": "无意义的记录注解"
                },
                "fullDescription": {
                  "text": "报告记录组件上使用但并没有效果的注解。 这可能发生在以下两种情况下： 报告的注解具有 METHOD 目标，但显式定义了相应的访问器。 报告的注解具有 PARAMETER 目标，但显式定义了规范构造函数。 示例： '@Target(ElementType.METHOD)\n@interface A { }\n  \n// 该注解根本不会出现在字节码中，\n// 因为它应当传播到访问器，但显式定义了访问器\nrecord R(@A int x) {\n  public int x() { return x; }\n}' 2021.1 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告记录组件上使用但并没有效果的注解。\n\n这可能发生在以下两种情况下：\n\n* 报告的注解具有 METHOD 目标，但显式定义了相应的访问器。\n* 报告的注解具有 PARAMETER 目标，但显式定义了规范构造函数。\n\n示例：\n\n\n    @Target(ElementType.METHOD)\n    @interface A { }\n      \n    // 该注解根本不会出现在字节码中，\n    // 因为它应当传播到访问器，但显式定义了访问器\n    record R(@A int x) {\n      public int x() { return x; }\n    }\n\n2021.1 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MeaninglessRecordAnnotationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FillPermitsList",
                "shortDescription": {
                  "text": "密封类的 permits 子句中缺失同一文件子类"
                },
                "fullDescription": {
                  "text": "报告其 permits 子句不包含来自同一文件的某些子类的密封类。 示例： 'sealed class A {}\n  final class B extends A {}' 在应用快速修复后： 'sealed class A permits B {}\n  final class B extends A {}' 2020.3 最新变化 此检查取决于 Java 功能 '密封类'，该功能自 Java 17 起可用。",
                  "markdown": "报告其 permits 子句不包含来自同一文件的某些子类的密封类。\n\n示例：\n\n\n      sealed class A {}\n      final class B extends A {}\n\n在应用快速修复后：\n\n\n      sealed class A permits B {}\n      final class B extends A {}\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '密封类'，该功能自 Java 17 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FillPermitsList",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicConstant",
                "shortDescription": {
                  "text": "魔术常量"
                },
                "fullDescription": {
                  "text": "报告可以替换为“魔术”常量的表达式。 示例 1： '// 使用了裸文字 \"2\"，警告：\n  Font font = new Font(\"Arial\", 2)' 示例 2： '// 使用了预定义常量，良好：\n  Font font = new Font(\"Arial\", Font.ITALIC)' 如果可能，该快速修复会插入相应的预定义常量。 此检查的行为由 'org.intellij.lang.annotations.MagicConstant' 注解进行控制。 有些标准的 Java 库方法进行了预先注解，但您也可以在代码中使用该注解。",
                  "markdown": "报告可以替换为\"魔术\"常量的表达式。\n\n示例 1：\n\n\n      // 使用了裸文字 \"2\"，警告：\n      Font font = new Font(\"Arial\", 2)\n\n示例 2：\n\n\n      // 使用了预定义常量，良好：\n      Font font = new Font(\"Arial\", Font.ITALIC)\n\n\n如果可能，该快速修复会插入相应的预定义常量。\n\n\n此检查的行为由 `org.intellij.lang.annotations.MagicConstant` 注解进行控制。\n有些标准的 Java 库方法进行了预先注解，但您也可以在代码中使用该注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicConstant",
                    "cweIds": [
                      489
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousDateFormat",
                "shortDescription": {
                  "text": "可疑的日期格式模式"
                },
                "fullDescription": {
                  "text": "报告可能错误使用的日期格式模式。 报告的模式如下： 大写的“Y”，除非“w”出现在附近。 它代表“周年”，几乎总是与正常的“年份”（小写的 \"y\" 模式）相同，但可能指向 12 月结束后的下一年。 靠近 \"H\"、\"K\"、\"h\" 或 \"k\"（小时）的大写 \"M\"（月份）。 可能本意是使用小写的 \"m\"（分钟）。 靠近 \"y\"（年份）或 \"d\"（一月中的某天）的小写 \"m\"（分钟）。 可能本意是使用大写的 \"M\"（分钟）。 靠近 \"M\" 或 \"L\"（月份）的大写的 \"D\"（一年中的某天）。 可能本意是使用小写的 \"d\"（一月中的某天）。 靠近 \"m\"（分钟）的大写的 \"S\"（毫秒）。 可能本意是使用小写的 \"s\"（秒）。 示例： 'new SimpleDateFormat(\"YYYY-MM-dd\")'：可能本意是使用 '\"yyyy-MM-dd\"'。 'new SimpleDateFormat(\"yyyy-MM-DD\")'：可能本意是使用 '\"yyyy-MM-dd\"'。 'new SimpleDateFormat(\"HH:MM\")'：可能本意是使用 '\"HH:mm\"'。 2020.1 最新变化",
                  "markdown": "报告可能错误使用的日期格式模式。\n\n报告的模式如下：\n\n* 大写的\"Y\"，除非\"w\"出现在附近。 它代表\"周年\"，几乎总是与正常的\"年份\"（小写的 \"y\" 模式）相同，但可能指向 12 月结束后的下一年。\n* 靠近 \"H\"、\"K\"、\"h\" 或 \"k\"（小时）的大写 \"M\"（月份）。 可能本意是使用小写的 \"m\"（分钟）。\n* 靠近 \"y\"（年份）或 \"d\"（一月中的某天）的小写 \"m\"（分钟）。 可能本意是使用大写的 \"M\"（分钟）。\n* 靠近 \"M\" 或 \"L\"（月份）的大写的 \"D\"（一年中的某天）。 可能本意是使用小写的 \"d\"（一月中的某天）。\n* 靠近 \"m\"（分钟）的大写的 \"S\"（毫秒）。 可能本意是使用小写的 \"s\"（秒）。\n\n\n示例：  \n\n`new SimpleDateFormat(\"YYYY-MM-dd\")`：可能本意是使用 `\"yyyy-MM-dd\"`。  \n\n`new SimpleDateFormat(\"yyyy-MM-DD\")`：可能本意是使用 `\"yyyy-MM-dd\"`。  \n\n`new SimpleDateFormat(\"HH:MM\")`：可能本意是使用 `\"HH:mm\"`。\n\n2020.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousDateFormat",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NumericToString",
                "shortDescription": {
                  "text": "调用 'Number.toString()'"
                },
                "fullDescription": {
                  "text": "报告扩展 'Number' 的类的对象上的 'toString()' 调用。 此类调用在国际化环境中通常是不正确的，应该使用一些特定于区域设置的格式。 示例： 'void print(Double d) {\n    System.out.println(d.toString());\n  }' 修正此问题的一种可能方式是： 'void print(Double d) {\n    System.out.printf(\"%f%n\", d);\n  }' 这将使用默认区域设置来格式化数字，该默认区域设置在 JVM 启动期间进行设置，并且基于主机环境。",
                  "markdown": "报告扩展 `Number` 的类的对象上的 `toString()` 调用。 此类调用在国际化环境中通常是不正确的，应该使用一些特定于区域设置的格式。\n\n**示例：**\n\n\n      void print(Double d) {\n        System.out.println(d.toString());\n      }\n\n修正此问题的一种可能方式是：\n\n\n      void print(Double d) {\n        System.out.printf(\"%f%n\", d);\n      }\n\n这将使用默认区域设置来格式化数字，该默认区域设置在 JVM 启动期间进行设置，并且基于主机环境。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToNumericToString",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryDefault",
                "shortDescription": {
                  "text": "枚举 'switch' 语句的 'default' 不必要"
                },
                "fullDescription": {
                  "text": "报告由于所有可能的值都被 'case' 分支覆盖而导致其 'default' 分支绝不会被接受的枚举 'switch' 语句或表达式。 此类元素冗余，对于 'switch' 表达式更是如此，因为当 'case' 分支没有覆盖所有枚举常量时，它们不会进行编译。 需要将语言级别配置为 14，才会报告 'switch' 表达式。 提供的快速修复可以移除 'default' 分支。 示例： 'enum E { A, B }\n  int foo(E e) {\n    return switch (e) {\n      case A -> 1;\n      case B -> 2;\n      default -> 3;\n    };\n  }' 在应用快速修复后： 'enum E { A, B }\n  int foo(E e) {\n    return switch (e) {\n      case A -> 1;\n      case B -> 2;\n    };\n  }' 使用仅报告 switch 表达式选项可以仅报告 switch 表达式中的冗余 'default' 分支。",
                  "markdown": "报告由于所有可能的值都被 `case` 分支覆盖而导致其 `default` 分支绝不会被接受的枚举 `switch` 语句或表达式。\n\n此类元素冗余，对于 `switch` 表达式更是如此，因为当 `case` 分支没有覆盖所有枚举常量时，它们不会进行编译。\n\n\n需要将语言级别配置为 14，才会报告 `switch` 表达式。\n\n提供的快速修复可以移除 `default` 分支。\n\n示例：\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n          default -> 3;\n        };\n      }\n\n在应用快速修复后：\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n        };\n      }\n\n使用**仅报告 switch 表达式** 选项可以仅报告 switch 表达式中的冗余 `default` 分支。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryDefault",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VolatileArrayField",
                "shortDescription": {
                  "text": "volatile 数组字段"
                },
                "fullDescription": {
                  "text": "报告被声明为 'volatile' 的数组字段。 此类声明可能令人困惑，因为访问数组本身遵循 'volatile' 字段的规则，但访问数组的内容时并非如此。 示例： 'class Data {\n    private volatile int[] idx = new int[0];\n  }' 如果需要对数组内容进行此类可变访问，不妨改用 'java.util.concurrent.atomic' 类： 'class Data {\n    private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);\n  }'",
                  "markdown": "报告被声明为 `volatile` 的数组字段。 此类声明可能令人困惑，因为访问数组本身遵循 `volatile` 字段的规则，但访问数组的内容时并非如此。\n\n**示例：**\n\n\n      class Data {\n        private volatile int[] idx = new int[0];\n      }\n\n\n如果需要对数组内容进行此类可变访问，不妨改用 `java.util.concurrent.atomic` 类：\n\n\n      class Data {\n        private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VolatileArrayField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryInheritDoc",
                "shortDescription": {
                  "text": "不必要的 '{@inheritDoc}' Javadoc 注释"
                },
                "fullDescription": {
                  "text": "报告仅包含 '{@inheritDoc}' 标记的 Javadoc 注释。 由于 Javadoc 会在没有注释的情况下复制超类的注释，因此仅包含 '{@inheritDoc}' 的注释不会添加任何内容。 此外，它还会报告无效位置（例如，字段）中的 '{@inheritDoc}' 用法。 建议移除不必要的 Javadoc 注释。 示例： 'class Example implements Comparable<Example> {\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int compareTo(Example o) {\n      return 0;\n    }\n  }' 在应用快速修复后： 'class Example implements Comparable<Example> {\n    @Override\n    public int compareTo(Example o) {\n      return 0;\n    }\n  }'",
                  "markdown": "报告仅包含 `{@inheritDoc}` 标记的 Javadoc 注释。 由于 Javadoc 会在没有注释的情况下复制超类的注释，因此仅包含 `{@inheritDoc}` 的注释不会添加任何内容。\n\n此外，它还会报告无效位置（例如，字段）中的 `{@inheritDoc}` 用法。\n\n建议移除不必要的 Javadoc 注释。\n\n**示例：**\n\n\n      class Example implements Comparable<Example> {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example implements Comparable<Example> {\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryInheritDoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParametersPerConstructor",
                "shortDescription": {
                  "text": "形参过多的构造函数"
                },
                "fullDescription": {
                  "text": "报告形参数量超过指定最大值的构造函数。 此类对象很难实例化，特别是在某些形参是可选形参的情况下。 构造函数的形参过多可能表明有必要重构。 例如，请考虑应用构建器模式。 示例： 'public BankAccount(long accountNumber,\n                     String owner,\n                     double balance,\n                     double interestRate) {\n    // fields initialization\n  }' 配置检查： 使用形参限制字段可以指定构造函数中允许的最大形参数量。 使用忽略具有以下可见性的构造函数列表可指定检查是否应忽略具有特定可见性的构造函数。",
                  "markdown": "报告形参数量超过指定最大值的构造函数。 此类对象很难实例化，特别是在某些形参是可选形参的情况下。 构造函数的形参过多可能表明有必要重构。 例如，请考虑应用构建器模式。\n\n**示例：**\n\n\n      public BankAccount(long accountNumber,\n                         String owner,\n                         double balance,\n                         double interestRate) {\n        // fields initialization\n      }\n\n配置检查：\n\n* 使用**形参限制**字段可以指定构造函数中允许的最大形参数量。\n* 使用**忽略具有以下可见性的构造函数**列表可指定检查是否应忽略具有特定可见性的构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstructorWithTooManyParameters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonReproducibleMathCall",
                "shortDescription": {
                  "text": "对 'Math' 的不可重现调用"
                },
                "fullDescription": {
                  "text": "报告不能保证准确再现结果的对 'java.lang.Math' 方法的调用。 在需要结果重现性的环境中，应改用 'java.lang.StrictMath'。",
                  "markdown": "报告不能保证准确再现结果的对 `java.lang.Math` 方法的调用。\n\n在需要结果重现性的环境中，应改用 `java.lang.StrictMath`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonReproducibleMathCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MappingBeforeCount",
                "shortDescription": {
                  "text": "count() 之前的映射调用"
                },
                "fullDescription": {
                  "text": "报告冗余的 'Stream' API 调用，如 'map()' 或在 'count()' 调用之前的 'boxed()'。 此类调用不会改变最终计数，因此可以移除。 代码可能依赖于此类映射调用中 lambda 的副作用。 然而，依靠 Stream 链内部的副作用是非常不好的做法。 不能保证该调用在未来的 Java 版本中不会被优化。 示例： '// map() 调用是冗余的\n  long count = list.stream().filter(s -> !s.isEmpty()).map(s -> s.trim()).count();' 2024.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告冗余的 `Stream` API 调用，如 `map()` 或在 `count()` 调用之前的 `boxed()`。\n\n\n此类调用不会改变最终计数，因此可以移除。 代码可能依赖于此类映射调用中 lambda 的副作用。 然而，依靠 Stream 链内部的副作用是非常不好的做法。 不能保证该调用在未来的 Java 版本中不会被优化。\n\n**示例：**\n\n\n      // map() 调用是冗余的\n      long count = list.stream().filter(s -> !s.isEmpty()).map(s -> s.trim()).count();\n\n2024.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MappingBeforeCount",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonExtendableApiUsage",
                "shortDescription": {
                  "text": "不应扩展类、接口或方法"
                },
                "fullDescription": {
                  "text": "报告扩展、实现或重写使用 '@ApiStatus.NonExtendable' 标记的 API 元素的类、接口和方法。 '@ApiStatus.NonExtendable' 注解表示不得扩展、实现或重写类、接口或方法。 将此类接口和类转换为内部库实现很常见，因此，如果客户端提供不同的实现，将获得 'ClassCastException'。 将新的 abstract 方法添加到这种类和接口将破坏与客户端实现的兼容性。",
                  "markdown": "报告扩展、实现或重写使用 `@ApiStatus.NonExtendable` 标记的 API 元素的类、接口和方法。\n\n\n`@ApiStatus.NonExtendable` 注解表示**不得扩展、实现或重写** 类、接口或方法。\n将此类接口和类转换为内部库实现很常见，因此，如果客户端提供不同的实现，将获得 `ClassCastException`。\n将新的 abstract 方法添加到这种类和接口将破坏与客户端实现的兼容性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonExtendableApiUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnqualifiedFieldAccess",
                "shortDescription": {
                  "text": "未使用 'this' 限定的实例字段访问"
                },
                "fullDescription": {
                  "text": "报告未使用 'this' 或某些其他限定符限定的字段访问操作。 某些编码样式要求对所有字段访问操作进行限定，以防止与局部变量或局部形参访问混淆。 示例： 'class Foo {\n    int foo;\n\n    void bar() {\n      foo += 1;\n    }\n  }' 在应用快速修复后： 'class Foo {\n    int foo;\n\n    void bar() {\n      this.foo += 1;\n    }\n  }'",
                  "markdown": "报告未使用 `this` 或某些其他限定符限定的字段访问操作。\n\n\n某些编码样式要求对所有字段访问操作进行限定，以防止与局部变量或局部形参访问混淆。\n\n**示例：**\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          foo += 1;\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          this.foo += 1;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnqualifiedFieldAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MismatchedCollectionQueryUpdate",
                "shortDescription": {
                  "text": "不匹配的集合查询和更新"
                },
                "fullDescription": {
                  "text": "报告其内容已查询但未更新或已更新但未查询的集合。 此类不一致查询和更新毫无意义，可能表明有死码或拼写错误。 使用检查设置可以指定与更新/查询方法相对应的名称模式。 返回元素的查询方法会被自动检测，并且只需指定将数据写入输出形参的查询方法（例如 'OutputStream'）。 示例： 假设您有一个包含方法 'store()' 的自定义 'FixedStack' 类： 'public class FixedStack<T> extends Collection<T> {\n    public T store(T t) {\n      // 实现\n    }\n  }' 您可以将 'store' 添加到更新方法表中，以报告不匹配的查询，例如： 'void test(int i) {\n    FixedStack<Integer> stack = new FixedStack<>();\n    stack.store(i);\n  }'",
                  "markdown": "报告其内容已查询但未更新或已更新但未查询的集合。\n\n\n此类不一致查询和更新毫无意义，可能表明有死码或拼写错误。\n\n\n使用检查设置可以指定与更新/查询方法相对应的名称模式。\n返回元素的查询方法会被自动检测，并且只需指定将数据写入输出形参的查询方法（例如 `OutputStream`）。\n\n\n**示例：**\n\n假设您有一个包含方法 `store()` 的自定义 `FixedStack` 类：\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // 实现\n        }\n      }\n\n您可以将 `store` 添加到更新方法表中，以报告不匹配的查询，例如：\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MismatchedQueryAndUpdateOfCollection",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CharacterComparison",
                "shortDescription": {
                  "text": "字符比较"
                },
                "fullDescription": {
                  "text": "报告 'char' 值的顺序比较。 在国际化环境中，此类比较很少是正确的。",
                  "markdown": "报告 `char` 值的顺序比较。 在国际化环境中，此类比较很少是正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CharacterComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/国际化",
                      "index": 4,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizeOnThis",
                "shortDescription": {
                  "text": "在 'this' 上同步"
                },
                "fullDescription": {
                  "text": "报告 'this' 或 'class' 表达式的同步。 报告的结构包括 'synchronized' 块以及对 'wait()'、'notify()' 或 'notifyAll()' 的调用。 同步 'this' 或 'class' 表达式可能并非好主意，原因有几点： 它使同步成为类的外部接口的一部分，导致将来很难更改为其他锁定机制， 难以跟踪究竟是谁锁定了给定对象， 使得故意为之或在子类化时很容易意外发生的拒绝服务攻击成为可能。 替代做法是考虑在 'private final' 锁定对象上同步，可以完全控制对该对象的访问。 示例： 'public void print() {\n    synchronized(this) { // 警告：对 'this' 的锁定操作可能会产生不可预见的副作用\n      System.out.println(\"synchronized\");\n    }\n  }'",
                  "markdown": "报告 `this` 或 `class` 表达式的同步。 报告的结构包括 `synchronized` 块以及对 `wait()`、`notify()` 或 `notifyAll()` 的调用。\n\n同步 `this` 或 `class` 表达式可能并非好主意，原因有几点：\n\n1. 它使同步成为类的外部接口的一部分，导致将来很难更改为其他锁定机制，\n2. 难以跟踪究竟是谁锁定了给定对象，\n3. 使得故意为之或在子类化时很容易意外发生的拒绝服务攻击成为可能。\n\n替代做法是考虑在 `private final` 锁定对象上同步，可以完全控制对该对象的访问。\n\n**示例：**\n\n\n      public void print() {\n        synchronized(this) { // 警告：对 'this' 的锁定操作可能会产生不可预见的副作用\n          System.out.println(\"synchronized\");\n        }\n      }\n      \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizeOnThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedAssignment",
                "shortDescription": {
                  "text": "未使用的赋值"
                },
                "fullDescription": {
                  "text": "报告赋值后未使用的赋值。 如果不使用，最好移除该赋值，以缩短代码并避免冗余分配。 将报告以下情况： 变量在赋值后从未被读取 变量在被读取前始终被新值重写 变量初始值设定项冗余（出于以上两种原因之一） 配置检查： 使用报告冗余初始值设定项选项可以报告冗余的初始值设定项： 'int getI() {\n    int i = 0; // 冗余初始化\n    i = 2;\n    return i;\n  }' 使用报告可被替换为二元表达式的前缀表达式选项可以报告可将 '++i' 表达式替换为 'i + 1' 的情况： 'int preInc(int value) {\n    int res = value;\n    return ++res;\n  }' 使用报告未使用更改后的值的后缀表达式选项可以报告稍后未使用 'i' 的值的 'i++' 情况： 'int postInc(int value) {\n    int res = value;\n    return res++;\n  }' 使用报告其值从未被使用的模式变量选项可以报告模式变量的值在读取之前被覆盖的情况： 'if (object instanceof String s) {\n      s = \"hello\";\n      System.out.println(s);\n  }' 使用报告其值从未被使用的迭代形参选项可以报告增强的 'for' 语句的迭代形参的值在读取前被覆盖的情况： 'for (String arg : args) {\n      arg = \"test\";\n      System.out.println(arg);\n  }'",
                  "markdown": "报告赋值后未使用的赋值。 如果不使用，最好移除该赋值，以缩短代码并避免冗余分配。\n\n将报告以下情况：\n\n* 变量在赋值后从未被读取\n* 变量在被读取前始终被新值重写\n* 变量初始值设定项冗余（出于以上两种原因之一）\n\n配置检查：\n\n\n使用**报告冗余初始值设定项**选项可以报告冗余的初始值设定项：\n\n\n      int getI() {\n        int i = 0; // 冗余初始化\n        i = 2;\n        return i;\n      }\n\n\n使用**报告可被替换为二元表达式的前缀表达式** 选项可以报告可将 `++i` 表达式替换为 `i + 1` 的情况：\n\n\n      int preInc(int value) {\n        int res = value;\n        return ++res;\n      }\n\n\n使用**报告未使用更改后的值的后缀表达式** 选项可以报告稍后未使用 `i` 的值的 `i++` 情况：\n\n\n      int postInc(int value) {\n        int res = value;\n        return res++;\n      }\n\n\n使用**报告其值从未被使用的模式变量**选项可以报告模式变量的值在读取之前被覆盖的情况：\n\n\n      if (object instanceof String s) {\n          s = \"hello\";\n          System.out.println(s);\n      }\n\n\n使用**报告其值从未被使用的迭代形参** 选项可以报告增强的 `for` 语句的迭代形参的值在读取前被覆盖的情况：\n\n\n      for (String arg : args) {\n          arg = \"test\";\n          System.out.println(arg);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedAssignment",
                    "cweIds": [
                      561,
                      563
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HashCodeUsesNonFinalVariable",
                "shortDescription": {
                  "text": "'hashCode()' 中引用了非 final 字段"
                },
                "fullDescription": {
                  "text": "报告访问非 'final' 变量的 'hashCode()' 的实现。 此类访问可能导致 'hashCode()' 在该对象生命周期的不同时刻返回不同的值，进而可能在使用标准集合类时导致问题。 示例： 'class Drink {\n    String name;\n    Drink(String name) { this.name = name; }\n    @Override public int hashCode() {\n      return Objects.hash(name); //警告\n    }\n  }\n  ...\n    Drink coffee = new Drink(\"Coffee\");\n    priceMap.put(coffee, 10.0);\n    coffee.name = \"Tea\";\n    double coffeePrice = priceMap.get(coffee); //找不到' 建议通过快速修复将该字段设为 final： 'class Drink {\n    final String name;\n    ...\n  }'",
                  "markdown": "报告访问非 `final` 变量的 `hashCode()` 的实现。\n\n\n此类访问可能导致 `hashCode()` 在该对象生命周期的不同时刻返回不同的值，进而可能在使用标准集合类时导致问题。\n\n**示例：**\n\n\n      class Drink {\n        String name;\n        Drink(String name) { this.name = name; }\n        @Override public int hashCode() {\n          return Objects.hash(name); //警告\n        }\n      }\n      ...\n        Drink coffee = new Drink(\"Coffee\");\n        priceMap.put(coffee, 10.0);\n        coffee.name = \"Tea\";\n        double coffeePrice = priceMap.get(coffee); //找不到\n\n建议通过快速修复将该字段设为 final：\n\n\n      class Drink {\n        final String name;\n        ...\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonFinalFieldReferencedInHashCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProtectedField",
                "shortDescription": {
                  "text": "protected 字段"
                },
                "fullDescription": {
                  "text": "报告 'protected' 字段。 不报告常量（即标记为 'static' 或 'final' 的变量）。 示例： 'public class A {\n    protected Object object;              // 警告\n    protected final static int MODE = 0;  // 常量，无警告\n  }'",
                  "markdown": "报告 `protected` 字段。\n\n不报告常量（即标记为 `static` 或 `final` 的变量）。\n\n**示例：**\n\n\n      public class A {\n        protected Object object;              // 警告\n        protected final static int MODE = 0;  // 常量，无警告\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProtectedField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentUsedAsCondition",
                "shortDescription": {
                  "text": "用作条件的赋值"
                },
                "fullDescription": {
                  "text": "报告用作 'if'、'while'、'for' 或 'do' 语句或条件表达式的赋值。 虽然有时是有意为之，但这种用法令人困惑，并且可能表明存在拼写错误（例如，应使用 '=' 而不是 '=='）。 该快速修复会将 '=' 替换为 '=='。 示例： 'void update(String str, boolean empty) {\n    // 警告：'empty' 被重新赋值，\n    // 不与 str.isEmpty() 进行比较\n    if (empty = str.isEmpty()) {\n      ...\n    }\n  }' 在应用快速修复后： 'void update(String str, boolean empty) {\n    if (empty == str.isEmpty()) {\n      ...\n    }\n  }'",
                  "markdown": "报告用作 `if`、`while`、`for` 或 `do` 语句或条件表达式的赋值。\n\n虽然有时是有意为之，但这种用法令人困惑，并且可能表明存在拼写错误（例如，应使用 `=` 而不是 `==`）。\n\n该快速修复会将 `=` 替换为 `==`。\n\n**示例：**\n\n\n      void update(String str, boolean empty) {\n        // 警告：'empty' 被重新赋值，\n        // 不与 str.isEmpty() 进行比较\n        if (empty = str.isEmpty()) {\n          ...\n        }\n      }\n\n在应用快速修复后：\n\n\n      void update(String str, boolean empty) {\n        if (empty == str.isEmpty()) {\n          ...\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentUsedAsCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceofThis",
                "shortDescription": {
                  "text": "'this' 的 'instanceof' 检查"
                },
                "fullDescription": {
                  "text": "报告在其中检查 'this' 表达式的 'instanceof' 或 'getClass() == SomeClass.class' 的用法。 此类表达式表明面向对象的设计失败，应该替换为多态构造。 示例： 'class Super {\n  void process() {\n    if (this instanceof Sub) { // 警告\n      doSomething();\n    } else {\n      doSomethingElse();\n    }\n  }\n}\n  \nclass Sub extends Super {}' 要修正该问题，可以使用重写方法： 'class Super {\n  void process() {\n    doSomethingElse();\n  }\n}\n  \nclass Sub extends Super {\n  @Override\n  void process() {\n    doSomething();\n  }\n}'",
                  "markdown": "报告在其中检查 `this` 表达式的 `instanceof` 或 `getClass() == SomeClass.class` 的用法。\n\n此类表达式表明面向对象的设计失败，应该替换为多态构造。\n\n示例：\n\n\n    class Super {\n      void process() {\n        if (this instanceof Sub) { // 警告\n          doSomething();\n        } else {\n          doSomethingElse();\n        }\n      }\n    }\n      \n    class Sub extends Super {}\n\n要修正该问题，可以使用重写方法：\n\n\n    class Super {\n      void process() {\n        doSomethingElse();\n      }\n    }\n      \n    class Sub extends Super {\n      @Override\n      void process() {\n        doSomething();\n      }\n    }  \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceofThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageInMultipleModules",
                "shortDescription": {
                  "text": "具有多个模块中的类的软件包"
                },
                "fullDescription": {
                  "text": "报告存在于多个模块中的非空软件包。 当软件包被包含在多个模块中时，很容易在两个模块中创建同名的类。 依赖于这些模块的模块如果尝试使用这种类，就会发生冲突。 Java Platform Module System 不允许包含在多个模块中的软件包（也称为 拆分软件包） 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告存在于多个模块中的非空软件包。 当软件包被包含在多个模块中时，很容易在两个模块中创建同名的类。 依赖于这些模块的模块如果尝试使用这种类，就会发生冲突。 Java Platform Module System 不允许包含在多个模块中的软件包（也称为 *拆分软件包* ）\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageInMultipleModules",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/打包问题",
                      "index": 36,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FloatingPointEquality",
                "shortDescription": {
                  "text": "浮点相等比较"
                },
                "fullDescription": {
                  "text": "报告使用 '==' 或 '!=' 运算符进行比较的浮点值。 浮点值本质上是不准确的，比较它们是否完全相等很少是所需的语义。 此检查会忽略与零和无穷大文字的比较。 示例： 'void m(double d1, double d2) {\n    if (d1 == d2) {}\n  }'",
                  "markdown": "报告使用 `==` 或 `!=` 运算符进行比较的浮点值。\n\n浮点值本质上是不准确的，比较它们是否完全相等很少是所需的语义。\n\n此检查会忽略与零和无穷大文字的比较。\n\n**示例：**\n\n\n      void m(double d1, double d2) {\n        if (d1 == d2) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FloatingPointEquality",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicField",
                "shortDescription": {
                  "text": "'public' 字段"
                },
                "fullDescription": {
                  "text": "报告 'public' 字段。 不报告常量（标记 'static' 和 'final' 的字段）。 示例： 'class Main {\n    public String name;\n  }' 在应用快速修复后： 'class Main {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n  }' 配置检查： 使用有注解时忽略列表可指定要忽略的注解。 该检查将忽略包含其中任何注解的字段。 使用忽略枚举的 'public final' 字段选项，可以忽略 'enum' 类型的 'public final' 字段。",
                  "markdown": "报告 `public` 字段。 不报告常量（标记 `static` 和 `final` 的字段）。\n\n**示例：**\n\n\n      class Main {\n        public String name;\n      }\n\n在应用快速修复后：\n\n\n      class Main {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n      }\n\n配置检查：\n\n* 使用**有注解时忽略**列表可指定要忽略的注解。 该检查将忽略包含其中任何注解的字段。\n* 使用**忽略枚举的 'public final' 字段** 选项，可以忽略 `enum` 类型的 `public final` 字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PublicField",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SequencedCollectionMethodCanBeUsed",
                "shortDescription": {
                  "text": "可以使用 SequencedCollection 方法"
                },
                "fullDescription": {
                  "text": "报告可以使用 'SequencedCollection' 方法简化的集合 API 方法调用。 支持以下转换： 'list.add(0, element)' → 'list.addFirst(element);' 'list.get(0)' → 'list.getFirst();' 'list.get(list.size() - 1)' → 'list.getLast();' 'list.remove(0)' → 'list.removeFirst();' 'list.remove(list.size() - 1)' → 'list.removeLast();' 'collection.iterator().next()' → 'collection.getFirst();' 2023.3 最新变化 此检查取决于 Java 功能 '有序集合'，该功能自 Java 21 起可用。",
                  "markdown": "报告可以使用 `SequencedCollection` 方法简化的集合 API 方法调用。\n\n支持以下转换：\n\n* `list.add(0, element)` → `list.addFirst(element);`\n* `list.get(0)` → `list.getFirst();`\n* `list.get(list.size() - 1)` → `list.getLast();`\n* `list.remove(0)` → `list.removeFirst();`\n* `list.remove(list.size() - 1)` → `list.removeLast();`\n* `collection.iterator().next()` → `collection.getFirst();`\n\n2023.3 最新变化\n\n此检查取决于 Java 功能 '有序集合'，该功能自 Java 21 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SequencedCollectionMethodCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 21",
                      "index": 159,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringBufferToStringInConcatenation",
                "shortDescription": {
                  "text": "连接中的 'StringBuilder.toString()'"
                },
                "fullDescription": {
                  "text": "报告字符串串联中的 'StringBuffer.toString()' 或 'StringBuilder.toString()' 调用。 此类调用在串联时不必要且可以移除，从而节省方法调用和对象分配，这样可以提高性能。",
                  "markdown": "报告字符串串联中的 `StringBuffer.toString()` 或 `StringBuilder.toString()` 调用。 此类调用在串联时不必要且可以移除，从而节省方法调用和对象分配，这样可以提高性能。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringBufferToStringInConcatenation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能",
                      "index": 5,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SerialAnnotationUsedOnWrongMember",
                "shortDescription": {
                  "text": "对错误的成员使用了 '@Serial' 注解"
                },
                "fullDescription": {
                  "text": "报告 'Serializable' 和 'Externalizable' 类中不适合使用 'java.io.Serial' 注解进行注解的方法和字段。 示例： 'class Test implements Serializable {\n  @Serial // 注解的字段不是序列化机制的一部分，因为它并非 final\n  private static long serialVersionUID = 7874493593505141603L;\n\n  @Serial // 注解的方法不是序列化机制的一部分，因为它并非 private\n  void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' 'class Test implements Externalizable {\n  @Serial // 该注解方法不是序列化机制的一部分，因为它在 Externalizable 类内部\n  private void writeObject(ObjectOutputStream out) throws IOException {\n  }\n}' 有关所有有效情况的信息，请参阅 'java.io.Serial' 的文档。 2020.3 最新变化 此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。",
                  "markdown": "报告 `Serializable` 和 `Externalizable` 类中不适合使用 `java.io.Serial` 注解进行注解的方法和字段。\n\n**示例：**\n\n\n    class Test implements Serializable {\n      @Serial // 注解的字段不是序列化机制的一部分，因为它并非 final\n      private static long serialVersionUID = 7874493593505141603L;\n\n      @Serial // 注解的方法不是序列化机制的一部分，因为它并非 private\n      void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n\n    class Test implements Externalizable {\n      @Serial // 该注解方法不是序列化机制的一部分，因为它在 Externalizable 类内部\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n有关所有有效情况的信息，请参阅 `java.io.Serial` 的文档。\n\n2020.3 最新变化\n\n此检查取决于 Java 功能 '@Serial 注解'，该功能自 Java 14 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "serial",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowsRuntimeException",
                "shortDescription": {
                  "text": "在 'throws' 子句中声明的未检查的异常"
                },
                "fullDescription": {
                  "text": "报告方法 'throws' 子句中未检查的异常的声明（'java.lang.RuntimeException' 或其子类之一）。 未检查的异常的声明不是必需的，可以删除或移动到 Javadoc '@throws' 标记。 示例： 'public class InvalidDataException extends RuntimeException {}\n\n  class TextEditor {\n    void readSettings() throws InvalidDataException {} // 警告：在 'throws' 子句中声明了未检查的异常 'InvalidDataException'\n  }'",
                  "markdown": "报告方法 `throws` 子句中未检查的异常的声明（`java.lang.RuntimeException` 或其子类之一）。\n\n未检查的异常的声明不是必需的，可以删除或移动到 Javadoc `@throws` 标记。\n\n**示例：**\n\n\n      public class InvalidDataException extends RuntimeException {}\n\n      class TextEditor {\n        void readSettings() throws InvalidDataException {} // 警告：在 'throws' 子句中声明了未检查的异常 'InvalidDataException'\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowsRuntimeException",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/错误处理",
                      "index": 8,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NewObjectEquality",
                "shortDescription": {
                  "text": "使用 '==' 比较新对象"
                },
                "fullDescription": {
                  "text": "报告将 '==' 或 '!=' 应用于新分配对象而不是调用 'equals()' 的代码。 对新分配对象的引用不能指向现有对象，因此比较结果始终为 'false'。 该检查还可以报告从简单方法返回的新建对象。 示例： 'void test(Object obj) {\n    if (new Object() == obj) {...}\n  }' 在应用快速修复后： 'void test(Object obj) {\n    if (new Object().equals(obj)) {...}\n  }' 2018.3 最新变化",
                  "markdown": "报告将 `==` 或 `!=` 应用于新分配对象而不是调用 `equals()` 的代码。\n\n\n对新分配对象的引用不能指向现有对象，因此比较结果始终为 `false`。 该检查还可以报告从简单方法返回的新建对象。\n\n**示例：**\n\n\n      void test(Object obj) {\n        if (new Object() == obj) {...}\n      }\n\n在应用快速修复后：\n\n\n      void test(Object obj) {\n        if (new Object().equals(obj)) {...}\n      }\n\n\n2018.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NewObjectEquality",
                    "cweIds": [
                      480
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JNDIResource",
                "shortDescription": {
                  "text": "JNDI 资源已打开，但未安全关闭"
                },
                "fullDescription": {
                  "text": "报告未安全关闭的 JNDI 资源。 此检查报告的 JNDI 资源包括 'javax.naming.InitialContext'和 'javax.naming.NamingEnumeration'。 默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。 示例： 'Object findObject(Properties properties, String name) throws NamingException {\n    Context context = new InitialContext(properties); //上下文未关闭\n    return context.lookup(name);\n  }' 使用以下选项配置检查： 是否允许在 'try' 块内打开 JNDI 资源。 这种样式不太合意，因为它比在 'try' 块前面打开资源更冗长。 资源能否通过任何将资源作为实参传递的方法调用来关闭。",
                  "markdown": "报告未安全关闭的 JNDI 资源。 此检查报告的 JNDI 资源包括 `javax.naming.InitialContext`和 `javax.naming.NamingEnumeration`。\n\n\n默认情况下，该检查假定资源可以由名称中带有 'close' 或 'cleanup' 的任何方法关闭。\n\n**示例：**\n\n\n      Object findObject(Properties properties, String name) throws NamingException {\n        Context context = new InitialContext(properties); //上下文未关闭\n        return context.lookup(name);\n      }\n\n\n使用以下选项配置检查：\n\n* 是否允许在 `try` 块内打开 JNDI 资源。 这种样式不太合意，因为它比在 `try` 块前面打开资源更冗长。\n* 资源能否通过任何将资源作为实参传递的方法调用来关闭。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JNDIResourceOpenedButNotSafelyClosed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TryWithIdenticalCatches",
                "shortDescription": {
                  "text": "'try' 语句中的相同 'catch' 分支"
                },
                "fullDescription": {
                  "text": "报告单个 'try' 语句中相同的 'catch' 部分。 将这些部分折叠成一个 multi-catch 块可以减少代码重复，并防止出现一个 'catch' 部分更新而另一个部分未更新的情况。 示例： 'try {\n        doSmth();\n    }\n    catch (IOException e) {\n        LOG.error(e);\n    }\n    catch (URISyntaxException e) {\n        LOG.error(e);\n    }' 可通过快速修复使代码更加紧凑： 'try {\n        doSmth();\n    }\n    catch (IOException | URISyntaxException e) {\n        LOG.error(e);\n    }' 此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。",
                  "markdown": "报告单个 `try` 语句中相同的 `catch` 部分。\n\n将这些部分折叠成一个 *multi-catch* 块可以减少代码重复，并防止出现一个 `catch` 部分更新而另一个部分未更新的情况。\n\n**示例：**\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException e) {\n            LOG.error(e);\n        }\n        catch (URISyntaxException e) {\n            LOG.error(e);\n        }\n\n可通过快速修复使代码更加紧凑：\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException | URISyntaxException e) {\n            LOG.error(e);\n        }\n\n此检查取决于 Java 功能 '多 catch'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TryWithIdenticalCatches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 127,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantCompareCall",
                "shortDescription": {
                  "text": "冗余的 'compare()' 方法调用"
                },
                "fullDescription": {
                  "text": "报告其中的 'compare' 方法多余的比较。 示例： 'boolean result = Integer.compare(a, b) == 0;' 在应用快速修复后： 'boolean result = a == b;' 2018.2 最新变化",
                  "markdown": "报告其中的 `compare` 方法多余的比较。\n\n示例：\n\n\n      boolean result = Integer.compare(a, b) == 0;\n\n在应用快速修复后：\n\n\n      boolean result = a == b;\n\n2018.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantCompareCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LambdaCanBeReplacedWithAnonymous",
                "shortDescription": {
                  "text": "lambda 可被替换为匿名类"
                },
                "fullDescription": {
                  "text": "报告可以替换为匿名类的 lambda 表达式。 如果需要在匿名类中实现其他方法，则将 lambda 表达式扩展到匿名类会很有用。 示例： 's -> System.out.println(s)' 在应用快速修复后： 'new Consumer<String>() {\n  @Override\n  public void accept(String s) {\n    System.out.println(s);\n  }\n}' 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告可以替换为匿名类的 lambda 表达式。\n\n\n如果需要在匿名类中实现其他方法，则将 lambda 表达式扩展到匿名类会很有用。\n\n示例：\n\n\n      s -> System.out.println(s)\n\n在应用快速修复后：\n\n    new Consumer<String>() {\n      @Override\n      public void accept(String s) {\n        System.out.println(s);\n      }\n    }\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LambdaCanBeReplacedWithAnonymous",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextBlockBackwardMigration",
                "shortDescription": {
                  "text": "文本块可被替换为正则字符串文字"
                },
                "fullDescription": {
                  "text": "报告可以替换为常规字符串文字的文本块。 示例： 'Object obj = engine.eval(\"\"\"\n                           function hello() {\n                             print('\"Hello, world\"');\n                           }\n\n                           hello();\n                           \"\"\");' 在应用快速修复后： 'Object obj = engine.eval(\"function hello() {\\n\" +\n                           \"  print('\\\"Hello, world\\\"');\\n\" +\n                           \"}\\n\" +\n                           \"\\n\" +\n                           \"hello();\\n\");' 2019.3 最新变化 此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。",
                  "markdown": "报告可以替换为常规字符串文字的文本块。\n\n**示例：**\n\n\n      Object obj = engine.eval(\"\"\"\n                               function hello() {\n                                 print('\"Hello, world\"');\n                               }\n\n                               hello();\n                               \"\"\");\n\n在应用快速修复后：\n\n\n      Object obj = engine.eval(\"function hello() {\\n\" +\n                               \"  print('\\\"Hello, world\\\"');\\n\" +\n                               \"}\\n\" +\n                               \"\\n\" +\n                               \"hello();\\n\");\n\n2019.3 最新变化\n\n此检查取决于 Java 功能 '文本块文字'，该功能自 Java 15 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TextBlockBackwardMigration",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 15",
                      "index": 103,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyClass",
                "shortDescription": {
                  "text": "空类"
                },
                "fullDescription": {
                  "text": "报告空类和空 Java 文件。 如果一个类不包含任何字段、方法、构造函数或初始值设定项，则为空类。 在进行重大更改或重构后，空类有时会被保留下来。 示例： 'class Example {\n    List<String> getList() {\n       return new ArrayList<>() {\n\n       };\n    }\n  }' 在应用快速修复后： 'class Example {\n    List<String> getList() {\n       return new ArrayList<>();\n    }\n  }' 配置检查： 使用有注解时忽略选项可以指定特殊注解。 该检查将忽略用这些注解标记的类。 使用如果类是父类型的形参化，则将其忽略选项，可以忽略形参化超类的类。 示例： 'class MyList extends ArrayList<String> {}' 使用忽略 java.lang.Throwable 的子类，可以忽略扩展 'java.lang.Throwable' 的类。 使用注释计为内容选项可忽略包含注释的类。",
                  "markdown": "报告空类和空 Java 文件。\n\n如果一个类不包含任何字段、方法、构造函数或初始值设定项，则为空类。 在进行重大更改或重构后，空类有时会被保留下来。\n\n**示例：**\n\n\n      class Example {\n        List<String> getList() {\n           return new ArrayList<>() {\n\n           };\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Example {\n        List<String> getList() {\n           return new ArrayList<>();\n        }\n      }\n\n配置检查：\n\n* 使用**有注解时忽略**选项可以指定特殊注解。 该检查将忽略用这些注解标记的类。\n*\n  使用**如果类是父类型的形参化，则将其忽略**选项，可以忽略形参化超类的类。 示例：\n\n      class MyList extends ArrayList<String> {}\n\n* 使用**忽略 java.lang.Throwable 的子类** ，可以忽略扩展 `java.lang.Throwable` 的类。\n* 使用**注释计为内容**选项可忽略包含注释的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalCanBeOptional",
                "shortDescription": {
                  "text": "条件可被替换为 Optional"
                },
                "fullDescription": {
                  "text": "报告 null 检查条件并建议用 'Optional' 链替换它们。 示例： 'return str == null ? \"\" : str.trim();' 应用快速修复后： 'return Optional.ofNullable(str).map(String::trim).orElse(\"\");' 虽然替换并不总是更短，但它可能有助于进一步重构（例如，将方法返回值更改为 'Optional'）。 请注意，当条件的非 null 分支返回 null 值时，相应的映射步骤将产生一个空的 'Optional'，可能会改变语义。 如果不能静态证明保留语义，则快速修复操作名称将包含 “（可能更改语义）” 通知，并关闭检查高亮显示。 2018.1 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告 null 检查条件并建议用 `Optional` 链替换它们。\n\n示例：\n\n\n      return str == null ? \"\" : str.trim();\n\n应用快速修复后：\n\n\n      return Optional.ofNullable(str).map(String::trim).orElse(\"\");\n\n虽然替换并不总是更短，但它可能有助于进一步重构（例如，将方法返回值更改为 `Optional`）。\n\n请注意，当条件的非 null 分支返回 null 值时，相应的映射步骤将产生一个空的 `Optional`，可能会改变语义。 如果不能静态证明保留语义，则快速修复操作名称将包含 \"（可能更改语义）\" 通知，并关闭检查高亮显示。\n\n2018.1 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConditionalCanBeOptional",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToLambdaParameter",
                "shortDescription": {
                  "text": "赋值给 lambda 形参"
                },
                "fullDescription": {
                  "text": "报告对 lambda 形参的赋值或修改。 虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量所致。 该快速修复会添加新变量的声明。 示例： 'list.forEach(s -> {\n    s = s.trim();\n    System.out.println(\"String: \" + s);\n  });' 在应用快速修复后： 'list.forEach(s -> {\n    String trimmed = s.trim();\n    System.out.println(\"String: \" + trimmed);\n  });' 使用如果赋值是原始形参的转换，则忽略选项可以忽略根据先前值修改形参值的赋值。 此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。",
                  "markdown": "报告对 lambda 形参的赋值或修改。 虽然偶尔是有意为之，但此结构可能令人困惑，通常是由拼写错误或使用错误变量所致。\n\n该快速修复会添加新变量的声明。\n\n**示例：**\n\n\n      list.forEach(s -> {\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      });\n\n在应用快速修复后：\n\n\n      list.forEach(s -> {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      });\n\n使用**如果赋值是原始形参的转换，则忽略**选项可以忽略根据先前值修改形参值的赋值。\n\n此检查取决于 Java 功能 'Lambda 表达式'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToLambdaParameter",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/赋值问题",
                      "index": 65,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SystemGetenv",
                "shortDescription": {
                  "text": "调用 'System.getenv()'"
                },
                "fullDescription": {
                  "text": "报告对 'System.getenv()' 的调用。 对 'System.getenv()' 的调用本质上不可移植。",
                  "markdown": "报告对 `System.getenv()` 的调用。 对 `System.getenv()` 的调用本质上不可移植。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToSystemGetenv",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可移植性",
                      "index": 72,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantExpression",
                "shortDescription": {
                  "text": "可以对常量表达式求值"
                },
                "fullDescription": {
                  "text": "报告可静态求值的常量表达式，并建议将其替换为其实际值。 例如，系统会提示您将 '2 + 2' 替换为 '4'，或将 'Math.sqrt(9.0)' 替换为 '3.0'。 2018.1 最新变化",
                  "markdown": "报告可静态求值的常量表达式，并建议将其替换为其实际值。 例如，系统会提示您将 `2 + 2` 替换为 `4`，或将 `Math.sqrt(9.0)` 替换为 `3.0`。\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ConstantExpression",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageDotHtmlMayBePackageInfo",
                "shortDescription": {
                  "text": "'package.html' 可以转换为 'package-info.java'"
                },
                "fullDescription": {
                  "text": "报告用于记录软件包的任何 'package.html' 文件。 从 JDK 1.5 开始，建议您改用 'package-info.java' 文件，因为此类文件还可以包含软件包注解。 这样，package-info.java 就变成了软件包级别注解和文档的唯一仓库。 示例：'package.html' '<html>\n  <body>\n    Documentation example.\n  </body>\n</html>' 应用该快速修复后：'package-info.java' '/**\n * Documentation example.\n */\npackage com.sample;'",
                  "markdown": "报告用于记录软件包的任何 `package.html` 文件。\n\n从 JDK 1.5 开始，建议您改用 `package-info.java` 文件，因为此类文件还可以包含软件包注解。 这样，package-info.java 就变成了软件包级别注解和文档的唯一仓库。\n\n示例：`package.html`\n\n\n    <html>\n      <body>\n        Documentation example.\n      </body>\n    </html>\n\n应用该快速修复后：`package-info.java`\n\n\n    /**\n     * Documentation example.\n     */\n    package com.sample;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageDotHtmlMayBePackageInfo",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LongLiteralsEndingWithLowercaseL",
                "shortDescription": {
                  "text": "'long' 文字以 'l' 而不是 'L' 结尾"
                },
                "fullDescription": {
                  "text": "报告以小写 'l' 结尾的 'long' 文字。 这些文字可能令人困惑，因为小写的 'l' 与文字 '1'（一）非常相似。 示例： 'long nights = 100l;' 在应用快速修复后： 'long nights = 100L;'",
                  "markdown": "报告以小写 'l' 结尾的 `long` 文字。 这些文字可能令人困惑，因为小写的 'l' 与文字 '1'（一）非常相似。\n\n**示例：**\n\n\n      long nights = 100l;\n\n在应用快速修复后：\n\n\n      long nights = 100L;\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LongLiteralEndingWithLowercaseL",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantArrayCreation",
                "shortDescription": {
                  "text": "冗余数组创建"
                },
                "fullDescription": {
                  "text": "报告专门创建以作为 vararg 形参传递的数组。 示例： 'Arrays.asList(new String[]{\"Hello\", \"world\"})' 该快速修复会将数组初始值设定项替换为单个实参： 'Arrays.asList(\"Hello\", \"world\")'",
                  "markdown": "报告专门创建以作为 vararg 形参传递的数组。\n\n示例：\n\n`Arrays.asList(new String[]{\"Hello\", \"world\"})`\n\n该快速修复会将数组初始值设定项替换为单个实参：\n\n`Arrays.asList(\"Hello\", \"world\")`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantArrayCreation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonShortCircuitBoolean",
                "shortDescription": {
                  "text": "非短路布尔表达式"
                },
                "fullDescription": {
                  "text": "报告布尔 'and' 和 'or' 的非短路形式（'&'、'|'、'&=' 和 '|='）的用法。 尽管非短路版本偶尔有用，但在大多数情况下，本应使用短路形式（'&&' 和 '||'），此类无意的用法可能会导致难以捉摸的错误。 建议通过快速修复来使用短路版本。 示例： 'void foo(boolean x, boolean y, boolean z) {\n    if (x | y) { x |= z; }\n  }' 在应用快速修复后： 'void foo(boolean x, boolean y) {\n    if (x || y) { x = x || z; }\n  }'",
                  "markdown": "报告布尔 'and' 和 'or' 的非短路形式（`&`、`|`、`&=` 和 `|=`）的用法。 尽管非短路版本偶尔有用，但在大多数情况下，本应使用短路形式（`&&` 和 `||`），此类无意的用法可能会导致难以捉摸的错误。\n\n\n建议通过快速修复来使用短路版本。\n\n**示例：**\n\n\n      void foo(boolean x, boolean y, boolean z) {\n        if (x | y) { x |= z; }\n      }\n\n在应用快速修复后：\n\n\n      void foo(boolean x, boolean y) {\n        if (x || y) { x = x || z; }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonShortCircuitBooleanExpression",
                    "cweIds": [
                      480,
                      691
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowablePrintedToSystemOut",
                "shortDescription": {
                  "text": "'Throwable' 打印到 'System.out'"
                },
                "fullDescription": {
                  "text": "报告以异常作为实参的 'System.out.println()' 调用。 使用 print 语句记录异常会隐藏堆栈跟踪，这可能会使问题的调查变得复杂。 建议您改用记录器。 也会报告以异常作为实参的 'System.out.print()'、'System.err.println()' 和 'System.err.print()' 调用。 建议使用记录器来记录异常。 例如，不建议使用： 'try {\n      foo();\n  } catch (Exception e) {\n      System.out.println(e);\n  }' 用以下代码代替： 'try {\n      foo();\n  } catch (Exception e) {\n      logger.warn(e); // 记录器调用可能有所不同\n  }'",
                  "markdown": "报告以异常作为实参的 `System.out.println()` 调用。\n\n使用 print 语句记录异常会隐藏堆栈跟踪，这可能会使问题的调查变得复杂。\n建议您改用记录器。\n\n也会报告以异常作为实参的 `System.out.print()`、`System.err.println()` 和 `System.err.print()` 调用。 建议使用记录器来记录异常。\n\n例如，不建议使用：\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n          System.out.println(e);\n      }\n\n用以下代码代替：\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n          logger.warn(e); // 记录器调用可能有所不同\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowablePrintedToSystemOut",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantRecordConstructor",
                "shortDescription": {
                  "text": "冗余记录构造函数"
                },
                "fullDescription": {
                  "text": "报告在 Java 记录中声明的冗余构造函数。 示例 1： 'record Point(int x, int y) {\n    public Point {} // 可以移除\n  }\n  \n  record Point(int x, int y) {\n    public Point(int x, int y) { // 可以移除\n      this.x = x;\n      this.y = y;\n    }\n  }' 该快速修复会移除冗余的构造函数。 示例 2： '// 可以转换为压缩构造函数\n  record Range(int from, int to) {\n    public Range(int from, int to) {\n      if (from > to) throw new IllegalArgumentException();\n      this.from = from;\n      this.to = to;\n    }\n  }' 该快速修复会将此代码转换为紧凑构造函数。 2020.1 最新变化 此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。",
                  "markdown": "报告在 Java 记录中声明的冗余构造函数。\n\n**示例 1：**\n\n\n      record Point(int x, int y) {\n        public Point {} // 可以移除\n      }\n      \n      record Point(int x, int y) {\n        public Point(int x, int y) { // 可以移除\n          this.x = x;\n          this.y = y;\n        }\n      }\n\n该快速修复会移除冗余的构造函数。\n\n**示例 2：**\n\n\n       // 可以转换为压缩构造函数\n      record Range(int from, int to) {\n        public Range(int from, int to) {\n          if (from > to) throw new IllegalArgumentException();\n          this.from = from;\n          this.to = to;\n        }\n      }\n\n该快速修复会将此代码转换为紧凑构造函数。\n\n2020.1 最新变化\n\n此检查取决于 Java 功能 '记录'，该功能自 Java 16 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantRecordConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AmbiguousMethodCall",
                "shortDescription": {
                  "text": "对继承方法的调用类似于对本地方法的调用"
                },
                "fullDescription": {
                  "text": "如果在类周围的代码中存在具有相同签名的方法，则报告从匿名类、内部类或局部类对超类方法的调用。 在这种情况下，看似调用了来自周围代码的方法，而实际上调用的是来自超类的方法。 为了阐明代码的意图，建议对方法调用添加显式的 'super' 限定符。 示例： 'class Parent {\n    void ambiguous(){}\n  }\n\n  class Example {\n    void ambiguous(){}\n\n    class Inner extends Parent {\n      void example(){\n        ambiguous(); //警告\n      }\n    }\n  }' 在应用快速修复后： 'class Parent {\n    void ambiguous(){}\n  }\n\n  class Example {\n    void ambiguous(){}\n\n    class Inner extends Parent {\n      void example(){\n        super.ambiguous();\n      }\n    }\n  }'",
                  "markdown": "如果在类周围的代码中存在具有相同签名的方法，则报告从匿名类、内部类或局部类对超类方法的调用。 在这种情况下，看似调用了来自周围代码的方法，而实际上调用的是来自超类的方法。\n\n\n为了阐明代码的意图，建议对方法调用添加显式的 ` super ` 限定符。\n\n**示例：**\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            ambiguous(); //警告\n          }\n        }\n      }\n      \n在应用快速修复后：\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            super.ambiguous();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AmbiguousMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可见性",
                      "index": 74,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticInheritance",
                "shortDescription": {
                  "text": "静态继承"
                },
                "fullDescription": {
                  "text": "报告仅为提供对常量的访问而实现的接口。 这种继承常常令人困惑，可能隐藏重要的依赖关系信息。",
                  "markdown": "报告仅为提供对常量的访问而实现的接口。 这种继承常常令人困惑，可能隐藏重要的依赖关系信息。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticInheritance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/继承问题",
                      "index": 117,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantUnmodifiable",
                "shortDescription": {
                  "text": "不可修改的集合包装器的冗余用法"
                },
                "fullDescription": {
                  "text": "报告从 'Collections' 类对不可修改的集合包装器的冗余调用。 如果传递给不可修改的集合包装器的实参已不可变，此类包装会变得冗余。 示例： 'List<String> x = Collections.unmodifiableList(Collections.singletonList(\"abc\"));' 在应用快速修复后： 'List<String> x = Collections.singletonList(\"abc\");' 为了检测返回不可修改集合的方法，该检查使用 'org.jetbrains.annotations.Unmodifiable' 和 'org.jetbrains.annotations.UnmodifiableView' 注解。 使用它们将检查扩展为您自己的不可修改的集合包装器。 2020.3 最新变化",
                  "markdown": "报告从 `Collections` 类对不可修改的集合包装器的冗余调用。\n\n如果传递给不可修改的集合包装器的实参已不可变，此类包装会变得冗余。\n\n示例：\n\n\n      List<String> x = Collections.unmodifiableList(Collections.singletonList(\"abc\"));\n\n在应用快速修复后：\n\n\n      List<String> x = Collections.singletonList(\"abc\");\n\n为了检测返回不可修改集合的方法，该检查使用 `org.jetbrains.annotations.Unmodifiable`\n和 `org.jetbrains.annotations.UnmodifiableView` 注解。\n使用它们将检查扩展为您自己的不可修改的集合包装器。\n\n2020.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantUnmodifiable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantValue",
                "shortDescription": {
                  "text": "常量值"
                },
                "fullDescription": {
                  "text": "报告始终产生相同结果的表达式和条件，如 true、false、null 或零。 此类表达式可被替换为相应的常量值。 但通常情况下，它们表示代码中存在 bug。 示例： '// 始终为 true\n  // 根本原因：使用了 ||，而非 &&\n  if (x > 0 || x < 10) {}\n\n  System.out.println(str.trim());\n  // 始终为 false\n  // 根本原因：在 null 检查之前变量被取消引用\n  if (str == null) {}' 检查行为可能由许多注解控制，例如可 null 性注解、'@Contract' 注解、'@Range' 注解等。 配置检查： 使用不报告条件静态证明始终为 true 的断言选项可避免报告静态证明始终为 true 的断言。 这还包括 'if (alwaysFalseCondition) throw new IllegalArgumentException();' 等条件。 使用忽略 assert 语句选项可控制检查如何处理 'assert' 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。 使用当常量存储在变量中时发出警告选项可以在使用已知其值为常量的变量时显示警告。 在 IntelliJ IDEA 2022.3 版本之前，此检查为“常量条件和异常”检查的一部分。 现在，它被拆分成两个检查：“常量值”和“为 null 性和数据流问题”。",
                  "markdown": "报告始终产生相同结果的表达式和条件，如 true、false、null 或零。 此类表达式可被替换为相应的常量值。 但通常情况下，它们表示代码中存在 bug。\n\n示例：\n\n      // 始终为 true\n      // 根本原因：使用了 ||，而非 &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // 始终为 false\n      // 根本原因：在 null 检查之前变量被取消引用\n      if (str == null) {}\n\n\n检查行为可能由许多注解控制，例如[可 null 性](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html)注解、[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) 注解、`@Range` 注解等。\n\n配置检查：\n\n* 使用**不报告条件静态证明始终为 true 的断言** 选项可避免报告静态证明始终为 true 的断言。 这还包括 `if (alwaysFalseCondition) throw new IllegalArgumentException();` 等条件。\n* 使用**忽略 assert 语句** 选项可控制检查如何处理 `assert` 语句。 默认情况下，该选项被禁用，这意味着断言视为被执行（-ea 模式）。 如果启用该选项，断言将被完全忽略（-da 模式）。\n* 使用**当常量存储在变量中时发出警告**选项可以在使用已知其值为常量的变量时显示警告。\n\n\n在 IntelliJ IDEA 2022.3 版本之前，此检查为\"常量条件和异常\"检查的一部分。 现在，它被拆分成两个检查：\"常量值\"和\"为 null 性和数据流问题\"。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantValue",
                    "cweIds": [
                      570,
                      571
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CastCanBeReplacedWithVariable",
                "shortDescription": {
                  "text": "转换可被替换为变量"
                },
                "fullDescription": {
                  "text": "报告可被替换为具有相同值的现有局部或模式变量的类型转换运算。 示例： 'void foo(Object obj) {\n    String s = (String) obj;\n    System.out.println(((String) obj).trim());\n  }' 在应用快速修复后： 'void foo(Object obj) {\n    String s = (String) obj;\n    System.out.println(s.trim());\n  }' 2022.3 最新变化",
                  "markdown": "报告可被替换为具有相同值的现有局部或模式变量的类型转换运算。\n\n示例：\n\n\n      void foo(Object obj) {\n        String s = (String) obj;\n        System.out.println(((String) obj).trim());\n      }\n\n在应用快速修复后：\n\n\n      void foo(Object obj) {\n        String s = (String) obj;\n        System.out.println(s.trim());\n      }\n\n2022.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CastCanBeReplacedWithVariable",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Convert2Diamond",
                "shortDescription": {
                  "text": "显式类型可被替换为 '<>'"
                },
                "fullDescription": {
                  "text": "报告其类型实参可被替换为菱形类型 '<>' 的所有 'new' 表达式。 示例： 'List<String> list = new ArrayList<String>(); // 报告数组列表类型实参' 在应用快速修复后： 'List<String> list = new ArrayList<>();' 此检查取决于 Java 功能 'Diamond 类型'，该功能自 Java 7 起可用。",
                  "markdown": "报告其类型实参可被替换为菱形类型 `<>` 的所有 `new` 表达式。\n\n示例：\n\n\n      List<String> list = new ArrayList<String>(); // 报告数组列表类型实参\n\n在应用快速修复后：\n\n\n      List<String> list = new ArrayList<>();\n\n此检查取决于 Java 功能 'Diamond 类型'，该功能自 Java 7 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Convert2Diamond",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 7",
                      "index": 127,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VarargParameter",
                "shortDescription": {
                  "text": "vararg 方法"
                },
                "fullDescription": {
                  "text": "报告接受任意数量形参的方法（也称为 vararg 方法）。 示例： 'enum EnumConstants {\n  A(null), B, C;\n\n  EnumConstants(String... ss) {}\n}' 可通过快速修复将可变实参形参替换为等效的数组形参。 方法调用中的相关实参包装在数组初始值设定项表达式中。 在应用快速修复后： 'enum EnumConstants {\n  A(null), B(new String[]{}), C(new String[]{});\n\n  EnumConstants(String[] ss) {}\n}' Varargs 方法在 Java 5 中出现。 此检查有助于为向后兼容早期 Java 版本而降级。",
                  "markdown": "报告接受任意数量形参的方法（也称为 vararg 方法）。\n\n**示例：**\n\n\n      enum EnumConstants {\n      A(null), B, C;\n\n      EnumConstants(String... ss) {}\n    }\n\n可通过快速修复将可变实参形参替换为等效的数组形参。 方法调用中的相关实参包装在数组初始值设定项表达式中。\n在应用快速修复后：\n\n\n      enum EnumConstants {\n      A(null), B(new String[]{}), C(new String[]{});\n\n      EnumConstants(String[] ss) {}\n    }\n\n\n*Varargs 方法*在 Java 5 中出现。\n此检查有助于为向后兼容早期 Java 版本而降级。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VariableArgumentMethod",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级问题",
                      "index": 114,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ArrayLengthInLoopCondition",
                "shortDescription": {
                  "text": "循环条件下的 Array.length"
                },
                "fullDescription": {
                  "text": "报告对循环语句条件部分中数组的 '.length' 属性的访问。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 示例： 'void foo(Object[] x) {\n    for (int i = 0; i < x.length; i++) { /**/ }\n  }'",
                  "markdown": "报告对循环语句条件部分中数组的 `.length` 属性的访问。 在资源高度受限的环境中，此类调用可能会对性能产生不利影响。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n**示例：**\n\n\n      void foo(Object[] x) {\n        for (int i = 0; i < x.length; i++) { /**/ }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ArrayLengthInLoopCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckForOutOfMemoryOnLargeArrayAllocation",
                "shortDescription": {
                  "text": "没有 OutOfMemoryError 检查的大型数组分配"
                },
                "fullDescription": {
                  "text": "报告不检查 'java.lang.OutOfMemoryError' 的大型数组分配。 在内存受限的环境中，可能应该检查大数据对象的分配是否存在内存耗尽的情况。 此检查适用于 Java ME 和其他资源高度受限的环境。 不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。 使用该选项可以指定在未检查的数组分配中允许的最大元素数。",
                  "markdown": "报告不检查 `java.lang.OutOfMemoryError` 的大型数组分配。 在内存受限的环境中，可能应该检查大数据对象的分配是否存在内存耗尽的情况。\n\n\n此检查适用于 Java ME 和其他资源高度受限的环境。\n不加考虑地应用此检查的结果可能会对代码清晰度和设计产生负面影响。\n\n\n使用该选项可以指定在未检查的数组分配中允许的最大元素数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckForOutOfMemoryOnLargeArrayAllocation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/性能/嵌入式",
                      "index": 139,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassWithoutConstructor",
                "shortDescription": {
                  "text": "不带构造函数的类"
                },
                "fullDescription": {
                  "text": "报告没有构造函数的类。 某些编码标准禁止这种类。",
                  "markdown": "报告没有构造函数的类。\n\n某些编码标准禁止这种类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithoutConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/JavaBeans 问题",
                      "index": 110,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageInfoWithoutPackage",
                "shortDescription": {
                  "text": "不带 'package' 语句的 'package-info.java'"
                },
                "fullDescription": {
                  "text": "报告没有 'package' 语句的 'package-info.java' 文件。 即便该文件位于其他位置，Javadoc 工具也会考虑默认软件包的此类文件。",
                  "markdown": "报告没有 `package` 语句的 `package-info.java` 文件。\n\n\n即便该文件位于其他位置，Javadoc 工具也会考虑默认软件包的此类文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageInfoWithoutPackage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Javadoc",
                      "index": 59,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CloneReturnsClassType",
                "shortDescription": {
                  "text": "'clone()' 应当具有等于其所包含类的返回值类型"
                },
                "fullDescription": {
                  "text": "报告返回类型与其所在的类不同的 'clone()' 方法。 'clone()' 方法的返回类型通常为 'java.lang.Object'，这导致其难以被客户端使用。 Effective Java（第二版和第三版）建议将 'clone()' 方法的返回类型设为与其返回对象的类的类型相同。 示例： 'class Foo implements Cloneable {\n    public Object clone() {\n      try {\n        return super.clone();\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }' 在应用快速修复后： 'class Foo implements Cloneable {\n    public Foo clone() {\n      try {\n        return (Foo)super.clone();\n      } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n      }\n    }\n  }'",
                  "markdown": "报告返回类型与其所在的类不同的 `clone()` 方法。\n\n`clone()` 方法的返回类型通常为 `java.lang.Object`，这导致其难以被客户端使用。\n*Effective Java* （第二版和第三版）建议将 `clone()` 方法的返回类型设为与其返回对象的类的类型相同。\n\n**示例：**\n\n\n      class Foo implements Cloneable {\n        public Object clone() {\n          try {\n            return super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Foo implements Cloneable {\n        public Foo clone() {\n          try {\n            return (Foo)super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CloneReturnsClassType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/克隆问题",
                      "index": 89,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableWithSerializationMethods",
                "shortDescription": {
                  "text": "具有 'readObject()' 或 'writeObject()' 的不可序列化类"
                },
                "fullDescription": {
                  "text": "报告定义 'readObject()' 或 'writeObject()' 方法的非 'Serializable' 类。 该上下文中的此类方法通常表明有错误。 示例： 'public class SampleClass {\n    private void readObject(ObjectInputStream str) {}\n    private void writeObject(ObjectOutputStream str) {}\n  }'",
                  "markdown": "报告定义 `readObject()` 或 `writeObject()` 方法的非 `Serializable` 类。 该上下文中的此类方法通常表明有错误。\n\n**示例：**\n\n\n      public class SampleClass {\n        private void readObject(ObjectInputStream str) {}\n        private void writeObject(ObjectOutputStream str) {}\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableClassWithSerializationMethods",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalToIf",
                "shortDescription": {
                  "text": "'Optional' 可被替换为 'if' 语句序列"
                },
                "fullDescription": {
                  "text": "报告可替换为 'if' 语句序列的 'Optional' 调用链。 示例： 'return Optional.ofNullable(name)\n    .map(this::extractInitials)\n    .map(initials -> initials.toUpperCase(Locale.ENGLISH))\n    .orElseGet(this::getDefault);' 在应用快速修复后： 'if (name != null) {\n    String initials = extractInitials(name);\n    if (initials != null) return initials.toUpperCase(Locale.ENGLISH);\n  }\n  return getDefault();' 此检查有助于为向后兼容早期 Java 版本而降级。 2020.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告可替换为 `if` 语句序列的 `Optional` 调用链。\n\n示例：\n\n\n      return Optional.ofNullable(name)\n        .map(this::extractInitials)\n        .map(initials -> initials.toUpperCase(Locale.ENGLISH))\n        .orElseGet(this::getDefault);\n\n在应用快速修复后：\n\n\n      if (name != null) {\n        String initials = extractInitials(name);\n        if (initials != null) return initials.toUpperCase(Locale.ENGLISH);\n      }\n      return getDefault();\n\n\n此检查有助于为向后兼容早期 Java 版本而降级。\n\n2020.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "OptionalToIf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IllegalDependencyOnInternalPackage",
                "shortDescription": {
                  "text": "对内部软件包的非法依赖"
                },
                "fullDescription": {
                  "text": "报告软件包上不包含 'module-info.java' 且未从命名模块中导出的模块中的引用。 当项目中的某些模块已经迁移到 Java 模块，而其他模块仍然处于非模块化状态时，可能会出现此类配置。 与 JDK 类似，此类非模块化代码不得访问命名模块中未显式导出的代码。",
                  "markdown": "报告软件包上不包含 `module-info.java` 且未从命名模块中导出的模块中的引用。\n\n当项目中的某些模块已经迁移到 Java 模块，而其他模块仍然处于非模块化状态时，可能会出现此类配置。\n与 JDK 类似，此类非模块化代码不得访问命名模块中未显式导出的代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "IllegalDependencyOnInternalPackage",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BigDecimalMethodWithoutRoundingCalled",
                "shortDescription": {
                  "text": "'BigDecimal' 方法调用没有舍入模式实参"
                },
                "fullDescription": {
                  "text": "报告对没有舍入模式实参的 'divide()' 或 'setScale()' 的调用。 在结果中不能表示精确值时（例如由于具有非终止十进制扩展），此类调用可能导致 'ArithmeticException'。 指定舍入模式可防止 'ArithmeticException'。 示例： 'BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));'",
                  "markdown": "报告对没有舍入模式实参的 `divide()` 或 `setScale()` 的调用。\n\n在结果中不能表示精确值时（例如由于具有非终止十进制扩展），此类调用可能导致 `ArithmeticException`。\n\n指定舍入模式可防止 `ArithmeticException`。\n\n**示例：**\n\n\n      BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BigDecimalMethodWithoutRoundingCalled",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexArithmeticExpression",
                "shortDescription": {
                  "text": "过于复杂的算术表达式"
                },
                "fullDescription": {
                  "text": "报告具有过多项的算术表达式。 此类表达式可能难以理解并且可能包含错误。 形参、字段引用和其他主要表达式均计为一项。 示例： 'int calc(int a, int b) {\n        return a + a + a + b + b + b + b; // 该行包含 7 个项并将被报告。\n    }' 使用下面的字段可指定算术表达式中允许的项数。",
                  "markdown": "报告具有过多项的算术表达式。 此类表达式可能难以理解并且可能包含错误。\n\n形参、字段引用和其他主要表达式均计为一项。\n\n**示例：**\n\n    int calc(int a, int b) {\n            return a + a + a + b + b + b + b; // 该行包含 7 个项并将被报告。\n        }\n\n使用下面的字段可指定算术表达式中允许的项数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexArithmeticExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数值问题",
                      "index": 18,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DriverManagerGetConnection",
                "shortDescription": {
                  "text": "使用 'DriverManager' 获取 JDBC 连接"
                },
                "fullDescription": {
                  "text": "报告任何使用 'java.sql.DriverManager' 获取 JDBC 连接的情况。 'java.sql.DriverManager' 已被 'javax.sql.Datasource' 取代，后者允许连接池和其他优化。 示例： 'Connection conn = DriverManager.getConnection(url, username, password);'",
                  "markdown": "报告任何使用 `java.sql.DriverManager` 获取 JDBC 连接的情况。\n\n\n`java.sql.DriverManager` 已被 `javax.sql.Datasource` 取代，后者允许连接池和其他优化。\n\n**示例：**\n\n      Connection conn = DriverManager.getConnection(url, username, password);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToDriverManagerGetConnection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/资源管理",
                      "index": 106,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreadDumpStack",
                "shortDescription": {
                  "text": "调用 'Thread.dumpStack()'"
                },
                "fullDescription": {
                  "text": "报告 'Thread.dumpStack()' 的用法。 此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。",
                  "markdown": "报告 `Thread.dumpStack()` 的用法。\n\n此类语句通常用于临时调试，应当从生产代码中移除，或者替换为更稳健的日志记录工具。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallToThreadDumpStack",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalMethodInFinalClass",
                "shortDescription": {
                  "text": "'final' 类位于 'final' 方法中"
                },
                "fullDescription": {
                  "text": "报告 'final' 类中的 'final' 方法。 由于不能继承 'final' 类，将方法标记为 'final' 可能是多余之举，而且令人困惑。 示例： 'record Bar(int a, int b) {\n  public final int sum() { \n     return a + b;\n  }\n}'\n 在应用快速修复后： 'record Bar(int a, int b) {\n  public int sum() { \n     return a + b;\n  }\n}' 如本例所示，可以显式或隐式地将类标记为 'final'。",
                  "markdown": "报告 `final` 类中的 `final` 方法。\n\n由于不能继承 `final` 类，将方法标记为 `final` 可能是多余之举，而且令人困惑。\n\n**示例：**\n\n    record Bar(int a, int b) {\n      public final int sum() { \n         return a + b;\n      }\n    }\n\n在应用快速修复后：\n\n    record Bar(int a, int b) {\n      public int sum() { \n         return a + b;\n      }\n    }\n\n如本例所示，可以显式或隐式地将类标记为 `final`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalMethodInFinalClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryBlockStatement",
                "shortDescription": {
                  "text": "不必要的代码块"
                },
                "fullDescription": {
                  "text": "报告对程序的语义冗余的代码块，并且可以用其内容替换。 作为 'if'、'do'、'while' 或 'for' 语句主体的代码块将不会被此检查报告。 示例： 'void foo() {\n    { // 不必要\n      int result = call();\n      analyze(result);\n    } // 不必要\n  }' 配置检查： 使用 忽略 'switch' 语句的分支 选项来忽略用作 switch 语句分支的代码块。",
                  "markdown": "报告对程序的语义冗余的代码块，并且可以用其内容替换。\n\n作为 `if`、`do`、`while` 或 `for` 语句主体的代码块将不会被此检查报告。\n\n示例：\n\n\n      void foo() {\n        { // 不必要\n          int result = call();\n          analyze(result);\n        } // 不必要\n      }\n\n配置检查：\n\n\n使用 **忽略 'switch' 语句的分支** 选项来忽略用作 switch 语句分支的代码块。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UnnecessaryCodeBlock",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FinalPrivateMethod",
                "shortDescription": {
                  "text": "'private' 方法被声明为 'final'"
                },
                "fullDescription": {
                  "text": "报告同时标有 'final' 和 'private' 关键字的方法。 由于 'private' 方法因其可见性而无法被有意义地重写，因此将它们声明为 'final' 是冗余的。",
                  "markdown": "报告同时标有 `final` 和 `private` 关键字的方法。\n\n由于 `private` 方法因其可见性而无法被有意义地重写，因此将它们声明为 `final` 是冗余的。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalPrivateMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryUnboxing",
                "shortDescription": {
                  "text": "不必要的拆箱"
                },
                "fullDescription": {
                  "text": "报告取消装箱，即显式解开已环绕的基元值。 对于 Java 5 和更高版本，拆箱不必要，并且可以安全移除。 示例： 'Integer i = Integer.valueOf(42).intValue();' → 'Integer i = Integer.valueOf(42);' 'int k = Integer.valueOf(42).intValue();' → 'int k = Integer.valueOf(42);' （仅在未选中仅报告真正多余的拆箱表达式选项时报告） 使用仅报告真正多余的拆箱表达式选项，可仅报告真正多余的拆箱，其中的拆箱值立即隐式或显式地装箱。 在本例中，可以移除整个拆箱-装箱步骤。 该检查不报告简单的显式拆箱。 仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。",
                  "markdown": "报告取消装箱，即显式解开已环绕的基元值。\n\n对于 Java 5 和更高版本，拆箱不必要，并且可以安全移除。\n\n**示例：**\n\n* `Integer i = Integer.valueOf(42).intValue();` → `Integer i = Integer.valueOf(42);`\n* `int k = Integer.valueOf(42).intValue();` → `int k = Integer.valueOf(42);`\n\n  （仅在未选中**仅报告真正多余的拆箱表达式**选项时报告）\n\n\n使用**仅报告真正多余的拆箱表达式**选项，可仅报告真正多余的拆箱，其中的拆箱值立即隐式或显式地装箱。\n在本例中，可以移除整个拆箱-装箱步骤。 该检查不报告简单的显式拆箱。\n\n仅当项目或模块的语言级别为 5 或更高时，此检查才会报告。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryUnboxing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 5",
                      "index": 92,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentOrReturnOfFieldWithMutableType",
                "shortDescription": {
                  "text": "具有可变类型的字段的赋值或返回"
                },
                "fullDescription": {
                  "text": "报告从方法形参到数组或可变类型（如 'Collection'、'Date'、'Map'、'Calendar' 等）的返回或赋值 由于这种类型是可变的，此结构可能会导致来自所属类之外的对象状态发生意外修改。 尽管出于性能原因，此结构可能很有用，但它本质上很容易出现错误。 报告了以下可变类型： 'java.util.Date' 'java.util.Calendar' 'java.util.Collection' 'java.util.Map' 'com.google.common.collect.Multimap' 'com.google.common.collect.Table' 该快速修复会添加对字段的 '.clone()' 方法的调用。 示例： 'class Log {\n    String[] messages;\n    ...\n\n    String[] getMessages() {\n      return messages; // 警告：返回 String[] 字段 'messages'\n    }\n  }' 在应用快速修复后： 'class Log {\n    String[] messages;\n    ...\n\n    String[] getMessages() {\n      return messages.clone();\n    }\n  }' 使用忽略 private 方法中的赋值和返回值选项可忽略 'private'方法中的赋值和返回值。",
                  "markdown": "报告从方法形参到数组或可变类型（如 `Collection`、`Date`、`Map`、`Calendar` 等）的返回或赋值\n\n由于这种类型是可变的，此结构可能会导致来自所属类之外的对象状态发生意外修改。 尽管出于性能原因，此结构可能很有用，但它本质上很容易出现错误。\n\n报告了以下可变类型：\n\n* `java.util.Date`\n* `java.util.Calendar`\n* `java.util.Collection`\n* `java.util.Map`\n* `com.google.common.collect.Multimap`\n* `com.google.common.collect.Table`\n\n该快速修复会添加对字段的 `.clone()` 方法的调用。\n\n**示例：**\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages; // 警告：返回 String[] 字段 'messages'\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages.clone();\n        }\n      }\n\n使用**忽略 private 方法中的赋值和返回值** 选项可忽略 `private`方法中的赋值和返回值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentOrReturnOfFieldWithMutableType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/封装",
                      "index": 96,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OptionalAssignedToNull",
                "shortDescription": {
                  "text": "Optional 类型的 null 值"
                },
                "fullDescription": {
                  "text": "报告 'null' 分配给 'Optional' 变量或从返回 'Optional' 的方法返回。 建议您使用 'Optional.empty()'（或 'Optional.absent()' 用于 Guava）来表示空值。 示例： 'Optional<Integer> foo(boolean flag) {\n    return flag ? Optional.of(42) : null;\n  }' 在应用快速修复后： 'Optional<Integer> foo(boolean flag) {\n    return flag ? Optional.of(42) : Optional.empty();\n  }' 配置检查： 使用 报告 Optional 与 null 的比较 选项还可以报告'optional == null' 之类的比较。 虽然在极少数情况下（例如延迟初始化的可选字段）这可能是正确的，但可选变量通常不会为 null，并且可能应为 'optional.isPresent()'。 2017.2 最新变化 此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。",
                  "markdown": "报告 `null` 分配给 `Optional` 变量或从返回 `Optional` 的方法返回。\n\n建议您使用 `Optional.empty()`（或 `Optional.absent()` 用于 Guava）来表示空值。\n\n示例：\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : null;\n      }\n\n在应用快速修复后：\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : Optional.empty();\n      }\n\n配置检查：\n\n\n使用 **报告 Optional 与 null 的比较** 选项还可以报告`optional == null` 之类的比较。 虽然在极少数情况下（例如延迟初始化的可选字段）这可能是正确的，但可选变量通常不会为 null，并且可能应为 `optional.isPresent()`。\n\n2017.2 最新变化\n\n此检查取决于 Java 功能 '流和可选 API'，该功能自 Java 8 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OptionalAssignedToNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessIndexOfComparison",
                "shortDescription": {
                  "text": "无意义的 'indexOf()' 比较"
                },
                "fullDescription": {
                  "text": "报告与 '.indexOf()' 表达式的不必要比较。 此类表达式的一个示例是将 '.indexOf()' 的结果与小于 -1 的数字进行比较。",
                  "markdown": "报告与 `.indexOf()` 表达式的不必要比较。 此类表达式的一个示例是将 `.indexOf()` 的结果与小于 -1 的数字进行比较。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessIndexOfComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EqualsAndHashcode",
                "shortDescription": {
                  "text": "'equals()' 和 'hashCode()' 未配对"
                },
                "fullDescription": {
                  "text": "报告重写 'equals()' 方法但不重写 'hashCode()' 方法的类，反之亦然。将类添加到 'Collection' 或 'HashMap' 时，可能会导致问题。 该快速修复会为不存在的方法生成默认实现。 示例： 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' 在应用快速修复后： 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
                  "markdown": "报告重写 `equals()` 方法但不重写 `hashCode()` 方法的类，反之亦然。将类添加到 `Collection` 或 `HashMap` 时，可能会导致问题。\n\n该快速修复会为不存在的方法生成默认实现。\n\n示例：\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n    }\n\n在应用快速修复后：\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof StringHolder)) return false;\n\n        StringHolder holder = (StringHolder)o;\n\n        if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n        return true;\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualsAndHashcode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IteratorHasNextCallsIteratorNext",
                "shortDescription": {
                  "text": "调用 'next()' 的 'Iterator.hasNext()'"
                },
                "fullDescription": {
                  "text": "报告迭代器实例上调用 'Iterator.next()' 或 'ListIterator.previous()' 的 'Iterator.hasNext()' 或 'ListIterator.hasPrevious()' 的实现。 此类调用几乎肯定是错误，因为 'hasNext()' 之类的方法不应修改迭代器状态，而 'next()' 应修改迭代器状态。 示例： 'class MyIterator implements Iterator<Integer> {\n    public boolean hasNext() {\n      return next() != null;\n    }\n  }'",
                  "markdown": "报告迭代器实例上调用 `Iterator.next()` 或 `ListIterator.previous()` 的 `Iterator.hasNext()` 或 `ListIterator.hasPrevious()` 的实现。 此类调用几乎肯定是错误，因为 `hasNext()` 之类的方法不应修改迭代器状态，而 `next()` 应修改迭代器状态。\n\n**示例：**\n\n\n      class MyIterator implements Iterator<Integer> {\n        public boolean hasNext() {\n          return next() != null;\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IteratorHasNextCallsIteratorNext",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringRepeatCanBeUsed",
                "shortDescription": {
                  "text": "可以使用 String.repeat()"
                },
                "fullDescription": {
                  "text": "报告可以替换为单一 'String.repeat()' 方法的循环（自 Java 11 起提供）。 示例： 'void append(StringBuilder sb, int count, Object obj) {\n    for (int i = 0; i < count; i++) {\n      sb.append(obj);\n    }\n  }' 在应用快速修复后： 'void append(StringBuilder sb, int count, Object obj) {\n    sb.append(String.valueOf(obj).repeat(Math.max(0, count)));\n  }' 默认情况下，如果不能静态地证明 'count' 非负，则该检查可以使用 'Math.max(0, count)' 来包装 'count'。 这样做的目的是防止可能发生的语义更改，因为 'String.repeat()' 拒绝负数。 必要时，可使用添加 Math.max(0, count) 以避免可能的语义更改选项禁用此行为。 同样，如果不知道要重复的字符串能否为 'null'，可将其包装在 'String.valueOf' 中，以防止可能发生的 'NullPointerException'。 仅当项目或模块的语言级别为 11 或更高时，此检查才会报告。 2019.1 最新变化",
                  "markdown": "报告可以替换为单一 `String.repeat()` 方法的循环（自 Java 11 起提供）。\n\n**示例：**\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        for (int i = 0; i < count; i++) {\n          sb.append(obj);\n        }\n      }\n\n在应用快速修复后：\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        sb.append(String.valueOf(obj).repeat(Math.max(0, count)));\n      }\n\n\n默认情况下，如果不能静态地证明 `count` 非负，则该检查可以使用 `Math.max(0, count)` 来包装 `count`。 这样做的目的是防止可能发生的语义更改，因为 `String.repeat()` 拒绝负数。\n必要时，可使用**添加 Math.max(0, count) 以避免可能的语义更改**选项禁用此行为。\n\n同样，如果不知道要重复的字符串能否为 `null`，可将其包装在 `String.valueOf` 中，以防止可能发生的 `NullPointerException`。\n\n仅当项目或模块的语言级别为 11 或更高时，此检查才会报告。\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringRepeatCanBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 11",
                      "index": 145,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MathRoundingWithIntArgument",
                "shortDescription": {
                  "text": "使用 'int' 实参调用数学舍入"
                },
                "fullDescription": {
                  "text": "报告对以 'int' 为实参的 'Math' 和 'StrictMath' 的 'round()'、'ceil()'、 'floor()'、'rint()' 方法的调用。 这些方法可以在预期实参为 'long' 或 'double' 的情况下调用，且可能会产生意外结果。 该检查提供了一种修复，能够将此类表达式（除了 'round'）简化为转换成 'double'。 示例： 'int i = 2;\n  double d1 = Math.floor(i);' 在应用快速修复后： 'int i = 2;\n  double d1 = i;' 2023.1 最新变化",
                  "markdown": "报告对以 `int` 为实参的 `Math` 和 `StrictMath` 的 `round()`、`ceil()`、 `floor()`、`rint()` 方法的调用。\n\n这些方法可以在预期实参为 `long` 或 `double` 的情况下调用，且可能会产生意外结果。\n\n该检查提供了一种修复，能够将此类表达式（除了 `round`）简化为转换成 `double`。\n\n**示例：**\n\n\n      int i = 2;\n      double d1 = Math.floor(i);\n\n在应用快速修复后：\n\n\n      int i = 2;\n      double d1 = i;\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MathRoundingWithIntArgument",
                    "cweIds": [
                      681
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SynchronizationOnStaticField",
                "shortDescription": {
                  "text": "在 'static' 字段上同步"
                },
                "fullDescription": {
                  "text": "报告 'static' 字段的同步。 虽然并非完全不正确，但 'static' 字段上的同步可能会因争用而导致性能不佳。",
                  "markdown": "报告 `static` 字段的同步。 虽然并非完全不正确，但 `static` 字段上的同步可能会因争用而导致性能不佳。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SynchronizationOnStaticField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithConfusingDeclaration",
                "shortDescription": {
                  "text": "在不同 'switch' 分支中使用并声明的局部变量"
                },
                "fullDescription": {
                  "text": "报告在 'switch' 语句的一个分支中声明并在另一个分支中使用的局部变量。 此类声明可能格外令人困惑。 示例： 'switch(i) {\n      case 2:\n          int x = 0;\n          break;\n      case 3:\n          x = 3;\n          System.out.println(x);\n          break;\n    }'",
                  "markdown": "报告在 `switch` 语句的一个分支中声明并在另一个分支中使用的局部变量。 此类声明可能格外令人困惑。\n\n示例：\n\n\n        switch(i) {\n          case 2:\n              int x = 0;\n              break;\n          case 3:\n              x = 3;\n              System.out.println(x);\n              break;\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableUsedAndDeclaredInDifferentSwitchBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldMayBeFinal",
                "shortDescription": {
                  "text": "字段可能为 'final'"
                },
                "fullDescription": {
                  "text": "报告可以安全地设为 'final' 的字段。 所有 'final' 字段都应具有一个不会更改的值，从而使代码更易于推理。 为避免分析开销过大，此检查仅报告字段是否具有 'private' 修饰符或者是否在局部类或匿名类中定义。 如果满足以下条件，字段可以为 'final'： 字段为 'static'，并在其声明或 'static' 初始值设定项中进行了一次初始化。 字段为非 'static'，并在其声明、实例初始值设定项或每个构造函数中进行了一次初始化 并且字段未在其他任何地方进行修改。 示例： 'public class Person {\n    private String name; // 可以为 final\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n  }' 在应用快速修复后： 'public class Person {\n    private final String name;\n\n    Person(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n  }' 使用“注解”按钮修改假定隐式字段写入的注解列表。",
                  "markdown": "报告可以安全地设为 `final` 的字段。 所有 `final` 字段都应具有一个不会更改的值，从而使代码更易于推理。\n\n为避免分析开销过大，此检查仅报告字段是否具有 `private` 修饰符或者是否在局部类或匿名类中定义。\n如果满足以下条件，字段可以为 `final`：\n\n* 字段为 `static`，并在其声明或 `static` 初始值设定项中进行了一次初始化。\n* 字段为非 `static`，并在其声明、实例初始值设定项或每个构造函数中进行了一次初始化\n\n并且字段未在其他任何地方进行修改。\n\n**示例：**\n\n\n      public class Person {\n        private String name; // 可以为 final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n在应用快速修复后：\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\n使用\"注解\"按钮修改假定隐式字段写入的注解列表。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldMayBeFinal",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousArrayMethodCall",
                "shortDescription": {
                  "text": "可疑的 'Arrays' 方法调用"
                },
                "fullDescription": {
                  "text": "报告对 'Arrays.fill()' 等实参类型不匹配的非泛型数组操作方法的调用。 此类调用不会执行任何有用的工作，很可能是错误的。 示例： 'int foo(String[] strings) {\n    return Arrays.binarySearch(strings, 1);\n  }' 2017.2 最新变化",
                  "markdown": "报告对 `Arrays.fill()` 等实参类型不匹配的非泛型数组操作方法的调用。 此类调用不会执行任何有用的工作，很可能是错误的。\n\n**示例：**\n\n\n      int foo(String[] strings) {\n        return Arrays.binarySearch(strings, 1);\n      }\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousArrayMethodCall",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ClassHasNoToStringMethod",
                "shortDescription": {
                  "text": "类不会重写 'toString()' 方法"
                },
                "fullDescription": {
                  "text": "报告没有 'toString()' 方法的类。",
                  "markdown": "报告没有 `toString()` 方法的类。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassHasNoToStringMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/toString() 问题",
                      "index": 165,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldAccessNotGuarded",
                "shortDescription": {
                  "text": "不受保护的字段访问或方法调用"
                },
                "fullDescription": {
                  "text": "报告对声明为 '@GuardedBy' 且不受适当同步结构保护的字段的访问。 示例： '@GuardedBy(\"this\")\n    void x() {\n        notify();\n    }\n    void y() {\n        x(); // 不受保护的方法调用\n    }' 支持的 '@GuardedBy' 注解是： 'net.jcip.annotations.GuardedBy' 'javax.annotation.concurrent.GuardedBy' 'org.apache.http.annotation.GuardedBy' 'com.android.annotations.concurrency.GuardedBy' 'androidx.annotation.GuardedBy' 'com.google.errorprone.annotations.concurrent.GuardedBy'",
                  "markdown": "报告对声明为 `@GuardedBy` 且不受适当同步结构保护的字段的访问。\n\n示例：\n\n\n        @GuardedBy(\"this\")\n        void x() {\n            notify();\n        }\n        void y() {\n            x(); // 不受保护的方法调用\n        }\n\n支持的 `@GuardedBy` 注解是：\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FieldAccessNotGuarded",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/并发注解问题",
                      "index": 76,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicStaticArrayField",
                "shortDescription": {
                  "text": "'public static' 数组字段"
                },
                "fullDescription": {
                  "text": "报告 'public' 'static' 数组字段。 此类字段通常用于存储常量值数组。 尽管如此，它们仍然存在安全隐患，因为它们的内容可能会被修改，即使该字段被声明为 'final'。 示例： 'public static String[] allowedPasswords = {\"foo\", \"bar\"};'",
                  "markdown": "报告 `public` `static` 数组字段。\n\n\n此类字段通常用于存储常量值数组。 尽管如此，它们仍然存在安全隐患，因为它们的内容可能会被修改，即使该字段被声明为 `final`。\n\n**示例：**\n\n\n      public static String[] allowedPasswords = {\"foo\", \"bar\"};\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicStaticArrayField",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/安全性",
                      "index": 29,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicNumber",
                "shortDescription": {
                  "text": "幻数"
                },
                "fullDescription": {
                  "text": "报告“幻数”：未通过常量声明来命名的数值文字。 使用幻数会导致代码不清晰，并且如果幻数在一个位置更改但在另一个位置保持不变，则会导致错误。 此检查不会报告数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、0L、1L、2L、0.0、1.0、0.0F 和 1.0F。 示例： 'void checkFileSize(long bytes) {\n    if (bytes > 1_048_576) {\n      throw new IllegalArgumentException(\"too big\");\n    }\n  }' 快速修复引入了一个新常量： 'static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;\n\n  void checkFileSize(long bytes) {\n    if (bytes > MAX_SUPPORTED_FILE_SIZE) {\n      throw new IllegalArgumentException(\"too big\");\n    }\n  }' 配置检查： 使用忽略 'hashCode()' 方法中的常量选项可在 'hashCode()' 方法中禁用此检查。 使用在注解中忽略选项可以忽略注解中的幻数。 在构造 'Collection'、'Map'、'StringBuilder' 或 'StringBuffer' 对象时，使用忽略 StringBuilders 和 Collections 的初始容量选项可以忽略用作初始容量的幻数。",
                  "markdown": "报告\"幻数\"：未通过常量声明来命名的数值文字。\n\n使用幻数会导致代码不清晰，并且如果幻数在一个位置更改但在另一个位置保持不变，则会导致错误。 此检查不会报告数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、0L、1L、2L、0.0、1.0、0.0F 和 1.0F。\n\n示例：\n\n\n      void checkFileSize(long bytes) {\n        if (bytes > 1_048_576) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\n快速修复引入了一个新常量：\n\n\n      static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;\n\n      void checkFileSize(long bytes) {\n        if (bytes > MAX_SUPPORTED_FILE_SIZE) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\n配置检查：\n\n* 使用**忽略 'hashCode()' 方法中的常量** 选项可在 `hashCode()` 方法中禁用此检查。\n* 使用**在注解中忽略**选项可以忽略注解中的幻数。\n* 在构造 `Collection`、`Map`、`StringBuilder` 或 `StringBuffer` 对象时，使用**忽略 StringBuilders 和 Collections 的初始容量**选项可以忽略用作初始容量的幻数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicNumber",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/抽象问题",
                      "index": 63,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EnumSwitchStatementWhichMissesCases",
                "shortDescription": {
                  "text": "缺少 case 的枚举 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告为不详尽的枚举类型执行的 'switch' 语句。 示例： 'enum AlphaBetaGamma {\n    A, B, C;\n\n    void x(AlphaBetaGamma e) {\n      switch (e) {\n\n      }\n    }\n  }' 在应用快速修复后： 'enum AlphaBetaGamma {\n    A, B, C;\n\n    void x(AlphaBetaGamma e) {\n      switch (e) {\n        case A -> {}\n        case B -> {}\n        case C -> {}\n      }\n    }\n  }' 使用 忽略具有默认分支的 switch 语句 选项忽略具有 'default' 分支的 'switch' 语句。 此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。",
                  "markdown": "报告为不详尽的枚举类型执行的 `switch` 语句。\n\n**示例：**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\n在应用快速修复后：\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\n使用 **忽略具有默认分支的 switch 语句** 选项忽略具有 `default` 分支的 `switch` 语句。\n\n\n此检查取决于 Java 功能 '枚举'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EnumSwitchStatementWhichMissesCases",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodWithMultipleLoops",
                "shortDescription": {
                  "text": "具有多个循环的方法"
                },
                "fullDescription": {
                  "text": "报告包含多个循环语句的方法。 示例： 以下方法将被报告，因为它包含两个循环： 'void methodWithTwoLoops(int n1, int n2) {\n    for (int i = 0; i < n1; i++) {\n      System.out.println(i);\n    }\n\n    int j = 0;\n    while (j < n2) {\n      System.out.println(j);\n      j++;\n    }\n  }' 以下方法也会被报告，因为它包含嵌套循环： 'void methodWithNestedLoop(int n1, int n2) {\n    for (int i = 0; i < n1; i++) {\n      for (int j = 0; j < n2; j++) {\n        System.out.println(i + j);\n      }\n    }\n  }'",
                  "markdown": "报告包含多个循环语句的方法。\n\n**示例：**\n\n以下方法将被报告，因为它包含两个循环：\n\n\n      void methodWithTwoLoops(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          System.out.println(i);\n        }\n\n        int j = 0;\n        while (j < n2) {\n          System.out.println(j);\n          j++;\n        }\n      }\n\n以下方法也会被报告，因为它包含嵌套循环：\n\n\n      void methodWithNestedLoop(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          for (int j = 0; j < n2; j++) {\n            System.out.println(i + j);\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodWithMultipleLoops",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/方法指标",
                      "index": 104,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousIntegerDivAssignment",
                "shortDescription": {
                  "text": "可疑的整数除法赋值"
                },
                "fullDescription": {
                  "text": "报告其右侧是不应截断为整数的除法的赋值。 虽然偶尔是有意为之，但此结构通常表明有错误。 示例： 'int x = 18;\n  x *= 3/2; // 不会因为整数除法的结果而改变 x' 此代码应替换为： 'int x = 18;\n  x *= 3.0/2;' 在检查选项中，可以禁用对可疑但可能正确的除法的警告，例如不能静态计算被除数时。 'void calc(int d) {\n     int x = 18;\n     x *= d/2;\n  }' 2019.2 最新变化",
                  "markdown": "报告其右侧是不应截断为整数的除法的赋值。\n\n虽然偶尔是有意为之，但此结构通常表明有错误。\n\n**示例：**\n\n\n      int x = 18;\n      x *= 3/2; // 不会因为整数除法的结果而改变 x\n\n\n此代码应替换为：\n\n\n      int x = 18;\n      x *= 3.0/2;\n\n\n在检查选项中，可以禁用对可疑但可能正确的除法的警告，例如不能静态计算被除数时。\n\n\n      void calc(int d) {\n         int x = 18;\n         x *= d/2;\n      }\n\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousIntegerDivAssignment",
                    "cweIds": [
                      682
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegativelyNamedBooleanVariable",
                "shortDescription": {
                  "text": "否定命名的布尔变量"
                },
                "fullDescription": {
                  "text": "报告否定命名的变量，例如：'disabled'、'hidden' 或 'isNotChanged'。 反转 'boolean' 值并从名称中移除否定通常有助于使代码更容易理解。 示例： 'boolean disabled = false;'",
                  "markdown": "报告否定命名的变量，例如：`disabled`、`hidden` 或 `isNotChanged`。\n\n反转 `boolean` 值并从名称中移除否定通常有助于使代码更容易理解。\n\n示例：\n\n\n        boolean disabled = false;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegativelyNamedBooleanVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/数据流",
                      "index": 48,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SleepWhileHoldingLock",
                "shortDescription": {
                  "text": "同步时调用 'Thread.sleep()'"
                },
                "fullDescription": {
                  "text": "报告对发生在 'synchronized' 块或方法中的'java.lang.Thread.sleep()' 方法的调用。 'synchronized' 块中的 'sleep()' 可能导致性能下降，可扩展性变差，甚至可能导致死锁。 不妨改用 'wait()'，因为它将释放持有的锁定。 示例： 'synchronized (lock) {\n    Thread.sleep(100);\n  }'",
                  "markdown": "报告对发生在 `synchronized` 块或方法中的`java.lang.Thread.sleep()` 方法的调用。\n\n\n`synchronized` 块中的 `sleep()` 可能导致性能下降，可扩展性变差，甚至可能导致死锁。 不妨改用 `wait()`，因为它将释放持有的锁定。\n\n**示例：**\n\n\n      synchronized (lock) {\n        Thread.sleep(100);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SleepWhileHoldingLock",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/线程问题",
                      "index": 17,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedClassUsageInspection",
                "shortDescription": {
                  "text": "XML 中的弃用 API 用法"
                },
                "fullDescription": {
                  "text": "报告 XML 文件中已弃用的类和方法的用法。",
                  "markdown": "报告 XML 文件中已弃用的类和方法的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedClassUsageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MethodReturnAlwaysConstant",
                "shortDescription": {
                  "text": "方法返回类特定的常量"
                },
                "fullDescription": {
                  "text": "报告仅返回常量（继承者不同，常量也可能不同）的方法。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。",
                  "markdown": "报告仅返回常量（继承者不同，常量也可能不同）的方法。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MethodReturnAlwaysConstant",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateBranchesInSwitch",
                "shortDescription": {
                  "text": "'switch' 中存在重复分支"
                },
                "fullDescription": {
                  "text": "报告在不同分支中包含相同代码的 'switch' 语句或表达式，并建议合并重复的分支。 示例： 'switch (n) {\n    case 1:\n      System.out.println(n);\n      break;\n    case 2:\n      System.out.println(n);\n      break;\n    default:\n      System.out.println(\"default\");\n  }' 在应用快速修复后： 'switch (n) {\n    case 1:\n    case 2:\n      System.out.println(n);\n      break;\n    default:\n      System.out.println(\"default\");\n  }' 2019.1 最新变化",
                  "markdown": "报告在不同分支中包含相同代码的 `switch` 语句或表达式，并建议合并重复的分支。\n\n示例：\n\n\n      switch (n) {\n        case 1:\n          System.out.println(n);\n          break;\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\n在应用快速修复后：\n\n\n      switch (n) {\n        case 1:\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\n2019.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DuplicateBranchesInSwitch",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SingleElementAnnotation",
                "shortDescription": {
                  "text": "非规范化注解"
                },
                "fullDescription": {
                  "text": "报告速记形式的注解并建议以具有特性名称的正常形式重写它们。 示例： '@SuppressWarnings(\"foo\")' 在应用快速修复后： '@SuppressWarnings(value = \"foo\")'",
                  "markdown": "报告速记形式的注解并建议以具有特性名称的正常形式重写它们。\n\n示例：\n\n\n      @SuppressWarnings(\"foo\")\n\n在应用快速修复后：\n\n\n      @SuppressWarnings(value = \"foo\")\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SingleElementAnnotation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ManualMinMaxCalculation",
                "shortDescription": {
                  "text": "手动最小值/最大值计算"
                },
                "fullDescription": {
                  "text": "报告可以使用 'Math.max()' 或 'Math.min()' 调用而不是手动计算两个数字的最小值或最大值的情况。 示例： 'public int min(int a, int b) {\n    return b < a ? b : a;\n  }' 在应用快速修复后： 'public int min(int a, int b) {\n    return Math.min(a, b);\n  }' 使用禁用 float 和 double 选项，可对 'double' 和 'float' 类型禁用此检查。 由于该快速修复在处理 'NaN' 时可能会略微更改 'float'/ 'double' 类型的语义，因此这很有用。 然而，如果不考虑 'NaN'，此快速修复在大多数情况下其实会修正难以捉摸的错误。 2019.2 最新变化",
                  "markdown": "报告可以使用 `Math.max()` 或 `Math.min()` 调用而不是手动计算两个数字的最小值或最大值的情况。\n\n**示例：**\n\n\n      public int min(int a, int b) {\n        return b < a ? b : a;\n      }\n\n在应用快速修复后：\n\n\n      public int min(int a, int b) {\n        return Math.min(a, b);\n      }\n\n\n使用**禁用 float 和 double** 选项，可对 `double` 和 `float` 类型禁用此检查。\n由于该快速修复在处理 `NaN` 时可能会略微更改 `float`/\n`double` 类型的语义，因此这很有用。 然而，如果不考虑 `NaN`，此快速修复在大多数情况下其实会修正难以捉摸的错误。\n\n2019.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ManualMinMaxCalculation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SillyAssignment",
                "shortDescription": {
                  "text": "变量被赋值给自己"
                },
                "fullDescription": {
                  "text": "报告变量对自身的赋值。 示例： 'a = a;' 该快速修复会移除赋值。",
                  "markdown": "报告变量对自身的赋值。\n\n**示例：**\n\n\n      a = a;\n\n该快速修复会移除赋值。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SillyAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/声明冗余",
                      "index": 7,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BoundedWildcard",
                "shortDescription": {
                  "text": "可以使用有界通配符"
                },
                "fullDescription": {
                  "text": "报告可以使用有界通配符的通用方法形参。 示例： 'void process(Consumer<Number> consumer);' 应替换为： 'void process(Consumer<? super Number> consumer);' 此方法签名更灵活，因为它接受更多类型：不仅是 'Consumer<Number>'，还有 'Consumer<Object>'。 同样，在协变位置输入形参： 'T produce(Producer<T> p);' 应替换为： 'T produce(Producer<? extends T> p);' 引用 Effective Java 第三版中的 Joshua Bloch： 第 31 项：使用有界通配符增加 API 灵活性 在 API 中使用通配符类型虽然麻烦，但会使 API 更加灵活。 如果您编写的库将被广泛使用，则应强制正确使用通配符类型。 记住基本规则：生产者-extends, 使用者-super (PECS)。 还要记住，所有 Comparable 和 Comparator 都是消费者。 使用检查选项可以切换以下各项的报告： 不变类。 一个不变类的示例是 'java.util.List<T>'，因为它既接受值（通过 'List.add(T)' 方法）又生成值（通过 'T List.get()' 方法）。 另一方面，'contravariant' 类只接收值，例如，只有方法 'accept(T)' 的 'java.util.function.Consumer<T>'。 类似地，'covariant' 类只产生值，例如，只有方法 'T get()' 的 'java.util.function.Supplier<T>'。 人们经常在协变/逆变类中使用有界通配符，但避免在不变类中使用通配符，例如 'void process(List<? extends T> l)'。 禁用此选项可以忽略这种不变类并保留它们的严格类型，例如 'void process(List<T> l)'。 可视为不属于公共 API 一部分的 'private' 方法 实例方法",
                  "markdown": "报告可以使用[有界通配符](https://en.wikipedia.org/wiki/Wildcard_(Java))的通用方法形参。\n\n**示例：**\n\n\n      void process(Consumer<Number> consumer);\n\n应替换为：\n\n\n      void process(Consumer<? super Number> consumer);\n\n\n此方法签名更灵活，因为它接受更多类型：不仅是 `Consumer<Number>`，还有 `Consumer<Object>`。\n\n同样，在协变位置输入形参：\n\n\n      T produce(Producer<T> p);\n\n应替换为：\n\n\n      T produce(Producer<? extends T> p);\n\n\n引用 *Effective Java* 第三版中的 [Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch#Effective_Java)：\n>\n> #### 第 31 项：使用有界通配符增加 API 灵活性\n>\n> 在 API 中使用通配符类型虽然麻烦，但会使 API 更加灵活。 如果您编写的库将被广泛使用，则应强制正确使用通配符类型。 记住基本规则：生产者-extends, 使用者-super (PECS)。 还要记住，所有 Comparable 和 Comparator 都是消费者。\n\n\n使用检查选项可以切换以下各项的报告：\n\n*\n  不变类。 一个不变类的示例是 `java.util.List<T>`，因为它既接受值（通过 `List.add(T)` 方法）又生成值（通过 `T List.get()` 方法）。\n\n\n  另一方面，`contravariant` 类只接收值，例如，只有方法 `accept(T)` 的 `java.util.function.Consumer<T>`。 类似地，`covariant` 类只产生值，例如，只有方法 `T get()` 的 `java.util.function.Supplier<T>`。\n\n\n  人们经常在协变/逆变类中使用有界通配符，但避免在不变类中使用通配符，例如 `void process(List<? extends T> l)`。\n  禁用此选项可以忽略这种不变类并保留它们的严格类型，例如 `void process(List<T> l)`。\n*\n  可视为不属于公共 API 一部分的 `private` 方法\n\n*\n  实例方法"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BoundedWildcard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码样式问题",
                      "index": 6,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InstanceVariableInitialization",
                "shortDescription": {
                  "text": "实例字段可能无法初始化"
                },
                "fullDescription": {
                  "text": "报告在对象初始化时可能未被初始化的实例变量。 示例： 'class Foo {\n    public int bar;\n\n    static { }\n  }' 请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。 使用忽略基元字段选项可以忽略未初始化的基元字段。",
                  "markdown": "报告在对象初始化时可能未被初始化的实例变量。\n\n**示例：**\n\n\n      class Foo {\n        public int bar;\n\n        static { }\n      }\n\n请注意，此检查会使用非常保守的数据流算法，可能会错误地将实例变量报告为未初始化。 报告为已初始化的变量将始终被初始化。\n\n使用**忽略基元字段**选项可以忽略未初始化的基元字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InstanceVariableMayNotBeInitialized",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/初始化",
                      "index": 23,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithTooManyBranches",
                "shortDescription": {
                  "text": "'if' 语句的分支过多"
                },
                "fullDescription": {
                  "text": "报告分支太多的 'if' 语句。 此类语句可能令人困惑，并且通常表明设计抽象级别不足。 使用最大分支数字段指定 'if' 语句可以具备的最大分支数。",
                  "markdown": "报告分支太多的 `if` 语句。\n\n此类语句可能令人困惑，并且通常表明设计抽象级别不足。\n\n\n使用**最大分支数** 字段指定 `if` 语句可以具备的最大分支数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithTooManyBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonSerializableObjectPassedToObjectStream",
                "shortDescription": {
                  "text": "不可序列化的对象被传递给了 'ObjectOutputStream'"
                },
                "fullDescription": {
                  "text": "报告用作 'java.io.ObjectOutputStream.write()' 实参的非 'Serializable' 对象。 此类调用将导致运行时异常。 此检查假定 'java.util.Collection' 和 'java.util.Map' 类型的对象为 'Serializable'，除非声明它们的类型为非 'Serializable'。 示例： 'public class IWantToSerializeThis {\n    public static void main(String[] args) throws IOException {\n      try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"output\")))) {\n        // 警告 -- 将会失败并抛出 NotSerializableException\n        stream.writeObject(new IWantToSerializeThis());\n      }\n    }\n  }'",
                  "markdown": "报告用作 `java.io.ObjectOutputStream.write()` 实参的非 `Serializable` 对象。 此类调用将导致运行时异常。\n\n\n此检查假定 `java.util.Collection` 和 `java.util.Map` 类型的对象为 `Serializable`，除非声明它们的类型为非 `Serializable`。\n\n**示例：**\n\n\n      public class IWantToSerializeThis {\n        public static void main(String[] args) throws IOException {\n          try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"output\")))) {\n            // 警告 -- 将会失败并抛出 NotSerializableException\n            stream.writeObject(new IWantToSerializeThis());\n          }\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonSerializableObjectPassedToObjectStream",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/序列化问题",
                      "index": 13,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NullArgumentToVariableArgMethod",
                "shortDescription": {
                  "text": "引起混淆的 vararg 方法实参"
                },
                "fullDescription": {
                  "text": "报告对可变 arity 方法的调用，该调用在 vararg 形参位置有一个实参，这个实参要么是 'null'，要么是 vararg 形参子类型的数组。 此类实参可能令人困惑，因为不清楚需要 vararg 调用还是非 vararg 调用。 示例： 'String[] ss = new String[]{\"foo\", \"bar\"};\n  System.out.printf(\"%s\", ss);' 在本例中，不会打印整个数组，而是只打印数组的第一个元素。 此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。",
                  "markdown": "报告对可变 arity 方法的调用，该调用在 vararg 形参位置有一个实参，这个实参要么是 `null`，要么是 vararg 形参子类型的数组。 此类实参可能令人困惑，因为不清楚需要 vararg 调用还是非 vararg 调用。\n\n**示例：**\n\n\n      String[] ss = new String[]{\"foo\", \"bar\"};\n      System.out.printf(\"%s\", ss);\n\n在本例中，不会打印整个数组，而是只打印数组的第一个元素。\n\n此检查取决于 Java 功能 '可变 arity 方法'，该功能自 Java 5 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingArgumentToVarargsMethod",
                    "cweIds": [
                      628
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/可能的 bug",
                      "index": 10,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ModuleWithTooFewClasses",
                "shortDescription": {
                  "text": "类过少的模块"
                },
                "fullDescription": {
                  "text": "报告包含的类太少的模块。 模块过小可能表明设计过于分散。 Java、Kotlin 和 Groovy 类均计算在内。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用最小类数字段可指定模块可能拥有的最小类数。",
                  "markdown": "报告包含的类太少的模块。 模块过小可能表明设计过于分散。 Java、Kotlin 和 Groovy 类均计算在内。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**最小类数**字段可指定模块可能拥有的最小类数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ModuleWithTooFewClasses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/模块化问题",
                      "index": 58,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UseOfObsoleteDateTimeApi",
                "shortDescription": {
                  "text": "使用废弃的日期时间 API"
                },
                "fullDescription": {
                  "text": "报告 'java.util.Date'、'java.util.Calendar'、'java.util.GregorianCalendar'、'java.util.TimeZone'、'java.util.SimpleTimeZone' 的用法。 虽然仍受支持，但 JDK8 Date-Time API 中已废弃这些类，或许不宜在新开发中使用。",
                  "markdown": "报告 `java.util.Date`、`java.util.Calendar`、`java.util.GregorianCalendar`、`java.util.TimeZone`、`java.util.SimpleTimeZone` 的用法。\n\n虽然仍受支持，但 JDK8 Date-Time API 中已废弃这些类，或许不宜在新开发中使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseOfObsoleteDateTimeApi",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/代码成熟度",
                      "index": 43,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverloadedVarargsMethod",
                "shortDescription": {
                  "text": "重载 vararg 方法"
                },
                "fullDescription": {
                  "text": "报告与类或超类中的其他方法同名的 vararg 方法。 采用可变数量实参的重载方法可能非常令人困惑，因为通常不清楚调用的是哪个重载。 示例： 'public void execute(Runnable... r) {} // 警告\n    public void execute(Runnable r1, Runnable r2) {}' 使用该选项可以忽略形参类型绝对不兼容的重载方法。",
                  "markdown": "报告与类或超类中的其他方法同名的 vararg 方法。 采用可变数量实参的重载方法可能非常令人困惑，因为通常不清楚调用的是哪个重载。\n\n**示例：**\n\n\n        public void execute(Runnable... r) {} // 警告\n        public void execute(Runnable r1, Runnable r2) {}\n\n\n使用该选项可以忽略形参类型绝对不兼容的重载方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverloadedVarargsMethod",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/命名约定/方法",
                      "index": 83,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousInnerClassMayBeStatic",
                "shortDescription": {
                  "text": "匿名类可能是命名为 'static' 的内部类"
                },
                "fullDescription": {
                  "text": "报告可以安全地替换为 'static' 内部类的匿名类。 如果某个匿名类没有从周围方法显式引用其封闭实例或局部类，则它可能是 'static' 内部类。 'static' 内部类不保留对其封闭实例的隐式引用。 这可以防止常见的内存泄漏，并减少每个类实例使用的内存。 从 Java 18 开始，只有可序列化的匿名类在不使用该引用的情况下，才保留对其封闭实例的隐式引用。 因此，如果模块语言级别为 Java 18 或更高，则此检查只报告可序列化的类。 该快速修复会将匿名类提取到命名的 'static' 内部类中。 示例： 'void sample(){\n    Thread thread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n      }\n    });\n  }' 在应用快速修复后： 'void sample() {\n    Thread thread = new Thread(new Task());\n  }\n\n  private static class Task implements Runnable {\n    @Override\n    public void run() {\n    }\n  }'",
                  "markdown": "报告可以安全地替换为 `static` 内部类的匿名类。 如果某个匿名类没有从周围方法显式引用其封闭实例或局部类，则它可能是 `static` 内部类。\n\n\n`static` 内部类不保留对其封闭实例的隐式引用。\n这可以防止常见的内存泄漏，并减少每个类实例使用的内存。\n\n\n从 Java 18 开始，只有可序列化的匿名类在不使用该引用的情况下，才保留对其封闭实例的隐式引用。 因此，如果模块语言级别为 Java 18 或更高，则此检查只报告可序列化的类。\n\n该快速修复会将匿名类提取到命名的 `static` 内部类中。\n\n**示例：**\n\n\n      void sample(){\n        Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n          }\n        });\n      }\n\n在应用快速修复后：\n\n\n      void sample() {\n        Thread thread = new Thread(new Task());\n      }\n\n      private static class Task implements Runnable {\n        @Override\n        public void run() {\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousInnerClassMayBeStatic",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/内存",
                      "index": 131,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PublicConstructor",
                "shortDescription": {
                  "text": "'public' 构造函数可被替换为工厂方法"
                },
                "fullDescription": {
                  "text": "报告 'public' 构造函数。 有些编码标准不建议使用 'public' 构造函数，而是建议使用 'static' 工厂方法。 这样就可以在不影响调用点的情况下交换实现。 示例： 'class Test {\n    private String name;\n\n    public Test(String name) {\n        this.name = name;\n    }\n\n    public void test() {\n        System.out.println(name);\n    }\n\n    public static void main(String[] args) {\n        new Test(\"str\").test();\n    }\n  }' 在应用快速修复后： 'class Test {\n    private String name;\n\n    private Test(String name) {\n        this.name = name;\n    }\n\n    public static Test getInstance(String name) {\n        return new Test(name);\n    }\n\n    public void test() {\n        System.out.println(name);\n    }\n\n    public static void main(String[] args) {\n        getInstance(\"str\").test();\n    }\n  }'",
                  "markdown": "报告 `public` 构造函数。\n\n有些编码标准不建议使用 `public` 构造函数，而是建议使用 `static` 工厂方法。\n这样就可以在不影响调用点的情况下交换实现。\n\n**示例：**\n\n\n      class Test {\n        private String name;\n\n        public Test(String name) {\n            this.name = name;\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            new Test(\"str\").test();\n        }\n      }\n\n在应用快速修复后：\n\n\n      class Test {\n        private String name;\n\n        private Test(String name) {\n            this.name = name;\n        }\n\n        public static Test getInstance(String name) {\n            return new Test(name);\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            getInstance(\"str\").test();\n        }\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PublicConstructor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantEmbeddedExpression",
                "shortDescription": {
                  "text": "字符串模板中的冗余嵌入表达式"
                },
                "fullDescription": {
                  "text": "报告 'STR' 模板中冗余的嵌入式表达式，例如普通文字或空表达式。 示例： 'System.out.println(STR.\"Hello \\{\"world\"}\");' 在应用快速修复后： 'System.out.println(STR.\"Hello world\");' 2023.3 最新变化 此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。",
                  "markdown": "报告 `STR` 模板中冗余的嵌入式表达式，例如普通文字或空表达式。\n\n示例：\n\n\n      System.out.println(STR.\"Hello \\{\"world\"}\");\n\n在应用快速修复后：\n\n\n      System.out.println(STR.\"Hello world\");\n\n2023.3 最新变化\n\n此检查取决于 Java 功能 '字符串模板'，该功能自 Java 21-preview 起可用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantEmbeddedExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SwitchStatementWithTooFewBranches",
                "shortDescription": {
                  "text": "最小 'switch' 分支"
                },
                "fullDescription": {
                  "text": "报告带有太少 'case' 标签的 'switch' 语句和表达式，并建议将它们重写为 'if' 和 'else if' 语句。 示例 (minimum branches == 3)： 'switch (expression) {\n    case \"foo\" -> foo();\n    case \"bar\" -> bar();\n  }' 在应用快速修复后： 'if (\"foo\".equals(expression)) {\n    foo();\n  } else if (\"bar\".equals(expression)) {\n    bar();\n  }' 不报告详尽的 switch 表达式 (Java 14+) 或不带 'default' 分支的模式 switch 语句（Java 17 预览版）。 这是因为当 'switch' 被转换为 'if' 后，编译时详尽性检查将丢失（可能是不希望发生的结果）。 配置检查： 使用最小分支数 字段指定 'case' 标签的最小预期数量。 使用不报告模式 switch 语句选项可避免报告具有模式分支的 switch 语句和表达式。 例如： 'String result = switch(obj) {\n    case String str -> str.trim();\n    default -> \"none\";\n  };' 即使只有一个模式分支，也应该保留 switch，而不是使用 'instanceof' 语句。",
                  "markdown": "报告带有太少 `case` 标签的 `switch` 语句和表达式，并建议将它们重写为 `if` 和 `else if` 语句。\n\n示例 (minimum branches == 3)：\n\n\n      switch (expression) {\n        case \"foo\" -> foo();\n        case \"bar\" -> bar();\n      }\n\n在应用快速修复后：\n\n\n      if (\"foo\".equals(expression)) {\n        foo();\n      } else if (\"bar\".equals(expression)) {\n        bar();\n      }\n\n不报告详尽的 switch 表达式 (Java 14+) 或不带 'default' 分支的模式 switch 语句（Java 17 预览版）。\n这是因为当 `switch` 被转换为 `if` 后，编译时详尽性检查将丢失（可能是不希望发生的结果）。\n\n配置检查：\n\n使用**最小分支数** 字段指定 `case` 标签的最小预期数量。\n\n使用**不报告模式 switch 语句**选项可避免报告具有模式分支的 switch 语句和表达式。 例如：\n\n\n      String result = switch(obj) {\n        case String str -> str.trim();\n        default -> \"none\";\n      };\n\n即使只有一个模式分支，也应该保留 switch，而不是使用 `instanceof` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SwitchStatementWithTooFewBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UsagesOfObsoleteApi",
                "shortDescription": {
                  "text": "ApiStatus.@Obsolete 的用法"
                },
                "fullDescription": {
                  "text": "报告注解为 '@ApiStatus.Obsolete' 的声明（类、方法、字段）。 有时无法删除当前的 API，尽管它可能无法正常工作，但有一个较新、更好或更通用的 API。 这样，它就是 '@Deprecated' 注解的一个较弱变体。 不应该在新代码中使用带注解的 API，但是允许推迟现有代码的迁移，因此这种用法不被视为警告。",
                  "markdown": "报告注解为 `@ApiStatus.Obsolete` 的声明（类、方法、字段）。\n\n\n有时无法删除当前的 API，尽管它可能无法正常工作，但有一个较新、更好或更通用的 API。\n这样，它就是 `@Deprecated` 注解的一个较弱变体。\n不应该在新代码中使用带注解的 API，但是允许推迟现有代码的迁移，因此这种用法不被视为警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UsagesOfObsoleteApi",
                    "ideaSeverity": "TEXT ATTRIBUTES",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JVM 语言",
                      "index": 0,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantDeclaredInInterface",
                "shortDescription": {
                  "text": "在接口中声明的常量"
                },
                "fullDescription": {
                  "text": "报告在接口中声明的常量（'public static final' 字段）。 有些编码标准要求在 abstract 类中声明常量。",
                  "markdown": "报告在接口中声明的常量（`public static final` 字段）。\n\n有些编码标准要求在 abstract 类中声明常量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantDeclaredInInterface",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类结构",
                      "index": 12,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticImport",
                "shortDescription": {
                  "text": "static import"
                },
                "fullDescription": {
                  "text": "报告 'import static' 语句。 Java 1.4 或更早版本的 JVM 不支持此类 'import' 语句。 配置检查： 使用下表可以指定在 'import static' 语句中使用时该检查将忽略的类。 使用忽略单字段 static import复选框可以忽略单字段 'import static' 语句。 使用忽略单方法 static import 复选框可以忽略单方法 'import static' 语句。",
                  "markdown": "报告 `import static` 语句。\n\nJava 1.4 或更早版本的 JVM 不支持此类 `import` 语句。\n\n配置检查：\n\n* 使用下表可以指定在 `import static` 语句中使用时该检查将忽略的类。\n* 使用**忽略单字段 static import** 复选框可以忽略单字段 `import static` 语句。\n* 使用**忽略单方法 static import** 复选框可以忽略单方法 `import static` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/导入",
                      "index": 14,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NoExplicitFinalizeCalls",
                "shortDescription": {
                  "text": "'finalize()' 被显式调用"
                },
                "fullDescription": {
                  "text": "报告对 'Object.finalize()' 的调用。 显式调用 'Object.finalize()' 可能导致对象处于不一致的状态。 垃圾收集器在确定没有对该对象的引用时，自动对该对象调用此方法。 该检查不报告 'finalize()' 实现中对 'super.finalize()' 的调用，因为它们是良性的。 示例： 'MyObject m = new MyObject();\n  m.finalize();\n  System.gc()'",
                  "markdown": "报告对 `Object.finalize()` 的调用。\n\n显式调用 `Object.finalize()` 可能导致对象处于不一致的状态。\n垃圾收集器在确定没有对该对象的引用时，自动对该对象调用此方法。\n\n该检查不报告 `finalize()` 实现中对 `super.finalize()` 的调用，因为它们是良性的。\n\n**示例：**\n\n\n      MyObject m = new MyObject();\n      m.finalize();\n      System.gc()\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FinalizeCalledExplicitly",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/完成",
                      "index": 56,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceNullCheck",
                "shortDescription": {
                  "text": "Null 检查可被替换为方法调用"
                },
                "fullDescription": {
                  "text": "报告可被替换为从 'Objects' 或 'Stream' 对 static 方法的调用的 'null' 检查。 示例： 'if (message == null) {\n    application.messageStorage().save(new EmptyMessage());\n  } else {\n    application.messageStorage().save(message);\n  }' 在应用快速修复后： 'application.messageStorage()\n    .save(Objects.requireNonNullElseGet(message, () -> new EmptyMessage()));' 使用替换长度大于原始长度时不发出警告选项，可以忽略替换长度超过原始代码的情况。 2017.3 最新变化",
                  "markdown": "报告可被替换为从 `Objects` 或 `Stream` 对 static 方法的调用的 `null` 检查。\n\n**示例：**\n\n\n      if (message == null) {\n        application.messageStorage().save(new EmptyMessage());\n      } else {\n        application.messageStorage().save(message);\n      }\n\n在应用快速修复后：\n\n\n      application.messageStorage()\n        .save(Objects.requireNonNullElseGet(message, () -> new EmptyMessage()));\n\n\n使用**替换长度大于原始长度时不发出警告**选项，可以忽略替换长度超过原始代码的情况。\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReplaceNullCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Java 语言级别迁移帮助/Java 9",
                      "index": 67,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedIfElse",
                "shortDescription": {
                  "text": "具有否定条件的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告包含 'else' 分支并且条件被否定的 'if' 语句。 翻转 'if' 和 'else' 分支的顺序通常会增加此类语句的清晰度。 可以通过修正反转当前 'if' 语句。 示例： 'void m(Object o1, Object o2) {\n        if (o1 != o2) {\n            System.out.println(1);\n        }\n        else {\n            System.out.println(2);\n        }\n    }' 应用快速修复后： 'void m(Object o1, Object o2) {\n        if (o1 == o2) {\n            System.out.println(2);\n        } else {\n            System.out.println(1);\n        }\n    }' 使用忽略 '!= null' 比较选项可以忽略 '!= null' 形式的比较。 使用忽略 '!= 0' 比较选项可以忽略 '!= 0' 形式的比较。",
                  "markdown": "报告包含 `else` 分支并且条件被否定的 `if` 语句。\n\n翻转 `if` 和 `else` 分支的顺序通常会增加此类语句的清晰度。\n\n可以通过修正反转当前 `if` 语句。\n\n示例：\n\n\n        void m(Object o1, Object o2) {\n            if (o1 != o2) {\n                System.out.println(1);\n            }\n            else {\n                System.out.println(2);\n            }\n        }\n\n应用快速修复后：\n\n\n        void m(Object o1, Object o2) {\n            if (o1 == o2) {\n                System.out.println(2);\n            } else {\n                System.out.println(1);\n            }\n        }\n\n使用**忽略 '!= null' 比较** 选项可以忽略 `!= null` 形式的比较。\n\n使用**忽略 '!= 0' 比较** 选项可以忽略 `!= 0` 形式的比较。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithNegatedCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/控制流问题",
                      "index": 19,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FieldCount",
                "shortDescription": {
                  "text": "字段过多的类"
                },
                "fullDescription": {
                  "text": "报告字段数超过指定最大值的类。 具有大量字段的类通常会试图进行过多处理。 请考虑将这种类拆分为多个较小的类。 配置检查： 使用字段计数限制字段可指定类中允许的最大字段数。 使用在计数中包含常量字段选项可指示是否应计算常量字段。 默认情况下，只有不可变的 'static final' 对象会被计为常量。 使用将 'static final' 字段计为常量选项可将任何 'static final' 字段计为常量。 使用在计数中包含枚举常量选项可指定是否应计算 'enum' 类中的 'enum' 常量。",
                  "markdown": "报告字段数超过指定最大值的类。\n\n具有大量字段的类通常会试图进行过多处理。 请考虑将这种类拆分为多个较小的类。\n\n配置检查：\n\n* 使用**字段计数限制**字段可指定类中允许的最大字段数。\n* 使用**在计数中包含常量字段**选项可指示是否应计算常量字段。\n* 默认情况下，只有不可变的 `static final` 对象会被计为常量。 使用**将 'static final' 字段计为常量** 选项可将任何 `static final` 字段计为常量。\n* 使用**在计数中包含枚举常量** 选项可指定是否应计算 `enum` 类中的 `enum` 常量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ClassWithTooManyFields",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/类指标",
                      "index": 95,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.jetbrains.php",
            "version": "241.17890.8",
            "rules": [
              {
                "id": "PhpDocDuplicateTypeInspection",
                "shortDescription": {
                  "text": "类型已存在于 PHPDoc 标记中"
                },
                "fullDescription": {
                  "text": "报告 PHPDoc 注释中的重复类型。",
                  "markdown": "报告 PHPDoc 注释中的重复类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDocDuplicateTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayFillCanBeConvertedToLoopInspection",
                "shortDescription": {
                  "text": "'array_fill' 可以转换为循环"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'foreach' 循环的 'array_fill()' 调用。",
                  "markdown": "报告可以替换为 `foreach` 循环的 `array_fill()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayFillCanBeConvertedToLoopInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNestedTernaryExpressionUsageInspection",
                "shortDescription": {
                  "text": "使用了嵌套的三元运算符"
                },
                "fullDescription": {
                  "text": "报告嵌套的三元表达式，这些表达式自 PHP 7.4 起已弃用。",
                  "markdown": "报告嵌套的三元表达式，这些表达式自 PHP 7.4 起已弃用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpNestedTernaryExpressionUsageInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConstantNamingConventionInspection",
                "shortDescription": {
                  "text": "常量名称未遵循编码约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合指定的正则表达式模式的常量。 某些编码风格对常量有特殊的命名约定。 使用检查选项来指定常量名称的最小/最大长度和预期正则表达式。 要忽略名字的长度，指定 0。 要了解更多关于正则表达式的信息，请参考 Quick Start guide (regular-expressions.info)。",
                  "markdown": "报告名称太短、太长或不符合指定的正则表达式模式的常量。 某些编码风格对常量有特殊的命名约定。\n\n\n使用检查选项来指定常量名称的最小/最大长度和预期正则表达式。\n要忽略名字的长度，指定 **0**。\n\n\n要了解更多关于正则表达式的信息，请参考 [Quick Start guide (regular-expressions.info)](https://www.regular-expressions.info/quickstart.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpConstantNamingConventionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/命名约定",
                      "index": 16,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTernaryExpressionCanBeReducedToShortVersionInspection",
                "shortDescription": {
                  "text": "三元表达式可被替换为短版本"
                },
                "fullDescription": {
                  "text": "报告条件和 'true' 语句相匹配的 '?:' 三元组表达式。",
                  "markdown": "报告条件和 `true` 语句相匹配的 `?:` 三元组表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTernaryExpressionCanBeReducedToShortVersionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCatchWithInstanceOfCanBeReplacedWithSpecificCatchesInspection",
                "shortDescription": {
                  "text": "'catch' 块中的 'instanceof' 检查可被替换为特定的 catch"
                },
                "fullDescription": {
                  "text": "报告单个 'catch' 块中的 'instanceof' 检查，这些单个块可以替换为特定于每个异常实例的多个 'catch' 块。",
                  "markdown": "报告单个 `catch` 块中的 `instanceof` 检查，这些单个块可以替换为特定于每个异常实例的多个 `catch` 块。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCatchWithInstanceOfCanBeReplacedWithSpecificCatchesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingDocCommentInspection",
                "shortDescription": {
                  "text": "缺少 PHPDoc 注释"
                },
                "fullDescription": {
                  "text": "报告没有 PHPDoc 注释或 PHPDoc 注释仅包含 '@noinspection' 标记的非完全类型化元素。 您可以使用强制执行 PHPDoc 注释检查报告完全类型化元素。",
                  "markdown": "报告没有 PHPDoc 注释或 PHPDoc 注释仅包含 `@noinspection` 标记的非完全类型化元素。\n\n您可以使用*强制执行 PHPDoc 注释*检查报告完全类型化元素。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingDocCommentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc/代码样式",
                      "index": 21,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpWriteAccessToReferencedArrayValueWithoutUnsetInspection",
                "shortDescription": {
                  "text": "对无 'unset' 的引用数组值的写入权限"
                },
                "fullDescription": {
                  "text": "报告仍然引用先前在 'foreach' 语句中使用的数组值的变量的写访问表达式。 建议通过使用 'unset' 来销毁这种引用。 有关详细信息，请参阅 foreach (php.net) and unset (php.net)。",
                  "markdown": "报告仍然引用先前在 `foreach` 语句中使用的数组值的变量的写访问表达式。\n\n\n建议通过使用 `unset` 来销毁这种引用。\n\n\n有关详细信息，请参阅 [foreach (php.net)](https://www.php.net/manual/en/control-structures.foreach.php) and [unset (php.net)](https://www.php.net/manual/en/function.unset.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpWriteAccessToReferencedArrayValueWithoutUnsetInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSameParameterValueInspection",
                "shortDescription": {
                  "text": "形参值始终相同"
                },
                "fullDescription": {
                  "text": "报告在所有方法调用中具有相同值的 private 方法形参。",
                  "markdown": "报告在所有方法调用中具有相同值的 private 方法形参。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSameParameterValueInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedGotoLabelInspection",
                "shortDescription": {
                  "text": "未定义的 goto 标签"
                },
                "fullDescription": {
                  "text": "报告在当前范围内没有找到的 'goto' 标签。 目标 'goto' 标签必须位于同一个文件和上下文中：您不能跳入或跳出一个函数或方法，也不能跳入一个循环或 switch 结构。 有关详细信息，请参阅 goto (php.net)。",
                  "markdown": "报告在当前范围内没有找到的 `goto` 标签。\n\n\n目标 `goto` 标签必须位于同一个文件和上下文中：您不能跳入或跳出一个函数或方法，也不能跳入一个循环或 switch 结构。\n\n\n有关详细信息，请参阅 [goto (php.net)](https://www.php.net/manual/en/control-structures.goto.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedGotoLabelInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedPartiallySupportedCallableInspection",
                "shortDescription": {
                  "text": "已弃用的部分支持可调用对象"
                },
                "fullDescription": {
                  "text": "报告 'call_user_func($callable)' 支持但 '$callable()' 不支持的 callable 的已弃用用法。 从 PHP 8.2 开始，已弃用以下 callable： '\"self::method\"'\n'\"parent::method\"'\n'\"static::method\"'\n'[\"self\", \"method\"]'\n'[\"parent\", \"method\"]'\n'[\"static\", \"method\"]'\n'[\"Foo\", \"Bar::method\"]'\n'[new Foo, \"Bar::method\"]' 有关详细信息，请参阅 Deprecate partially supported callables (php.net)。",
                  "markdown": "报告 `call_user_func($callable)` 支持但 `$callable()` 不支持的 callable 的已弃用用法。\n\n从 PHP 8.2 开始，已弃用以下 callable：\n\n    \"self::method\"\n    \"parent::method\"\n    \"static::method\"\n    [\"self\", \"method\"]\n    [\"parent\", \"method\"]\n    [\"static\", \"method\"]\n    [\"Foo\", \"Bar::method\"]\n    [new Foo, \"Bar::method\"]\n\n\n有关详细信息，请参阅 [Deprecate partially supported callables (php.net)](https://wiki.php.net/rfc/deprecate_partially_supported_callables)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedPartiallySupportedCallableInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayToStringConversionInspection",
                "shortDescription": {
                  "text": "数组到字符串的转换"
                },
                "fullDescription": {
                  "text": "报告数组到字符串的转换，即在需要字符串的上下文中提供的数组。 在 PHP 8.0 之前，这将导致 'E_NOTICE' 级别错误。 在 PHP 8.0 中，会发出 'E-WARNING'。",
                  "markdown": "报告数组到字符串的转换，即在需要字符串的上下文中提供的数组。\n\n\n在 PHP 8.0 之前，这将导致 `E_NOTICE` 级别错误。 在 PHP 8.0 中，会发出 `E-WARNING`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpArrayToStringConversionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConstantReassignmentInspection",
                "shortDescription": {
                  "text": "常量重新赋值"
                },
                "fullDescription": {
                  "text": "报告常量的重新赋值。 由于不能更改常量，因此此类赋值将无效，并且将发出 'E_NOTICE'（在 PHP 7.4 和更低版本中）或 'E_WARNING'（在 PHP 8.0 和更高版本中）。",
                  "markdown": "报告常量的重新赋值。\n\n\n由于不能更改常量，因此此类赋值将无效，并且将发出 `E_NOTICE`（在 PHP 7.4 和更低版本中）或 `E_WARNING`（在 PHP 8.0 和更高版本中）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpConstantReassignmentInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpToStringReturnInspection",
                "shortDescription": {
                  "text": "方法 '__toString' 返回值类型"
                },
                "fullDescription": {
                  "text": "报告那些不返回 'string' 的 '__toString' 方法。 在 PHP 7.4 之前，这将导致一个致命的 'E_RECOVERABLE_ERROR' 级错误。 在 PHP 7.4 中，会抛出一个致命的不可恢复的 'ERROR'。 从 PHP 8.0 开始，返回值遵循标准 PHP 类型语义，如果可能且严格类型模式被禁用，就会被强制转换为字符串。 有关详细信息，请参阅 __toString (php.net)。",
                  "markdown": "报告那些不返回 `string` 的 `__toString` 方法。\n\n在 PHP 7.4 之前，这将导致一个致命的 `E_RECOVERABLE_ERROR` 级错误。 在 PHP 7.4 中，会抛出一个致命的不可恢复的 `ERROR`。 从 PHP 8.0 开始，返回值遵循标准 PHP 类型语义，如果可能且严格类型模式被禁用，就会被强制转换为字符串。\n\n\n有关详细信息，请参阅 [__toString (php.net)](https://www.php.net/manual/en/language.oop5.magic.php#language.oop5.magic.tostring)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpToStringReturnInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpParamsInspection",
                "shortDescription": {
                  "text": "形参类型"
                },
                "fullDescription": {
                  "text": "报告传递给函数调用的形参，这些形参的类型与通过类型声明或 PHPDoc '@param' 标记在函数定义中指定的类型不匹配。 有关详细信息，请参阅 Type declarations (php.net) 和 @param (phpdoc.org)。",
                  "markdown": "报告传递给函数调用的形参，这些形参的类型与通过类型声明或 PHPDoc `@param` 标记在函数定义中指定的类型不匹配。\n\n有关详细信息，请参阅 [Type declarations (php.net)](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration) 和\n[@param (phpdoc.org)](https://docs.phpdoc.org/guide/references/phpdoc/tags/param.html#param)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpParamsInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCastIsUnnecessaryInspection",
                "shortDescription": {
                  "text": "类型转换不必要"
                },
                "fullDescription": {
                  "text": "报告在已经是相应类型的值上使用的类型转换运算符。 此类运算符冗余，可以安全移除。 有关详细信息，请参阅 Type juggling (php.net)。",
                  "markdown": "报告在已经是相应类型的值上使用的类型转换运算符。 此类运算符冗余，可以安全移除。\n\n\n有关详细信息，请参阅 [Type juggling (php.net)](https://www.php.net/manual/en/language.types.type-juggling.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCastIsUnnecessaryInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDocMissingThrowsInspection",
                "shortDescription": {
                  "text": "缺少 @throws 标记"
                },
                "fullDescription": {
                  "text": "报告由函数或方法抛出的异常的缺失 PHPDoc '@throws' 标记。 添加到设置 | PHP | 分析下的未检查的异常列表中的异常类被排除在检查范围之外。",
                  "markdown": "报告由函数或方法抛出的异常的缺失 PHPDoc `@throws` 标记。\n\n添加到[设置 \\| PHP \\| 分析](settings://reference.webide.settings.project.settings.php?Unchecked%20Exceptions)下的**未检查的异常**列表中的异常类被排除在检查范围之外。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDocMissingThrowsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc/代码样式",
                      "index": 21,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComposerJsonFileReferencesInspection",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告 composer.json 中未解析的文件引用。",
                  "markdown": "报告 composer.json 中未解析的文件引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ComposerJsonFileReferencesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Composer",
                      "index": 54,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIssetCanCheckNestedAccessDirectlyInspection",
                "shortDescription": {
                  "text": "'isset' 可以直接检查嵌套数组访问和子属性"
                },
                "fullDescription": {
                  "text": "报告可被替换为 'isset($a['a']['b']) && isset($b->b)' 的类似 'isset($a['a']) && isset($a['a']['b']) && isset($b) && isset($b->b)' 的构造。",
                  "markdown": "报告可被替换为 `isset($a['a']['b']) && isset($b->b)` 的类似 `isset($a['a']) && isset($a['a']['b']) && isset($b) && isset($b->b)` 的构造。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIssetCanCheckNestedAccessDirectlyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayUsedOnlyForWriteInspection",
                "shortDescription": {
                  "text": "数组仅用于写访问"
                },
                "fullDescription": {
                  "text": "报告仅被更新，但从未被查询的本地数组。",
                  "markdown": "报告仅被更新，但从未被查询的本地数组。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayUsedOnlyForWriteInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPowCallCanBeReplacedWithOperatorInspection",
                "shortDescription": {
                  "text": "'pow()' 调用可被替换为 '**' 运算符"
                },
                "fullDescription": {
                  "text": "报告可以用 '**' 运算符替换，但不会增加调用函数的开销的 'pow()' 调用。 有关详细信息，请参阅 Power operator (php.net)。",
                  "markdown": "报告可以用 `**` 运算符替换，但不会增加调用函数的开销的 `pow()` 调用。\n\n\n有关详细信息，请参阅 [Power operator (php.net)](https://wiki.php.net/rfc/pow-operator)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPowCallCanBeReplacedWithOperatorInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLoopCanBeReplacedWithStdFunctionCallsInspection",
                "shortDescription": {
                  "text": "循环可被替换为 'in_array()' 或 'array_key_exists()' 调用"
                },
                "fullDescription": {
                  "text": "报告可以安全替换为 'in_array()' 或 'array_key_exists()' 调用的 'foreach' 循环。 有关详细信息，请参阅 in_array (php.net) 和 array_key_exists (php.net)。",
                  "markdown": "报告可以安全替换为 `in_array()` 或 `array_key_exists()` 调用的 `foreach` 循环。\n\n\n有关详细信息，请参阅 [in_array (php.net)](https://www.php.net/manual/en/function.in-array) 和 [array_key_exists (php.net)](https://www.php.net/manual/en/function.array-key-exists)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLoopCanBeReplacedWithStdFunctionCallsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayKeyDoesNotMatchArrayShapeInspection",
                "shortDescription": {
                  "text": "数组键与数组形状不匹配 "
                },
                "fullDescription": {
                  "text": "报告不符合通过 '#[ArrayShape]' 特性指定的键的数组键。",
                  "markdown": "报告不符合通过 `#[ArrayShape]` 特性指定的键的数组键。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayKeyDoesNotMatchArrayShapeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpComposerExtensionStubsInspection",
                "shortDescription": {
                  "text": "composer.json 中缺少扩展"
                },
                "fullDescription": {
                  "text": "报告未在 composer.json 中指定的 PHP 扩展中的类、函数和常量的用法。 如果扩展被列在 composer.json 的 'require-dev' 部分，检查将报告标记为测试根的文件夹之外的相应符号用法。",
                  "markdown": "报告未在 *composer.json* 中指定的 PHP 扩展中的类、函数和常量的用法。 如果扩展被列在 *composer.json* 的 `require-dev` 部分，检查将报告标记为测试根的文件夹之外的相应符号用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpComposerExtensionStubsInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Composer",
                      "index": 54,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedParameterInspection",
                "shortDescription": {
                  "text": "未使用的形参"
                },
                "fullDescription": {
                  "text": "报告在以下情况下被认为是未使用的形参： 形参是通过值传递的，而且该值不会在任何位置使用或立即被覆盖。 形参是通过引用传递的，而且该引用不会在任何位置使用或立即被覆盖。",
                  "markdown": "报告在以下情况下被认为是未使用的形参：\n\n* 形参是通过值传递的，而且该值不会在任何位置使用或立即被覆盖。\n* 形参是通过引用传递的，而且该引用不会在任何位置使用或立即被覆盖。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedParameterInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未使用的符号",
                      "index": 70,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPregMatchReplaceWithComparisonInspection",
                "shortDescription": {
                  "text": "'preg_match()' 可被替换为比较"
                },
                "fullDescription": {
                  "text": "报告包含开头是 '^'（字符串定位标记开头）、结尾是 '$'（字符串定位标记结尾）的字符串实参的 'preg_match()' 调用。 此类调用可以替换为比较运算。",
                  "markdown": "报告包含开头是 `^`（字符串定位标记开头）、结尾是 `$`（字符串定位标记结尾）的字符串实参的 `preg_match()` 调用。 此类调用可以替换为比较运算。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPregMatchReplaceWithComparisonInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMethodMayBeInaccessibleInLateStaticBindingInspection",
                "shortDescription": {
                  "text": "在延迟 static 绑定调用期间可能无法访问 private 方法"
                },
                "fullDescription": {
                  "text": "报告对延迟 static 绑定方法的调用（即通过 'static::' 执行），这些方法调用可能被解析为来自子类的不可访问的 private 方法。 有关详细信息，请参阅延迟 static 绑定 (php.net)。",
                  "markdown": "报告对延迟 static 绑定方法的调用（即通过 `static::` 执行），这些方法调用可能被解析为来自子类的不可访问的 private 方法。\n\n\n有关详细信息，请参阅[延迟 static 绑定 (php.net)](https://www.php.net/manual/en/language.oop5.late-static-bindings.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpMethodMayBeInaccessibleInLateStaticBindingInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClassConstantCanBeFinalInspection",
                "shortDescription": {
                  "text": "类常量可以为 'final'"
                },
                "fullDescription": {
                  "text": "报告未在子类中重新定义的非 'final' 类常量。 在 PHP 8.1 和更高版本中，此类常量可以设为 'final'。 有关详细信息，请参阅 Final 类常量 (php.net)。",
                  "markdown": "报告未在子类中重新定义的非 `final` 类常量。 在 PHP 8.1 和更高版本中，此类常量可以设为 `final`。\n\n\n有关详细信息，请参阅 [Final 类常量 (php.net)](https://wiki.php.net/rfc/final_class_const)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpClassConstantCanBeFinalInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantArrayCallInForeachIteratedValueInspection",
                "shortDescription": {
                  "text": "对 'foreach' 中迭代的值的冗余 'array_values' 调用"
                },
                "fullDescription": {
                  "text": "报告 'foreach' 循环内使用迭代值而没有键的 'array_values()' 调用。 此类调用冗余，可以安全移除。",
                  "markdown": "报告 `foreach` 循环内使用迭代值而没有键的 `array_values()` 调用。 此类调用冗余，可以安全移除。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantArrayCallInForeachIteratedValueInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayModificationWillNotHaveEffectInspection",
                "shortDescription": {
                  "text": "按值修改从函数返回的数组不会有任何影响"
                },
                "fullDescription": {
                  "text": "报告对按值返回数组的函数（该函数会使赋值操作失效）的调用。 应改为按引用返回。 示例： '<?php\nclass A {\n    private $values = [];\n    public function getValues() {\n        return $this->values;\n    }\n}\n$config = new A();\n$config->getValues()['a'] = 'a';'",
                  "markdown": "报告对按值返回数组的函数（该函数会使赋值操作失效）的调用。 应改为按引用返回。\n\n**示例：**\n\n\n    <?php\n    class A {\n        private $values = [];\n        public function getValues() {\n            return $this->values;\n        }\n    }\n    $config = new A();\n    $config->getValues()['a'] = 'a';\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayModificationWillNotHaveEffectInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConstructorStyleInspection",
                "shortDescription": {
                  "text": "旧式构造函数"
                },
                "fullDescription": {
                  "text": "报告旧式的构造函数声明（'ClassName()'），并建议用新式的构造函数（'__construct()'）替换它们。 在 PHP 8.0 之前，全局命名空间中的类所使用的旧式构造函数语法被视为弃用的，会导致 'E_DEPRECATED' 错误。 如果同时定义了 '__construct()' 和 'ClassName()' 方法，'__construct()' 将被调用。 在带命名空间的类，或者任何 PHP 8.0 的类中，'ClassName()' 方法从来没有任何特殊含义，也不会被作为构造函数调用。 因此，如果 PHP 语言级别设置为 8.0 或更高，检查就不会报告这种情况。 有关详细信息，请参阅 Constructors and destructors (php.net)。",
                  "markdown": "报告旧式的构造函数声明（`ClassName()`），并建议用新式的构造函数（`__construct()`）替换它们。\n\n\n在 PHP 8.0 之前，全局命名空间中的类所使用的旧式构造函数语法被视为弃用的，会导致 `E_DEPRECATED` 错误。 如果同时定义了 `__construct()` 和 `ClassName()` 方法，`__construct()` 将被调用。\n\n在带命名空间的类，或者任何 PHP 8.0 的类中，`ClassName()` 方法从来没有任何特殊含义，也不会被作为构造函数调用。 因此，如果 PHP 语言级别设置为 8.0 或更高，检查就不会报告这种情况。\n\n\n有关详细信息，请参阅 [Constructors and destructors (php.net)](https://www.php.net/manual/en/language.oop5.decon.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpConstructorStyleInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNonStrictObjectEqualityInspection",
                "shortDescription": {
                  "text": "非严格对象相等"
                },
                "fullDescription": {
                  "text": "报告比较运算符（'=='）在比较对象变量中的用法。 对象变量的比较如下： 当使用比较运算符（'=='）时，如果两个对象实例具有相同的特性和数值（数值用 '==' 比较），并且是同一个类的实例，则认为它们是相等的。 当使用身份运算符（'==='）时，当且仅当它们指向同一个类的同一个实例，两个对象变量被认为是相等的。 有关详细信息，请参阅 Comparing Objects (php.net)。",
                  "markdown": "报告比较运算符（`==`）在比较对象变量中的用法。\n\n\n对象变量的比较如下：\n\n* 当使用比较运算符（`==`）时，如果两个对象实例具有相同的特性和数值（数值用 `==` 比较），并且是同一个类的实例，则认为它们是相等的。\n* 当使用身份运算符（`===`）时，当且仅当它们指向同一个类的同一个实例，两个对象变量被认为是相等的。\n\n\n有关详细信息，请参阅 [Comparing Objects (php.net)](http://www.php.net/manual/en/language.oop5.object-comparison.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNonStrictObjectEqualityInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUsageOfSilenceOperatorInspection",
                "shortDescription": {
                  "text": "使用了静默运算符"
                },
                "fullDescription": {
                  "text": "报告静默运算符（'@'）的使用情况，这种做法强烈不推荐。 有关详细信息，请参阅 Error Control Operators (php.net)。",
                  "markdown": "报告静默运算符（`@`）的使用情况，这种做法强烈不推荐。\n\n有关详细信息，请参阅 [Error Control Operators (php.net)](https://www.php.net/manual/en/language.operators.errorcontrol.php)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUsageOfSilenceOperatorInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedVariableInspection",
                "shortDescription": {
                  "text": "未定义的变量"
                },
                "fullDescription": {
                  "text": "产生两种类型的警告： 未定义变量：在项目文件、配置的 include 路径或 PHP 预定义变量中找不到该变量的定义。 变量可能还未定义：存在一条或多条路径到达变量的用法行而此时变量还没有定义。 使用以下选项来自定义检查： 报告变量可能未定义：清除复选框以禁用 变量可能还未定义 警告。 在全局空间中启用检查：默认情况下，对全局空间启用检查。 清除复选框以仅报告 函数本地作用域中的未定义变量。 在当前文件外搜索变量定义：如果选中该选项，仅当当前文件中没有 'include' 或 'require' 语句以及变量的定义在项目中找不到时，IDE 才会将全局变量报告为未定义。 请注意，IDE 不检查所包含文件的实际内容，而只检查是否存在 'include' 或 'require' 语句。 否则，如果未选择，IDE 仅在当前文件中搜索变量的定义，并且忽略 'include' 或 'require' 语句（如果有）。",
                  "markdown": "产生两种类型的警告：\n\n* *未定义变量*：在项目文件、配置的 include 路径或 PHP 预定义变量中找不到该变量的定义。\n* *变量可能还未定义*：存在一条或多条路径到达变量的用法行而此时变量还没有定义。\n\n\n使用以下选项来自定义检查：\n\n* **报告变量可能未定义** ：清除复选框以禁用 *变量可能还未定义* 警告。\n* **在全局空间中启用检查**：默认情况下，对全局空间启用检查。 清除复选框以仅报告 函数本地作用域中的未定义变量。\n*\n  **在当前文件外搜索变量定义** ：如果选中该选项，仅当当前文件中没有 `include` 或 `require` 语句以及变量的定义在项目中找不到时，IDE 才会将全局变量报告为未定义。 请注意，IDE 不检查所包含文件的实际内容，而只检查是否存在 `include` 或 `require` 语句。\n\n\n  否则，如果未选择，IDE 仅在当前文件中搜索变量的定义，并且忽略 `include` 或 `require` 语句（如果有）。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedVariableInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIntRangesMismatchInspection",
                "shortDescription": {
                  "text": "数字范围不匹配"
                },
                "fullDescription": {
                  "text": "报告实参与通过 'int<min, max>' PHPDoc 语法指定的预期范围不匹配的赋值和 return 语句。",
                  "markdown": "报告实参与通过 `int<min, max>` PHPDoc 语法指定的预期范围不匹配的赋值和 return 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpIntRangesMismatchInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFieldCanBePromotedInspection",
                "shortDescription": {
                  "text": "可以提升属性"
                },
                "fullDescription": {
                  "text": "报告可以用提升版本替换的属性。 有关详细信息，请参阅 Constructor Property Promotion (php.net)。",
                  "markdown": "报告可以用提升版本替换的属性。\n\n\n有关详细信息，请参阅 [Constructor Property Promotion (php.net)](https://wiki.php.net/rfc/constructor_promotion)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpFieldCanBePromotedInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPrivateFieldCanBeLocalVariableInspection",
                "shortDescription": {
                  "text": "private 属性可为局部"
                },
                "fullDescription": {
                  "text": "报告仅在单个方法中使用的 private 属性。 这种属性可以替换为局部变量。",
                  "markdown": "报告仅在单个方法中使用的 private 属性。 这种属性可以替换为局部变量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPrivateFieldCanBeLocalVariableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTypedPropertyMightBeUninitializedInspection",
                "shortDescription": {
                  "text": "类型化属性可能未初始化"
                },
                "fullDescription": {
                  "text": "报告从一个未初始化的类型化属性中读取的尝试。 这种尝试将导致 'TypeError'。 类型属性应以下列任何一种方式初始化： 以一个默认值 在构造函数中 以 '__get()' 魔术 getter 就地，在使用的时候 有关详细信息，请参阅 Uninitialized and Unset Properties (php.net)。",
                  "markdown": "报告从一个未初始化的类型化属性中读取的尝试。 这种尝试将导致 `TypeError`。\n\n\n类型属性应以下列任何一种方式初始化：\n\n* 以一个默认值\n* 在构造函数中\n* 以 `__get()` 魔术 getter\n* 就地，在使用的时候\n\n\n有关详细信息，请参阅 [Uninitialized and Unset Properties (php.net)](https://wiki.php.net/rfc/typed_properties_v2#uninitialized_and_unset_properties)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpTypedPropertyMightBeUninitializedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryFullyQualifiedNameInspection",
                "shortDescription": {
                  "text": "不必要的完全限定名称"
                },
                "fullDescription": {
                  "text": "报告完全合格的类名的使用情况，可以在不添加 'use' 语句的情况下缩短。",
                  "markdown": "报告完全合格的类名的使用情况，可以在不添加 `use` 语句的情况下缩短。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryFullyQualifiedNameInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInconsistentReturnPointsInspection",
                "shortDescription": {
                  "text": "不一致的返回点"
                },
                "fullDescription": {
                  "text": "报告函数/方法退出点的不一致性。 报告了以下类型的不一致情况： 函数/方法既有带有实参又有不带有实参的 'return' 语句。 函数或方法可能返回一个值或终止执行而不返回任何值。 严格来说，这些都不是错误，但实际上它们通常表明了一个编程错误。",
                  "markdown": "报告函数/方法退出点的不一致性。\n\n\n报告了以下类型的不一致情况：\n\n* 函数/方法既有带有实参又有不带有实参的 `return` 语句。\n* 函数或方法可能返回一个值或终止执行而不返回任何值。\n\n\n严格来说，这些都不是错误，但实际上它们通常表明了一个编程错误。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpInconsistentReturnPointsInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInapplicableAttributeTargetDeclarationInspection",
                "shortDescription": {
                  "text": "不适用的特性目标声明"
                },
                "fullDescription": {
                  "text": "报告那些在实参声明中没有适当的 'Attribute::TARGET_*' 标志的特性。 有关详细信息，请参阅 Attributes (php.net)。",
                  "markdown": "报告那些在实参声明中没有适当的 `Attribute::TARGET_*` 标志的特性。\n\n\n有关详细信息，请参阅 [Attributes (php.net)](https://wiki.php.net/rfc/attributes_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpInapplicableAttributeTargetDeclarationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingParentCallMagicInspection",
                "shortDescription": {
                  "text": "魔术方法缺少父调用"
                },
                "fullDescription": {
                  "text": "报告那些不调用其父魔术方法的魔术方法。",
                  "markdown": "报告那些不调用其父魔术方法的魔术方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingParentCallMagicInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMatchExpressionCanBeReplacedWithTernaryInspection",
                "shortDescription": {
                  "text": "'match' 表达式可被替换为三元表达式"
                },
                "fullDescription": {
                  "text": "报告包含一个默认分支和单个非默认分支的 'match' 表达式。 这种 'match' 表达式可以用三元表达式代替。 有关详细信息，请参阅 Match expression (php.net)。",
                  "markdown": "报告包含一个默认分支和单个非默认分支的 `match` 表达式。 这种 `match` 表达式可以用三元表达式代替。\n\n\n有关详细信息，请参阅 [Match expression (php.net)](https://wiki.php.net/rfc/match_expression_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMatchExpressionCanBeReplacedWithTernaryInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMethodMayBeStaticInspection",
                "shortDescription": {
                  "text": "方法可以为 'static'"
                },
                "fullDescription": {
                  "text": "报告不使用任何实例引用而可以转换为 static 方法的方法。",
                  "markdown": "报告不使用任何实例引用而可以转换为 static 方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMethodMayBeStaticInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpToStringMayProduceExceptionInspection",
                "shortDescription": {
                  "text": "'__toString' 可能会抛出异常"
                },
                "fullDescription": {
                  "text": "报告可能抛出异常的 '__toString' 的用法，这在 PHP 语言等级低于 7.4 时是不允许的。",
                  "markdown": "报告可能抛出异常的 `__toString` 的用法，这在 PHP 语言等级低于 7.4 时是不允许的。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpToStringMayProduceExceptionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedDollarBraceStringInterpolationInspection",
                "shortDescription": {
                  "text": "已弃用的 '${' 字符串内插"
                },
                "fullDescription": {
                  "text": "报告字符串中的 '${var}' 和 '${expr}' 内插。 从 PHP 8.2 开始，已弃用此类内插。 有关详细信息，请参阅 Deprecate ${} string interpolation (php.net)。",
                  "markdown": "报告字符串中的 `${var}` 和 `${expr}` 内插。 从 PHP 8.2 开始，已弃用此类内插。\n\n\n有关详细信息，请参阅 [Deprecate ${} string interpolation (php.net)](https://wiki.php.net/rfc/deprecate_dollar_brace_string_interpolation)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedDollarBraceStringInterpolationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedFunctionInspection",
                "shortDescription": {
                  "text": "未定义的函数"
                },
                "fullDescription": {
                  "text": "报告对未在项目文件中定义的函数、配置的 include 路径或 PHP 预定义函数的引用。",
                  "markdown": "报告对未在项目文件中定义的函数、配置的 include 路径或 PHP 预定义函数的引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedFunctionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitDeprecatedExpectExceptionInspection",
                "shortDescription": {
                  "text": "使用了弃用的 expectException"
                },
                "fullDescription": {
                  "text": "报告 'expectException()' 的弃用用法。 已弃用将 '\\PHPUnit\\Framework\\Error\\Deprecated'、 '\\PHPUnit\\Framework\\Error\\Error'、 '\\PHPUnit\\Framework\\Error\\Notice' 和 '\\PHPUnit\\Framework\\Error\\Warning' 与 'expectException()' 一起使用的支持，并将在 PHPUnit 10 中删除。 应该改为使用 'expectDeprecation()'、'expectError()'、'expectNotice()' 和 'expectWarning()' 方法。 有关详细信息，请参阅 Testing PHP Errors, Warnings, and Notices (phpunit.readthedocs.io)。",
                  "markdown": "报告 `expectException()` 的弃用用法。\n\n\n已弃用将 `\\PHPUnit\\Framework\\Error\\Deprecated`、\n`\\PHPUnit\\Framework\\Error\\Error`、\n`\\PHPUnit\\Framework\\Error\\Notice` 和\n`\\PHPUnit\\Framework\\Error\\Warning` 与 `expectException()` 一起使用的支持，并将在 PHPUnit 10 中删除。\n\n\n应该改为使用 `expectDeprecation()`、`expectError()`、`expectNotice()` 和\n`expectWarning()` 方法。\n\n\n有关详细信息，请参阅 [Testing PHP Errors, Warnings, and Notices (phpunit.readthedocs.io)](https://phpunit.readthedocs.io/en/stable/writing-tests-for-phpunit.html#testing-php-errors-warnings-and-notices)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitDeprecatedExpectExceptionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMatchCanBeReplacedWithSwitchStatementInspection",
                "shortDescription": {
                  "text": "'match' 可被替换为 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'switch' 语句的 'match' 表达式。 请注意，'match' 表达式使用严格类型比较，而 'switch' 语句使用松散比较。 因此，替换后表达式语义可能发生变化。 有关详细信息，请参阅 match (php.net) 和 match (php.net)。",
                  "markdown": "报告可以替换为 `switch` 语句的 `match` 表达式。\n\n\n请注意，`match` 表达式使用严格类型比较，而 `switch` 语句使用松散比较。 因此，替换后表达式语义可能发生变化。\n\n\n有关详细信息，请参阅 [match (php.net)](https://www.php.net/manual/en/control-structures.match.php) 和 [match (php.net)](https://www.php.net/manual/en/control-structures.switch.php)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMatchCanBeReplacedWithSwitchStatementInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSecondWriteToReadonlyPropertyInspection",
                "shortDescription": {
                  "text": "第二次写入 'readonly' 属性"
                },
                "fullDescription": {
                  "text": "报告 'readonly' 属性的重新赋值。 此类属性在初始化后无法修改。 有关详细信息，请参阅只读属性 (php.net)。",
                  "markdown": "报告 `readonly` 属性的重新赋值。 此类属性在初始化后无法修改。\n\n\n有关详细信息，请参阅[只读属性 (php.net)](https://wiki.php.net/rfc/readonly_properties_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpSecondWriteToReadonlyPropertyInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPureAttributeCanBeAddedInspection",
                "shortDescription": {
                  "text": "可以添加 '#[Pure]' 特性"
                },
                "fullDescription": {
                  "text": "报告非普通的纯函数。 这种函数在其主体内有其他的函数调用，但所有这种调用不会产生任何副作用。",
                  "markdown": "报告非普通的纯函数。 这种函数在其主体内有其他的函数调用，但所有这种调用不会产生任何副作用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPureAttributeCanBeAddedInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpVarTagWithoutVariableNameInspection",
                "shortDescription": {
                  "text": "不带变量名称的类型标记"
                },
                "fullDescription": {
                  "text": "报告无指定变量/形参名称的 PHPDoc 类型标记（'@var'、'@type''@param'）。 此类标记不提供表达式的任何类型信息，应该删除或扩展以包括提供类型的具体变量名。",
                  "markdown": "报告无指定变量/形参名称的 PHPDoc 类型标记（`@var`、`@type``@param`）。 此类标记不提供表达式的任何类型信息，应该删除或扩展以包括提供类型的具体变量名。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpVarTagWithoutVariableNameInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedAssertDeclarationInspection",
                "shortDescription": {
                  "text": "已弃用的 'assert()' 函数声明"
                },
                "fullDescription": {
                  "text": "报告 'assert()' 函数声明。 禁止将 'assert()' 函数声明为全局命名空间。 从 PHP 7.3 起，不推荐在非全局命名空间中声明 'assert()' 函数。 有关详细信息，请参阅 assert (php.net)。",
                  "markdown": "报告 `assert()` 函数声明。\n\n* 禁止将 `assert()` 函数声明为全局命名空间。\n* 从 PHP 7.3 起，不推荐在非全局命名空间中声明 `assert()` 函数。\n\n\n有关详细信息，请参阅 [assert (php.net)](https://www.php.net/manual/en/function.assert.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedAssertDeclarationInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAutovivificationOnFalseValuesInspection",
                "shortDescription": {
                  "text": "'false' 到数组的自动转换已弃用"
                },
                "fullDescription": {
                  "text": "报告将 'false' 值自动转换为数组的情况。 从 PHP 8.1 开始，使用此类表达式已弃用。 有关详细信息，请参阅在 false 上弃用自动复活。",
                  "markdown": "报告将 `false` 值自动转换为数组的情况。 从 PHP 8.1 开始，使用此类表达式已弃用。\n\n\n有关详细信息，请参阅[在 false 上弃用自动复活](https://wiki.php.net/rfc/autovivification_false)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAutovivificationOnFalseValuesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDocSignatureIsNotCompleteInspection",
                "shortDescription": {
                  "text": "PHPDoc 注释签名不完整"
                },
                "fullDescription": {
                  "text": "报告至少包含一个 '@param' 或 '@return' 标记，但函数/方法声明中指定的形参或返回类型缺少 '@param' 或 '@return' 标记的 PHPDoc 注释。",
                  "markdown": "报告至少包含一个 `@param` 或 `@return` 标记，但函数/方法声明中指定的形参或返回类型缺少 `@param` 或 `@return` 标记的 PHPDoc 注释。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDocSignatureIsNotCompleteInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc/代码样式",
                      "index": 21,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIfWithCommonPartsInspection",
                "shortDescription": {
                  "text": "具有通用部分的 'if'"
                },
                "fullDescription": {
                  "text": "报告有重复的通用部分的 'if' 语句。",
                  "markdown": "报告有重复的通用部分的 `if` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIfWithCommonPartsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpStaticAsDynamicMethodCallInspection",
                "shortDescription": {
                  "text": "static 方法被调用为动态"
                },
                "fullDescription": {
                  "text": "报告对 static 类方法的动态调用。 如果目标使用魔术方法 '__call'，则可以设置单独的检查严重性和高亮显示级别。",
                  "markdown": "报告对 static 类方法的动态调用。\n\n如果目标使用魔术方法 `__call`，则可以设置单独的检查严重性和高亮显示级别。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpStaticAsDynamicMethodCallInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedImplodeUsageInspection",
                "shortDescription": {
                  "text": "弃用的 'implode/join' 用法"
                },
                "fullDescription": {
                  "text": "报告 'implode' 和 'join' 函数的已弃用用法。 从 PHP 7.4 开始，不建议使用 'implode' 和 'join'，将数组作为第一个实参，而字符串作为第二个实参。 有关详细信息，请参阅 Deprecations for PHP 7.4 (php.net)。",
                  "markdown": "报告 `implode` 和 `join` 函数的已弃用用法。\n\n从 PHP 7.4 开始，不建议使用 `implode` 和 `join`，将数组作为第一个实参，而字符串作为第二个实参。\n\n\n有关详细信息，请参阅 [Deprecations for PHP 7.4 (php.net)](https://wiki.php.net/rfc/deprecations_php_7_4#implode_parameter_order_mix)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedImplodeUsageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDangerousArrayInitializationInspection",
                "shortDescription": {
                  "text": "危险的数组初始化"
                },
                "fullDescription": {
                  "text": "报告危险的数组初始化（如 '$arr[] = value'）。 不建议采取这种做法，因为如果 '$arr' 已包含某些值（例如来自请求变量的字符串），此值将保留，并且 '[]' 实际上可能代表字符串访问运算符。 最好始终通过直接赋值来初始化变量。 有关详细信息，请参阅 Creating/modifying with square bracket syntax (php.net)。",
                  "markdown": "报告危险的数组初始化（如 `$arr[] = value`）。\n\n\n不建议采取这种做法，因为如果 `$arr` 已包含某些值（例如来自请求变量的字符串），此值将保留，并且 `[]` 实际上可能代表字符串访问运算符。 最好始终通过直接赋值来初始化变量。\n\n有关详细信息，请参阅 [Creating/modifying with square bracket syntax (php.net)](https://www.php.net/manual/en/language.types.array.php#language.types.array.syntax.modifying)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDangerousArrayInitializationInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpOverridingMethodVisibilityInspection",
                "shortDescription": {
                  "text": "方法可见性不应被重写"
                },
                "fullDescription": {
                  "text": "检查这些方法未覆盖可见性。 在子类中用 'public' 方法覆盖 'protected' 方法，使得这个方法可以从任何地方被访问。 这违反了封装原则，被认为是一种不好的做法。 有关详细信息，请参阅 Method Visibility (php.net)。",
                  "markdown": "检查这些方法未覆盖可见性。\n\n\n在子类中用 `public` 方法覆盖 `protected` 方法，使得这个方法可以从任何地方被访问。\n这违反了封装原则，被认为是一种不好的做法。\n\n\n有关详细信息，请参阅 [Method Visibility (php.net)](https://www.php.net/manual/en/language.oop5.visibility.php#language.oop5.visiblity-methods)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpOverridingMethodVisibilityInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMockeryInvalidMockingMethodInspection",
                "shortDescription": {
                  "text": "无效的 Mockery 模拟目标"
                },
                "fullDescription": {
                  "text": "报告在 Mockery 测试中被错误模拟的方法和类。 报告以下实体： 'private' 方法 没有适当的 '\\Mockery\\Mock::shouldAllowMockingProtectedMethods' 调用的 'protected' 方法",
                  "markdown": "报告在 Mockery 测试中被错误模拟的方法和类。\n\n\n报告以下实体：\n\n* `private` 方法\n* 没有适当的 `\\Mockery\\Mock::shouldAllowMockingProtectedMethods` 调用的 `protected` 方法"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpMockeryInvalidMockingMethodInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClassNamingConventionInspection",
                "shortDescription": {
                  "text": "类名未遵循编码约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合指定的正则表达式模式的类。 某些编码风格对类有特殊的命名约定。 使用检查选项来指定类名称的最小/最大长度和预期正则表达式。 要忽略名字的长度，指定 0。 要了解更多关于正则表达式的信息，请参考 Quick Start guide (regular-expressions.info)。",
                  "markdown": "报告名称太短、太长或不符合指定的正则表达式模式的类。 某些编码风格对类有特殊的命名约定。\n\n\n使用检查选项来指定类名称的最小/最大长度和预期正则表达式。\n要忽略名字的长度，指定 **0**。\n\n\n要了解更多关于正则表达式的信息，请参考 [Quick Start guide (regular-expressions.info)](https://www.regular-expressions.info/quickstart.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpClassNamingConventionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/命名约定",
                      "index": 16,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnreachableStatementInspection",
                "shortDescription": {
                  "text": "不可到达的语句"
                },
                "fullDescription": {
                  "text": "报告无法达到的语句。",
                  "markdown": "报告无法达到的语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnreachableStatementInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitDeprecatedCallsIn10VersionInspection",
                "shortDescription": {
                  "text": "方法在 PHPUnit 10 中已弃用"
                },
                "fullDescription": {
                  "text": "报告对 PHPUnit 10 中移除的 PHPUnit 断言方法的调用。",
                  "markdown": "报告对 PHPUnit 10 中移除的 PHPUnit 断言方法的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnitDeprecatedCallsIn10VersionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitUndefinedDataProviderInspection",
                "shortDescription": {
                  "text": "未定义的 PHPUnit 数据提供程序"
                },
                "fullDescription": {
                  "text": "报告在 '@dataProvider' PHPDoc 标签中对未解析的函数/方法的引用。 请注意，在解析 'dataProvider' 时，PHPUnit 不会考虑 'use' 语句。",
                  "markdown": "报告在 `@dataProvider` PHPDoc 标签中对未解析的函数/方法的引用。\n\n请注意，在解析 `dataProvider` 时，PHPUnit 不会考虑 `use` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnitUndefinedDataProviderInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFieldAssignmentTypeMismatchInspection",
                "shortDescription": {
                  "text": "属性赋值中的类型不匹配"
                },
                "fullDescription": {
                  "text": "报告属性赋值中的类型违规。",
                  "markdown": "报告属性赋值中的类型违规。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpFieldAssignmentTypeMismatchInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingParentConstructorInspection",
                "shortDescription": {
                  "text": "构造函数缺少父调用"
                },
                "fullDescription": {
                  "text": "报告不调用其父构造函数的构造函数。",
                  "markdown": "报告不调用其父构造函数的构造函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpMissingParentConstructorInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDynamicAsStaticMethodCallInspection",
                "shortDescription": {
                  "text": "动态方法被调用为 static"
                },
                "fullDescription": {
                  "text": "报告对动态类方法的静态调用。 对于具有魔术方法'__ callStatic'的类，可以设置单独的检查严重性和突出显示级别。",
                  "markdown": "报告对动态类方法的静态调用。\n\n对于具有魔术方法` __ callStatic `的类，可以设置单独的检查严重性和突出显示级别。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDynamicAsStaticMethodCallInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayIsAlwaysEmptyInspection",
                "shortDescription": {
                  "text": "数组在访问点始终为空"
                },
                "fullDescription": {
                  "text": "报告在迭代/访问时得知为空的数组。",
                  "markdown": "报告在迭代/访问时得知为空的数组。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayIsAlwaysEmptyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRegExpUnsupportedModifierInspection",
                "shortDescription": {
                  "text": "不支持的修饰符"
                },
                "fullDescription": {
                  "text": "报告正则表达式模式中 'e' 修饰符的用法。 在 PHP 7.0 及更高版本中，此类用法已弃用，并会发出 'E_WARNING'。",
                  "markdown": "报告正则表达式模式中 `e` 修饰符的用法。 在 PHP 7.0 及更高版本中，此类用法已弃用，并会发出 `E_WARNING`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpRegExpUnsupportedModifierInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/正则表达式",
                      "index": 116,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPassByRefInspection",
                "shortDescription": {
                  "text": "通过引用传递形参"
                },
                "fullDescription": {
                  "text": "报告无法通过引用传递的函数/方法调用中的实参。 只有变量和从函数返回的引用可以通过引用传递。 有关详细信息，请参阅 Passing by Reference (php.net)。",
                  "markdown": "报告无法通过引用传递的函数/方法调用中的实参。\n\n\n只有变量和从函数返回的引用可以通过引用传递。 有关详细信息，请参阅 [Passing by Reference (php.net)](https://www.php.net/manual/en/language.references.pass.php#language.references.pass)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpPassByRefInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNonCanonicalElementsOrderInspection",
                "shortDescription": {
                  "text": "元素的非规范顺序"
                },
                "fullDescription": {
                  "text": "报告元素列出顺序不规范的 PHPDoc 标签。 例如，对于 '@property'、'@param' 或 '@var' 这样的标签，检查将报告 '[name] [\"Type\"]' 的用法，而不是 '[\"Type\"] [name]'。",
                  "markdown": "报告元素列出顺序不规范的 PHPDoc 标签。\n\n例如，对于 `@property`、`@param` 或 `@var` 这样的标签，检查将报告 `[name] [\"Type\"]` 的用法，而不是 `[\"Type\"] [name]`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNonCanonicalElementsOrderInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc/代码样式",
                      "index": 21,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAbstractStaticMethodInspection",
                "shortDescription": {
                  "text": "static 函数不应为 abstract"
                },
                "fullDescription": {
                  "text": "报告声明为 abstract 的 static 方法。",
                  "markdown": "报告声明为 abstract 的 static 方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpAbstractStaticMethodInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHP 严格标准",
                      "index": 121,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTooLongMemberReferenceChainInspection",
                "shortDescription": {
                  "text": "成员引用链过长，无法分析"
                },
                "fullDescription": {
                  "text": "报告方法引用链过长，从而使 IDE 无法分析的情况。",
                  "markdown": "报告方法引用链过长，从而使 IDE 无法分析的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTooLongMemberReferenceChainInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInArrayCanBeReplacedWithComparisonInspection",
                "shortDescription": {
                  "text": "'in_array' 可被替换为比较"
                },
                "fullDescription": {
                  "text": "报告单元素数组作为 '$haystack' 实参提供的 'in_array()' 调用。 这种调用可以用直接比较来代替。 有关详细信息，请参阅 in_array (php.net)。",
                  "markdown": "报告单元素数组作为 `$haystack` 实参提供的 `in_array()` 调用。 这种调用可以用直接比较来代替。\n\n\n有关详细信息，请参阅 [in_array (php.net)](https://www.php.net/manual/en/function.in-array.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpInArrayCanBeReplacedWithComparisonInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantTypeInUnionTypeInspection",
                "shortDescription": {
                  "text": "类型声明冗余，可以简化"
                },
                "fullDescription": {
                  "text": "报告包含冗余类型的联合类型声明，例如，同时包含类别名和原始类的联合类型。 有关详细信息，请参阅 Union Types RFC: Duplicate and redundant types (php.net)。",
                  "markdown": "报告包含冗余类型的联合类型声明，例如，同时包含类别名和原始类的联合类型。\n\n\n有关详细信息，请参阅 [Union Types RFC: Duplicate and redundant types (php.net)](https://wiki.php.net/rfc/union_types_v2#duplicate_and_redundant_types)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantTypeInUnionTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpModuloByOneInspection",
                "shortDescription": {
                  "text": "以 '1' 为操作数的取模运算"
                },
                "fullDescription": {
                  "text": "报告始终评估为 '0' 或 '1' 的模数表达式 '%'。",
                  "markdown": "报告始终评估为 `0` 或 `1` 的模数表达式 `%`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpModuloByOneInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantAssignmentToPromotedFieldInspection",
                "shortDescription": {
                  "text": "冗余的提升属性赋值"
                },
                "fullDescription": {
                  "text": "报告对类属性的冗余赋值，这些赋值重复了通过提升的构造函数形参进行的自动赋值。 有关详细信息，请参阅 Constructor Property Promotion (php.net)。",
                  "markdown": "报告对类属性的冗余赋值，这些赋值重复了通过提升的构造函数形参进行的自动赋值。\n\n\n有关详细信息，请参阅 [Constructor Property Promotion (php.net)](https://wiki.php.net/rfc/constructor_promotion)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantAssignmentToPromotedFieldInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayPushWithOneElementInspection",
                "shortDescription": {
                  "text": "只有一个元素的 'array_push()'"
                },
                "fullDescription": {
                  "text": "报告用于向数组中添加一个元素的 'array_push()' 调用。 在此类情况下，建议改用 '$array[] ='，这样不会增加调用函数的开销。 有关详细信息，请参阅 array_push (php.net)。",
                  "markdown": "报告用于向数组中添加一个元素的 `array_push()` 调用。 在此类情况下，建议改用 `$array[] =`，这样不会增加调用函数的开销。\n\n\n有关详细信息，请参阅 [array_push (php.net)](https://www.php.net/manual/en/function.array-push.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayPushWithOneElementInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantOptionalArgumentInspection",
                "shortDescription": {
                  "text": "冗余的可选实参"
                },
                "fullDescription": {
                  "text": "报告匹配可选形参相应默认值的冗余实参。",
                  "markdown": "报告匹配可选形参相应默认值的冗余实参。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantOptionalArgumentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpStrictComparisonWithOperandsOfDifferentTypesInspection",
                "shortDescription": {
                  "text": "严格比较类型不兼容的操作数"
                },
                "fullDescription": {
                  "text": "报告对类型不兼容的操作数使用的 '===' 或 '!==' 严格比较。 有关详细信息，请参阅 PHP type comparison tables (php.net)。",
                  "markdown": "报告对类型不兼容的操作数使用的 `===` 或 `!==` 严格比较。\n\n\n有关详细信息，请参阅 [PHP type comparison tables (php.net)](https://www.php.net/manual/en/types.comparisons.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpStrictComparisonWithOperandsOfDifferentTypesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpExpectedValuesShouldBeUsedInspection",
                "shortDescription": {
                  "text": "应使用预期值"
                },
                "fullDescription": {
                  "text": "报告赋值和比较表达式的值，这些值应该被预期值替换（也就是通过 '#[ExpectedValues]' 特性指定的值）。 有关详细信息，请参阅 Attributes (php.net)。",
                  "markdown": "报告赋值和比较表达式的值，这些值应该被预期值替换（也就是通过 `#[ExpectedValues]` 特性指定的值）。\n\n\n有关详细信息，请参阅 [Attributes (php.net)](https://wiki.php.net/rfc/attributes_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpExpectedValuesShouldBeUsedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecationInspection",
                "shortDescription": {
                  "text": "已弃用"
                },
                "fullDescription": {
                  "text": "报告已弃用的实体的用法。 在大多数情况下，这种用法应该被删除，或者用其他结构来代替。",
                  "markdown": "报告已弃用的实体的用法。\n\n\n在大多数情况下，这种用法应该被删除，或者用其他结构来代替。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDeprecationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNestedDirNameCallsCanBeReplacedWithLevelParameterInspection",
                "shortDescription": {
                  "text": "嵌套的 'dirname()' 调用可被替换为 'levels' 形参用法"
                },
                "fullDescription": {
                  "text": "报告可以通过改用 'levels' 形参省略的嵌套 'dirname()' 调用。",
                  "markdown": "报告可以通过改用 `levels` 形参省略的嵌套 `dirname()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNestedDirNameCallsCanBeReplacedWithLevelParameterInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAnnotationToAttributeInspection",
                "shortDescription": {
                  "text": "PHPUnit 注解在 PHPUnit 11 中已弃用，可被替换为特性"
                },
                "fullDescription": {
                  "text": "建议将 PHPUnit 注解替换为特性。",
                  "markdown": "建议将 PHPUnit 注解替换为特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnitAnnotationToAttributeInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTraitsUseListInspection",
                "shortDescription": {
                  "text": "每行一个特征 use"
                },
                "fullDescription": {
                  "text": "报告通过单个 'use' 语句导入多个特征的情况。 根据 PSR-12，导入到类中的每个单个特征必须每行包含一个，并且每个包含必须具有自己的 'use' 导入语句。 有关详细信息，请参阅 PSR-12: Extended Coding Style (php-fig.org)。",
                  "markdown": "报告通过单个 `use` 语句导入多个特征的情况。\n\n\n根据 PSR-12，导入到类中的每个单个特征必须每行包含一个，并且每个包含必须具有自己的 `use` 导入语句。\n\n\n有关详细信息，请参阅 [PSR-12: Extended Coding Style (php-fig.org)](https://www.php-fig.org/psr/psr-12/#42-using-traits)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTraitsUseListInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNamedArgumentUsageInspection",
                "shortDescription": {
                  "text": "有名称标识符的实参"
                },
                "fullDescription": {
                  "text": "报告有名称标识符的实参。",
                  "markdown": "报告有名称标识符的实参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNamedArgumentUsageInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedFieldDefaultValueInspection",
                "shortDescription": {
                  "text": "冗余属性初始值设定项"
                },
                "fullDescription": {
                  "text": "报告具有默认初始化器的字段，这些初始化器在类的构造函数中总是被覆盖。",
                  "markdown": "报告具有默认初始化器的字段，这些初始化器在类的构造函数中总是被覆盖。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedFieldDefaultValueInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未使用的符号",
                      "index": 70,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpObjectFieldsAreOnlyWrittenInspection",
                "shortDescription": {
                  "text": "局部对象仅用于写入属性"
                },
                "fullDescription": {
                  "text": "报告对新对象的变量赋值，这些赋值仅用于编写对象属性，没有明显的副作用。",
                  "markdown": "报告对新对象的变量赋值，这些赋值仅用于编写对象属性，没有明显的副作用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpObjectFieldsAreOnlyWrittenInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryStaticReferenceInspection",
                "shortDescription": {
                  "text": "final 类中有冗余的 'static'"
                },
                "fullDescription": {
                  "text": "报告 final 类中的 'static' 用法",
                  "markdown": "报告 final 类中的 `static` 用法"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryStaticReferenceInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClassCantBeUsedAsAttributeInspection",
                "shortDescription": {
                  "text": "类不能用作特性"
                },
                "fullDescription": {
                  "text": "报告特性被解析为没有用 '#[Attribute]' 注释的类。 有关详细信息，请参阅 Attributes (php.net)。",
                  "markdown": "报告特性被解析为没有用 `#[Attribute]` 注释的类。\n\n\n有关详细信息，请参阅 [Attributes (php.net)](https://wiki.php.net/rfc/attributes_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpClassCantBeUsedAsAttributeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedCallbackInspection",
                "shortDescription": {
                  "text": "未定义的回调"
                },
                "fullDescription": {
                  "text": "报告从回调中引用但未被发现的函数、方法、属性或类。 使用以下选项来自定义检查： 忽略来自 '*_exists' 和 'is_callable' 函数的回调：如果选择，检查将跳过来自 'method_exists'、'function_exists'、'property_exists'、'class_exists' 和 'is_callable' 函数的回调。 不明确时不报告：如果选择，检查将跳过具有多种可能类型的形参，例如标记为 'callable|string'。",
                  "markdown": "报告从回调中引用但未被发现的函数、方法、属性或类。\n\n使用以下选项来自定义检查：\n\n* **忽略来自 '\\*_exists' 和 'is_callable' 函数的回调** ：如果选择，检查将跳过来自 `method_exists`、`function_exists`、`property_exists`、`class_exists` 和 `is_callable` 函数的回调。\n* **不明确时不报告** ：如果选择，检查将跳过具有多种可能类型的形参，例如标记为 `callable|string`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedCallbackInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpOptionalBeforeRequiredParametersInspection",
                "shortDescription": {
                  "text": "可选形参在必选形参之前"
                },
                "fullDescription": {
                  "text": "报告在函数/方法声明中出现在必要形参之前的可选形参。 有关详细信息，请参阅 Default argument values (php.net)。",
                  "markdown": "报告在函数/方法声明中出现在必要形参之前的可选形参。\n\n\n有关详细信息，请参阅 [Default argument values (php.net)](http://www.php.net/manual/en/functions.arguments.php#functions.arguments.default)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpOptionalBeforeRequiredParametersInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDocRedundantThrowsInspection",
                "shortDescription": {
                  "text": "冗余 @throws 标记"
                },
                "fullDescription": {
                  "text": "报告并非由函数或方法抛出的异常的 '@throws' 标记。 添加到设置 | PHP | 分析下的未检查的异常列表中的异常类被排除在检查范围之外。",
                  "markdown": "报告并非由函数或方法抛出的异常的 `@throws` 标记。\n\n添加到[设置 \\| PHP \\| 分析](settings://reference.webide.settings.project.settings.php?Unchecked%20Exceptions)下的**未检查的异常**列表中的异常类被排除在检查范围之外。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDocRedundantThrowsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSymfonyAnnotationToAttributeInspection",
                "shortDescription": {
                  "text": "Symfony 注解可被替换为特性"
                },
                "fullDescription": {
                  "text": "建议将 Symfony 注解替换为特性。",
                  "markdown": "建议将 Symfony 注解替换为特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSymfonyAnnotationToAttributeInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayMapCanBeConvertedToLoopInspection",
                "shortDescription": {
                  "text": "'array_map()' 调用可以转换为循环"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'foreach' 循环的 'array_map()' 调用。",
                  "markdown": "报告可以替换为 `foreach` 循环的 `array_map()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayMapCanBeConvertedToLoopInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryStringCastInspection",
                "shortDescription": {
                  "text": "冗余转换为字符串"
                },
                "fullDescription": {
                  "text": "报告冗余的 '(string)' 转换和 'strval()' 调用，因为向字符串的转换是隐式进行的。",
                  "markdown": "报告冗余的 `(string)` 转换和 `strval()` 调用，因为向字符串的转换是隐式进行的。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryStringCastInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNullIsNotCompatibleWithParameterInspection",
                "shortDescription": {
                  "text": "'null' 与形参的声明类型不兼容"
                },
                "fullDescription": {
                  "text": "报告通过被引用传递给与 'null' 不兼容的形参来初始化的变量。",
                  "markdown": "报告通过被引用传递给与 `null` 不兼容的形参来初始化的变量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpNullIsNotCompatibleWithParameterInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPregReplaceWithEmptyReplacementInspection",
                "shortDescription": {
                  "text": "'preg_replace()' 可被替换为 '(l|r)trim' 调用"
                },
                "fullDescription": {
                  "text": "报告具有空 'replacement' 的 'preg_replace()' 调用。 此类调用可被替换为 '(l|r)trim' 调用。",
                  "markdown": "报告具有空 `replacement` 的 `preg_replace()` 调用。 此类调用可被替换为 `(l|r)trim` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPregReplaceWithEmptyReplacementInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantClosingTagInspection",
                "shortDescription": {
                  "text": "冗余结束标记"
                },
                "fullDescription": {
                  "text": "报告PHP结束标记 '?>' 的用法，这些用法在仅包含 PHP 代码的文件中是冗余的。",
                  "markdown": "报告PHP结束标记 `?>` 的用法，这些用法在仅包含 PHP 代码的文件中是冗余的。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantClosingTagInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedAutoloadDeclarationInspection",
                "shortDescription": {
                  "text": "已弃用的 '__autoload()' 函数声明"
                },
                "fullDescription": {
                  "text": "报告 '__autoload()' 函数声明。 从 PHP 7.4 起，不推荐声明 '__autoload()' 函数。 从 PHP 8.0 起，禁止声明 '__autoload()' 函数。 有关详细信息，请参阅 __autoload (php.net)。",
                  "markdown": "报告 `__autoload()` 函数声明。\n\n* 从 PHP 7.4 起，不推荐声明 `__autoload()` 函数。\n* 从 PHP 8.0 起，禁止声明 `__autoload()` 函数。\n\n\n有关详细信息，请参阅 [__autoload (php.net)](https://www.php.net/manual/en/function.autoload.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedAutoloadDeclarationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpExpressionWithSameOperandsInspection",
                "shortDescription": {
                  "text": "逻辑表达式有相同操作数"
                },
                "fullDescription": {
                  "text": "报告使用相同操作数的表达式，但应该使用不同的操作数（例如，'$var == $var'）。 这包括比较、逻辑、空值合并、减法和除法表达式。",
                  "markdown": "报告使用相同操作数的表达式，但应该使用不同的操作数（例如，`$var == $var`）。 这包括比较、逻辑、空值合并、减法和除法表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpExpressionWithSameOperandsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArithmeticTypeCheckInspection",
                "shortDescription": {
                  "text": "带有不支持操作数的算术运算"
                },
                "fullDescription": {
                  "text": "报告具有不受支持的操作数的算术和按位表达式。 从 PHP 8.0 开始，当操作数之一是数组、资源或非重载对象时，使用算术和按位运算符 '+'、'-'、'*'、'/'、'**'、'%'、'< <'、'>'、'&'、'|'、'^'、'~'、'++'、'-' 将导致 'TypeError'。 唯一的例外是 'array + array'合并操作，它仍然被支持。 完整的操作列表见 PHP's internal test source。",
                  "markdown": "报告具有不受支持的操作数的算术和按位表达式。\n\n\n从 PHP 8.0 开始，当操作数之一是数组、资源或非重载对象时，使用算术和按位运算符 `+`、`-`、`*`、`/`、`**`、`%`、`< <`、`>`、`&`、`|`、`^`、`~`、`++`、`-` 将导致 `TypeError`。 唯一的例外是\n`array + array`合并操作，它仍然被支持。\n\n\n完整的操作列表见 [PHP's internal test source](https://github.com/php/php-src/blob/master/Zend/tests/operator_unsupported_types.phpt)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpArithmeticTypeCheckInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantVariableDocTypeInspection",
                "shortDescription": {
                  "text": "冗余 @var 标记"
                },
                "fullDescription": {
                  "text": "报告 '@var' 标签的变量，其类型已经从源代码中推断出。",
                  "markdown": "报告 `@var` 标签的变量，其类型已经从源代码中推断出。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantVariableDocTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMethodNamingConventionInspection",
                "shortDescription": {
                  "text": "方法名称未遵循编码约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合指定的正则表达式模式的方法。 某些编码风格对方法有特殊的命名约定。 使用检查选项来指定方法名称的最小/最大长度和预期正则表达式。 要忽略名字的长度，指定 0。 要了解更多关于正则表达式的信息，请参考 Quick Start guide (regular-expressions.info)。",
                  "markdown": "报告名称太短、太长或不符合指定的正则表达式模式的方法。 某些编码风格对方法有特殊的命名约定。\n\n\n使用检查选项来指定方法名称的最小/最大长度和预期正则表达式。\n要忽略名字的长度，指定 **0**。\n\n\n要了解更多关于正则表达式的信息，请参考 [Quick Start guide (regular-expressions.info)](https://www.regular-expressions.info/quickstart.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMethodNamingConventionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/命名约定",
                      "index": 16,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedPrivateMethodInspection",
                "shortDescription": {
                  "text": "未使用的 private 方法"
                },
                "fullDescription": {
                  "text": "报告从未使用的 private 方法。",
                  "markdown": "报告从未使用的 private 方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedPrivateMethodInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未使用的符号",
                      "index": 70,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpObjectShapeCanBeAddedInspection",
                "shortDescription": {
                  "text": "ObjectShape 可以添加"
                },
                "fullDescription": {
                  "text": "报告具有指定类型的对象的 public 属性。 建议通过 '#[ObjectShape]' 特性或 PHPDoc 注释中的对象形状来指定返回对象的形状。 示例： '$a = new stdClass();\n  $a->name = \"name\";\n  $a->age = 2;' 在应用快速修复后： '/** @var $a object{name: string, age: int} */\n  $a = new stdClass();\n  $a->name = \"name\";\n  $a->age = 2;'",
                  "markdown": "报告具有指定类型的对象的 public 属性。 建议通过 `#[ObjectShape]` 特性或 PHPDoc 注释中的对象形状来指定返回对象的形状。\n\n**示例：**\n\n\n      $a = new stdClass();\n      $a->name = \"name\";\n      $a->age = 2;\n\n在应用快速修复后：\n\n\n      /** @var $a object{name: string, age: int} */\n      $a = new stdClass();\n      $a->name = \"name\";\n      $a->age = 2;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpObjectShapeCanBeAddedInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInvalidMagicMethodModifiersInspection",
                "shortDescription": {
                  "text": "魔术方法修饰符无效"
                },
                "fullDescription": {
                  "text": "报告没有被声明为 public 的或被声明为 static 的魔术方法。",
                  "markdown": "报告没有被声明为 public 的或被声明为 static 的魔术方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpInvalidMagicMethodModifiersInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpWrongCatchClausesOrderInspection",
                "shortDescription": {
                  "text": "catch 子句顺序错误"
                },
                "fullDescription": {
                  "text": "报告已经被前面的异常捕获的异常和被捕获两次的异常。 'catch' 子句必须按从较特定的子句到较普通的子句排序。 否则，一些异常可能不会被最特定的处理程序所捕获。 有关详细信息，请参阅 Exceptions (php.net)。",
                  "markdown": "报告已经被前面的异常捕获的异常和被捕获两次的异常。\n\n\n`catch` 子句必须按从较特定的子句到较普通的子句排序。 否则，一些异常可能不会被最特定的处理程序所捕获。\n\n\n有关详细信息，请参阅 [Exceptions (php.net)](http://www.php.net/manual/en/language.exceptions.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpWrongCatchClausesOrderInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/错误处理",
                      "index": 144,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPregSplitWithoutRegExpInspection",
                "shortDescription": {
                  "text": "'preg_split' 可被替换为 'explode'"
                },
                "fullDescription": {
                  "text": "报告可被替换为 'explode()' 的 'preg_split()' 调用。",
                  "markdown": "报告可被替换为 `explode()` 的 `preg_split()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPregSplitWithoutRegExpInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnpackingArraysWithStringKeysInspection",
                "shortDescription": {
                  "text": "对于 PHP 8.1 之前的版本，禁止使用字符串键解包数组"
                },
                "fullDescription": {
                  "text": "在 PHP 8.1 及更早版本中报告使用字符串键的数组解包 有关详细信息，请参阅 Array unpacking with string keys。",
                  "markdown": "在 PHP 8.1 及更早版本中报告使用字符串键的数组解包\n\n\n有关详细信息，请参阅 [Array unpacking with string keys](https://wiki.php.net/rfc/array_unpacking_string_keys)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpUnpackingArraysWithStringKeysInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRangesInClassCanBeMergedInspection",
                "shortDescription": {
                  "text": "类中的范围可以合并"
                },
                "fullDescription": {
                  "text": "报告正则表达式字符类中仅调整现有范围的字母范围或字符。 此类元素可以与调整后的范围合并。",
                  "markdown": "报告正则表达式字符类中仅调整现有范围的字母范围或字符。 此类元素可以与调整后的范围合并。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRangesInClassCanBeMergedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/正则表达式",
                      "index": 116,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicateMatchConditionInspection",
                "shortDescription": {
                  "text": "重复条件"
                },
                "fullDescription": {
                  "text": "报告 'match' 表达式中的重复条件。 有关详细信息，请参阅 Match expression (php.net)。",
                  "markdown": "报告 `match` 表达式中的重复条件。\n\n\n有关详细信息，请参阅 [Match expression (php.net)](https://wiki.php.net/rfc/match_expression_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDuplicateMatchConditionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicateSwitchCaseBodyInspection",
                "shortDescription": {
                  "text": "switch 语句中存在重复分支"
                },
                "fullDescription": {
                  "text": "报告不同分支中包含相同代码的 'switch' 语句。",
                  "markdown": "报告不同分支中包含相同代码的 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDuplicateSwitchCaseBodyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPregMatchRedundantClosureInspection",
                "shortDescription": {
                  "text": "冗余闭包 '.*'"
                },
                "fullDescription": {
                  "text": "报告 `preg_match` 函数的模式中的冗余前导和尾随 '.*'。",
                  "markdown": "报告 \\`preg_match\\` 函数的模式中的冗余前导和尾随 '.\\*'。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPregMatchRedundantClosureInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitDeprecatedCallsIn11VersionInspection",
                "shortDescription": {
                  "text": "方法在 PHPUnit 11 中已弃用"
                },
                "fullDescription": {
                  "text": "报告对 PHPUnit 11 中移除的 PHPUnit 测试用例方法的调用。",
                  "markdown": "报告对 PHPUnit 11 中移除的 PHPUnit 测试用例方法的调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnitDeprecatedCallsIn11VersionInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCombineMultipleIssetCallsIntoOneInspection",
                "shortDescription": {
                  "text": "可将多个 'isset' 调用替换为一个"
                },
                "fullDescription": {
                  "text": "报告可被替换为单个检查的多个 'isset()' 检查.",
                  "markdown": "报告可被替换为单个检查的多个 `isset()` 检查."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCombineMultipleIssetCallsIntoOneInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSuperClassIncompatibleWithInterfaceInspection",
                "shortDescription": {
                  "text": "父类的方法声明与实现的接口不兼容"
                },
                "fullDescription": {
                  "text": "报告父类中与实现的接口不兼容的方法声明。",
                  "markdown": "报告父类中与实现的接口不兼容的方法声明。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpSuperClassIncompatibleWithInterfaceInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAccessingStaticMembersOnTraitInspection",
                "shortDescription": {
                  "text": "正在访问 static 特征成员"
                },
                "fullDescription": {
                  "text": "报告用于特征的 static 成员访问表达式。 此类直接访问自 PHP 8.1 起已弃用。 相反，应该在使用特征的类上访问 static 成员。 有关详细信息，请参阅 PHP 8.1 弃用：访问特征上的 static 成员 (php.net)。",
                  "markdown": "报告用于特征的 static 成员访问表达式。 此类直接访问自 PHP 8.1 起已弃用。 相反，应该在使用特征的类上访问 static 成员。\n\n\n有关详细信息，请参阅 [PHP 8.1 弃用：访问特征上的 static 成员 (php.net)](https://wiki.php.net/rfc/deprecations_php_8_1#accessing_static_members_on_traits)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAccessingStaticMembersOnTraitInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitMisorderedAssertEqualsArgumentsInspection",
                "shortDescription": {
                  "text": "顺序错误的 PHPUnit 等式断言方法实参"
                },
                "fullDescription": {
                  "text": "报告对 PHPUnit 相等断言方法（如 'assertEquals()'、'assertNotEquals()'、'assertSame()' 等）的调用，这些方法的预期结果实参为非文字，实际结果实参为文字。 此类调用对于通过的断言将表现良好，但是如果它们的预期实参和实际实参不同，则可能产生令人困惑的错误报告。 有关详细信息，请参阅 assertEquals。",
                  "markdown": "报告对 PHPUnit 相等断言方法（如 `assertEquals()`、`assertNotEquals()`、`assertSame()` 等）的调用，这些方法的预期结果实参为非文字，实际结果实参为文字。 此类调用对于通过的断言将表现良好，但是如果它们的预期实参和实际实参不同，则可能产生令人困惑的错误报告。\n\n\n有关详细信息，请参阅 [assertEquals](https://phpunit.readthedocs.io/en/stable/assertions.html#assertequals)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitMisorderedAssertEqualsArgumentsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArraySearchInBooleanContextInspection",
                "shortDescription": {
                  "text": "'array_search()' 可被替换为 'in_array()' 调用"
                },
                "fullDescription": {
                  "text": "报告仅用于检查数组中是否存在某个元素的 'array_search()' 调用，即 'if (array_search($a, $b) === false) {}' 之类的表达式。 此类调用可以安全地替换为 'in_array()' 调用。",
                  "markdown": "报告仅用于检查数组中是否存在某个元素的 `array_search()` 调用，即 `if (array_search($a, $b) === false) {}` 之类的表达式。 此类调用可以安全地替换为 `in_array()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArraySearchInBooleanContextInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingVisibilityInspection",
                "shortDescription": {
                  "text": "缺少可见性"
                },
                "fullDescription": {
                  "text": "报告声明时未定义可见性的属性、常量和方法。 根据 PSR-12，应为以下方面定义可见性： 所有属性， 所有常量，如果您项目的 PHP 最低版本支持常量可见性（PHP 7.1 或更高版本）， 所有方法。 有关详细信息，请参阅 PSR-12: Extended Coding Style (php-fig.org)。",
                  "markdown": "报告声明时未定义可见性的属性、常量和方法。\n\n根据 PSR-12，应为以下方面定义可见性：\n\n* 所有属性，\n* 所有常量，如果您项目的 PHP 最低版本支持常量可见性（PHP 7.1 或更高版本），\n* 所有方法。\n\n\n有关详细信息，请参阅 [PSR-12: Extended Coding Style (php-fig.org)](https://www.php-fig.org/psr/psr-12/#43-properties-and-constants)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingVisibilityInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitExpectedExceptionDocTagIsDeprecatedInspection",
                "shortDescription": {
                  "text": "弃用的通过文档标记进行的异常处理"
                },
                "fullDescription": {
                  "text": "报告以下弃用的 PHPUnit 文档标记的用法。 '@expectedException' '@expectedExceptionMessage' '@expectedExceptionCode' '@expectedExceptionMessageRegExp'",
                  "markdown": "报告以下弃用的 PHPUnit 文档标记的用法。\n\n* `@expectedException`\n* `@expectedExceptionMessage`\n* `@expectedExceptionCode`\n* `@expectedExceptionMessageRegExp`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitExpectedExceptionDocTagIsDeprecatedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNotInstalledPackagesInspection",
                "shortDescription": {
                  "text": "未安装的 Composer 软件包"
                },
                "fullDescription": {
                  "text": "报告 composer.json 中需要但没有安装的 Composer 软件包。",
                  "markdown": "报告 *composer.json* 中需要但没有安装的 Composer 软件包。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNotInstalledPackagesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Composer",
                      "index": 54,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNeverTypedFunctionReturnViolationInspection",
                "shortDescription": {
                  "text": "'never' 类型的函数返回一个值"
                },
                "fullDescription": {
                  "text": "报告其 'never' 返回类型提示可能返回某个值的函数。 具有这种返回类型的函数不会返回任何值，必须通过调用 'die()'、'exit()' 等或者抛出异常来阻止其余脚本执行。 有关详细信息，请参阅 noreturn 类型 (php.net)。",
                  "markdown": "报告其 `never` 返回类型提示可能返回某个值的函数。 具有这种返回类型的函数不会返回任何值，必须通过调用 `die()`、`exit()` 等或者抛出异常来阻止其余脚本执行。\n\n\n有关详细信息，请参阅 [noreturn 类型 (php.net)](https://wiki.php.net/rfc/noreturn_type)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpNeverTypedFunctionReturnViolationInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicateCaseInspection",
                "shortDescription": {
                  "text": "switch 语句中存在重复的 case"
                },
                "fullDescription": {
                  "text": "报告在 'switch' 语句中重复的 'case' 表达式。 如果 'switch' 语句具有多个重复的 'case' 表达式，仅执行第一个表达式。",
                  "markdown": "报告在 `switch` 语句中重复的 `case` 表达式。\n\n如果 `switch` 语句具有多个重复的 `case` 表达式，仅执行第一个表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDuplicateCaseInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantIntersectionTypeInspection",
                "shortDescription": {
                  "text": "冗余的交叉类型"
                },
                "fullDescription": {
                  "text": "报告包含冗余类型的相交类型声明，例如，同时包含父类及其子类的交叉类型。 有关详细信息，请参阅 PHP RFC：纯相交类型 (php.net)。",
                  "markdown": "报告包含冗余类型的相交类型声明，例如，同时包含父类及其子类的交叉类型。\n\n\n有关详细信息，请参阅 [PHP RFC：纯相交类型 (php.net)](https://wiki.php.net/rfc/pure-intersection-types)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantIntersectionTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInappropriateInheritDocUsageInspection",
                "shortDescription": {
                  "text": "使用了不当的 @inheritDoc"
                },
                "fullDescription": {
                  "text": "报告不当的 '@inheritDoc' 用法： 对非类成员 对没有带有文档注释的超级成员的类成员。",
                  "markdown": "报告不当的 `@inheritDoc` 用法：\n\n* 对非类成员\n* 对没有带有文档注释的超级成员的类成员。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpInappropriateInheritDocUsageInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClassConstantAccessedViaChildClassInspection",
                "shortDescription": {
                  "text": "通过子类引用的类常量"
                },
                "fullDescription": {
                  "text": "报告通过子类对类常量的引用，该子类通过继承从父类获得常量，并且不会在自己的作用域内重写该常量。 此类引用可能会导致继承与重写之间的混淆，因此建议通过父类直接引用常量。",
                  "markdown": "报告通过子类对类常量的引用，该子类通过继承从父类获得常量，并且不会在自己的作用域内重写该常量。 此类引用可能会导致继承与重写之间的混淆，因此建议通过父类直接引用常量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpClassConstantAccessedViaChildClassInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSwitchStatementWitSingleBranchInspection",
                "shortDescription": {
                  "text": "只有一个 'case' 的 'switch'"
                },
                "fullDescription": {
                  "text": "报告仅包含一个 'case' 语句的 'switch' 语句。 此类 'switch' 语句可以转换为 'if' 语句。",
                  "markdown": "报告仅包含一个 `case` 语句的 `switch` 语句。 此类 `switch` 语句可以转换为 `if` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSwitchStatementWitSingleBranchInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayIndexImmediatelyRewrittenInspection",
                "shortDescription": {
                  "text": "数组索引会被立即重写"
                },
                "fullDescription": {
                  "text": "报告在访问之前被覆盖的数组索引上的写入表达式。",
                  "markdown": "报告在访问之前被覆盖的数组索引上的写入表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpArrayIndexImmediatelyRewrittenInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpGetClassCanBeReplacedWithClassNameLiteralInspection",
                "shortDescription": {
                  "text": "'get_class()' 调用可被替换为 '::class'"
                },
                "fullDescription": {
                  "text": "报告 'get_class()' 调用，并建议在 PHP 语言级别设置为 8.0 或更高时将其替换为 '::class'。 有关详细信息，请参阅 Allow ::class on objects (php.net)。",
                  "markdown": "报告 `get_class()` 调用，并建议在 PHP 语言级别设置为 8.0 或更高时将其替换为 `::class`。\n\n\n有关详细信息，请参阅 [Allow ::class on objects (php.net)](https://wiki.php.net/rfc/class_name_literal_on_object)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpGetClassCanBeReplacedWithClassNameLiteralInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpContinueTargetingSwitchInspection",
                "shortDescription": {
                  "text": "'continue' 针对 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告以 'switch' 语句为目标的 'continue' 语句。 在 PHP 7.3 和更高版本中，此类用法已弃用，并会发出 'E_WARNING'，因为它们很可能是编程错误的结果。 在 PHP 中，此类 'continue' 语句等效于 'break'，也就是说，它们会终止当前 'switch' 结构的执行。 在其他语言中，此类 'continue' 语句在 PHP 中的行为与 'continue 2' 相同，也就是说，它们将执行带到更高级别的控制结构（例如，外循环的下一迭代）。 有关详细信息，请参阅 continue (php.net)，break (php.net) 和 switch (php.net)。",
                  "markdown": "报告以 `switch` 语句为目标的 `continue` 语句。 在 PHP 7.3 和更高版本中，此类用法已弃用，并会发出 `E_WARNING `，因为它们很可能是编程错误的结果。\n\n* 在 PHP 中，此类 `continue` 语句等效于 `break`，也就是说，它们会终止当前 `switch` 结构的执行。\n* 在其他语言中，此类 `continue` 语句在 PHP 中的行为与 ` continue 2 ` 相同，也就是说，它们将执行带到更高级别的控制结构（例如，外循环的下一迭代）。\n\n\n有关详细信息，请参阅 [continue (php.net)](https://www.php.net/manual/en/control-structures.continue.php)，[break (php.net)](https://www.php.net/manual/en/control-structures.break.php) 和 [switch (php.net)](https://www.php.net/manual/en/control-structures.switch.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpContinueTargetingSwitchInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCurlyBraceAccessSyntaxUsageInspection",
                "shortDescription": {
                  "text": "使用了大括号访问语法"
                },
                "fullDescription": {
                  "text": "报告大括号语法在访问数组元素和字符串偏移时的用法。",
                  "markdown": "报告大括号语法在访问数组元素和字符串偏移时的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpCurlyBraceAccessSyntaxUsageInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRegExpInvalidDelimiterInspection",
                "shortDescription": {
                  "text": "无效分隔符"
                },
                "fullDescription": {
                  "text": "在两种情况下报告正则表达式中的无效分隔符： 1. 如果分隔符是字母数字或反斜杠。 2. 如果在正则表达式模式中使用了分隔符。",
                  "markdown": "在两种情况下报告正则表达式中的无效分隔符： 1. 如果分隔符是字母数字或反斜杠。 2. 如果在正则表达式模式中使用了分隔符。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpRegExpInvalidDelimiterInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/正则表达式",
                      "index": 116,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedNamespaceInspection",
                "shortDescription": {
                  "text": "未定义的命名空间"
                },
                "fullDescription": {
                  "text": "报告对找不到的命名空间的引用。",
                  "markdown": "报告对找不到的命名空间的引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedNamespaceInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedMethodInspection",
                "shortDescription": {
                  "text": "未定义的方法"
                },
                "fullDescription": {
                  "text": "报告对未定义的类方法的引用。",
                  "markdown": "报告对未定义的类方法的引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedMethodInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIncompatibleReturnTypeInspection",
                "shortDescription": {
                  "text": "返回值类型不兼容"
                },
                "fullDescription": {
                  "text": "报告'return'语句，该语句的返回类型与函数或方法中声明的返回类型不兼容。",
                  "markdown": "报告` return `语句，该语句的返回类型与函数或方法中声明的返回类型不兼容。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpIncompatibleReturnTypeInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingStrictTypesDeclarationInspection",
                "shortDescription": {
                  "text": "缺少严格类型声明"
                },
                "fullDescription": {
                  "text": "检测文件中缺少的 'declare(strict_types=1)' 指令。 请参阅 Strict typing (php.net) 以了解更多关于您可能需要使用这个指令的原因。",
                  "markdown": "检测文件中缺少的 `declare(strict_types=1)` 指令。\n\n\n请参阅 [Strict typing (php.net)](https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict) 以了解更多关于您可能需要使用这个指令的原因。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingStrictTypesDeclarationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConvertToJsonValidateInspection",
                "shortDescription": {
                  "text": "'json_decode()' 和 'json_last_error()' 可以转换为 'json_validate()'"
                },
                "fullDescription": {
                  "text": "在 PHP 8.3 和更高版本中，建议将 `json_decode()` 和 `json_last_error() === JSON_ERROR_NONE` 转换为 `json_validate()`。 有关详细信息，请参阅 PHP RFC: json_validate。",
                  "markdown": "在 PHP 8.3 和更高版本中，建议将 \\`json_decode()\\` 和 \\`json_last_error() === JSON_ERROR_NONE\\` 转换为 \\`json_validate()\\`。\n\n\n有关详细信息，请参阅 [PHP RFC: json_validate](https://wiki.php.net/rfc/json_validate)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpConvertToJsonValidateInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDoctrineAnnotationToAttributeInspection",
                "shortDescription": {
                  "text": "Doctrine 注解可被替换为特性"
                },
                "fullDescription": {
                  "text": "建议将 Doctrine 注解替换为特性。",
                  "markdown": "建议将 Doctrine 注解替换为特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDoctrineAnnotationToAttributeInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLanguageLevelInspection",
                "shortDescription": {
                  "text": "语言级别"
                },
                "fullDescription": {
                  "text": "报告源代码中对于所选的语言级别不被支持的语言特性。 例如，联合类型只能在 PHP 8.0 及更新版本中使用。",
                  "markdown": "报告源代码中对于所选的语言级别不被支持的语言特性。\n\n例如，联合类型只能在 PHP 8.0 及更新版本中使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpLanguageLevelInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAssignmentInConditionInspection",
                "shortDescription": {
                  "text": "条件中的赋值"
                },
                "fullDescription": {
                  "text": "报告在条件表达式中使用的赋值。",
                  "markdown": "报告在条件表达式中使用的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAssignmentInConditionInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCommentCanBeReplacedWithNamedArgumentInspection",
                "shortDescription": {
                  "text": "注释可被替换为命名实参"
                },
                "fullDescription": {
                  "text": "报告函数调用中实参前仅包含形参名称并因此用作提示的内联注释。 在 PHP 8.0 及更高版本中，可以改用命名实参。 有关详细信息，请参阅命名实参 (php.net)。",
                  "markdown": "报告函数调用中实参前仅包含形参名称并因此用作提示的内联注释。 在 PHP 8.0 及更高版本中，可以改用命名实参。\n\n\n有关详细信息，请参阅[命名实参 (php.net)](https://wiki.php.net/rfc/match_expression_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCommentCanBeReplacedWithNamedArgumentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNestedMinMaxCallInspection",
                "shortDescription": {
                  "text": "嵌套的 'min/max' 调用"
                },
                "fullDescription": {
                  "text": "报告嵌套的 'min'/'max' 调用。 由于 'min'/'max' 函数接受任意数量的实参，此类嵌套调用是冗余的。",
                  "markdown": "报告嵌套的 `min`/`max` 调用。 由于 `min`/`max` 函数接受任意数量的实参，此类嵌套调用是冗余的。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNestedMinMaxCallInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPluralMixedCanBeReplacedWithArrayInspection",
                "shortDescription": {
                  "text": "'mixed' 类型可被替换为 'array'"
                },
                "fullDescription": {
                  "text": "报告 PHPDoc 块中可以安全地用 'array' 替代的 'mixed[]' 的用法。",
                  "markdown": "报告 PHPDoc 块中可以安全地用 `array` 替代的 `mixed[]` 的用法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPluralMixedCanBeReplacedWithArrayInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicatedCharacterInStrFunctionCallInspection",
                "shortDescription": {
                  "text": "函数调用中的重复字符"
                },
                "fullDescription": {
                  "text": "报告在 'ltrim' 或 'str_words_counts' 等函数的 'characters' 实参中提供的重复字符。 此类重复很可能由错误导致，可以安全移除。",
                  "markdown": "报告在 `ltrim` 或 `str_words_counts` 等函数的 `characters` 实参中提供的重复字符。 此类重复很可能由错误导致，可以安全移除。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDuplicatedCharacterInStrFunctionCallInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAccessStaticViaInstanceInspection",
                "shortDescription": {
                  "text": "通过实例访问的类 static 成员"
                },
                "fullDescription": {
                  "text": "通过类实例而不是类本身报告对 static 方法和字段的引用。 虽然 PHP 语言规范允许通过实例变量引用 static 成员，但读者可能会误认为该方法依赖于实例，从而使代码令人困惑。 该快速修复会将实例变量替换为类名。 示例： 'class StaticClass {\n    public static function someStaticFunction(): int\n    {\n        return 3;\n    }\n\n  }\n\n  $var = new StaticClass\n  $var::someStaticFunction();' 在应用快速修复后： 'StaticClass::someStaticFunction()'",
                  "markdown": "通过类实例而不是类本身报告对 static 方法和字段的引用。\n\n虽然 PHP 语言规范允许通过实例变量引用 static 成员，但读者可能会误认为该方法依赖于实例，从而使代码令人困惑。\n\n该快速修复会将实例变量替换为类名。\n\n示例：\n\n\n      class StaticClass {\n        public static function someStaticFunction(): int\n        {\n            return 3;\n        }\n\n      }\n\n      $var = new StaticClass\n      $var::someStaticFunction();\n\n在应用快速修复后：\n\n\n      StaticClass::someStaticFunction()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAccessStaticViaInstanceInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRegExpRedundantModifierInspection",
                "shortDescription": {
                  "text": "冗余修饰符"
                },
                "fullDescription": {
                  "text": "报告在不包含字母的正则表达式模式中使用的 'i'（不区分大小写）修饰符。 此类修饰符冗余，可以安全移除。",
                  "markdown": "报告在不包含字母的正则表达式模式中使用的 `i`（不区分大小写）修饰符。 此类修饰符冗余，可以安全移除。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRegExpRedundantModifierInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/正则表达式",
                      "index": 116,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedPrivateFieldInspection",
                "shortDescription": {
                  "text": "未使用的 private 属性"
                },
                "fullDescription": {
                  "text": "报告从未使用的 private 属性。",
                  "markdown": "报告从未使用的 private 属性。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedPrivateFieldInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未使用的符号",
                      "index": 70,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSingleStatementWithBracesInspection",
                "shortDescription": {
                  "text": "单语句主体带大括号"
                },
                "fullDescription": {
                  "text": "报告控制结构（如循环或条件），其主体被包围在大括号中，但只包含一个子语句。 在这种情况下使用大括号不必要。 有关详细信息，请参阅 Control structures (php.net)。",
                  "markdown": "报告控制结构（如循环或条件），其主体被包围在大括号中，但只包含一个子语句。 在这种情况下使用大括号不必要。\n\n\n有关详细信息，请参阅 [Control structures (php.net)](https://www.php.net/manual/en/language.control-structures.php)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSingleStatementWithBracesInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryElseBranchInspection",
                "shortDescription": {
                  "text": "不必要的 'else' 分支"
                },
                "fullDescription": {
                  "text": "报告语句体始终执行 'return' 或 'throw' 等终止语句的 'if' 语句中的 'else' 分支。 这种分支是冗余的，可以安全地省略。",
                  "markdown": "报告语句体始终执行 `return` 或 `throw` 等终止语句的 `if` 语句中的 `else` 分支。 这种分支是冗余的，可以安全地省略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryElseBranchInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SymfonyImportMapModuleIsNotInstalled",
                "shortDescription": {
                  "text": "importmap 中未安装模块"
                },
                "fullDescription": {
                  "text": "报告未安装的模块，并建议运行 \"importmap:require\" 或 \"importmap:install\" 命令",
                  "markdown": "报告未安装的模块，并建议运行 \"importmap:require\" 或 \"importmap:install\" 命令"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SymfonyImportMapModuleIsNotInstalled",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Symfony",
                      "index": 151,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPointlessBooleanExpressionInConditionInspection",
                "shortDescription": {
                  "text": "'if' 条件内的无意义布尔表达式"
                },
                "fullDescription": {
                  "text": "报告 'if' 条件内部包含 '$expr == true' 或 '$expr == false' 的布尔表达式。 此类表达式可以简化为 'if($expr)' 和 'if(!expr)'。",
                  "markdown": "报告 `if` 条件内部包含 `$expr == true` 或 `$expr == false` 的布尔表达式。 此类表达式可以简化为 `if($expr)` 和 `if(!expr)`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPointlessBooleanExpressionInConditionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCaseWithValueNotFoundInEnumInspection",
                "shortDescription": {
                  "text": "枚举中找不到包含指定值的 case"
                },
                "fullDescription": {
                  "text": "报告在目标枚举类中找不到的枚举 'from' 方法调用的实参。 有关详细信息，请参阅枚举 (php.net)。",
                  "markdown": "报告在目标枚举类中找不到的枚举 `from` 方法调用的实参。\n\n\n有关详细信息，请参阅[枚举 (php.net)](https://wiki.php.net/rfc/enumerations)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpCaseWithValueNotFoundInEnumInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpToStringImplementationInspection",
                "shortDescription": {
                  "text": "方法 '__toString' 实现"
                },
                "fullDescription": {
                  "text": "报告将没有 '__ toString' 方法实现的对象转换为 'string' 的尝试。 在 PHP 7.4 之前，这将导致一个致命的 'E_RECOVERABLE_ERROR' 级错误。 在 PHP 7.4 中，会抛出一个致命的不可恢复的 'ERROR'。 从 PHP 8.0 开始，返回值遵循标准 PHP 类型语义，如果可能且严格类型模式被禁用，就会被强制转换为字符串。 如果启用了检查每种表达式类型是否存在 __toString 选项，则该检查将会检查表达式的所有可能类型，如果其中至少一种类型不包含 '__toString' 方法实现，则进行报告。 有关详细信息，请参阅 __toString (php.net)。",
                  "markdown": "报告将没有 `__ toString` 方法实现的对象转换为 `string` 的尝试。\n\n\n在 PHP 7.4 之前，这将导致一个致命的 `E_RECOVERABLE_ERROR` 级错误。 在 PHP 7.4 中，会抛出一个致命的不可恢复的 `ERROR`。 从 PHP 8.0 开始，返回值遵循标准 PHP 类型语义，如果可能且严格类型模式被禁用，就会被强制转换为字符串。\n\n\n如果启用了**检查每种表达式类型是否存在 __toString** 选项，则该检查将会检查表达式的所有可能类型，如果其中至少一种类型不包含 `__toString` 方法实现，则进行报告。\n\n\n有关详细信息，请参阅 [__toString (php.net)](https://www.php.net/manual/en/language.oop5.magic.php#language.oop5.magic.tostring)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpToStringImplementationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayAccessCanBeReplacedWithForeachValueInspection",
                "shortDescription": {
                  "text": "数组访问可被替换为 'foreach' 值"
                },
                "fullDescription": {
                  "text": "报告 'foreach' 循环内可以用 'foreach' 值替换的数组访问表达式。",
                  "markdown": "报告 `foreach` 循环内可以用 `foreach` 值替换的数组访问表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayAccessCanBeReplacedWithForeachValueInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLoopCanBeConvertedToArrayFilterInspection",
                "shortDescription": {
                  "text": "循环可以转换为 'array_filter()' 调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'array_filter()' 调用的 'foreach' 循环。",
                  "markdown": "报告可以替换为 `array_filter()` 调用的 `foreach` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLoopCanBeConvertedToArrayFilterInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitInvalidMockingEntityInspection",
                "shortDescription": {
                  "text": "无效的 PHPUnit 模拟目标"
                },
                "fullDescription": {
                  "text": "报告在 PHPUnit 测试中被错误模拟的方法和类。 报告以下实体： 枚举和 'final' 类 'private'、'static' 或 'final' 方法 通过 'addMethods()'、'onlyMethods()'、'setMethods()' 等在模拟方法列表中提供的重复方法。",
                  "markdown": "报告在 PHPUnit 测试中被错误模拟的方法和类。\n\n\n报告以下实体：\n\n* 枚举和 `final` 类\n* `private`、`static` 或 `final` 方法\n* 通过 `addMethods()`、`onlyMethods()`、`setMethods()` 等在模拟方法列表中提供的重复方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpUnitInvalidMockingEntityInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertCanBeReplacedWithEmptyInspection",
                "shortDescription": {
                  "text": "断言可被替换为 'assertEmpty/assertNotEmpty'"
                },
                "fullDescription": {
                  "text": "报告 PHPUnit 测试中可以替换为 'assertEmpty'/'assertNotEmpty' 的'assertTrue'/'assertFalse' 的用法。 有关详细信息，请参阅 assertEmpty (phpunit.readthedocs.io)。",
                  "markdown": "报告 PHPUnit 测试中可以替换为 `assertEmpty`/`assertNotEmpty` 的`assertTrue`/`assertFalse` 的用法。\n\n\n有关详细信息，请参阅 [assertEmpty (phpunit.readthedocs.io)](https://phpunit.readthedocs.io/en/stable/assertions.html#assertempty)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertCanBeReplacedWithEmptyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIgnoredClassAliasDeclaration",
                "shortDescription": {
                  "text": "忽略的类别名声明"
                },
                "fullDescription": {
                  "text": "报告被 IDE 忽略的类别名声明，因为存在相同 FQN 的实际类声明。 检查的目的是澄清 IDE 在类和类别名声明同时存在的情况下的行为。 当存在几个具有相同 FQN 的声明时，IDE 通常无法在它们之间选择一个声明。 这会导致不正确的代码补全、错误的类型推断等。 由于类的声明优先于 类的别名声明，后者成为冗余的，因此被 IDE 忽略了。 注意，忽略类别名声明并不影响 PHP 解释器的行为。",
                  "markdown": "报告被 IDE 忽略的类别名声明，因为存在相同 FQN 的实际类声明。\n\n\n检查的目的是澄清 IDE 在类和类别名声明同时存在的情况下的行为。\n当存在几个具有相同 FQN 的声明时，IDE 通常无法在它们之间选择一个声明。\n这会导致不正确的代码补全、错误的类型推断等。 由于类的声明优先于\n类的别名声明，后者成为冗余的，因此被 IDE 忽略了。\n\n\n注意，忽略类别名声明并不影响 PHP 解释器的行为。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIgnoredClassAliasDeclaration",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpStatementHasEmptyBodyInspection",
                "shortDescription": {
                  "text": "语句具有空体"
                },
                "fullDescription": {
                  "text": "报告主体为空的语句。 虽然偶尔有用，但此类语句通常是拼写错误的结果，可能会引起混淆。",
                  "markdown": "报告主体为空的语句。\n\n虽然偶尔有用，但此类语句通常是拼写错误的结果，可能会引起混淆。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpStatementHasEmptyBodyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPureFunctionMayProduceSideEffectsInspection",
                "shortDescription": {
                  "text": "纯函数可能会产生副作用"
                },
                "fullDescription": {
                  "text": "报告可能产生副作用的函数上使用的 '#[Pure]' 注解。",
                  "markdown": "报告可能产生副作用的函数上使用的 `#[Pure]` 注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPureFunctionMayProduceSideEffectsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedeclarationStdlibFunctionInspection",
                "shortDescription": {
                  "text": "标准库函数的重复声明"
                },
                "fullDescription": {
                  "text": "报告标准库函数的重新声明。 标准库中的函数不能在用户代码中重新声明。",
                  "markdown": "报告标准库函数的重新声明。 标准库中的函数不能在用户代码中重新声明。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpRedeclarationStdlibFunctionInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpForeachNestedOuterKeyValueVariablesConflictInspection",
                "shortDescription": {
                  "text": "嵌套与外部 'foreach' 变量冲突"
                },
                "fullDescription": {
                  "text": "报告同时被内部和外部 'foreach' 循环作为键或值的变量。 在大多数情况下，这是一个错误，或者将来可能会导致错误。",
                  "markdown": "报告同时被内部和外部 `foreach` 循环作为键或值的变量。 在大多数情况下，这是一个错误，或者将来可能会导致错误。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpForeachNestedOuterKeyValueVariablesConflictInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMethodParametersCountMismatchInspection",
                "shortDescription": {
                  "text": "形参数量与声明不匹配"
                },
                "fullDescription": {
                  "text": "报告采取比声明中指定的更多形参的函数/方法调用。",
                  "markdown": "报告采取比声明中指定的更多形参的函数/方法调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMethodParametersCountMismatchInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSwitchCaseWithoutDefaultBranchInspection",
                "shortDescription": {
                  "text": "switch 语句没有 default 分支"
                },
                "fullDescription": {
                  "text": "报告没有默认分支的 'switch' 语句。",
                  "markdown": "报告没有默认分支的 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSwitchCaseWithoutDefaultBranchInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LaravelPintValidationInspection",
                "shortDescription": {
                  "text": "Laravel Pint 验证"
                },
                "fullDescription": {
                  "text": "报告由 Laravel Pint 检测到的代码样式问题。 该项检查要求正确安装 Laravel Pint，并在 IDE 中的设置 | PHP | 质量工具 | Laravel Pint 下正确设置。 要详细了解 Laravel Pint 安装，请参阅：Laravel Pint。",
                  "markdown": "报告由 Laravel Pint 检测到的代码样式问题。\n\n\n该项检查要求正确安装 Laravel Pint，并在 IDE 中的[设置 \\| PHP \\| 质量工具 \\| Laravel Pint](settings://settings.php.quality.tools.laravel.pint) 下正确设置。\n\n\n要详细了解 Laravel Pint 安装，请参阅：[Laravel Pint](https://laravel.com/docs/10.x/pint#installation)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LaravelPintValidationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/质量工具",
                      "index": 152,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMultipleClassDeclarationsInspection",
                "shortDescription": {
                  "text": "多个类声明"
                },
                "fullDescription": {
                  "text": "报告对在项目文件中有多个声明的类的引用。 使用以下选项来自定义检查： 忽略 PHPDoc ：如果选择，检查将不会报告在 PHPDoc 块中引用的类的多个声明。",
                  "markdown": "报告对在项目文件中有多个声明的类的引用。\n\n使用以下选项来自定义检查：\n\n* **忽略 PHPDoc** ：如果选择，检查将不会报告在 PHPDoc 块中引用的类的多个声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMultipleClassDeclarationsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClassImplementsSolelyTraversableInspection",
                "shortDescription": {
                  "text": "类无法直接实现 Traversable"
                },
                "fullDescription": {
                  "text": "报告那些单独实现 'Traversable' 接口的类，而不是作为 'Iterator' 或 'IteratorAggregate' 接口的一部分。 'Traversable' 接口是一个内部引擎接口；它不能在 PHP 脚本中实现。 有关详细信息，请参阅 The Traversable interface (php.net)。",
                  "markdown": "报告那些单独实现 `Traversable` 接口的类，而不是作为 `Iterator` 或 `IteratorAggregate` 接口的一部分。\n\n\n`Traversable` 接口是一个内部引擎接口；它不能在 PHP 脚本中实现。 有关详细信息，请参阅 [The Traversable interface (php.net)](https://www.php.net/manual/en/class.traversable.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpClassImplementsSolelyTraversableInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedSwitchBranchInspection",
                "shortDescription": {
                  "text": "未使用的 'switch' 分支"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句中不属于枚举 case 集并且因此未执行的分支。 有关详细信息，请参阅枚举 (php.net)。",
                  "markdown": "报告 `switch` 语句中不属于枚举 case 集并且因此未执行的分支。\n\n\n有关详细信息，请参阅[枚举 (php.net)](https://wiki.php.net/rfc/enumerations)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedSwitchBranchInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPromotedFieldUsageInspection",
                "shortDescription": {
                  "text": "提升的属性用法"
                },
                "fullDescription": {
                  "text": "报告通过提升的构造函数形参声明的属性。 仅在 PHP 8.0 及更高版本允许使用提升的属性。 在早期的 PHP 版本中，它会导致一个解析错误。 有关详细信息，请参阅 Constructor Property Promotion (php.net)。",
                  "markdown": "报告通过提升的构造函数形参声明的属性。\n\n\n仅在 PHP 8.0 及更高版本允许使用提升的属性。 在早期的 PHP 版本中，它会导致一个解析错误。\n\n\n有关详细信息，请参阅 [Constructor Property Promotion (php.net)](https://wiki.php.net/rfc/constructor_promotion)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPromotedFieldUsageInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDocFieldTypeMismatchInspection",
                "shortDescription": {
                  "text": "类型与属性的声明类型不匹配"
                },
                "fullDescription": {
                  "text": "报告 PHPDoc '@var' 标签中与属性的声明类型不匹配的属性类型。",
                  "markdown": "报告 PHPDoc `@var` 标签中与属性的声明类型不匹配的属性类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDocFieldTypeMismatchInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLoopCanBeReplacedWithStrRepeatInspection",
                "shortDescription": {
                  "text": "循环可被替换为 'str_repeat'"
                },
                "fullDescription": {
                  "text": "报告可以安全地替换为 'str_repeat()' 调用的 'for' 循环。",
                  "markdown": "报告可以安全地替换为 `str_repeat()` 调用的 `for` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLoopCanBeReplacedWithStrRepeatInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryCurlyVarSyntaxInspection",
                "shortDescription": {
                  "text": "变量的不必要大括号语法"
                },
                "fullDescription": {
                  "text": "报告不必要的'{'和'}'，用于在字符串文字中对变量进行内插。 有关详细信息，请参阅 Variable parsing (php.net)。",
                  "markdown": "报告不必要的`{`和`}`，用于在字符串文字中对变量进行内插。\n\n\n有关详细信息，请参阅 [Variable parsing (php.net)](https://www.php.net/manual/en/language.types.string.php#language.types.string.parsing)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryCurlyVarSyntaxInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFunctionNamingConventionInspection",
                "shortDescription": {
                  "text": "函数名称未遵循编码约定"
                },
                "fullDescription": {
                  "text": "报告太短、太长或不符合指定的正则表达式模式的函数名称。 某些编码风格对函数有特殊的命名约定。 使用检查选项来指定函数名称的最小/最大长度和预期正则表达式。 要忽略名字的长度，指定 0。 要了解更多关于正则表达式的信息，请参考 Quick Start guide (regular-expressions.info)。",
                  "markdown": "报告太短、太长或不符合指定的正则表达式模式的函数名称。 某些编码风格对函数有特殊的命名约定。\n\n\n使用检查选项来指定函数名称的最小/最大长度和预期正则表达式。\n要忽略名字的长度，指定 **0**。\n\n\n要了解更多关于正则表达式的信息，请参考 [Quick Start guide (regular-expressions.info)](https://www.regular-expressions.info/quickstart.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpFunctionNamingConventionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/命名约定",
                      "index": 16,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIssetCanBeReplacedWithCoalesceInspection",
                "shortDescription": {
                  "text": "'isset' 可被替换为合并"
                },
                "fullDescription": {
                  "text": "报告使用 'isset' 的条件，这些条件可以安全地被使用 '??' null合并运算符的表达式取代。 有关详细信息，请参阅 Null coalesce operator (php.net)。",
                  "markdown": "报告使用 `isset` 的条件，这些条件可以安全地被使用 `??` null合并运算符的表达式取代。\n\n\n有关详细信息，请参阅 [Null coalesce operator (php.net)](https://wiki.php.net/rfc/isset_ternary)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIssetCanBeReplacedWithCoalesceInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpVoidFunctionResultUsedInspection",
                "shortDescription": {
                  "text": "使用了无效的函数结果"
                },
                "fullDescription": {
                  "text": "报告 'void' 或 'never' 函数的返回值的用法。 由于 'void' 函数没有返回值，且 'never' 函数会终止执行或抛出异常，这种用法很可能是编程错误。",
                  "markdown": "报告 `void` 或 `never` 函数的返回值的用法。\n\n\n由于 `void` 函数没有返回值，且 `never` 函数会终止执行或抛出异常，这种用法很可能是编程错误。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpVoidFunctionResultUsedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicateMatchArmBodyInspection",
                "shortDescription": {
                  "text": "'match' 表达式中的重复 arm"
                },
                "fullDescription": {
                  "text": "报告在 'match' 分支中的重复主体。 有关详细信息，请参阅 Match expression (php.net)。",
                  "markdown": "报告在 `match` 分支中的重复主体。\n\n\n有关详细信息，请参阅 [Match expression (php.net)](https://wiki.php.net/rfc/match_expression_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDuplicateMatchArmBodyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitCoversFunctionWithoutScopeResolutionOperatorInspection",
                "shortDescription": {
                  "text": "提供的覆盖函数引用没有 '::'"
                },
                "fullDescription": {
                  "text": "报告对 '@covers' PHPDoc 标记中不带范围解析运算符（'::'）的函数/方法的引用。",
                  "markdown": "报告对 `@covers` PHPDoc 标记中不带范围解析运算符（`::`）的函数/方法的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitCoversFunctionWithoutScopeResolutionOperatorInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayAccessOnIllegalTypeInspection",
                "shortDescription": {
                  "text": "非法类型的数组偏移访问"
                },
                "fullDescription": {
                  "text": "报告在非法类型上使用的数组偏移访问表达式。",
                  "markdown": "报告在非法类型上使用的数组偏移访问表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayAccessOnIllegalTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SymfonyLibraryIsNotDownloaded",
                "shortDescription": {
                  "text": "缺少本地存储的 HTTP 链接库"
                },
                "fullDescription": {
                  "text": "报告缺少的本地存储库",
                  "markdown": "报告缺少的本地存储库"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SymfonyLibraryIsNotDownloaded",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Symfony",
                      "index": 151,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingClassConstantTypeInspection",
                "shortDescription": {
                  "text": "缺少类常量类型"
                },
                "fullDescription": {
                  "text": "在 PHP 8.3 及更高版本中，报告缺少类型声明的类常量。 建议插入正确的类常量类型。",
                  "markdown": "在 PHP 8.3 及更高版本中，报告缺少类型声明的类常量。 建议插入正确的类常量类型。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingClassConstantTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLoopCanBeConvertedToArrayFillInspection",
                "shortDescription": {
                  "text": "循环可以转换为 'array_fill()' 调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'array_fill()' 调用的 'for' 循环。",
                  "markdown": "报告可以替换为 `array_fill()` 调用的 `for` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLoopCanBeConvertedToArrayFillInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedFieldInspection",
                "shortDescription": {
                  "text": "未定义的属性"
                },
                "fullDescription": {
                  "text": "报告对未声明的类属性的引用。 检查会跳过 'stdClass' 或派生类型的对象。",
                  "markdown": "报告对未声明的类属性的引用。\n\n\n检查会跳过 `stdClass` 或派生类型的对象。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedFieldInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedClassConstantInspection",
                "shortDescription": {
                  "text": "未定义的类常量"
                },
                "fullDescription": {
                  "text": "报告对未声明的类常量的引用。",
                  "markdown": "报告对未声明的类常量的引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedClassConstantInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPregMatchWithoutEffectiveRegexpInspection",
                "shortDescription": {
                  "text": "'preg_match' 可被替换为 'str_contains'"
                },
                "fullDescription": {
                  "text": "报告所包含的 'pattern' 实参不使用任何正则表达式工具的 'preg_match' 调用。 此类调用可被替换为 'str_starts_with()'、'str_ends_with()' 或 'str_contains()' 调用。",
                  "markdown": "报告所包含的 `pattern` 实参不使用任何正则表达式工具的 `preg_match` 调用。 此类调用可被替换为 `str_starts_with()`、`str_ends_with()` 或 `str_contains()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPregMatchWithoutEffectiveRegexpInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIfCanBeReplacedWithMatchExpressionInspection",
                "shortDescription": {
                  "text": "'if' 可被替换为 'match' 表达式"
                },
                "fullDescription": {
                  "text": "报告 'if-elseif-else' 结构内部使用严格比较 ('===') 且可以替换为 'match' 表达式的 'if' 语句。",
                  "markdown": "报告 `if-elseif-else` 结构内部使用严格比较 (`===`) 且可以替换为 `match` 表达式的 `if` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIfCanBeReplacedWithMatchExpressionInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUselessTrailingCommaInspection",
                "shortDescription": {
                  "text": "无用的尾随逗号"
                },
                "fullDescription": {
                  "text": "报告形参列表和闭包的 'use' 列表中没有带来任何好处的尾随逗号。 在单行列表中，尾随逗号是多余的，可以删除。 在多行列表中，如果在逗号后没有提供换行符，则无法轻松地添加，删除或移动行。",
                  "markdown": "报告形参列表和闭包的 `use` 列表中没有带来任何好处的尾随逗号。\n\n* 在单行列表中，尾随逗号是多余的，可以删除。\n* 在多行列表中，如果在逗号后没有提供换行符，则无法轻松地添加，删除或移动行。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUselessTrailingCommaInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClassCanBeReadonlyInspection",
                "shortDescription": {
                  "text": "类可以为 'readonly'"
                },
                "fullDescription": {
                  "text": "报告仅包含 'readonly' 属性的类。",
                  "markdown": "报告仅包含 `readonly` 属性的类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpClassCanBeReadonlyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedAliasInspection",
                "shortDescription": {
                  "text": "未使用的 import"
                },
                "fullDescription": {
                  "text": "报告从未使用的导入。",
                  "markdown": "报告从未使用的导入。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedAliasInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未使用的符号",
                      "index": 70,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantDefaultBreakContinueArgumentInspection",
                "shortDescription": {
                  "text": "冗余的 'continue/break' 实参"
                },
                "fullDescription": {
                  "text": "报告 'continue' 和 'break' 语句的冗余 '1' 实参。 由于此实参是可选的，并且其默认值为 '1'，因此可以省略此类用法。 有关详细信息，请参阅 continue (php.net) 和 break (php.net)。",
                  "markdown": "报告 `continue` 和 `break` 语句的冗余 `1` 实参。 由于此实参是可选的，并且其默认值为 `1`，因此可以省略此类用法。\n\n\n有关详细信息，请参阅 [continue (php.net)](https://www.php.net/manual/en/control-structures.continue.php) 和 [break (php.net)](https://www.php.net/manual/en/control-structures.break.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantDefaultBreakContinueArgumentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIllegalPsrClassPathInspection",
                "shortDescription": {
                  "text": "类路径与项目结构不匹配"
                },
                "fullDescription": {
                  "text": "报告文件路径不遵循 PSR-0/PSR-4 项目结构的类。 您可以在 设置/偏好设置 | 目录 下配置项目供应商的根目录。 有关详细信息，请参阅 PSR-0/PSR-4 standards (php-fig.org)。",
                  "markdown": "报告文件路径不遵循 PSR-0/PSR-4 项目结构的类。\n\n\n您可以在 **设置/偏好设置 \\| 目录** 下配置项目供应商的根目录。\n\n\n有关详细信息，请参阅 [PSR-0/PSR-4 standards (php-fig.org)](https://www.php-fig.org/psr/psr-4/)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpIllegalPsrClassPathInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantMethodOverrideInspection",
                "shortDescription": {
                  "text": "冗余方法重写"
                },
                "fullDescription": {
                  "text": "报告只包含对父方法的单个调用的重写方法。",
                  "markdown": "报告只包含对父方法的单个调用的重写方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantMethodOverrideInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDefineCanBeReplacedWithConstInspection",
                "shortDescription": {
                  "text": "define 常量名称可被替换为 'const' 语法"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'const' 语法的 'define()' 调用。",
                  "markdown": "报告可以替换为 `const` 语法的 `define()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDefineCanBeReplacedWithConstInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayAppendUsingCountInspection",
                "shortDescription": {
                  "text": "使用 'count()' 作为索引将值追加到数组"
                },
                "fullDescription": {
                  "text": "报告用作数组索引将元素追加到数组的 'count($array)' 调用：'$array[count($array)] = 42'。 在此类情况下，建议改用中括号语法 ('$array[] = 42')，这样不会增加调用函数的开销。",
                  "markdown": "报告用作数组索引将元素追加到数组的 `count($array)` 调用：`$array[count($array)] = 42`。 在此类情况下，建议改用中括号语法 (`$array[] = 42`)，这样不会增加调用函数的开销。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayAppendUsingCountInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSwitchCanBeReplacedWithMatchExpressionInspection",
                "shortDescription": {
                  "text": "'switch' 可被替换为 'match' 表达式"
                },
                "fullDescription": {
                  "text": "报告可以用 'match' 表达式代替的 'switch' 语句",
                  "markdown": "报告可以用 'match' 表达式代替的 'switch' 语句"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSwitchCanBeReplacedWithMatchExpressionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFormatFunctionParametersMismatchInspection",
                "shortDescription": {
                  "text": "格式函数形参不匹配"
                },
                "fullDescription": {
                  "text": "报告格式函数（如 'printf' 或 'sprintf'）的实参，这些实参没有被映射到任何形参或规范转换。 有关详细信息，请参阅 printf (php.net) 和 sprintf (php.net)。",
                  "markdown": "报告格式函数（如 `printf` 或 `sprintf`）的实参，这些实参没有被映射到任何形参或规范转换。\n\n\n有关详细信息，请参阅 [printf (php.net)](https://www.php.net/manual/en/function.printf.php) 和 [sprintf (php.net)](https://www.php.net/manual/en/function.sprintf.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpFormatFunctionParametersMismatchInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpForeachVariableOverwritesAlreadyDefinedVariableInspection",
                "shortDescription": {
                  "text": "'foreach' 变量重写已定义的变量"
                },
                "fullDescription": {
                  "text": "报告 'foreach' 循环中的键和值，这些键和值在 'foreach' 循环之前被分配了一个非基元值，并在其之后被访问。 这可能导致潜在的错误，因为它意外地覆盖了已经定义的值。",
                  "markdown": "报告 `foreach` 循环中的键和值，这些键和值在 `foreach` 循环之前被分配了一个非基元值，并在其之后被访问。 这可能导致潜在的错误，因为它意外地覆盖了已经定义的值。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpForeachVariableOverwritesAlreadyDefinedVariableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDisabledExtensionStubsInspection",
                "shortDescription": {
                  "text": "已禁用的扩展存根"
                },
                "fullDescription": {
                  "text": "报告相应 PHP 解释器扩展的存根对其被禁用的类、函数和常量的使用。 可以在设置 | PHP | PHP 运行时下配置存根集。 有关详细信息，请参阅 PhpStorm stubs (blog.jetbrains.com/phpstorm)。",
                  "markdown": "报告相应 PHP 解释器扩展的存根对其被禁用的类、函数和常量的使用。\n\n\n可以在[设置 \\| PHP \\| PHP 运行时](settings://reference.webide.settings.project.settings.php?PHP%20Runtime)下配置存根集。\n\n\n有关详细信息，请参阅 [PhpStorm stubs (blog.jetbrains.com/phpstorm)](https://blog.jetbrains.com/phpstorm/2018/03/how-to-provide-stubs-for-phpstorm/)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDisabledExtensionStubsInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTernaryExpressionCanBeReplacedWithConditionInspection",
                "shortDescription": {
                  "text": "三元表达式可被替换为条件"
                },
                "fullDescription": {
                  "text": "报告三元表达式，该表达式可以将 'condition ? true : false' 安全替换为 'condition'。",
                  "markdown": "报告三元表达式，该表达式可以将 `condition ? true : false` 安全替换为 `condition`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTernaryExpressionCanBeReplacedWithConditionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClosureCanBeConvertedToFirstClassCallableInspection",
                "shortDescription": {
                  "text": "'Closure::fromCallable()' 可以转换为一级可调用语法"
                },
                "fullDescription": {
                  "text": "报告使用 'Closure::fromCallable' 但可以替换为自 PHP 8.1 起可用的一级可调用语法 'f(...)' 的 'callable' 创建表达式。 有关详细信息，请参阅一级可调用语法 (php.net)。",
                  "markdown": "报告使用 `Closure::fromCallable` 但可以替换为自 PHP 8.1 起可用的一级可调用语法 `f(...)` 的 `callable` 创建表达式。\n\n\n有关详细信息，请参阅[一级可调用语法 (php.net)](https://wiki.php.net/rfc/first_class_callable_syntax)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpClosureCanBeConvertedToFirstClassCallableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpExpressionAlwaysNullInspection",
                "shortDescription": {
                  "text": "表达式始终为 'null'"
                },
                "fullDescription": {
                  "text": "报告 'return' 语句中始终为 'null' 的变量。",
                  "markdown": "报告 `return` 语句中始终为 `null` 的变量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpExpressionAlwaysNullInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDefineConstantNameStartsWithLeadingSlashInspection",
                "shortDescription": {
                  "text": "使用前导斜杠定义的常量名称"
                },
                "fullDescription": {
                  "text": "报告 'define' 结构，其中常量的 FQN 由前导斜杠开头。 此类常量将不会被 PHP 正确注册。",
                  "markdown": "报告 `define` 结构，其中常量的 FQN 由前导斜杠开头。 此类常量将不会被 PHP 正确注册。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDefineConstantNameStartsWithLeadingSlashInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertCountInspection",
                "shortDescription": {
                  "text": "使用了 'assertCount/assertSameSize' 方法而非 assertEquals"
                },
                "fullDescription": {
                  "text": "报告 'assertEquals' 和 'assertNotEquals' 方法的替代用法，以 'count' 函数作为形参 有关详细信息，请参阅 Usage of the assertCount。 有关详细信息，请参阅 Usage of the assertSameSize。",
                  "markdown": "报告 `assertEquals` 和 `assertNotEquals` 方法的替代用法，以 `count` 函数作为形参\n\n\n有关详细信息，请参阅 [Usage of the assertCount](https://phpunit.readthedocs.io/en/stable/assertions.html#assertcount)。\n\n\n有关详细信息，请参阅 [Usage of the assertSameSize](https://hotexamples.com/examples/-/PHPUnit_Framework_Assert/assertSameSize/php-phpunit_framework_assert-assertsamesize-method-examples.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertCountInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryParenthesesInspection",
                "shortDescription": {
                  "text": "不必要的圆括号"
                },
                "fullDescription": {
                  "text": "报告含有冗余圆括号的表达式，这些圆括号可以被安全地移除。",
                  "markdown": "报告含有冗余圆括号的表达式，这些圆括号可以被安全地移除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryParenthesesInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIfCanBeMergedWithSequentialConditionInspection",
                "shortDescription": {
                  "text": "'if' 可以与后续条件合并"
                },
                "fullDescription": {
                  "text": "报告一个后面跟随主体相同的 'elseif' 或其他 'if' 语句的 'if' 语句。 此类声明可以合并在一起。",
                  "markdown": "报告一个后面跟随主体相同的 `elseif` 或其他 `if` 语句的 `if` 语句。 此类声明可以合并在一起。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIfCanBeMergedWithSequentialConditionInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpShortOpenTagInspection",
                "shortDescription": {
                  "text": "使用了短起始标记"
                },
                "fullDescription": {
                  "text": "报告短的 PHP 起始标记 '<?' 的用法。 由于短标记可以在 PHP 解释器配置中被禁用，使用它们可能会导致代码兼容性问题。 有关详细信息，请参阅 PHP tags (php.net)。",
                  "markdown": "报告短的 PHP 起始标记 `<?` 的用法。 由于短标记可以在 PHP 解释器配置中被禁用，使用它们可能会导致代码兼容性问题。\n\n\n有关详细信息，请参阅 [PHP tags (php.net)](https://www.php.net/manual/en/language.basic-syntax.phptags.php#language.basic-syntax.phptags)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpShortOpenTagInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpReturnDocTypeMismatchInspection",
                "shortDescription": {
                  "text": "PHPDoc 注释中的返回值类型与实际返回值类型不匹配"
                },
                "fullDescription": {
                  "text": "报告 PHPDoc 注释中与函数的实际返回类型不匹配的返回类型。",
                  "markdown": "报告 PHPDoc 注释中与函数的实际返回类型不匹配的返回类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpReturnDocTypeMismatchInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpElementIsNotAvailableInCurrentPhpVersionInspection",
                "shortDescription": {
                  "text": "元素在配置的 PHP 版本中不可用"
                },
                "fullDescription": {
                  "text": "报告使用比配置的 PHP 版本更新的实体的情况。",
                  "markdown": "报告使用比配置的 PHP 版本更新的实体的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpElementIsNotAvailableInCurrentPhpVersionInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingParamTypeInspection",
                "shortDescription": {
                  "text": "缺少形参的类型声明"
                },
                "fullDescription": {
                  "text": "报告未指定类型声明的形参。",
                  "markdown": "报告未指定类型声明的形参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingParamTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingParentCallCommonInspection",
                "shortDescription": {
                  "text": "方法缺少父调用"
                },
                "fullDescription": {
                  "text": "报告那些不调用其父方法的方法。",
                  "markdown": "报告那些不调用其父方法的方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingParentCallCommonInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMixedReturnTypeCanBeReducedInspection",
                "shortDescription": {
                  "text": "可以缩小 'mixed' 返回值类型的范围"
                },
                "fullDescription": {
                  "text": "报告 'mixed' 返回类型，可以将其缩小为更具体的类型。",
                  "markdown": "报告 'mixed' 返回类型，可以将其缩小为更具体的类型。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMixedReturnTypeCanBeReducedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTraditionalSyntaxArrayLiteralInspection",
                "shortDescription": {
                  "text": "检测到传统语法数组文字"
                },
                "fullDescription": {
                  "text": "报告了传统数组语法（'array()'）在数组文字上的用法，并建议用短数组语法（'[]'）取代它们。",
                  "markdown": "报告了传统数组语法（`array()`）在数组文字上的用法，并建议用短数组语法（`[]`）取代它们。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTraditionalSyntaxArrayLiteralInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConditionCheckedByNextConditionInspection",
                "shortDescription": {
                  "text": "逻辑表达式内部的条件由后续条件检查"
                },
                "fullDescription": {
                  "text": "报告被后续条件覆盖并因此变得冗余的逻辑二元表达式内的条件。",
                  "markdown": "报告被后续条件覆盖并因此变得冗余的逻辑二元表达式内的条件。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpConditionCheckedByNextConditionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNoReturnAttributeCanBeAddedInspection",
                "shortDescription": {
                  "text": "可以添加 NoReturn 特性"
                },
                "fullDescription": {
                  "text": "报告没有 '#[NoReturn]' 的函数，这些函数总是通过调用其他 exitPoint 函数特性来停止其执行。",
                  "markdown": "报告没有 `#[NoReturn]` 的函数，这些函数总是通过调用其他 exitPoint 函数特性来停止其执行。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNoReturnAttributeCanBeAddedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConditionCanBeReplacedWithMinMaxCallInspection",
                "shortDescription": {
                  "text": "条件可被替换为 'min()'/'max()' 调用"
                },
                "fullDescription": {
                  "text": "报告手动计算最小值/最大值而不是调用 'min'/'max' 函数的条件。",
                  "markdown": "报告手动计算最小值/最大值而不是调用 `min`/`max` 函数的条件。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpConditionCanBeReplacedWithMinMaxCallInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpGotoIntoLoopInspection",
                "shortDescription": {
                  "text": "Goto 转入循环语句"
                },
                "fullDescription": {
                  "text": "报告位于循环或 'switch' 语句内的 'goto' 标签。 有关详细信息，请参阅 goto (php.net)。",
                  "markdown": "报告位于循环或 `switch` 语句内的 `goto` 标签。\n\n\n有关详细信息，请参阅 [goto (php.net)](https://www.php.net/manual/en/control-structures.goto.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpGotoIntoLoopInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedStdLibCallInspection",
                "shortDescription": {
                  "text": "已弃用的标准库调用"
                },
                "fullDescription": {
                  "text": "报告对从 PHP 8.1 开始弃用的标准 PHP 库函数的调用。 报告以下调用： 将对象作为实参的 'key()'、'current()'、'next()'、'prev()' 和 'reset( )' 调用。 不包含实参的 'mb_check_encoding()' 调用。 不包含实参的 'get_class()'、'get_parent_class()' 和 'get_Called_class()' 调用。 将布尔值作为 '$value' 实参传递的 'IntlCalendar::roll()' 调用。 包含非字符串实参的 'ctype_*()' 调用。 有关详细信息，请参阅 PHP RFC：PHP 8.1 弃用。",
                  "markdown": "报告对从 PHP 8.1 开始弃用的标准 PHP 库函数的调用。\n\n\n报告以下调用：\n\n* 将对象作为实参的 `key()`、`current()`、`next()`、`prev()` 和 `reset( )` 调用。\n* 不包含实参的 `mb_check_encoding()` 调用。\n* 不包含实参的 `get_class()`、`get_parent_class()` 和 `get_Called_class()` 调用。\n* 将布尔值作为 `$value` 实参传递的 `IntlCalendar::roll()` 调用。\n* 包含非字符串实参的 `ctype_*()` 调用。\n\n\n有关详细信息，请参阅 [PHP RFC：PHP 8.1 弃用](https://wiki.php.net/rfc/deprecations_php_8_1)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedStdLibCallInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingBreakStatementInspection",
                "shortDescription": {
                  "text": "缺少 'break' 语句"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句中不以 'break' 或 'return' 语句结尾的 'case' 子句。 如果 'case' 子句不以 'break' 或 'return' 结尾，则其执行可能无意中落入下一个 case。",
                  "markdown": "报告 `switch` 语句中不以 `break` 或 `return` 语句结尾的 `case` 子句。\n\n\n如果 `case` 子句不以 `break` 或 `return` 结尾，则其执行可能无意中落入下一个 case。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingBreakStatementInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpForeachArrayIsUsedAsValueInspection",
                "shortDescription": {
                  "text": "Foreach 数组用作值"
                },
                "fullDescription": {
                  "text": "报告在 'foreach' 循环中用作数组表达式和数组键或值的变量（例如，'foreach ($items as $items) {}'）。 通常情况下，这是一个拼写错误的结果。",
                  "markdown": "报告在 `foreach` 循环中用作数组表达式和数组键或值的变量（例如，`foreach ($items as $items) {}`）。\n\n\n通常情况下，这是一个拼写错误的结果。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpForeachArrayIsUsedAsValueInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSeparateElseIfInspection",
                "shortDescription": {
                  "text": "Else if"
                },
                "fullDescription": {
                  "text": "报告用两个词指定的 'else if' 结构的用法。 根据 PSR-12，您必须使用 'elseif'，而不是 'else if'，以使所有控制关键字作为一个词显示。 有关详细信息，请参阅 PSR-12: Extended Coding Style (php-fig.org)。",
                  "markdown": "报告用两个词指定的 `else if` 结构的用法。\n\n根据 PSR-12，您必须使用 `elseif`，而不是 `else if`，以使所有控制关键字作为一个词显示。\n\n\n有关详细信息，请参阅 [PSR-12: Extended Coding Style (php-fig.org)](https://www.php-fig.org/psr/psr-12/#51-if-elseif-else)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSeparateElseIfInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicateArrayKeysInspection",
                "shortDescription": {
                  "text": "重复的数组键"
                },
                "fullDescription": {
                  "text": "报告数组声明中的重复键。 如果数组声明中的多个元素使用相同的键，只有最后一个会被使用，其他的都会被覆盖掉。",
                  "markdown": "报告数组声明中的重复键。\n\n如果数组声明中的多个元素使用相同的键，只有最后一个会被使用，其他的都会被覆盖掉。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDuplicateArrayKeysInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitTestFailedLineInspection",
                "shortDescription": {
                  "text": "测试中失败的行"
                },
                "fullDescription": {
                  "text": "报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。 示例： 'function test() {\n      $this->assertEquals(1,2); //highlighted\n  }'",
                  "markdown": "报告测试中失败的方法调用或断言。 它有助于更快地检测代码中失败的行，并立即开始调试。\n\n**示例：**\n\n\n      function test() {\n          $this->assertEquals(1,2); //highlighted\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnitTestFailedLineInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpEnforceDocCommentInspection",
                "shortDescription": {
                  "text": "强制执行 PHPDoc 注释"
                },
                "fullDescription": {
                  "text": "报告没有 PHPDoc 注释或仅包含 '@noinspection' 标记的 PHPDoc 注释的元素。 您可以使用缺少 PHPDoc 注释 检查仅报告非完全类型化元素。",
                  "markdown": "报告没有 PHPDoc 注释或仅包含 `@noinspection` 标记的 PHPDoc 注释的元素。\n\n您可以使用*缺少 PHPDoc 注释* 检查仅报告非完全类型化元素。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpEnforceDocCommentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc/代码样式",
                      "index": 21,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDocFinalChecksInspection",
                "shortDescription": {
                  "text": "被标记为 '@final' 的重写方法/扩展类"
                },
                "fullDescription": {
                  "text": "报告 PHPDoc 中对带有 '@final' 的方法或类扩展的重写。",
                  "markdown": "报告 PHPDoc 中对带有 `@final` 的方法或类扩展的重写。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDocFinalChecksInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpImmutablePropertyIsWrittenInspection",
                "shortDescription": {
                  "text": "在无效的作用域中写入不可变属性"
                },
                "fullDescription": {
                  "text": "高亮显示对属性的写入权限引用，通过 '#[Immutable]' 为这些属性声明的写入权限范围比引用范围更严格。",
                  "markdown": "高亮显示对属性的写入权限引用，通过 `#[Immutable]` 为这些属性声明的写入权限范围比引用范围更严格。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpImmutablePropertyIsWrittenInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSignatureMismatchDuringInheritanceInspection",
                "shortDescription": {
                  "text": "重写方法的声明应与父类兼容"
                },
                "fullDescription": {
                  "text": "报告与父类不兼容的重写方法声明。 该检查仅在 PHP 语言等级低于 8.0 的情况下被启用。",
                  "markdown": "报告与父类不兼容的重写方法声明。 该检查仅在 PHP 语言等级低于 8.0 的情况下被启用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpSignatureMismatchDuringInheritanceInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHP 严格标准",
                      "index": 121,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTraitUsageOutsideUseInspection",
                "shortDescription": {
                  "text": "不允许特征用法"
                },
                "fullDescription": {
                  "text": "报告已解析为特征但在 'use' 语句之外指定的类引用。 此类用法很可能是编程错误的结果，因为特征无法实例化，并且设计上不支持任何类似 'instanceof' 行为。 有关详细信息，请参阅 Traits (php.net)。",
                  "markdown": "报告已解析为特征但在 `use` 语句之外指定的类引用。 此类用法很可能是编程错误的结果，因为特征无法实例化，并且设计上不支持任何类似 `instanceof` 行为。\n\n\n有关详细信息，请参阅 [Traits (php.net)](https://www.php.net/manual/en/language.oop5.traits.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTraitUsageOutsideUseInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpStrictTypeCheckingInspection",
                "shortDescription": {
                  "text": "严格类型检查规则违反"
                },
                "fullDescription": {
                  "text": "报告违反严格类型检查规则的行为。 在严格模式下，只有与声明类型完全匹配的变量才被接受。 严格类型检查模式可以按以下方式启用： 为每个文件，如果 'declare(strict_types=1)' 指令被指定。 该指令必须是一个文件中的第一条语句，明确不允许使用块模式。 为所有文件，如果为所有文件启用检查选项被启用。 有关详细信息，请参阅 Strict typing (php.net)。",
                  "markdown": "报告违反严格类型检查规则的行为。\n\n\n在严格模式下，只有与声明类型完全匹配的变量才被接受。 严格类型检查模式可以按以下方式启用：\n\n* 为每个文件，如果 `declare(strict_types=1)` 指令被指定。 该指令必须是一个文件中的第一条语句，明确不允许使用块模式。\n* 为所有文件，如果**为所有文件启用**检查选项被启用。\n\n\n有关详细信息，请参阅 [Strict typing (php.net)](https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpStrictTypeCheckingInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFieldReferenceDoesNotMatchObjectShapeInspection",
                "shortDescription": {
                  "text": "字段引用与对象形状不匹配"
                },
                "fullDescription": {
                  "text": "报告对名称与通过 '#[ObjectShape]' 特性或在 PHPDoc 注释中指定的名称不匹配的属性的引用。",
                  "markdown": "报告对名称与通过 `#[ObjectShape]` 特性或在 PHPDoc 注释中指定的名称不匹配的属性的引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpFieldReferenceDoesNotMatchObjectShapeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAddOverrideAttributeInspection",
                "shortDescription": {
                  "text": "用 #[Override] 标记重写的方法"
                },
                "fullDescription": {
                  "text": "建议将 '#[Override]' 特性添加到重写父类或任何已实现接口中同名方法的方法中。 '#[Override]' 特性仅自 PHP 8.3 起可用。 有关详细信息，请参阅 PHP RFC: Marking overridden methods (wiki.php.net)。",
                  "markdown": "建议将 `#[Override]` 特性添加到重写父类或任何已实现接口中同名方法的方法中。\n\n\n`#[Override]` 特性仅自 PHP 8.3 起可用。 有关详细信息，请参阅 [PHP RFC: Marking overridden methods (wiki.php.net)](https://wiki.php.net/rfc/marking_overriden_methods)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAddOverrideAttributeInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpForeachOverSingleElementArrayLiteralInspection",
                "shortDescription": {
                  "text": "对只有一个元素的数组文字执行 Foreach"
                },
                "fullDescription": {
                  "text": "报告迭代的数组文字只包含一个元素的 'foreach' 语句。",
                  "markdown": "报告迭代的数组文字只包含一个元素的 `foreach` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpForeachOverSingleElementArrayLiteralInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCoveredCharacterInClassInspection",
                "shortDescription": {
                  "text": "类中的元素已被覆盖"
                },
                "fullDescription": {
                  "text": "报告正则表达式字符类中已被同一类中的另一个元素覆盖的元素。 此类元素冗余，可以安全移除。",
                  "markdown": "报告正则表达式字符类中已被同一类中的另一个元素覆盖的元素。 此类元素冗余，可以安全移除。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCoveredCharacterInClassInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/正则表达式",
                      "index": 116,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpVariableIsUsedOnlyInClosureInspection",
                "shortDescription": {
                  "text": "变量仅在闭包内使用"
                },
                "fullDescription": {
                  "text": "报告闭包的 'use' 列表中仅在闭包内部使用的变量。",
                  "markdown": "报告闭包的 `use` 列表中仅在闭包内部使用的变量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpVariableIsUsedOnlyInClosureInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLongTypeFormInspection",
                "shortDescription": {
                  "text": "类型关键字的缩写"
                },
                "fullDescription": {
                  "text": "报告长形类型关键字的用法。 根据 PSR-12，必须使用类型关键字的缩写，即 'bool' 而不是 'boolean'、'int' 而不是 'integer'等。 有关详细信息，请参阅 Keywords and Types (php-fig.org)。",
                  "markdown": "报告长形类型关键字的用法。\n\n\n根据 PSR-12，必须使用类型关键字的缩写，即 `bool` 而不是 `boolean`、`int` 而不是 `integer`等。\n\n\n有关详细信息，请参阅 [Keywords and Types (php-fig.org)](https://www.php-fig.org/psr/psr-12/#25-keywords-and-types)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLongTypeFormInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCSFixerValidationInspection",
                "shortDescription": {
                  "text": "PHP CS Fixer 验证"
                },
                "fullDescription": {
                  "text": "报告由 PHP CS Fixer 检测到的编码风格问题。 该检查要求正确安装 PHP CS Fixer，并在 IDE 中的设置 | PHP | 质量工具 | PHP CS Fixer 下正确设置。 要了解有关安装 PHP CS Fixer 的更多信息，请参见 PHP CS Fixer installation (GitHub)。",
                  "markdown": "报告由 PHP CS Fixer 检测到的编码风格问题。\n\n\n该检查要求正确安装 PHP CS Fixer，并在 IDE 中的[设置 \\| PHP \\| 质量工具 \\| PHP CS Fixer](settings://settings.php.quality.tools.php.cs.fixer) 下正确设置。\n\n\n要了解有关安装 PHP CS Fixer 的更多信息，请参见 [PHP CS Fixer installation (GitHub)](https://github.com/FriendsOfPHP/PHP-CS-Fixer#installation)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCSFixerValidationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/质量工具",
                      "index": 152,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpClosureCanBeConvertedToShortArrowFunctionInspection",
                "shortDescription": {
                  "text": "闭包可以转换为箭头函数"
                },
                "fullDescription": {
                  "text": "报告可以转化为短箭头函数的匿名函数。 短箭头函数的支持自 PHP 7.4 起可用。 有关详细信息，请参阅 PHP RFC: Arrow Functions 2.0 (php.net)。",
                  "markdown": "报告可以转化为短箭头函数的匿名函数。 短箭头函数的支持自 PHP 7.4 起可用。\n\n\n有关详细信息，请参阅 [PHP RFC: Arrow Functions 2.0 (php.net)](https://wiki.php.net/rfc/arrow_functions_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpClosureCanBeConvertedToShortArrowFunctionInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnhandledExceptionInspection",
                "shortDescription": {
                  "text": "未处理的异常"
                },
                "fullDescription": {
                  "text": "报告既未包含在 'try-catch'块中，也未通过'@throws'标记记录的异常。",
                  "markdown": "报告既未包含在 ` try-catch `块中，也未通过` @throws `标记记录的异常。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnhandledExceptionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/错误处理",
                      "index": 144,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIncludeInspection",
                "shortDescription": {
                  "text": "未解析的 include"
                },
                "fullDescription": {
                  "text": "报告未解析的 'include'、'include_once'、'require' 和 'require_once' 表达式。",
                  "markdown": "报告未解析的 `include`、`include_once`、`require` 和 `require_once` 表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIncludeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertEqualsCanBeReplacedWithAssertTrueOrFalseInspection",
                "shortDescription": {
                  "text": "断言可被替换为 'assertTrue/assertFalse'"
                },
                "fullDescription": {
                  "text": "报告 PHPUnit 测试中带有 'true'/'false' 实参的 'assertEquals()' 调用。 此类用法可被替换为 'assertTrue()'/'assertFalse()' 调用。",
                  "markdown": "报告 PHPUnit 测试中带有 `true`/`false` 实参的 `assertEquals()` 调用。 此类用法可被替换为 `assertTrue()`/`assertFalse()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertEqualsCanBeReplacedWithAssertTrueOrFalseInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpReadonlyPropertyWrittenOutsideDeclarationScopeInspection",
                "shortDescription": {
                  "text": "对声明作用域之外的 'readonly' 属性的写入权限"
                },
                "fullDescription": {
                  "text": "报告在声明范围之外对 'readonly' 属性的写入访问。 声明范围实际上意味着在其中声明属性的类的非 static 方法。 有关详细信息，请参阅只读属性 (php.net)。",
                  "markdown": "报告在声明范围之外对 `readonly` 属性的写入访问。 声明范围实际上意味着在其中声明属性的类的非 static 方法。\n\n\n有关详细信息，请参阅[只读属性 (php.net)](https://wiki.php.net/rfc/readonly_properties_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpReadonlyPropertyWrittenOutsideDeclarationScopeInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFormatCallWithSingleArgumentInspection",
                "shortDescription": {
                  "text": "使用单个实参格式化函数调用"
                },
                "fullDescription": {
                  "text": "报告使用单个实参的 'sprintf()' 和 'vsprintf()' 调用。 此类调用不会产生任何效果，并且可以安全解开，即替换为实参本身。",
                  "markdown": "报告使用单个实参的 `sprintf()` 和 `vsprintf()` 调用。 此类调用不会产生任何效果，并且可以安全解开，即替换为实参本身。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpFormatCallWithSingleArgumentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIllegalArrayKeyTypeInspection",
                "shortDescription": {
                  "text": "非法数组键类型"
                },
                "fullDescription": {
                  "text": "报告非法类型的数组键，例如对象或数组。 有关详细信息，请参阅 Arrays (php.net)。",
                  "markdown": "报告非法类型的数组键，例如对象或数组。\n\n\n有关详细信息，请参阅 [Arrays (php.net)](http://www.php.net/manual/en/language.types.array.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpIllegalArrayKeyTypeInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLoopNeverIteratesInspection",
                "shortDescription": {
                  "text": "循环未迭代"
                },
                "fullDescription": {
                  "text": "报告其主体最多执行一次的循环语句。 检查不报告主体内使用了一个键或值的 'foreach' 循环。 通常情况下，这种循环只在其第一次迭代时执行一个操作（例如，获得数组的第一个元素）。",
                  "markdown": "报告其主体最多执行一次的循环语句。\n\n\n检查不报告主体内使用了一个键或值的 `foreach` 循环。 通常情况下，这种循环只在其第一次迭代时执行一个操作（例如，获得数组的第一个元素）。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLoopNeverIteratesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpVariableNamingConventionInspection",
                "shortDescription": {
                  "text": "变量名称未遵循编码约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合指定的正则表达式模式的变量。 某些编码风格对变量有特殊的命名约定。 使用检查选项来指定变量名称的最小/最大长度和预期正则表达式。 要忽略名字的长度，指定 0。 要了解更多关于正则表达式的信息，请参考 Quick Start guide (regular-expressions.info)。",
                  "markdown": "报告名称太短、太长或不符合指定的正则表达式模式的变量。 某些编码风格对变量有特殊的命名约定。\n\n\n使用检查选项来指定变量名称的最小/最大长度和预期正则表达式。\n要忽略名字的长度，指定 **0**。\n\n\n要了解更多关于正则表达式的信息，请参考 [Quick Start guide (regular-expressions.info)](https://www.regular-expressions.info/quickstart.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpVariableNamingConventionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/命名约定",
                      "index": 16,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpWrongStringConcatenationInspection",
                "shortDescription": {
                  "text": "字符串串联错误"
                },
                "fullDescription": {
                  "text": "报告使用 '+' 运算符而不是点（'.'）串联运算符来串联字符串的尝试。 这种尝试很可能是编程错误。",
                  "markdown": "报告使用 `+` 运算符而不是点（`.`）串联运算符来串联字符串的尝试。 这种尝试很可能是编程错误。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpWrongStringConcatenationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryLocalVariableInspection",
                "shortDescription": {
                  "text": "不必要的局部变量"
                },
                "fullDescription": {
                  "text": "报告在赋值后立即用于退出语句的局部变量，如 'throw'、'return' 或 'yield'。",
                  "markdown": "报告在赋值后立即用于退出语句的局部变量，如 `throw`、`return` 或 `yield`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryLocalVariableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIllegalStringOffsetInspection",
                "shortDescription": {
                  "text": "非法字符串偏移"
                },
                "fullDescription": {
                  "text": "报告在字符串访问表达式中使用非 'integer' 偏移量，如 '$str[42]'。 自 PHP 5.4 起，字符串偏移量必须是整数或类整数字符串。 由于使用字符串作为字符串偏移量被认为是一种不好的做法，该检查也会报告此类用法。 有关详细信息，请参阅 String access and modification by character (php.net)。",
                  "markdown": "报告在字符串访问表达式中使用非 `integer` 偏移量，如 `$str[42]`。\n\n\n自 PHP 5.4 起，字符串偏移量必须是整数或类整数字符串。\n由于使用字符串作为字符串偏移量被认为是一种不好的做法，该检查也会报告此类用法。\n\n有关详细信息，请参阅 [String access and modification by character (php.net)](https://www.php.net/manual/en/language.types.string.php#language.types.string.substr)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpIllegalStringOffsetInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMatchExpressionWithOnlyDefaultArmInspection",
                "shortDescription": {
                  "text": "'match' 表达式只有 default arm，应当进行简化"
                },
                "fullDescription": {
                  "text": "报告只包含 'default' 分支的 'match' 表达式。 这种表达式是冗余的，应当进行简化。 有关详细信息，请参阅 Match expression (php.net)。",
                  "markdown": "报告只包含 `default` 分支的 `match` 表达式。 这种表达式是冗余的，应当进行简化。\n\n\n有关详细信息，请参阅 [Match expression (php.net)](https://wiki.php.net/rfc/match_expression_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMatchExpressionWithOnlyDefaultArmInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNModifierCanBeReplacedWithNonCapturingGroupInspection",
                "shortDescription": {
                  "text": "'n' 修饰符可被替换为非捕获组"
                },
                "fullDescription": {
                  "text": "报告可被替换为使用非捕获组，而不是以正则表达式模式捕获的 'n' PCRE 修饰符。",
                  "markdown": "报告可被替换为使用非捕获组，而不是以正则表达式模式捕获的 `n` PCRE 修饰符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNModifierCanBeReplacedWithNonCapturingGroupInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantReadonlyModifierInspection",
                "shortDescription": {
                  "text": "'readonly' 修饰符冗余"
                },
                "fullDescription": {
                  "text": "报告应用于只读类中的属性的 'readonly' 修饰符。 这些修饰符是冗余的，因为只读类中的所有属性均为隐式只读。 有关详细信息，请参阅 Readonly classes RFC (php.net)。",
                  "markdown": "报告应用于只读类中的属性的 `readonly` 修饰符。 这些修饰符是冗余的，因为只读类中的所有属性均为隐式只读。\n\n\n有关详细信息，请参阅 [Readonly classes RFC (php.net)](https://wiki.php.net/rfc/readonly_classes#proposal)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantReadonlyModifierInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessarySpreadOperatorForFunctionCallArgumentInspection",
                "shortDescription": {
                  "text": "函数调用实参的不必要展开运算符"
                },
                "fullDescription": {
                  "text": "报告在可以安全解开的函数调用实参中的数组文字上使用展开运算符 ('...') 的情况。",
                  "markdown": "报告在可以安全解开的函数调用实参中的数组文字上使用展开运算符 (`...`) 的情况。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessarySpreadOperatorForFunctionCallArgumentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNonCompoundUseInspection",
                "shortDescription": {
                  "text": "不必要的语句使用"
                },
                "fullDescription": {
                  "text": "报告包含非完全合格的类名的 'use' 语句，因为没有任何作用。 该检查只报告类的导入；函数和常量的导入不被考虑。 有关详细信息，请参阅 Using namespaces: Aliasing/Importing (php.net)。",
                  "markdown": "报告包含非完全合格的类名的 `use` 语句，因为没有任何作用。 该检查只报告类的导入；函数和常量的导入不被考虑。\n\n\n有关详细信息，请参阅 [Using namespaces: Aliasing/Importing (php.net)](http://www.php.net/manual/en/language.namespaces.importing.php#language.namespaces.importing)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpNonCompoundUseInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInvalidInstanceofInspection",
                "shortDescription": {
                  "text": "'instanceof' 的实参只应是对象或字符串"
                },
                "fullDescription": {
                  "text": "报告不是对象或字符串的 'instanceof' 实参",
                  "markdown": "报告不是对象或字符串的 'instanceof' 实参"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpInvalidInstanceofInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MessDetectorValidationInspection",
                "shortDescription": {
                  "text": "PHP Mess Detector 验证"
                },
                "fullDescription": {
                  "text": "报告由 PHP Mess Detector 检测到的编码风格问题。 该检查要求正确安装 PHP Mess Detector，并在 IDE 中的>设置 | PHP | 质量工具 | Mess Detector 下正确设置。 要了解有关安装 PHP Mess Detector 的更多信息，请参见 PHP Mess Detector installation (phpmd.org)。 您可以使用预定义规则集，或通过指定有效的 ruleset.xml 文件添加您自己的规则。 有关详细信息，请参阅 rules index (phpmd.org) 和 How to create a custom rule set (phpmd.org)。",
                  "markdown": "报告由 PHP Mess Detector 检测到的编码风格问题。\n\n\n该检查要求正确安装 PHP Mess Detector，并在 IDE 中的[\\>设置 \\| PHP \\| 质量工具 \\| Mess Detector](settings://settings.php.quality.tools.mess.detector) 下正确设置。\n\n\n要了解有关安装 PHP Mess Detector 的更多信息，请参见 [PHP Mess Detector installation (phpmd.org)](https://phpmd.org/download/index.html)。\n\n\n您可以使用预定义规则集，或通过指定有效的 *ruleset.xml* 文件添加您自己的规则。 有关详细信息，请参阅 [rules index (phpmd.org)](https://phpmd.org/rules/index.html) 和 [How to create a custom rule set (phpmd.org)](https://phpmd.org/documentation/creating-a-ruleset.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MessDetectorValidationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/质量工具",
                      "index": 152,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedCastInspection",
                "shortDescription": {
                  "text": "弃用的转换"
                },
                "fullDescription": {
                  "text": "报告已弃用的转换表达式： '(unset)' 转换表达式，自 PHP 7.2 已弃用。 '(real)' 转换表达式，自 PHP 7.4 已弃用。 有关详细信息，请参阅 Deprecated features in PHP 7.2.x (php.net) 和 Deprecations for PHP 7.4 (php.net)。",
                  "markdown": "报告已弃用的转换表达式：\n\n* `(unset)` 转换表达式，自 PHP 7.2 已弃用。\n* `(real)` 转换表达式，自 PHP 7.4 已弃用。\n\n\n有关详细信息，请参阅 [Deprecated features in PHP 7.2.x (php.net)](https://www.php.net/manual/en/migration72.deprecated.php#migration72.deprecated.unset-cast) 和 [Deprecations for PHP 7.4 (php.net)](https://wiki.php.net/rfc/deprecations_php_7_4#the_real_type)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedCastInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertEqualsInspection",
                "shortDescription": {
                  "text": "弃用的 'assertEquals/assertNotEquals' 用法"
                },
                "fullDescription": {
                  "text": "报告带有 '$delta'、'$maxDepth'、'$canonicalize' 和 '$ignoreCase' 形参的 'assertEquals' 和 'assertNotEquals' 函数的弃用用法。 'assertEquals' 和 'assertNotEquals' 函数的可选'$delta'、'$maxDepth'、'$canonicalize' 和 '$ignoreCase' 形参已被弃用，并将在 PHPUnit 9 中移除。 有关详细信息，请参阅 Usage of the assertEquals function (phpunit.readthedocs.io)。",
                  "markdown": "报告带有 `$delta`、`$maxDepth`、`$canonicalize` 和 `$ignoreCase` 形参的 `assertEquals` 和 `assertNotEquals` 函数的弃用用法。\n\n`assertEquals` 和 `assertNotEquals` 函数的可选`$delta`、`$maxDepth`、`$canonicalize` 和 `$ignoreCase` 形参已被弃用，并将在 PHPUnit 9 中移除。\n\n\n有关详细信息，请参阅 [Usage of the assertEquals function (phpunit.readthedocs.io)](https://phpunit.readthedocs.io/en/stable/assertions.html#assertequals)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertEqualsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFieldImmediatelyRewrittenInspection",
                "shortDescription": {
                  "text": "属性会被立即重写"
                },
                "fullDescription": {
                  "text": "报告在访问之前被覆盖的属性上的写入表达式。",
                  "markdown": "报告在访问之前被覆盖的属性上的写入表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpFieldImmediatelyRewrittenInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpExpressionWithoutClarifyingParenthesesInspection",
                "shortDescription": {
                  "text": "表达式不带澄清括号"
                },
                "fullDescription": {
                  "text": "报告潜在不明确表达式，并建议将其置于澄清圆括号中。",
                  "markdown": "报告潜在不明确表达式，并建议将其置于澄清圆括号中。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpExpressionWithoutClarifyingParenthesesInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantAttributeParenthesisInspection",
                "shortDescription": {
                  "text": "特性中的冗余圆括号"
                },
                "fullDescription": {
                  "text": "报告特性中的空实参列表。 有关详细信息，请参阅 Attributes (php.net)。",
                  "markdown": "报告特性中的空实参列表。\n\n\n有关详细信息，请参阅 [Attributes (php.net)](https://wiki.php.net/rfc/attributes_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantAttributeParenthesisInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpParameterNameChangedDuringInheritanceInspection",
                "shortDescription": {
                  "text": "在继承期间更改了形参名称"
                },
                "fullDescription": {
                  "text": "报告名称与父方法中定义的相同形参名称不同的方法形参。 从 PHP 8.0 开始，此类代码可能会导致运行时出错。",
                  "markdown": "报告名称与父方法中定义的相同形参名称不同的方法形参。 从 PHP 8.0 开始，此类代码可能会导致运行时出错。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpParameterNameChangedDuringInheritanceInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConcatenationWithEmptyStringCanBeInlinedInspection",
                "shortDescription": {
                  "text": "空字符串的串联可以与赋值合并"
                },
                "fullDescription": {
                  "text": "报告在给空字符串文字赋值之后立即执行的 '.=' 串联赋值。 此类赋值可以合并在一起。",
                  "markdown": "报告在给空字符串文字赋值之后立即执行的 `.=` 串联赋值。 此类赋值可以合并在一起。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpConcatenationWithEmptyStringCanBeInlinedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDisabledQualityToolComposerInspection",
                "shortDescription": {
                  "text": "质量工具检查已禁用"
                },
                "fullDescription": {
                  "text": "在相应的代码检查被禁用的情况下，在 composer.json 中高亮显示质量工具的条目。",
                  "markdown": "在相应的代码检查被禁用的情况下，在 *composer.json* 中高亮显示质量工具的条目。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDisabledQualityToolComposerInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Composer",
                      "index": 54,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayIndexResetIsUnnecessaryInspection",
                "shortDescription": {
                  "text": "无需数组内部指针重置"
                },
                "fullDescription": {
                  "text": "报告已在第一个元素上设置内部指针的数组上的 'reset($array)' 调用。 此类调用冗余，可以安全移除。 有关详细信息，请参阅 reset (php.net)。",
                  "markdown": "报告已在第一个元素上设置内部指针的数组上的 `reset($array)` 调用。 此类调用冗余，可以安全移除。\n\n\n有关详细信息，请参阅 [reset (php.net)](https://www.php.net/manual/en/function.reset.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayIndexResetIsUnnecessaryInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpApplyingEmptyIndexOperatorOnStringInspection",
                "shortDescription": {
                  "text": "字符串不支持的空索引运算符"
                },
                "fullDescription": {
                  "text": "报告空索引运算符 ('[]') 在字符串中的用法。 从 PHP 7.1 开始，对字符串应用空索引运算符会抛出致命错误。 有关详细信息，请参阅 Creating/modifying with square bracket syntax (php.net)。",
                  "markdown": "报告空索引运算符 (`[]`) 在字符串中的用法。\n\n\n从 PHP 7.1 开始，对字符串应用空索引运算符会抛出致命错误。\n\n有关详细信息，请参阅 [Creating/modifying with square bracket syntax (php.net)](https://www.php.net/manual/en/language.types.array.php#language.types.array.syntax.modifying)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpApplyingEmptyIndexOperatorOnStringInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTraitUseRuleInsideDifferentClassUseListInspection",
                "shortDescription": {
                  "text": "特征 use 规则已解析为使用不同包含类的方法 "
                },
                "fullDescription": {
                  "text": "报告特征方法 'use' 规则，这些规则解析为来自其他包含类的方法，而不是 'use' 声明中指定的方法。",
                  "markdown": "报告特征方法 `use` 规则，这些规则解析为来自其他包含类的方法，而不是 `use` 声明中指定的方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTraitUseRuleInsideDifferentClassUseListInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertArrayHasKeyInspection",
                "shortDescription": {
                  "text": "可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'"
                },
                "fullDescription": {
                  "text": "报告将 'array_key_exists()' 调用作为实参提供的 'assertTrue()' 和 'assertNotTrue()' 方法调用。 此类调用可以替换为对专用 'assertArrayHasKey()' 方法的调用。 有关详细信息，请参阅 assertArrayHasKey (phpunit.readthedocs.io)。",
                  "markdown": "报告将 `array_key_exists()` 调用作为实参提供的 `assertTrue()` 和 `assertNotTrue()` 方法调用。 此类调用可以替换为对专用 `assertArrayHasKey()` 方法的调用。\n\n\n有关详细信息，请参阅 [assertArrayHasKey (phpunit.readthedocs.io)](https://phpunit.readthedocs.io/en/stable/assertions.html#assertarrayhaskey)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertArrayHasKeyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDynamicFieldDeclarationInspection",
                "shortDescription": {
                  "text": "动态属性声明"
                },
                "fullDescription": {
                  "text": "报告对动态类属性声明的引用。 从 PHP 8.2 开始，已弃用此类声明 检查会跳过 'stdClass' 或派生类型的对象。",
                  "markdown": "报告对动态类属性声明的引用。 从 PHP 8.2 开始，已弃用此类声明\n\n\n检查会跳过 `stdClass` 或派生类型的对象。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDynamicFieldDeclarationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDocSignatureInspection",
                "shortDescription": {
                  "text": "PHPDoc 注释匹配函数/方法签名"
                },
                "fullDescription": {
                  "text": "报告在 PHPDoc 注释中的形参名称和类型，这些形参名称和类型与函数/方法声明中的形参名称和类型不匹配。",
                  "markdown": "报告在 PHPDoc 注释中的形参名称和类型，这些形参名称和类型与函数/方法声明中的形参名称和类型不匹配。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDocSignatureInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMultipleClassesDeclarationsInOneFile",
                "shortDescription": {
                  "text": "一个文件中有多个类声明"
                },
                "fullDescription": {
                  "text": "报告在单个文件中有多个类声明，这违反了 PSR-0 / PSR-4 标准。 有关详细信息，请参阅 PSR-0/PSR-4 standards (php-fig.org)。",
                  "markdown": "报告在单个文件中有多个类声明，这违反了 PSR-0 / PSR-4 标准。\n\n\n有关详细信息，请参阅 [PSR-0/PSR-4 standards (php-fig.org)](https://www.php-fig.org/psr/psr-4/)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMultipleClassesDeclarationsInOneFile",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayWriteIsNotUsedInspection",
                "shortDescription": {
                  "text": "未使用数组写入访问"
                },
                "fullDescription": {
                  "text": "报告之后没有在代码中使用的数组写入访问表达式。 此类问题最常见的来源是修改通过形参传递的数组：如果一个数组是通过值传递的，则更改在函数外部将不可见。",
                  "markdown": "报告之后没有在代码中使用的数组写入访问表达式。 此类问题最常见的来源是修改通过形参传递的数组：如果一个数组是通过值传递的，则更改在函数外部将不可见。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayWriteIsNotUsedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpReturnValueOfMethodIsNeverUsedInspection",
                "shortDescription": {
                  "text": "方法的返回值从未使用"
                },
                "fullDescription": {
                  "text": "报告返回值未被使用的 private 方法。",
                  "markdown": "报告返回值未被使用的 private 方法。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpReturnValueOfMethodIsNeverUsedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertFileEqualsInspection",
                "shortDescription": {
                  "text": "弃用的 'assertFileEquals/assertStringEqualsFile' 用法"
                },
                "fullDescription": {
                  "text": "报告具有 '$canonicalize' 和 '$ignoreCase' 形参的'assertFileEquals'、'assertFileNotEquals'、'assertStringEqualsFile' 和 'assertStringNotEqualsFile' 函数已弃用的用法。 'assertFileEquals' 和 'assertFileNotEquals' 函数的可选 '$canonicalize' 和 '$ignoreCase' 形参已弃用，并将在 PHPUnit 9 中移除。 有关详细信息，请参阅 Usage of the assertFileEquals function (phpunit.readthedocs.io) 或 Usage of the assertFileEquals function (phpunit.readthedocs.io)。",
                  "markdown": "报告具有 `$canonicalize` 和 `$ignoreCase` 形参的`assertFileEquals`、`assertFileNotEquals`、`assertStringEqualsFile` 和 `assertStringNotEqualsFile` 函数已弃用的用法。\n\n`assertFileEquals` 和 `assertFileNotEquals` 函数的可选 `$canonicalize` 和 `$ignoreCase` 形参已弃用，并将在 PHPUnit 9 中移除。\n\n\n有关详细信息，请参阅 [Usage of the assertFileEquals function (phpunit.readthedocs.io)](https://phpunit.readthedocs.io/en/stable/assertions.html#assertfileequals) 或 [Usage of the assertFileEquals function (phpunit.readthedocs.io)](https://phpunit.readthedocs.io/en/stable/assertions.html#assertstringequalsfile)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertFileEqualsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpVariableVariableInspection",
                "shortDescription": {
                  "text": "使用了可变变量"
                },
                "fullDescription": {
                  "text": "报告可变变量的用法（动态变量名称，如 '$$a'）。",
                  "markdown": "报告可变变量的用法（动态变量名称，如 `$$a`）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpVariableVariableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDeprecatedSerializableUsageInspection",
                "shortDescription": {
                  "text": "已弃用的 'Serializable' 接口用法"
                },
                "fullDescription": {
                  "text": "报告已弃用的 'Serializable' 接口的用法。 从 PHP 8.1 开始，非抽象类、实现 'Serializable' 的类、不实现 '__serialize()' 和 '__unserialize()' 的类将抛出弃用警告。 有关详细信息，请参阅逐步淘汰可序列化对象 (php.net)。",
                  "markdown": "报告已弃用的 `Serializable` 接口的用法。\n\n\n从 PHP 8.1 开始，非抽象类、实现 `Serializable` 的类、不实现 `__serialize()` 和 `__unserialize()` 的类将抛出弃用警告。\n\n\n有关详细信息，请参阅[逐步淘汰可序列化对象 (php.net)](https://wiki.php.net/rfc/custom_object_serialization)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpDeprecatedSerializableUsageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLoopCanBeConvertedToArrayMapInspection",
                "shortDescription": {
                  "text": "循环可以转换为 'array_map()' 调用"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'array_map()' 调用的 'foreach' 循环。",
                  "markdown": "报告可以替换为 `array_map()` 调用的 `foreach` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLoopCanBeConvertedToArrayMapInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpStrFunctionsInspection",
                "shortDescription": {
                  "text": "'str*()' 调用可被替换为 PHP 8 'str_*()' 调用"
                },
                "fullDescription": {
                  "text": "报告 'strpos' 和 'substr' 函数调用，可以用 'str_*' 函数调用（在 PHP 8.0 中引入）代替。 有关详细信息，请参阅 str_contains (php.net) 和 str_starts_with and str_ends_with functions (php.net)。",
                  "markdown": "报告 `strpos` 和 `substr` 函数调用，可以用 `str_*` 函数调用（在 PHP 8.0 中引入）代替。\n\n\n有关详细信息，请参阅 [str_contains (php.net)](https://wiki.php.net/rfc/str_contains) 和 [str_starts_with and str_ends_with functions (php.net)](https://wiki.php.net/rfc/add_str_starts_with_and_ends_with_functions)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpStrFunctionsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessarySemicolonInspection",
                "shortDescription": {
                  "text": "不必要的分号"
                },
                "fullDescription": {
                  "text": "报告不必要的分号。",
                  "markdown": "报告不必要的分号。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessarySemicolonInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCSValidationInspection",
                "shortDescription": {
                  "text": "PHP_CodeSniffer 验证"
                },
                "fullDescription": {
                  "text": "报告由 PHP_CodeSniffer 检测到的编码风格问题。 该项检查要求正确安装 PHP_CodeSniffer，并在设置 | PHP | 质量工具 | PHP_CodeSniffer 下正确设置 。 要了解有关安装 PHP_CodeSniffer 的更多信息，请参见 PHP_CodeSniffer installation (GitHub)。",
                  "markdown": "报告由 PHP_CodeSniffer 检测到的编码风格问题。\n\n\n该项检查要求正确安装 PHP_CodeSniffer，并在[设置 \\| PHP \\| 质量工具 \\| PHP_CodeSniffer](settings://settings.php.quality.tools.php.code.sniffer) 下正确设置 。\n\n\n要了解有关安装 PHP_CodeSniffer 的更多信息，请参见 [PHP_CodeSniffer installation (GitHub)](https://github.com/squizlabs/PHP_CodeSniffer#installation)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCSValidationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/质量工具",
                      "index": 152,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryStopStatementInspection",
                "shortDescription": {
                  "text": "不必要的 'return/continue' 语句"
                },
                "fullDescription": {
                  "text": "报告不必要并可以安全删除的 'return' 和 'continue' 语句。",
                  "markdown": "报告不必要并可以安全删除的 `return` 和 `continue` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryStopStatementInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConditionAlreadyCheckedInspection",
                "shortDescription": {
                  "text": "条件的求值结果始终为 'true/false'"
                },
                "fullDescription": {
                  "text": "报告已被早期的条件涵盖因而不起任何作用的条件以及在到达时始终为 true（或始终为 false）的变量。",
                  "markdown": "报告已被早期的条件涵盖因而不起任何作用的条件以及在到达时始终为 true（或始终为 false）的变量。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpConditionAlreadyCheckedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFuncGetArgCanBeReplacedWithParamInspection",
                "shortDescription": {
                  "text": "'func_get_arg()' 调用可被替换为形参访问"
                },
                "fullDescription": {
                  "text": "报告可以替换为直接形参访问的 'func_get_arg()' 调用。",
                  "markdown": "报告可以替换为直接形参访问的 `func_get_arg()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpFuncGetArgCanBeReplacedWithParamInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpBooleanCanBeSimplifiedInspection",
                "shortDescription": {
                  "text": "可以简化布尔表达式"
                },
                "fullDescription": {
                  "text": "报告包含 'true' 或 'false' 文本并且可以被简化的布尔表达式。",
                  "markdown": "报告包含 `true` 或 `false` 文本并且可以被简化的布尔表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpBooleanCanBeSimplifiedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitCoversByAccessModifierIsDeprecatedInspection",
                "shortDescription": {
                  "text": "弃用的通过修饰符注解进行的 @covers/@uses"
                },
                "fullDescription": {
                  "text": "报告使用 'ClassName::<*>' 的 '@covers' 和 '@uses' PHPUnit 文档标签。 在 PHPUnit 10 及更新版本中不支持这种注解。",
                  "markdown": "报告使用 `ClassName::<*>` 的 `@covers` 和 `@uses` PHPUnit 文档标签。 在 PHPUnit 10 及更新版本中不支持这种注解。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitCoversByAccessModifierIsDeprecatedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAssignmentReplaceableWithPrefixExpressionInspection",
                "shortDescription": {
                  "text": "赋值可被替换为增量或减量"
                },
                "fullDescription": {
                  "text": "报告可以用增量（'++'）或减量（'--'）操作替换的赋值。",
                  "markdown": "报告可以用增量（`++`）或减量（`--`）操作替换的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAssignmentReplaceableWithPrefixExpressionInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可替换赋值",
                      "index": 166,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRandArgumentsInReverseOrderInspection",
                "shortDescription": {
                  "text": "顺序错误的 'rand' 函数实参"
                },
                "fullDescription": {
                  "text": "报告其中 'max' 实参小于 'min' 的 'rand($min, $max)' 系列函数调用。 对于诸如 'mt_rand' 和 'random_int' 之类的函数，这将导致致命错误。",
                  "markdown": "报告其中 `max` 实参小于 `min` 的 `rand($min, $max)` 系列函数调用。 对于诸如 `mt_rand` 和 `random_int` 之类的函数，这将导致致命错误。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpRandArgumentsInReverseOrderInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAttributeIsNotRepeatableInspection",
                "shortDescription": {
                  "text": "不可重复的特性"
                },
                "fullDescription": {
                  "text": "报告在其实参声明中没有 'Attribute::IS_REPEATABLE' 标志的重复特性。 有关详细信息，请参阅 Attributes (php.net)。",
                  "markdown": "报告在其实参声明中没有 `Attribute::IS_REPEATABLE` 标志的重复特性。\n\n\n有关详细信息，请参阅 [Attributes (php.net)](https://wiki.php.net/rfc/attributes_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAttributeIsNotRepeatableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpVarUsageInspection",
                "shortDescription": {
                  "text": "使用了 var"
                },
                "fullDescription": {
                  "text": "报告在声明类属性时 'var' 关键字的用法。 根据 PSR-12，'var' 关键字决不能用来声明一个属性。 有关详细信息，请参阅 PSR-12: Extended Coding Style (php-fig.org)。",
                  "markdown": "报告在声明类属性时 `var` 关键字的用法。\n\n根据 PSR-12，`var` 关键字决不能用来声明一个属性。\n\n\n有关详细信息，请参阅 [PSR-12: Extended Coding Style (php-fig.org)](https://www.php-fig.org/psr/psr-12/#43-properties-and-constants)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpVarUsageInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSillyAssignmentInspection",
                "shortDescription": {
                  "text": "冗余赋值"
                },
                "fullDescription": {
                  "text": "报告赋值语句，其中两边都是相等的。 这种赋值没有任何作用，可以被删除。",
                  "markdown": "报告赋值语句，其中两边都是相等的。 这种赋值没有任何作用，可以被删除。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpSillyAssignmentInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpFullyQualifiedNameUsageInspection",
                "shortDescription": {
                  "text": "使用了完全限定名称"
                },
                "fullDescription": {
                  "text": "报告可以通过添加 'use' 语句来缩短的完全合格的类名。",
                  "markdown": "报告可以通过添加 `use` 语句来缩短的完全合格的类名。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpFullyQualifiedNameUsageInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSuspiciousNameCombinationInspection",
                "shortDescription": {
                  "text": "可疑名称组合"
                },
                "fullDescription": {
                  "text": "报告变量或形参的名称与分配或传递的值的名称不匹配的赋值和函数调用。 支持以下几组名称： 'needle'、'haystack' 'x'、'y' 'top'、'bottom'、'left'、'right' 'year'、'month'、'week'、'day'、'hour'、'minute'、'second'",
                  "markdown": "报告变量或形参的名称与分配或传递的值的名称不匹配的赋值和函数调用。\n\n\n支持以下几组名称：\n\n* `needle`、`haystack`\n* `x`、`y`\n* `top`、`bottom`、`left`、`right`\n* `year`、`month`、`week`、`day`、`hour`、`minute`、`second`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpSuspiciousNameCombinationInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPossiblePolymorphicInvocationInspection",
                "shortDescription": {
                  "text": "可能的多态调用"
                },
                "fullDescription": {
                  "text": "报告多态代码用法。 此类用法不明确，可能不实用，具体取决于作为实参传递的类实例。",
                  "markdown": "报告多态代码用法。 此类用法不明确，可能不实用，具体取决于作为实参传递的类实例。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPossiblePolymorphicInvocationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpStatementWithoutBracesInspection",
                "shortDescription": {
                  "text": "控制语句主体无大括号"
                },
                "fullDescription": {
                  "text": "报告控制结构（如循环或条件），其主体不被包围在大括号内。 有关详细信息，请参阅 Control structures (php.net)。",
                  "markdown": "报告控制结构（如循环或条件），其主体不被包围在大括号内。\n\n\n有关详细信息，请参阅 [Control structures (php.net)](https://www.php.net/manual/en/language.control-structures.php)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpStatementWithoutBracesInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpShortOpenEchoTagInspection",
                "shortDescription": {
                  "text": "短起始 'echo' 标记用法"
                },
                "fullDescription": {
                  "text": "报告短 PHP 'echo' 标记 '<?=' 的用法。",
                  "markdown": "报告短 PHP `echo` 标记 `<?=` 的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpShortOpenEchoTagInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNewClassMissingParameterListInspection",
                "shortDescription": {
                  "text": "缺少形参列表"
                },
                "fullDescription": {
                  "text": "报告类的实例化中缺少的形参列表。 根据 PSR-12 规范，当实例化一个新类时，即使没有实参传递给构造函数，您也必须始终使用圆括号。 有关详细信息，请参阅 PSR-12: Extended Coding Style (php-fig.org)。",
                  "markdown": "报告类的实例化中缺少的形参列表。\n\n根据 PSR-12 规范，当实例化一个新类时，即使没有实参传递给构造函数，您也必须始终使用圆括号。\n\n\n有关详细信息，请参阅 [PSR-12: Extended Coding Style (php-fig.org)](https://www.php-fig.org/psr/psr-12/#4-classes-properties-and-methods)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNewClassMissingParameterListInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingReturnTypeInspection",
                "shortDescription": {
                  "text": "缺少返回值类型声明"
                },
                "fullDescription": {
                  "text": "报告那些没有指定返回类型声明的函数。",
                  "markdown": "报告那些没有指定返回类型声明的函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingReturnTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnused",
                "shortDescription": {
                  "text": "未使用的声明"
                },
                "fullDescription": {
                  "text": "报告未使用或从入口点不可达的类、方法、函数、常量或属性。 它还报告所有方法的实现/重写。 某些未使用的成员可能不会即时在代码编辑器中被报告。 由于性能原因，仅当非私有成员的名称很少出现在项目中时，才会对其进行检查。 要看到所有的结果，请使用代码 | 检查代码...或代码 | 通过名称运行检查，在批处理模式下运行检查。",
                  "markdown": "报告未使用或从入口点不可达的类、方法、函数、常量或属性。 它还报告所有方法的实现/重写。\n\n某些未使用的成员可能不会即时在代码编辑器中被报告。 由于性能原因，仅当非私有成员的名称很少出现在项目中时，才会对其进行检查。\n\n要看到所有的结果，请使用**代码 \\| 检查代码...** 或**代码 \\| 通过名称运行检查**，在批处理模式下运行检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnused",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未使用的符号",
                      "index": 70,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCastIsEvaluableInspection",
                "shortDescription": {
                  "text": "对标量值进行类型转换"
                },
                "fullDescription": {
                  "text": "报告可以就地评估的类型转换，并建议将其替换为计算得出的实际值。 有关详细信息，请参阅 Type juggling (php.net)。",
                  "markdown": "报告可以就地评估的类型转换，并建议将其替换为计算得出的实际值。\n\n\n有关详细信息，请参阅 [Type juggling (php.net)](https://www.php.net/manual/en/language.types.type-juggling.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCastIsEvaluableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpModifierOrderInspection",
                "shortDescription": {
                  "text": "修饰符顺序"
                },
                "fullDescription": {
                  "text": "报告以不正确的顺序指定的可见性修饰符。 根据 PSR-12，正确的顺序如下： 当存在时，'abstract' 和 'final' 声明必须位于可见性声明前面。 当存在时，'static' 声明必须位于可见性声明后面。 有关详细信息，请参阅 PSR-12: Extended Coding Style (php-fig.org)。",
                  "markdown": "报告以不正确的顺序指定的可见性修饰符。\n\n根据 PSR-12，正确的顺序如下：\n\n* 当存在时，`abstract` 和 `final` 声明必须位于可见性声明前面。\n* 当存在时，`static` 声明必须位于可见性声明后面。\n\n\n有关详细信息，请参阅 [PSR-12: Extended Coding Style (php-fig.org)](https://www.php-fig.org/psr/psr-12/#46-abstract-final-and-static)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpModifierOrderInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInstanceofIsAlwaysTrueInspection",
                "shortDescription": {
                  "text": "'instanceof' 的结果始终为 'true'"
                },
                "fullDescription": {
                  "text": "报告实参在已检查的变量的层次结构内的 'instanceof' 表达式。 此类表达式将始终是评估为 'true'。",
                  "markdown": "报告实参在已检查的变量的层次结构内的 `instanceof` 表达式。 此类表达式将始终是评估为 `true`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpInstanceofIsAlwaysTrueInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpImplicitOctalLiteralUsageInspection",
                "shortDescription": {
                  "text": "隐式八进制文字可被替换为显式八进制文字"
                },
                "fullDescription": {
                  "text": "报告可以替换为显式文字（例如 0o71）的隐式八进制文字（例如 '071'）。 PHP 8.1 及更高版本支持使用 '0o/0O' 前缀的显式八进制文字。 有关详细信息，请参阅显式八进制整数文字表示法 (php.net)。",
                  "markdown": "报告可以替换为显式文字（例如 0o71）的隐式八进制文字（例如 `071`）。\n\n\nPHP 8.1 及更高版本支持使用 `0o/0O` 前缀的显式八进制文字。\n\n\n有关详细信息，请参阅[显式八进制整数文字表示法 (php.net)](https://wiki.php.net/rfc/explicit_octal_notation)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpImplicitOctalLiteralUsageInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpVarExportUsedWithoutReturnArgumentInspection",
                "shortDescription": {
                  "text": "使用 'var_export' 或 'print_r' 调用时不带 'return' 实参"
                },
                "fullDescription": {
                  "text": "报告其结果被显式使用时，没有 'return' 实参的 'var_export()' 和 'print_r()' 调用。 此类调用很可能由错误导致，因为如果未指定 'argument'，'var_export'/'print_r' 将始终返回 'null'/'true'。",
                  "markdown": "报告其结果被显式使用时，没有 `return` 实参的 `var_export()` 和 `print_r()` 调用。 此类调用很可能由错误导致，因为如果未指定 `argument`，`var_export`/`print_r` 将始终返回 `null`/`true`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpVarExportUsedWithoutReturnArgumentInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitMissingTargetForTestInspection",
                "shortDescription": {
                  "text": "PHPUnit 测试缺少目标元素"
                },
                "fullDescription": {
                  "text": "报告没有找到相应的生产类或方法的测试类和方法。",
                  "markdown": "报告没有找到相应的生产类或方法的测试类和方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitMissingTargetForTestInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIncorrectMagicMethodSignatureInspection",
                "shortDescription": {
                  "text": "魔术方法签名不正确"
                },
                "fullDescription": {
                  "text": "报告不兼容的魔法方法签名。 有关详细信息，请参阅 RFC: Ensure correct signatures of magic methods (php.net)。",
                  "markdown": "报告不兼容的魔法方法签名。\n\n\n有关详细信息，请参阅 [RFC: Ensure correct signatures of magic methods (php.net)](https://wiki.php.net/rfc/magic-methods-signature)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpIncorrectMagicMethodSignatureInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicateCatchBodyInspection",
                "shortDescription": {
                  "text": "'catch' 语句中的重复分支"
                },
                "fullDescription": {
                  "text": "报告有重复主体的 'catch' 语句。",
                  "markdown": "报告有重复主体的 `catch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDuplicateCatchBodyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPropertyCanBeReadonlyInspection",
                "shortDescription": {
                  "text": "属性可以为 'readonly'"
                },
                "fullDescription": {
                  "text": "报告从未写入的 private 提升属性。 在 PHP 8.1 和更高版本中，此类属性可以声明为 'readonly'。 有关详细信息，请参阅只读属性 (php.net)。",
                  "markdown": "报告从未写入的 private 提升属性。 在 PHP 8.1 和更高版本中，此类属性可以声明为 `readonly`。\n\n\n有关详细信息，请参阅[只读属性 (php.net)](https://wiki.php.net/rfc/readonly_properties_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPropertyCanBeReadonlyInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPropertyNamingConventionInspection",
                "shortDescription": {
                  "text": "属性名称未遵循编码约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合指定的正则表达式模式的属性。 某些编码风格对属性有特殊的命名约定。 使用检查选项来指定属性名称的最小/最大长度和预期正则表达式。 要忽略名字的长度，指定 0。 要了解更多关于正则表达式的信息，请参考 Quick Start guide (regular-expressions.info)。",
                  "markdown": "报告名称太短、太长或不符合指定的正则表达式模式的属性。 某些编码风格对属性有特殊的命名约定。\n\n\n使用检查选项来指定属性名称的最小/最大长度和预期正则表达式。\n要忽略名字的长度，指定 **0**。\n\n\n要了解更多关于正则表达式的信息，请参考 [Quick Start guide (regular-expressions.info)](https://www.regular-expressions.info/quickstart.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpPropertyNamingConventionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/命名约定",
                      "index": 16,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNamedArgumentMightBeUnresolvedInspection",
                "shortDescription": {
                  "text": "命名实参可能未解析"
                },
                "fullDescription": {
                  "text": "报告方法调用中可能由于层次结构中的特定类实例而未被解析的命名实参。",
                  "markdown": "报告方法调用中可能由于层次结构中的特定类实例而未被解析的命名实参。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNamedArgumentMightBeUnresolvedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayTraversableCanBeReplacedWithIterableInspection",
                "shortDescription": {
                  "text": "类型提示 'array|Traversable' 可被替换为 'iterable'"
                },
                "fullDescription": {
                  "text": "报告可被替换为 'iterable' 的 'array|Traversable' 类型提示。",
                  "markdown": "报告可被替换为 `iterable` 的 `array|Traversable` 类型提示。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayTraversableCanBeReplacedWithIterableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpEchoOpenTagInspection",
                "shortDescription": {
                  "text": "打开 'echo' 标记用法"
                },
                "fullDescription": {
                  "text": "报告可被替换为短标记 '<?=' 的 '<?php echo' 用法。",
                  "markdown": "报告可被替换为短标记 `<?=` 的 `<?php echo` 用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpEchoOpenTagInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertContainsInspection",
                "shortDescription": {
                  "text": "弃用的 'assertContains/assertNotContains' 用法"
                },
                "fullDescription": {
                  "text": "报告包含字符串 '$needle' 和 '$ignoreCase' 实参的已弃用 'assertContains()' 和 'assertNotContains()' 调用。 字符串 '$needle' 以及 'assertContains()' 和 'assertNotContains()' 函数的 '$ignoreCase' 可选布尔形参已弃用，并且已在 PHPUnit 9 中移除。 对于在字符串上进行操作的断言，应该使用 'assertStringContainsString()'、'assertStringContainsStringIgnoringCase()'、'assertStringNotContainsString()' 和 'assertStringNotContainsStringIgnoringCase()' 这些特定的方法。 有关详细信息，请参阅 Usage of the assertEquals function (phpunit.readthedocs.io)。",
                  "markdown": "报告包含字符串 `$needle` 和 `$ignoreCase` 实参的已弃用 `assertContains()` 和 `assertNotContains()` 调用。\n\n\n字符串 `$needle` 以及 `assertContains()` 和 `assertNotContains()` 函数的 `$ignoreCase` 可选布尔形参已弃用，并且已在 PHPUnit 9 中移除。 对于在字符串上进行操作的断言，应该使用 `assertStringContainsString()`、`assertStringContainsStringIgnoringCase()`、`assertStringNotContainsString()` 和 `assertStringNotContainsStringIgnoringCase()` 这些特定的方法。\n\n\n有关详细信息，请参阅 [Usage of the assertEquals function (phpunit.readthedocs.io)](https://phpunit.readthedocs.io/en/stable/assertions.html)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertContainsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryDoubleQuotesInspection",
                "shortDescription": {
                  "text": "不必要的双引号"
                },
                "fullDescription": {
                  "text": "报告不带字符串内插、转义序列或单引号的双引号引用的字符串文字。",
                  "markdown": "报告不带字符串内插、转义序列或单引号的双引号引用的字符串文字。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryDoubleQuotesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDivisionByZeroInspection",
                "shortDescription": {
                  "text": "除以零"
                },
                "fullDescription": {
                  "text": "报告除 0 或对0 取模。",
                  "markdown": "报告除 0 或对0 取模。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpDivisionByZeroInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNullSafeOperatorCanBeUsedInspection",
                "shortDescription": {
                  "text": "可以使用 Nullsafe 运算符 '?->'"
                },
                "fullDescription": {
                  "text": "报告可以用 '?->' nullsafe 运算符安全替换的 null 检查条件表达式。",
                  "markdown": "报告可以用 `?->` nullsafe 运算符安全替换的 null 检查条件表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNullSafeOperatorCanBeUsedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLineCommentWillBeParsedAsAttributeInspection",
                "shortDescription": {
                  "text": "在 PHP 8.0 中注释被解析为特性"
                },
                "fullDescription": {
                  "text": "报告以 '#[' 开头的行注释。 在 PHP 8.0 和更高版本中，此类注释被解析为特性。 有关详细信息，请参阅 Attributes (php.net)。",
                  "markdown": "报告以 `#[` 开头的行注释。 在 PHP 8.0 和更高版本中，此类注释被解析为特性。\n\n\n有关详细信息，请参阅 [Attributes (php.net)](https://wiki.php.net/rfc/attributes_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpLineCommentWillBeParsedAsAttributeInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayShapeCanBeAddedInspection",
                "shortDescription": {
                  "text": "可以添加 '#[ArrayShape]' 特性"
                },
                "fullDescription": {
                  "text": "报告使用已知非普通键返回数组的方法和函数。 建议通过 '#[ArrayShape]' 特性或 PHPDoc 注释中的数组形状来指定返回数组的形状。",
                  "markdown": "报告使用已知非普通键返回数组的方法和函数。 建议通过 `#[ArrayShape]` 特性或 PHPDoc 注释中的数组形状来指定返回数组的形状。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayShapeCanBeAddedInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantCatchClauseInspection",
                "shortDescription": {
                  "text": "冗余 catch 子句"
                },
                "fullDescription": {
                  "text": "报告带有异常的 'catch' 子句，这些异常在相应的'try'块中从未抛出。",
                  "markdown": "报告带有异常的 `catch` 子句，这些异常在相应的`try`块中从未抛出。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantCatchClauseInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/错误处理",
                      "index": 144,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnpackedArgumentTypeMismatchInspection",
                "shortDescription": {
                  "text": "无效类型的解包实参"
                },
                "fullDescription": {
                  "text": "报告类型既不是 'array' 也不是 'Traversable' 的解包的函数实参和数组元素。 从 PHP 8.0 开始，这种用法将导致'致命错误'。",
                  "markdown": "报告类型既不是 `array` 也不是 `Traversable` 的解包的函数实参和数组元素。\n\n\n从 PHP 8.0 开始，这种用法将导致`致命错误`。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnpackedArgumentTypeMismatchInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryLeadingBackslashInUseStatementInspection",
                "shortDescription": {
                  "text": "'use' 语句中有不必要的前导 ''"
                },
                "fullDescription": {
                  "text": "报告 'use' 语句，有一个不必要的前导 '\\'。 对于命名空间的名称（完全合格的命名空间名称包含一个命名空间分隔符，如'Foo\\Bar'，与之相反全局命名空间名称则没有，如'FooBar'），不需要也不建议开头使用反斜杠，因为导入名称必须是完全合格的，并且它不会相对于现有命名空间进行处理。 有关详细信息，请参阅 Using namespaces: Aliasing/Importing (php.net)。",
                  "markdown": "报告 `use` 语句，有一个不必要的前导 `\\`。\n\n\n对于命名空间的名称（完全合格的命名空间名称包含一个命名空间分隔符，如`Foo\\Bar`，与之相反全局命名空间名称则没有，如`FooBar`），不需要也不建议开头使用反斜杠，因为导入名称必须是完全合格的，并且它不会相对于现有命名空间进行处理。\n\n\n有关详细信息，请参阅 [Using namespaces: Aliasing/Importing (php.net)](https://www.php.net/manual/en/language.namespaces.importing.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryLeadingBackslashInUseStatementInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertTrueWithIncompatibleTypeArgumentInspection",
                "shortDescription": {
                  "text": "实参类型不兼容的 'assertTrue()'"
                },
                "fullDescription": {
                  "text": "报告实参类型不兼容的 PHPUnit 'assertTrue()' 调用。 由于 'assertTrue()' 方法依赖于与 'true' 的严格类型比较，此类断言始终会失败。",
                  "markdown": "报告实参类型不兼容的 PHPUnit `assertTrue()` 调用。 由于 `assertTrue()` 方法依赖于与 `true` 的严格类型比较，此类断言始终会失败。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertTrueWithIncompatibleTypeArgumentInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpDuplicateOperandInComparisonInspection",
                "shortDescription": {
                  "text": "比较中的重复操作数"
                },
                "fullDescription": {
                  "text": "报告在比较表达式内部依次使用的二进制表达式中的重复操作数（'+'、'-'、'*'、'/'、'&&'、'||' 和 '.'）。 此类操作数不会影响比较结果，可以安全移除。",
                  "markdown": "报告在比较表达式内部依次使用的二进制表达式中的重复操作数（`+`、`-`、`*`、`/`、`&&`、`||` 和 `.`）。 此类操作数不会影响比较结果，可以安全移除。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpDuplicateOperandInComparisonInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedClassInspection",
                "shortDescription": {
                  "text": "未定义的类"
                },
                "fullDescription": {
                  "text": "报告那些在项目文件、配置的包含路径或 PHP 预定义类中没有找到的类的引用。 使用以下选项来自定义检查： 忽略 PHPDoc：如果选择，检查将不会报告 PHPDoc 块中引用的未定义类。",
                  "markdown": "报告那些在项目文件、配置的包含路径或 PHP 预定义类中没有找到的类的引用。\n\n使用以下选项来自定义检查：\n\n* **忽略 PHPDoc**：如果选择，检查将不会报告 PHPDoc 块中引用的未定义类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedClassInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCompoundNamespaceDepthInspection",
                "shortDescription": {
                  "text": "复合命名空间深度大于 2"
                },
                "fullDescription": {
                  "text": "报告深度超过两级的复合命名空间使用情况。 根据 PSR-12，不得使用深度超过两级的复合命名空间。 有关详细信息，请参阅 PSR-12: Extended Coding Style (php-fig.org)。",
                  "markdown": "报告深度超过两级的复合命名空间使用情况。\n\n根据 PSR-12，不得使用深度超过两级的复合命名空间。\n\n\n有关详细信息，请参阅 [PSR-12: Extended Coding Style (php-fig.org)](https://www.php-fig.org/psr/psr-12/#3-declare-statements-namespace-and-import-statements)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpCompoundNamespaceDepthInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Code style/PSR-12",
                      "index": 134,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArgumentWithoutNamedIdentifierInspection",
                "shortDescription": {
                  "text": "无名称标识符的实参"
                },
                "fullDescription": {
                  "text": "报告没有名称标识符的实参。",
                  "markdown": "报告没有名称标识符的实参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArgumentWithoutNamedIdentifierInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUndefinedConstantInspection",
                "shortDescription": {
                  "text": "未定义的常量"
                },
                "fullDescription": {
                  "text": "报告对在项目文件中找不到的常量、配置的 include 路径或 PHP 预定义常量的引用。",
                  "markdown": "报告对在项目文件中找不到的常量、配置的 include 路径或 PHP 预定义常量的引用。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpUndefinedConstantInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未定义的符号",
                      "index": 33,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUncoveredEnumCasesInspection",
                "shortDescription": {
                  "text": "某些 enum case 未被覆盖"
                },
                "fullDescription": {
                  "text": "报告在未覆盖 'match' arm 条件的所有 'enum' case 的 'match' 表达式。",
                  "markdown": "报告在未覆盖 `match` arm 条件的所有 `enum` case 的 `match` 表达式。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUncoveredEnumCasesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMethodOrClassCallIsNotCaseSensitiveInspection",
                "shortDescription": {
                  "text": "方法调用或类用法中的大小写不匹配"
                },
                "fullDescription": {
                  "text": "报告与声明中使用的大小写不匹配的函数、方法、类和命名空间的用法。",
                  "markdown": "报告与声明中使用的大小写不匹配的函数、方法、类和命名空间的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMethodOrClassCallIsNotCaseSensitiveInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAttributeCanBeAddedToOverriddenMemberInspection",
                "shortDescription": {
                  "text": "可以将特性添加到重写成员"
                },
                "fullDescription": {
                  "text": "报告可以传播到覆盖方法/形参的方法和形参的特性。 有关详细信息，请参阅 Attributes (php.net)。",
                  "markdown": "报告可以传播到覆盖方法/形参的方法和形参的特性。\n\n\n有关详细信息，请参阅 [Attributes (php.net)](https://wiki.php.net/rfc/attributes_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAttributeCanBeAddedToOverriddenMemberInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpRedundantDocCommentInspection",
                "shortDescription": {
                  "text": "冗余 PHPDoc 注释"
                },
                "fullDescription": {
                  "text": "报告包含声明中已提供信息的 PHPDoc 注释或其部分。",
                  "markdown": "报告包含声明中已提供信息的 PHPDoc 注释或其部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpRedundantDocCommentInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPDoc",
                      "index": 2,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpOverriddenMethodExistsInspection",
                "shortDescription": {
                  "text": "方法未从其超类重写方法"
                },
                "fullDescription": {
                  "text": "检查被重写的方法是否存在。 有关详细信息，请参阅 PHP RFC: Marking overridden methods (wiki.php.net)。",
                  "markdown": "检查被重写的方法是否存在。\n\n\n有关详细信息，请参阅 [PHP RFC: Marking overridden methods (wiki.php.net)](https://wiki.php.net/rfc/marking_overriden_methods)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpOverriddenMethodExistsInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/特性",
                      "index": 68,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnnecessaryBoolCastInspection",
                "shortDescription": {
                  "text": "冗余转换为布尔值"
                },
                "fullDescription": {
                  "text": "报告冗余的 '(bool)'/'(boolean)' 转换和 'boolval()' 调用，因为向 'bool' 的转换是隐式进行的。",
                  "markdown": "报告冗余的 `(bool)`/`(boolean)` 转换和 `boolval()` 调用，因为向 `bool` 的转换是隐式进行的。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnnecessaryBoolCastInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedMatchConditionInspection",
                "shortDescription": {
                  "text": "未使用的 'match' 条件"
                },
                "fullDescription": {
                  "text": "报告 'match' 表达式中永远不会匹配的条件。 与 PHP Engine 行为类似，检查使用严格比较 ('===') 来检查 'match' 条件下的类型与 'match' 实参类型， 不管 'strict_types' 指令如何。 由于没有发生类型强制，因此某些条件可能由于类型不匹配而无法匹配。 有关详细信息，请参阅 Match expression (php.net)。",
                  "markdown": "报告 `match` 表达式中永远不会匹配的条件。\n\n\n与 PHP Engine 行为类似，检查使用严格比较 (`===`) 来检查 `match` 条件下的类型与 `match` 实参类型， 不管 `strict_types` 指令如何。 由于没有发生类型强制，因此某些条件可能由于类型不匹配而无法匹配。\n\n\n有关详细信息，请参阅 [Match expression (php.net)](https://wiki.php.net/rfc/match_expression_v2)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedMatchConditionInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpComposerDuplicatedRequirementInspection",
                "shortDescription": {
                  "text": "composer.json 中存在重复的软件包条目"
                },
                "fullDescription": {
                  "text": "报告在 composer.json 中 'require' 和 'require-dev' 部分的重复软件包条目。",
                  "markdown": "报告在 *composer.json* 中 `require` 和 `require-dev` 部分的重复软件包条目。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpComposerDuplicatedRequirementInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Composer",
                      "index": 54,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpExpressionResultUnusedInspection",
                "shortDescription": {
                  "text": "未使用表达式结果"
                },
                "fullDescription": {
                  "text": "报告被计算但计算结果不在任何地方使用的表达式。 例如，将 '=' 运算符错写成 '=='，就会造成这种错误。",
                  "markdown": "报告被计算但计算结果不在任何地方使用的表达式。\n\n例如，将 `=` 运算符错写成 `==`，就会造成这种错误。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpExpressionResultUnusedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInternalEntityUsedInspection",
                "shortDescription": {
                  "text": "使用了内部实体"
                },
                "fullDescription": {
                  "text": "报告被标记为 '@internal' 并且位于不同源根的实体用法。 位于同一源根中的用法不被报告。 在大多数情况下，报告的用法应该被删除，或者用其他结构来代替。",
                  "markdown": "报告被标记为 `@internal` 并且位于不同源根的实体用法。 位于同一源根中的用法不被报告。\n\n\n在大多数情况下，报告的用法应该被删除，或者用其他结构来代替。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpInternalEntityUsedInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpNamedArgumentsWithChangedOrderInspection",
                "shortDescription": {
                  "text": "命名实参顺序与形参顺序不匹配"
                },
                "fullDescription": {
                  "text": "报告命名实参的顺序与形参顺序不匹配",
                  "markdown": "报告命名实参的顺序与形参顺序不匹配"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpNamedArgumentsWithChangedOrderInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpIdempotentOperationInspection",
                "shortDescription": {
                  "text": "二元表达式中的幂等运算"
                },
                "fullDescription": {
                  "text": "报告不更改表达式结果 (如 '+ 0' 或 '. \"\"') 并因此而冗余的二进制表达式操作数。",
                  "markdown": "报告不更改表达式结果 (如 `+ 0` 或 `. \"\"`) 并因此而冗余的二进制表达式操作数。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpIdempotentOperationInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpLoopCanBeReplacedWithImplodeInspection",
                "shortDescription": {
                  "text": "循环可被替换为 'implode()'"
                },
                "fullDescription": {
                  "text": "报告可以安全替换为 'implode()' 调用的 'foreach' 循环。 有关详细信息，请参阅 implode (php.net)。",
                  "markdown": "报告可以安全替换为 `implode()` 调用的 `foreach` 循环。\n\n\n有关详细信息，请参阅 [implode (php.net)](https://www.php.net/manual/en/function.implode.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpLoopCanBeReplacedWithImplodeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpConcatenationWithArithmeticInspection",
                "shortDescription": {
                  "text": "具有算术用法的串联"
                },
                "fullDescription": {
                  "text": "报告与 '+'、'-'、'<<' 和 '>>' 一起使用的字符串串联表达式运算符。 从 PHP 8 开始，串联操作的优先级较低，因此此类表达式可能会产生意外的结果。 有关详细信息，请参阅 Concatenation precedence (php.net)。",
                  "markdown": "报告与 `+`、`-`、`<<` 和 `>>` 一起使用的字符串串联表达式运算符。 从 PHP 8 开始，串联操作的优先级较低，因此此类表达式可能会产生意外的结果。\n\n\n有关详细信息，请参阅 [Concatenation precedence (php.net)](https://wiki.php.net/rfc/concatenation_precedence)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpConcatenationWithArithmeticInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitAssertCanBeReplacedWithFailInspection",
                "shortDescription": {
                  "text": "断言可被替换为 'fail'"
                },
                "fullDescription": {
                  "text": "报告 PHPUnit 测试中带有 'false'/'true' 实参的 'assertTrue()'/'assertFalse()' 调用。 此类用法可以替换为 'fail()' 调用，以表示测试预计会失败。",
                  "markdown": "报告 PHPUnit 测试中带有 `false`/`true` 实参的 `assertTrue()`/`assertFalse()` 调用。 此类用法可以替换为 `fail()` 调用，以表示测试预计会失败。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitAssertCanBeReplacedWithFailInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnusedLocalVariableInspection",
                "shortDescription": {
                  "text": "未使用的局部变量"
                },
                "fullDescription": {
                  "text": "报告在以下情况下被认为是未使用的变量： 变量的值未在任何位置使用或立即被覆盖。 变量中存储的引用未在任何位置使用或立即被覆盖。",
                  "markdown": "报告在以下情况下被认为是未使用的变量：\n\n* 变量的值未在任何位置使用或立即被覆盖。\n* 变量中存储的引用未在任何位置使用或立即被覆盖。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnusedLocalVariableInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/未使用的符号",
                      "index": 70,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpAssignmentReplaceableWithOperatorAssignmentInspection",
                "shortDescription": {
                  "text": "赋值可被替换为运算符赋值"
                },
                "fullDescription": {
                  "text": "报告可以用组合运算符赋值替换的赋值（例如，'+='）。",
                  "markdown": "报告可以用组合运算符赋值替换的赋值（例如，`+=`）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpAssignmentReplaceableWithOperatorAssignmentInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可替换赋值",
                      "index": 166,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpSwitchWithCommonPartsInspection",
                "shortDescription": {
                  "text": "包含通用部分的 'switch'"
                },
                "fullDescription": {
                  "text": "报告有重复的通用部分的 'switch' 语句。",
                  "markdown": "报告有重复的通用部分的 'switch' 语句。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpSwitchWithCommonPartsInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/控制流",
                      "index": 22,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpParameterByRefIsNotUsedAsReferenceInspection",
                "shortDescription": {
                  "text": "不必要的通过引用传递"
                },
                "fullDescription": {
                  "text": "报告通过引用传递给函数/方法但在函数/方法主体中没有被修改的变量。 在这种情况下，形参声明中的 '&' 可以被安全地移除。 有关详细信息，请参阅 Passing by Reference (php.net)。",
                  "markdown": "报告通过引用传递给函数/方法但在函数/方法主体中没有被修改的变量。 在这种情况下，形参声明中的 `&` 可以被安全地移除。\n\n\n有关详细信息，请参阅 [Passing by Reference (php.net)](https://www.php.net/manual/en/language.references.pass.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpParameterByRefIsNotUsedAsReferenceInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpExceptionImmediatelyRethrownInspection",
                "shortDescription": {
                  "text": "立即重新抛出异常"
                },
                "fullDescription": {
                  "text": "报告只重新抛出捕获的异常的 'catch' 语句，该异常位于与后续异常类型不同的类层次结构中。",
                  "markdown": "报告只重新抛出捕获的异常的 `catch` 语句，该异常位于与后续异常类型不同的类层次结构中。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpExceptionImmediatelyRethrownInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpHierarchyChecksInspection",
                "shortDescription": {
                  "text": "类层次结构检查"
                },
                "fullDescription": {
                  "text": "检查类的层次结构：抽象方法的实现，实现/重写方法与其在父类中的声明兼容性以及属性的类型重新声明。 所有报告的违规行为都会导致 PHP 致命错误。 不建议禁用或取消此检查。",
                  "markdown": "检查类的层次结构：抽象方法的实现，实现/重写方法与其在父类中的声明兼容性以及属性的类型重新声明。\n\n所有报告的违规行为都会导致 PHP 致命错误。 不建议禁用或取消此检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpHierarchyChecksInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/常规",
                      "index": 11,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpPropertyOnlyWrittenInspection",
                "shortDescription": {
                  "text": "属性用法具有相同的访问权限"
                },
                "fullDescription": {
                  "text": "报告以下 private 属性： 写入但从未读取 读取但从未写入",
                  "markdown": "报告以下 private 属性：\n\n* 写入但从未读取\n* 读取但从未写入"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpPropertyOnlyWrittenInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpMissingFieldTypeInspection",
                "shortDescription": {
                  "text": "缺少属性的类型声明"
                },
                "fullDescription": {
                  "text": "报告没有类型声明的属性。",
                  "markdown": "报告没有类型声明的属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpMissingFieldTypeInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpWrongForeachArgumentTypeInspection",
                "shortDescription": {
                  "text": "为 'foreach()' 提供的无效实参"
                },
                "fullDescription": {
                  "text": "报告在 'string'、'float'、'int' 或 'boolean' 类型的变量上使用的 'foreach' 结构。 有关详细信息，请参阅 foreach (php.net)。",
                  "markdown": "报告在 `string`、`float`、`int` 或 `boolean` 类型的变量上使用的 `foreach` 结构。\n\n\n有关详细信息，请参阅 [foreach (php.net)](http://www.php.net/manual/en/control-structures.foreach.php)。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpWrongForeachArgumentTypeInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/类型兼容性",
                      "index": 49,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpTooManyParametersInspection",
                "shortDescription": {
                  "text": "函数声明中的形参过多"
                },
                "fullDescription": {
                  "text": "报告形参数量超过指定限制的函数/方法声明。",
                  "markdown": "报告形参数量超过指定限制的函数/方法声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpTooManyParametersInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码异味",
                      "index": 20,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpInvalidStringOffsetUsageInspection",
                "shortDescription": {
                  "text": "字符串偏移用法无效"
                },
                "fullDescription": {
                  "text": "报告将导致运行时错误的无效字符串偏移量用法。 报告以下用法： 将字符串偏移量用作对象或数组 通过 'unset' 取消设置字符串偏移量 通过引用传递字符串偏移量 创建对字符串偏移量的引用或从字符串偏移量引用 增大或减小字符串偏移量 在字符串偏移量上使用组合运算符赋值，例如 '+=' 或 '.=' 使用空字符串或长度大于 1 的字符串分配字符串偏移量",
                  "markdown": "报告将导致运行时错误的无效字符串偏移量用法。\n\n\n报告以下用法：\n\n* 将字符串偏移量用作对象或数组\n* 通过 `unset` 取消设置字符串偏移量\n* 通过引用传递字符串偏移量\n* 创建对字符串偏移量的引用或从字符串偏移量引用\n* 增大或减小字符串偏移量\n* 在字符串偏移量上使用组合运算符赋值，例如 `+=` 或 `.=`\n* 使用空字符串或长度大于 1 的字符串分配字符串偏移量"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PhpInvalidStringOffsetUsageInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/可能的 bug",
                      "index": 46,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpArrayFilterCanBeConvertedToLoopInspection",
                "shortDescription": {
                  "text": "'array_filter()' 调用可以转换为循环"
                },
                "fullDescription": {
                  "text": "报告可以替换为 'foreach' 循环的 'array_filter()' 调用。",
                  "markdown": "报告可以替换为 `foreach` 循环的 `array_filter()` 调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpArrayFilterCanBeConvertedToLoopInspection",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/代码样式",
                      "index": 9,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpUnitDeprecatedDataProviderSignatureInspection",
                "shortDescription": {
                  "text": "自 PHPUnit 10 以来，已弃用数据提供程序"
                },
                "fullDescription": {
                  "text": "报告在 '@dataProvider' PHPDoc 标记中对解析为非 static 或非 public 方法的函数/方法的引用。 从 PHPUnit 10 开始，使用这些方法作为 PHPUnit 数据提供程序的用法已弃用。",
                  "markdown": "报告在 `@dataProvider` PHPDoc 标记中对解析为非 static 或非 public 方法的函数/方法的引用。 从 PHPUnit 10 开始，使用这些方法作为 PHPUnit 数据提供程序的用法已弃用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "PhpUnitDeprecatedDataProviderSignatureInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/PHPUnit",
                      "index": 100,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.database",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "MysqlLoadDataPathInspection",
                "shortDescription": {
                  "text": "LOAD 语句路径"
                },
                "fullDescription": {
                  "text": "报告 LOAD 语句中以波浪符号开头的路径。 示例（MySQL）： 'CREATE TABLE table_name (id int);\nLOAD DATA LOCAL INFILE '~/Documents/some_file.txt'\nINTO TABLE table_name FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'\nIGNORE 1 LINES;' 使用文件的完整路径代替波浪符号。",
                  "markdown": "报告 LOAD 语句中以波浪符号开头的路径。\n\n示例（MySQL）：\n\n    CREATE TABLE table_name (id int);\n    LOAD DATA LOCAL INFILE '~/Documents/some_file.txt'\n    INTO TABLE table_name FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'\n    IGNORE 1 LINES;\n\n使用文件的完整路径代替波浪符号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MysqlLoadDataPath",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MySQL",
                      "index": 15,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlMissingReturnInspection",
                "shortDescription": {
                  "text": "缺少 return 语句"
                },
                "fullDescription": {
                  "text": "报告没有 RETURN 语句的函数。 示例（Oracle）： 'CREATE FUNCTION foo RETURN int AS\nBEGIN\nEND;' 'foo' 函数必须返回整数值，但函数体不返回任何内容。 要修正错误，请添加 RETURN 语句（例如，'RETURN 1;'）。 'CREATE FUNCTION foo RETURN int AS\nBEGIN\n RETURN 1;\nEND;'",
                  "markdown": "报告没有 RETURN 语句的函数。\n\n示例（Oracle）：\n\n    CREATE FUNCTION foo RETURN int AS\n    BEGIN\n    END;\n\n`foo` 函数必须返回整数值，但函数体不返回任何内容。 要修正错误，请添加 RETURN 语句（例如，`RETURN 1;`）。\n\n    CREATE FUNCTION foo RETURN int AS\n    BEGIN\n     RETURN 1;\n    END;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "SqlMissingReturn",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlCaseVsIfInspection",
                "shortDescription": {
                  "text": "使用 CASE 代替条件函数，反之亦然"
                },
                "fullDescription": {
                  "text": "报告 CASE 和 IF 可互换的情况。 示例（MySQL）： 'SELECT CASE\nWHEN C1 IS NULL THEN 1\nELSE 0\nEND\nFROM dual;' 您可以通过用 IF 替换 CASE 结构来缩短代码。 为此，请应用 替换为 'IF' 调用 意图操作。 示例代码如下所示： 'SELECT IF(C1 IS NULL, 1, 0)\nFROM dual;' 要将 IF 恢复为 CASE，请点击 IF 并应用替换为 CASE 表达式 意图操作。",
                  "markdown": "报告 CASE 和 IF 可互换的情况。\n\n示例（MySQL）：\n\n    SELECT CASE\n    WHEN C1 IS NULL THEN 1\n    ELSE 0\n    END\n    FROM dual;\n\n您可以通过用 IF 替换 CASE 结构来缩短代码。 为此，请应用 **替换为 'IF' 调用** 意图操作。 示例代码如下所示：\n\n    SELECT IF(C1 IS NULL, 1, 0)\n    FROM dual;\n\n要将 IF 恢复为 CASE，请点击 IF 并应用**替换为 CASE 表达式** 意图操作。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlCaseVsIf",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlShouldBeInGroupByInspection",
                "shortDescription": {
                  "text": "列应在 group by 子句中"
                },
                "fullDescription": {
                  "text": "报告不在 GROUP BY 子句或聚合函数调用中的列。 示例（Microsoft SQL 服务器）： 'CREATE TABLE t1 (a INT, b INT);\nSELECT a, b FROM t1 GROUP BY a;' 如果您运行 SELECT 查询，您将收到一个错误，因为 Microsoft SQL Server 需要 'b' 列在 GROUP BY 中或在聚合函数内使用。 以下两个示例将修复该错误。 'SELECT a, b FROM t1 GROUP BY a, b;\nSELECT a, max(b) max_b FROM t1 GROUP BY a;'",
                  "markdown": "报告不在 GROUP BY 子句或聚合函数调用中的列。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE TABLE t1 (a INT, b INT);\n    SELECT a, b FROM t1 GROUP BY a;\n\n如果您运行 SELECT 查询，您将收到一个错误，因为 Microsoft SQL Server 需要 `b` 列在 GROUP BY 中或在聚合函数内使用。 以下两个示例将修复该错误。\n\n    SELECT a, b FROM t1 GROUP BY a, b;\n    SELECT a, max(b) max_b FROM t1 GROUP BY a;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlShouldBeInGroupBy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlDtInspection",
                "shortDescription": {
                  "text": "格式错误的日期/时间文字"
                },
                "fullDescription": {
                  "text": "报告日期和时间文字中的错误。 此检查在 MySQL、Oracle、Db2 和 H2 中可用。 示例（MySQL）： 'SELECT TIME '10 -12:13:14' FROM dual;\nSELECT TIME ' 12 : 13 : 14 ' FROM dual;\nSELECT TIME '12 13 14' FROM dual;\nSELECT TIME '12-13-14' FROM dual;\nSELECT TIME '12.13.14' FROM dual;\nSELECT TIME '12:13:' FROM dual;\nSELECT TIME '12:13' FROM dual;\nSELECT TIME '12:' FROM dual;' 在此示例中，日期会忽略 MySQL 日期文字和时间文字标准。 因此，这些将高亮显示。 有关 MySQL 中日期和时间文字的详细信息，请参阅 dev.mysql.com 上的 Date and Time Literals。 以下日期和时间文字对 MySQL 有效。 'SELECT TIME '12:13:14' FROM dual;\nSELECT TIME '12:13:14.555' FROM dual;\nSELECT TIME '12:13:14.' FROM dual;\nSELECT TIME '-12:13:14' FROM dual;\nSELECT TIME '10 12:13:14' FROM dual;\nSELECT TIME '-10 12:13:14' FROM dual;'",
                  "markdown": "报告日期和时间文字中的错误。 此检查在 MySQL、Oracle、Db2 和 H2 中可用。\n\n示例（MySQL）：\n\n    SELECT TIME '10 -12:13:14' FROM dual;\n    SELECT TIME ' 12 : 13 : 14 ' FROM dual;\n    SELECT TIME '12 13 14' FROM dual;\n    SELECT TIME '12-13-14' FROM dual;\n    SELECT TIME '12.13.14' FROM dual;\n    SELECT TIME '12:13:' FROM dual;\n    SELECT TIME '12:13' FROM dual;\n    SELECT TIME '12:' FROM dual;\n\n在此示例中，日期会忽略 MySQL 日期文字和时间文字标准。 因此，这些将高亮显示。\n有关 MySQL 中日期和时间文字的详细信息，请参阅 [dev.mysql.com 上的 Date and Time Literals](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html)。\n\n以下日期和时间文字对 MySQL 有效。\n\n    SELECT TIME '12:13:14' FROM dual;\n    SELECT TIME '12:13:14.555' FROM dual;\n    SELECT TIME '12:13:14.' FROM dual;\n    SELECT TIME '-12:13:14' FROM dual;\n    SELECT TIME '10 12:13:14' FROM dual;\n    SELECT TIME '-10 12:13:14' FROM dual;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlDateTime",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlNoDataSourceInspection",
                "shortDescription": {
                  "text": "未配置数据源"
                },
                "fullDescription": {
                  "text": "报告数据库工具窗口中缺少数据源（视图 | 工具窗口 | 数据库）。",
                  "markdown": "报告**数据库** 工具窗口中缺少数据源（**视图 \\| 工具窗口 \\| 数据库**）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlNoDataSourceInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlMisleadingReferenceInspection",
                "shortDescription": {
                  "text": "误导性引用"
                },
                "fullDescription": {
                  "text": "报告 SQL 代码中不明确的引用。 例如，当名称同时引用表列和例程形参时。 由于违反直观的解析逻辑，此类代码的执行可能会导致错误或意外结果。 通常，范围更局部的名称具有更高的优先级。 示例（PostgreSQL）： 'CREATE TABLE foo\n(\n    id   INT,\n    name VARCHAR(5)\n);\nCREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS\n$$\nDECLARE\n    b INT;\nBEGIN\n      -- `name` 不明确，因为它被用作列名和形参\n    SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;\n    RETURN b;\nEND;\n$$ LANGUAGE plpgsql;' 在 PostgreSQL 中，您可以使用 '#variable_conflict' 指令来明确指定正确的引用。 例如，使用 '#variable_conflict use_column' 引用列名，或使用 '#variable_conflict use_variable' 引用形参。 'CREATE TABLE foo\n(\n    id   INT,\n    name VARCHAR(5)\n);\nCREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS\n$$\n    #variable_conflict use_column\nDECLARE\n    b INT;\nBEGIN\n    SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;\n    RETURN b;\nEND;\n$$ LANGUAGE plpgsql;'",
                  "markdown": "报告 SQL 代码中不明确的引用。\n\n例如，当名称同时引用表列和例程形参时。 由于违反直观的解析逻辑，此类代码的执行可能会导致错误或意外结果。 通常，范围更局部的名称具有更高的优先级。\n\n示例（PostgreSQL）：\n\n    CREATE TABLE foo\n    (\n        id   INT,\n        name VARCHAR(5)\n    );\n    CREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS\n    $$\n    DECLARE\n        b INT;\n    BEGIN\n          -- `name` 不明确，因为它被用作列名和形参\n        SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;\n        RETURN b;\n    END;\n    $$ LANGUAGE plpgsql;\n\n在 PostgreSQL 中，您可以使用 `#variable_conflict` 指令来明确指定正确的引用。 例如，使用 `#variable_conflict use_column` 引用列名，或使用 `#variable_conflict use_variable` 引用形参。\n\n    CREATE TABLE foo\n    (\n        id   INT,\n        name VARCHAR(5)\n    );\n    CREATE FUNCTION func(name VARCHAR(5)) RETURNS INT AS\n    $$\n        #variable_conflict use_column\n    DECLARE\n        b INT;\n    BEGIN\n        SELECT COUNT(*) INTO b FROM foo t WHERE t.name = name;\n        RETURN b;\n    END;\n    $$ LANGUAGE plpgsql;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlMisleadingReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlRedundantAliasInspection",
                "shortDescription": {
                  "text": "冗余别名表达式"
                },
                "fullDescription": {
                  "text": "报告可能与表中的列名重叠并且可能是冗余的别名表达式。 示例（PostgreSQL）： 'CREATE TABLE foo(a INT, b INT);\n\nSELECT * FROM foo foo(a, b);\nSELECT * FROM foo foo(a);\nSELECT * FROM foo foo(x);\nSELECT * FROM foo foo(x, y);' 前两个别名使用与 'foo' 表中相同的列名。 这些被认为是冗余的，因为列具有相同的名称。",
                  "markdown": "报告可能与表中的列名重叠并且可能是冗余的别名表达式。\n\n示例（PostgreSQL）：\n\n    CREATE TABLE foo(a INT, b INT);\n\n    SELECT * FROM foo foo(a, b);\n    SELECT * FROM foo foo(a);\n    SELECT * FROM foo foo(x);\n    SELECT * FROM foo foo(x, y);\n\n前两个别名使用与 `foo` 表中相同的列名。 这些被认为是冗余的，因为列具有相同的名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlRedundantAlias",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlConstantExpressionInspection",
                "shortDescription": {
                  "text": "常量表达式"
                },
                "fullDescription": {
                  "text": "报告始终为 true、false 或 null 的条件和表达式。 示例（MySQL）： 'CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);\nSELECT a FROM t1 WHERE 'Cat' = 'Cat';\nSELECT a FROM t1 WHERE 'Cat' = null;' ''Cat' = 'Cat'' 始终为 true，将被报告。 ''Cat' = null' 始终为 null，将被报告。",
                  "markdown": "报告始终为 true、false 或 null 的条件和表达式。\n\n示例（MySQL）：\n\n    CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);\n    SELECT a FROM t1 WHERE 'Cat' = 'Cat';\n    SELECT a FROM t1 WHERE 'Cat' = null;\n\n`'Cat' = 'Cat'` 始终为 true，将被报告。\n\n`'Cat' = null` 始终为 null，将被报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlConstantExpression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OraUnmatchedForwardDeclarationInspection",
                "shortDescription": {
                  "text": "不含定义的前向声明"
                },
                "fullDescription": {
                  "text": "报告在代码中缺少实现的过程和函数的声明。 在 Oracle 中，您可以声明一个没有主体的过程或函数，并在稍后的某个时间编写实现。 该检查将报告未实现的此类过程或函数的名称。 示例（Oracle）： 'DECLARE PROCEDURE foo(a int, b varchar2);\nBEGIN\n    NULL;\nEND;' 'foo' 过程已被声明，但缺少实现。 我们可以添加实现来消除错误。 'DECLARE PROCEDURE foo(a int, b varchar2);\n  PROCEDURE foo(a int, b varchar2) IS\nBEGIN\n    NULL;\nEND;\nBEGIN\n    NULL;\nEND;'",
                  "markdown": "报告在代码中缺少实现的过程和函数的声明。\n\n在 Oracle 中，您可以声明一个没有主体的过程或函数，并在稍后的某个时间编写实现。 该检查将报告未实现的此类过程或函数的名称。\n\n示例（Oracle）：\n\n    DECLARE PROCEDURE foo(a int, b varchar2);\n    BEGIN\n        NULL;\n    END;\n\n`foo` 过程已被声明，但缺少实现。 我们可以添加实现来消除错误。\n\n    DECLARE PROCEDURE foo(a int, b varchar2);\n      PROCEDURE foo(a int, b varchar2) IS\n    BEGIN\n        NULL;\n    END;\n    BEGIN\n        NULL;\n    END;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "SqlUnmatchedForwardDeclaration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Oracle",
                      "index": 123,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlWithoutWhereInspection",
                "shortDescription": {
                  "text": "不带 where 子句的删除或更新语句"
                },
                "fullDescription": {
                  "text": "报告不带 WHERE 子句的 DELETE 或 UPDATE 语句的用法。 如果没有 WHERE 子句，DELETE 会删除表中的所有数据，而 UPDATE 会覆盖所有表行的值。 示例（MySQL）： 'CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);\nupdate t1 set  a = 'Smith';\ndelete from t1;'",
                  "markdown": "报告不带 WHERE 子句的 DELETE 或 UPDATE 语句的用法。\n\n如果没有 WHERE 子句，DELETE 会删除表中的所有数据，而 UPDATE 会覆盖所有表行的值。\n\n示例（MySQL）：\n\n    CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);\n    update t1 set  a = 'Smith';\n    delete from t1;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlWithoutWhere",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlUnusedCteInspection",
                "shortDescription": {
                  "text": "未使用的通用表表达式"
                },
                "fullDescription": {
                  "text": "报告查询中未使用的通用表表达式 (CTE)。 示例（PostgreSQL）： 'CREATE TABLE foo(a INT);\n\nWITH a AS (SELECT 1 AS x FROM foo)\nSELECT 1 + 2 FROM foo;' 通过使用 WITH，我们创建了一个名为 'a' 的临时命名结果集，也称为通用表表达式 (CTE)。 但是，我们稍后不会在代码中使用此 CTE。 未使用的 CTE 显示为灰色。",
                  "markdown": "报告查询中未使用的通用表表达式 (CTE)。\n\n示例（PostgreSQL）：\n\n    CREATE TABLE foo(a INT);\n\n    WITH a AS (SELECT 1 AS x FROM foo)\n    SELECT 1 + 2 FROM foo;\n\n通过使用 WITH，我们创建了一个名为 `a` 的临时命名结果集，也称为通用表表达式 (CTE)。 但是，我们稍后不会在代码中使用此 CTE。 未使用的 CTE 显示为灰色。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlUnusedCte",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MongoJSResolveInspection",
                "shortDescription": {
                  "text": "解析问题"
                },
                "fullDescription": {
                  "text": "报告 MongoDB 和 JavaScript 代码中未解析的引用。 示例： 'db\nuse foo\n  -- a reference to a non-existing collection\ndb.non_existing_collection\ndb['non_existing_collection']\ndb['non_existing_collection'].find().hasNext()' 'non_existing_collection' 集合在数据库中不存在，将被报告。",
                  "markdown": "报告 MongoDB 和 JavaScript 代码中未解析的引用。\n\n示例：\n\n    db\n    use foo\n      -- a reference to a non-existing collection\n    db.non_existing_collection\n    db['non_existing_collection']\n    db['non_existing_collection'].find().hasNext()\n\n`non_existing_collection` 集合在数据库中不存在，将被报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MongoJSResolve",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MongoJS",
                      "index": 130,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MongoJSSideEffectsInspection",
                "shortDescription": {
                  "text": "具有副作用的语句"
                },
                "fullDescription": {
                  "text": "报告在数据源处于只读模式时可能导致副作用的语句。 有关启用只读模式的详细信息，请参阅 IDE 文档中的“为连接启用只读模式”。 禁用只读模式快速修复会关闭相应数据源的只读模式。 示例： 'db.my_collection.insertOne()'",
                  "markdown": "报告在数据源处于只读模式时可能导致副作用的语句。\n\n有关启用只读模式的详细信息，请参阅 [IDE 文档中的\"为连接启用只读模式\"](https://www.jetbrains.com/help/datagrip/configuring-database-connections.html#enable-read-only-mode-for-a-connection)。\n\n**禁用只读模式**快速修复会关闭相应数据源的只读模式。\n\n示例：\n\n\n    db.my_collection.insertOne()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MongoJSSideEffects",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MongoJS",
                      "index": 130,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MongoJSExtSideEffectsInspection",
                "shortDescription": {
                  "text": "具有副作用的语句"
                },
                "fullDescription": {
                  "text": "报告在数据源处于只读模式时可能导致副作用的语句。 该快速修复会关闭相应数据源的只读模式。 示例： 'db.my_collection.insertOne()'",
                  "markdown": "报告在数据源处于只读模式时可能导致副作用的语句。\n\n该快速修复会关闭相应数据源的只读模式。\n\n示例：\n\n\n    db.my_collection.insertOne()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MongoJSSideEffects",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MongoJS",
                      "index": 130,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlUnusedSubqueryItemInspection",
                "shortDescription": {
                  "text": "未使用的子查询项"
                },
                "fullDescription": {
                  "text": "报告外部查询表达式中未引用的列、别名和其他子查询项。 示例（PostgreSQL）： 'CREATE TABLE for_subquery(id INT);\nSELECT a, q FROM (SELECT 1 AS a, 10 AS b, 2 + 3 AS q, id\n      FROM for_subquery) x;' 我们引用子查询中的别名 'a' 和 'q'。 但是 'b' 别名和 'id' 列在外部 SELECT 语句中没有被引用。 因此，'b' 和 'id' 将显示为灰色。",
                  "markdown": "报告外部查询表达式中未引用的列、别名和其他子查询项。\n\n示例（PostgreSQL）：\n\n    CREATE TABLE for_subquery(id INT);\n    SELECT a, q FROM (SELECT 1 AS a, 10 AS b, 2 + 3 AS q, id\n          FROM for_subquery) x;\n\n我们引用子查询中的别名 `a` 和 `q`。 但是 `b` 别名和 `id` 列在外部 SELECT 语句中没有被引用。 因此，`b` 和 `id` 将显示为灰色。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlUnused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlSideEffectsInspection",
                "shortDescription": {
                  "text": "具有副作用的语句"
                },
                "fullDescription": {
                  "text": "报告在只读连接期间可能会修改数据库的语句。 要为连接启用只读模式，请在数据库工具窗口（视图 | 工具窗口 | 数据库）中右键点击数据源，然后选择属性。 在数据源和驱动程序对话框中，点击选项标签页并选中只读复选框。 示例（MySQL）： 'CREATE TABLE foo(a INT);\nINSERT INTO foo VALUES (1);' 由于 'CREATE TABLE' 和'INSERT INTO' 语句会导致数据库修改，因此这些语句将在只读连接模式中高亮显示。",
                  "markdown": "报告在只读连接期间可能会修改数据库的语句。\n\n要为连接启用只读模式，请在**数据库** 工具窗口（**视图 \\| 工具窗口 \\| 数据库** ）中右键点击数据源，然后选择**属性** 。\n在**数据源和驱动程序** 对话框中，点击**选项** 标签页并选中**只读**复选框。\n\n示例（MySQL）：\n\n    CREATE TABLE foo(a INT);\n    INSERT INTO foo VALUES (1);\n\n由于 `CREATE TABLE` 和`INSERT INTO` 语句会导致数据库修改，因此这些语句将在只读连接模式中高亮显示。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlSideEffects",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlJoinWithoutOnInspection",
                "shortDescription": {
                  "text": "'delete' 语句中的 'join' 子句不安全"
                },
                "fullDescription": {
                  "text": "报告可能更改整个数据库的语句的缺失条件检查。 例如，在没有 ON 或 WHERE 的 DELETE 语句中使用 JOIN 子句。 如果不对 JOIN 进行条件检查，DELETE 将删除整个表的内容。 示例（MySQL）： 'CREATE TABLE foo (a INT,b INT,c INT);\nCREATE TABLE bar (a INT,b INT,c INT);\n\nDELETE table1 FROM foo table1  INNER JOIN bar table2;'",
                  "markdown": "报告可能更改整个数据库的语句的缺失条件检查。\n\n例如，在没有 ON 或 WHERE 的 DELETE 语句中使用 JOIN 子句。 如果不对 JOIN 进行条件检查，DELETE 将删除整个表的内容。\n\n示例（MySQL）：\n\n    CREATE TABLE foo (a INT,b INT,c INT);\n    CREATE TABLE bar (a INT,b INT,c INT);\n\n    DELETE table1 FROM foo table1  INNER JOIN bar table2;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlJoinWithoutOn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlDropIndexedColumnInspection",
                "shortDescription": {
                  "text": "索引依赖于列"
                },
                "fullDescription": {
                  "text": "报告尝试从索引表中删除列的情况。 此检查在 Microsoft SQL Server 和 Sybase ASE 中可用。 示例（Microsoft SQL 服务器）： 'CREATE TABLE test_index\n(\ncol  INT NOT NULL,\ncol2 INT NOT NULL,\ncol3 INT NOT NULL UNIQUE,\ncol4 VARCHAR(200)\n);\n\nCREATE UNIQUE INDEX aaaa ON test_index (col, col2);\n\nALTER TABLE test_index\nDROP COLUMN col;' 您不能删除 'col' 列，因为它在索引表中。 要删除该列，您需要先删除 'aaaa' 索引（例如 DROP INDEX aaaa）。",
                  "markdown": "报告尝试从索引表中删除列的情况。 此检查在 Microsoft SQL Server 和 Sybase ASE 中可用。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE TABLE test_index\n    (\n    col  INT NOT NULL,\n    col2 INT NOT NULL,\n    col3 INT NOT NULL UNIQUE,\n    col4 VARCHAR(200)\n    );\n\n    CREATE UNIQUE INDEX aaaa ON test_index (col, col2);\n\n    ALTER TABLE test_index\n    DROP COLUMN col;\n\n您不能删除 `col` 列，因为它在索引表中。 要删除该列，您需要先删除 `aaaa` 索引（例如 DROP INDEX aaaa）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlDropIndexedColumn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlDialectInspection",
                "shortDescription": {
                  "text": "SQL 方言检测"
                },
                "fullDescription": {
                  "text": "报告未将方言分配给 SQL 文件的情况。 例如，当您打开一个新的 SQL 文件而没有为其分配方言时，您会看到一条通知，其中建议了最匹配的方言。 点击 使用<dialect> 链接以使用建议的方言。 或者，点击将方言更改为链接以选择其他方言。",
                  "markdown": "报告未将方言分配给 SQL 文件的情况。\n\n例如，当您打开一个新的 SQL 文件而没有为其分配方言时，您会看到一条通知，其中建议了最匹配的方言。 点击 **使用\\<dialect\\>** 链接以使用建议的方言。 或者，点击**将方言更改为**链接以选择其他方言。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlDialectInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MongoJSExtDeprecationInspection",
                "shortDescription": {
                  "text": "弃用的元素"
                },
                "fullDescription": {
                  "text": "报告 MongoDB 和 JavaScript 代码中已弃用的方法的用法。 快速修复用推荐的替代方法替换了已弃用的方法。 示例： 'db.my_collection.insert()' 在应用快速修复后： 'db.my_collection.insertOne()'",
                  "markdown": "报告 MongoDB 和 JavaScript 代码中已弃用的方法的用法。\n\n快速修复用推荐的替代方法替换了已弃用的方法。\n\n示例：\n\n\n      db.my_collection.insert()\n\n在应用快速修复后：\n\n\n      db.my_collection.insertOne()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MongoJSDeprecation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MongoJS",
                      "index": 130,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MongoJSDeprecationInspection",
                "shortDescription": {
                  "text": "弃用的元素"
                },
                "fullDescription": {
                  "text": "报告 MongoDB 和 JavaScript 代码中已弃用的方法的用法。 快速修复用推荐的替代方法替换了已弃用的方法。 示例： 'db.my_collection.insert()' 在应用快速修复后： 'db.my_collection.insertOne()'",
                  "markdown": "报告 MongoDB 和 JavaScript 代码中已弃用的方法的用法。\n\n快速修复用推荐的替代方法替换了已弃用的方法。\n\n示例：\n\n    db.my_collection.insert()\n\n在应用快速修复后：\n\n    db.my_collection.insertOne()\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MongoJSDeprecation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MongoJS",
                      "index": 130,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlTypeInspection",
                "shortDescription": {
                  "text": "类型兼容性"
                },
                "fullDescription": {
                  "text": "报告与类型相关的错误。",
                  "markdown": "报告与类型相关的错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlUnicodeStringLiteralInspection",
                "shortDescription": {
                  "text": "SQL 中的 Unicode 用法"
                },
                "fullDescription": {
                  "text": "报告使用没有 'N' 前缀的国家字符的字符串文字。 如果没有 N 前缀，字符串将被转换为数据库的默认代码页面。 此默认代码页面可能无法识别某些字符。 有关更多信息，请参阅 docs.microsoft.com 上的“nchar 和 nvarchar”(Transact-SQL) 页面。 示例（Microsoft SQL 服务器）： 'SELECT 'abcde' AS a;\nSELECT N'abcde' AS b;\nSELECT 'абвгд' AS c;\nSELECT N'абвгд' AS d;' 'SELECT 'абвгд' AS c;' 没有 'N' 前缀，''абвгд'' 部分将被高亮显示。",
                  "markdown": "报告使用没有 `N` 前缀的国家字符的字符串文字。\n\n如果没有 N 前缀，字符串将被转换为数据库的默认代码页面。 此默认代码页面可能无法识别某些字符。 有关更多信息，请参阅 [docs.microsoft.com 上的\"nchar 和 nvarchar\"(Transact-SQL)](https://docs.microsoft.com/en-us/sql/t-sql/data-types/nchar-and-nvarchar-transact-sql) 页面。\n\n示例（Microsoft SQL 服务器）：\n\n    SELECT 'abcde' AS a;\n    SELECT N'abcde' AS b;\n    SELECT 'абвгд' AS c;\n    SELECT N'абвгд' AS d;\n\n`SELECT 'абвгд' AS c;` 没有 `N` 前缀，`'абвгд'` 部分将被高亮显示。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlUnicodeStringLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlUnusedVariableInspection",
                "shortDescription": {
                  "text": "未使用的变量"
                },
                "fullDescription": {
                  "text": "报告未使用的实参、变量或形参。 示例（PostgreSQL）： 'CREATE FUNCTION foo(PARAMUSED INT, PARAMUNUSED INT) RETURNS INT AS\n$$\nBEGIN\n    RETURN PARAMUSED;\nEND\n$$ LANGUAGE plpgsql;' 'PARAMUNUSED' 形参未在函数中使用，可能会被删除。",
                  "markdown": "报告未使用的实参、变量或形参。\n\n示例（PostgreSQL）：\n\n    CREATE FUNCTION foo(PARAMUSED INT, PARAMUNUSED INT) RETURNS INT AS\n    $$\n    BEGIN\n        RETURN PARAMUSED;\n    END\n    $$ LANGUAGE plpgsql;\n\n`PARAMUNUSED` 形参未在函数中使用，可能会被删除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlUnused",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PgSelectFromProcedureInspection",
                "shortDescription": {
                  "text": "Postgres: 从过程调用中 select"
                },
                "fullDescription": {
                  "text": "报告从函数执行 SELECT 或执行没有类型别名的 DBLINK（例如 'AS t1 (s VARCHAR)'）的情况。 此要求不适用于标量函数。 示例（PostgreSQL）： 'CREATE FUNCTION produce_a_table() RETURNS RECORD AS $$\nSELECT 1;\n$$ LANGUAGE sql;\nSELECT * FROM produce_a_table() AS s (c1 INT);\nSELECT * FROM produce_a_table() AS s (c1);\nSELECT * FROM DBLINK('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc') AS t1;' 'AS s (c1 INT)' 具有类型别名，而 'AS s (c1)' 和 'AS t1' 没有。 在这种情况下，将高亮显示 'produce_a_table()' 和 'DBLINK()' 的第二次调用。",
                  "markdown": "报告从函数执行 SELECT 或执行没有类型别名的 DBLINK（例如 ` AS t1 (s VARCHAR) `）的情况。\n\n此要求不适用于标量函数。\n\n示例（PostgreSQL）：\n\n    CREATE FUNCTION produce_a_table() RETURNS RECORD AS $$\n    SELECT 1;\n    $$ LANGUAGE sql;\n    SELECT * FROM produce_a_table() AS s (c1 INT);\n    SELECT * FROM produce_a_table() AS s (c1);\n    SELECT * FROM DBLINK('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc') AS t1;\n\n`AS s (c1 INT)` 具有类型别名，而 `AS s (c1)` 和 `AS t1` 没有。\n在这种情况下，将高亮显示 `produce_a_table()` 和 `DBLINK()` 的第二次调用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PgSelectFromProcedure",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PostgreSQL",
                      "index": 146,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MsBuiltinInspection",
                "shortDescription": {
                  "text": "内置函数"
                },
                "fullDescription": {
                  "text": "报告 ISNULL 函数中字符串实参的截断。 ISNULL 语法是 'ISNULL(check_expression, replacement_value)'。 根据 docs.microsoft.com 上的 ISNULL，如果 'replacement_value' 比 'check_expression' 长，'replacement_value' 将被截断。 示例（Microsoft SQL 服务器）： 'DECLARE @name1 VARCHAR(2) = NULL;\nDECLARE @name2 VARCHAR(10) = 'Example';\nDECLARE @name3 VARCHAR(2) = 'Hi';\n\n  -- `@name2` 是 VARCHAR(10) 并且将被截断\nSELECT ISNULL(@name1, @name2);\n\n  -- `@name3` 是 VARCHAR(2)（作为 `@name1`）并且不会被截断\nSELECT ISNULL(@name1, @name3);'",
                  "markdown": "报告 ISNULL 函数中字符串实参的截断。\n\nISNULL 语法是 `ISNULL(check_expression, replacement_value)`。\n\n根据 [docs.microsoft.com 上的 ISNULL](https://docs.microsoft.com/en-us/sql/t-sql/functions/isnull-transact-sql)，如果 `replacement_value` 比 `check_expression` 长，`replacement_value` 将被截断。\n\n示例（Microsoft SQL 服务器）：\n\n    DECLARE @name1 VARCHAR(2) = NULL;\n    DECLARE @name2 VARCHAR(10) = 'Example';\n    DECLARE @name3 VARCHAR(2) = 'Hi';\n\n      -- `@name2` 是 VARCHAR(10) 并且将被截断\n    SELECT ISNULL(@name1, @name2);\n\n      -- `@name3` 是 VARCHAR(2)（作为 `@name1`）并且不会被截断\n    SELECT ISNULL(@name1, @name3);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MssqlBuiltin",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL Server",
                      "index": 147,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlMultipleLimitClausesInspection",
                "shortDescription": {
                  "text": "查询中的多个行限制/偏移子句"
                },
                "fullDescription": {
                  "text": "报告单个查询中多个行限制子句的使用情况。 示例（Microsoft SQL 服务器）： 'create table foo(a int);\nselect top 1 * from foo order by a offset 10 rows fetch next 20 rows only;' SELECT TOP 子句用于指定必须只返回 1 条记录。 FETCH 子句指定在处理完 OFFSET 子句后要返回的行数。 但是因为我们已经有了 SELECT TOP 限制子句，所以 FETCH 子句可能是冗余的。",
                  "markdown": "报告单个查询中多个行限制子句的使用情况。\n\n示例（Microsoft SQL 服务器）：\n\n    create table foo(a int);\n    select top 1 * from foo order by a offset 10 rows fetch next 20 rows only;\n\nSELECT TOP 子句用于指定必须只返回 1 条记录。 FETCH 子句指定在处理完 OFFSET 子句后要返回的行数。 但是因为我们已经有了 SELECT TOP 限制子句，所以 FETCH 子句可能是冗余的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlMultipleLimitClauses",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlStorageInspection",
                "shortDescription": {
                  "text": "SQL 源修改检测"
                },
                "fullDescription": {
                  "text": "报告数据库对象的源代码已更改的情况。 执行数据库或对象内省时会触发检查。 当您打开对象的源代码、运行语句和执行代码重构时，就会运行内省。 此外，您可以通过右键点击对象并选择刷新来运行内省。 检查包括以下几种情况： 数据库中的对象源代码已更改，但编辑器中的代码未更新。 适用于 PostgreSQL、Microsoft SQL Server、Oracle 和 Sybase ASE。 您更改了对象源代码，内省了数据库，但源代码已被其他人更改。 IDE 中的数据库内省器已更新，您需要下载先前内省器版本中缺少的新对象属性。",
                  "markdown": "报告数据库对象的源代码已更改的情况。\n\n执行数据库或对象内省时会触发检查。 当您打开对象的源代码、运行语句和执行代码重构时，就会运行内省。\n此外，您可以通过右键点击对象并选择**刷新**来运行内省。\n\n检查包括以下几种情况：\n\n* 数据库中的对象源代码已更改，但编辑器中的代码未更新。 适用于 PostgreSQL、Microsoft SQL Server、Oracle 和 Sybase ASE。\n* 您更改了对象源代码，内省了数据库，但源代码已被其他人更改。\n* IDE 中的数据库内省器已更新，您需要下载先前内省器版本中缺少的新对象属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlStorageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlSignatureInspection",
                "shortDescription": {
                  "text": "函数签名"
                },
                "fullDescription": {
                  "text": "报告内置函数的签名问题。 检查将报告错误数量的实参、无效的关键字、错误的数据类型和其他问题。 示例（MySQL）： 'CREATE TABLE foo (a INT, b INT, c INT)\n\nSELECT IFNULL() FROM foo; -- 错误\nSELECT IFNULL(a) FROM foo; -- 错误\nSELECT IFNULL(a, b) FROM foo; -- 正确\nSELECT IFNULL(a, b, c) FROM foo; -- 错误' 在 MySQL 中，'IFNULL()' 函数严格接受两个实参。 因此，只有 'SELECT IFNULL(a, b) FROM foo;' 查询是正确的。",
                  "markdown": "报告内置函数的签名问题。\n\n检查将报告错误数量的实参、无效的关键字、错误的数据类型和其他问题。\n\n示例（MySQL）：\n\n    CREATE TABLE foo (a INT, b INT, c INT)\n\n    SELECT IFNULL() FROM foo; -- 错误\n    SELECT IFNULL(a) FROM foo; -- 错误\n    SELECT IFNULL(a, b) FROM foo; -- 正确\n    SELECT IFNULL(a, b, c) FROM foo; -- 错误\n\n在 MySQL 中，`IFNULL()` 函数严格接受两个实参。 因此，只有 `SELECT IFNULL(a, b) FROM foo;` 查询是正确的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlRedundantOrderingDirectionInspection",
                "shortDescription": {
                  "text": "冗余排序方向"
                },
                "fullDescription": {
                  "text": "在 ORDER BY 子句中报告冗余的排序方向，如 ASC 和 DESC。 示例（MySQL）： 'CREATE TABLE foo(a INT, b INT, c INT);\nSELECT * FROM foo ORDER BY a ASC, b DESC, c ASC;' ORDER BY 关键字默认按升序对记录进行排序。 因此，'a' 和 'c' 列的 'ASC' 关键字是冗余的。",
                  "markdown": "在 ORDER BY 子句中报告冗余的排序方向，如 ASC 和 DESC。\n\n示例（MySQL）：\n\n    CREATE TABLE foo(a INT, b INT, c INT);\n    SELECT * FROM foo ORDER BY a ASC, b DESC, c ASC;\n\nORDER BY 关键字默认按升序对记录进行排序。 因此，`a` 和 `c` 列的 `ASC` 关键字是冗余的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlRedundantOrderingDirection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OraOverloadInspection",
                "shortDescription": {
                  "text": "重载错误"
                },
                "fullDescription": {
                  "text": "报告 Oracle 中子程序重载的无效情况。 示例（Oracle）： 'DECLARE\n    SUBTYPE fff IS BINARY_INTEGER;\n    SUBTYPE ggg IS NATURAL;\n    PROCEDURE foo (a IN ggg) IS BEGIN NULL; END;\n    PROCEDURE foo (a IN fff) IS BEGIN NULL; END;\nBEGIN\n    NULL;\nEND;' 您不能重载形参仅在子类型方面不同的子程序。 例如，您不能重载一个接受 BINARY INTEGER 形参而另一个接受 NATURAL 形参的过程。 有关过程重载限制的更多信息，请参阅 docs.oracle.com 上的 Restrictions on Overloading。",
                  "markdown": "报告 Oracle 中子程序重载的无效情况。\n\n示例（Oracle）：\n\n    DECLARE\n        SUBTYPE fff IS BINARY_INTEGER;\n        SUBTYPE ggg IS NATURAL;\n        PROCEDURE foo (a IN ggg) IS BEGIN NULL; END;\n        PROCEDURE foo (a IN fff) IS BEGIN NULL; END;\n    BEGIN\n        NULL;\n    END;\n\n您不能重载形参仅在子类型方面不同的子程序。 例如，您不能重载一个接受 BINARY INTEGER 形参而另一个接受 NATURAL 形参的过程。 有关过程重载限制的更多信息，请参阅 [docs.oracle.com 上的 Restrictions on Overloading](https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/subprograms.htm)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlOverload",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Oracle",
                      "index": 123,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlAmbiguousColumnInspection",
                "shortDescription": {
                  "text": "不明确的引用"
                },
                "fullDescription": {
                  "text": "报告名称相同但属于不同表的列。 示例（MySQL）： 'CREATE TABLE foo(id INT PRIMARY KEY);\nCREATE TABLE bar(id INT PRIMARY KEY);\n\nSELECT foo.id, bar.id FROM foo, bar WHERE id > 0;' 'id' 列出现在 'foo' 和 'bar' 表中。 您需要限定列名以使查询正确。 'SELECT foo.id, bar.id FROM foo, bar WHERE foo.id > 0;'",
                  "markdown": "报告名称相同但属于不同表的列。\n\n示例（MySQL）：\n\n    CREATE TABLE foo(id INT PRIMARY KEY);\n    CREATE TABLE bar(id INT PRIMARY KEY);\n\n    SELECT foo.id, bar.id FROM foo, bar WHERE id > 0;\n\n`id` 列出现在 `foo` 和 `bar` 表中。 您需要限定列名以使查询正确。\n\n    SELECT foo.id, bar.id FROM foo, bar WHERE foo.id > 0;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlAmbiguousColumn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlNullComparisonInspection",
                "shortDescription": {
                  "text": "null 比较"
                },
                "fullDescription": {
                  "text": "报告与可以替换为 IS NULL 或 IS NOT NULL 运算符的 NULL 的比较。 示例（Microsoft SQL 服务器）： 'CREATE TABLE foo ( id int );\n\nSELECT * FROM foo WHERE NULL = NULL;\nSELECT * FROM foo WHERE NULL != NULL;' 'NULL = NULL' 可以替换为 'IS NULL'，'NULL != NULL' 比较可以替换为 'IS NOT NULL'。 要进行此替换，您可以使用使用 IS NULL 运算符或使用 IS NOT NULL 运算符快速修复。 'SELECT * FROM foo WHERE NULL IS NULL;\nSELECT * FROM foo WHERE NULL IS NOT NULL;'",
                  "markdown": "报告与可以替换为 IS NULL 或 IS NOT NULL 运算符的 NULL 的比较。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE TABLE foo ( id int );\n\n    SELECT * FROM foo WHERE NULL = NULL;\n    SELECT * FROM foo WHERE NULL != NULL;\n\n`NULL = NULL` 可以替换为 `IS NULL`，`NULL != NULL` 比较可以替换为 `IS NOT NULL`。 要进行此替换，您可以使用**使用 IS NULL 运算符** 或**使用 IS NOT NULL 运算符**快速修复。\n\n    SELECT * FROM foo WHERE NULL IS NULL;\n    SELECT * FROM foo WHERE NULL IS NOT NULL;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlNullComparison",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MysqlSpaceAfterFunctionNameInspection",
                "shortDescription": {
                  "text": "函数名称和左圆括号之间的空格"
                },
                "fullDescription": {
                  "text": "报告函数调用中函数名称和左圆括号之间的任何空格，这在默认情况下不受支持。 示例（MySQL）： 'SELECT MAX (qty) FROM orders;'",
                  "markdown": "报告函数调用中函数名称和左圆括号之间的任何空格，这在默认情况下不受支持。\n\n示例（MySQL）：\n\n    SELECT MAX (qty) FROM orders;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MysqlSpaceAfterFunctionName",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MySQL",
                      "index": 15,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlAutoIncrementDuplicateInspection",
                "shortDescription": {
                  "text": "自动增量重复"
                },
                "fullDescription": {
                  "text": "报告包含两个具有自动增量的列的表。 在 MySQL、Microsoft SQL Server 和 Db2 方言中，一个表只能有一个带有自动增量选项的字段，并且此字段必须是键。 示例（MySQL）： 'CREATE TABLE my_table\n(\n    id INT AUTO_INCREMENT,\n    c2 INT AUTO_INCREMENT,\n);' 'c2' 的 AUTO_INCREMENT 约束将被高亮显示，因为 'c1' 已经具有此约束。 要修正警告，您可以将 'id' 设为主键并删除 'c2' 的 AUTO_INCREMENT。 'CREATE TABLE my_table\n(\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    c2 INT,\n);'",
                  "markdown": "报告包含两个具有自动增量的列的表。 在 MySQL、Microsoft SQL Server 和 Db2 方言中，一个表只能有一个带有自动增量选项的字段，并且此字段必须是键。\n\n示例（MySQL）：\n\n    CREATE TABLE my_table\n    (\n        id INT AUTO_INCREMENT,\n        c2 INT AUTO_INCREMENT,\n    );\n\n`c2` 的 AUTO_INCREMENT 约束将被高亮显示，因为 `c1` 已经具有此约束。 要修正警告，您可以将 `id` 设为主键并删除 `c2` 的 AUTO_INCREMENT。\n\n    CREATE TABLE my_table\n    (\n        id INT AUTO_INCREMENT PRIMARY KEY,\n        c2 INT,\n    );\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlAutoIncrementDuplicate",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlStringLengthExceededInspection",
                "shortDescription": {
                  "text": "隐式字符串截断"
                },
                "fullDescription": {
                  "text": "报告超过定义的字符长度的变量。 示例（Microsoft SQL 服务器）： 'CREATE PROCEDURE test() AS\nBEGIN\nDECLARE myVarOk VARCHAR(5) = 'abcde';\nDECLARE myVarExceeded VARCHAR(5) = 'abcde12345';\n\nSET myVarOk = 'xyz';\nSET myVarExceeded = '123456789';\nEND;' 'myVarExceeded' 变量被定义为 'VARCHAR(5)' 但两个分配的值（''abcde12345'' 和 ''123456789'') 都超出了此限制。 您可以截断指定的值或增加定义的长度。 要增加长度，请使用增加类型长度 快速修复。 在应用快速修复后： 'CREATE PROCEDURE test() AS\nBEGIN\nDECLARE myVarOk VARCHAR(5) = 'abcde';\nDECLARE myVarExceeded VARCHAR(10) = 'abcde12345';\n\nSET myVarOk = 'xyz';\nSET myVarExceeded = '123456789';\nEND;'",
                  "markdown": "报告超过定义的字符长度的变量。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE PROCEDURE test() AS\n    BEGIN\n    DECLARE myVarOk VARCHAR(5) = 'abcde';\n    DECLARE myVarExceeded VARCHAR(5) = 'abcde12345';\n\n    SET myVarOk = 'xyz';\n    SET myVarExceeded = '123456789';\n    END;\n\n`myVarExceeded` 变量被定义为 `VARCHAR(5)` 但两个分配的值（`'abcde12345'` 和 `'123456789'`) 都超出了此限制。 您可以截断指定的值或增加定义的长度。\n要增加长度，请使用**增加类型长度** 快速修复。\n\n在应用快速修复后：\n\n    CREATE PROCEDURE test() AS\n    BEGIN\n    DECLARE myVarOk VARCHAR(5) = 'abcde';\n    DECLARE myVarExceeded VARCHAR(10) = 'abcde12345';\n\n    SET myVarOk = 'xyz';\n    SET myVarExceeded = '123456789';\n    END;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlStringLengthExceeded",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlInsertValuesInspection",
                "shortDescription": {
                  "text": "VALUE 子句基数"
                },
                "fullDescription": {
                  "text": "报告 VALUES 中的形参数目与目标表中的列数不匹配的情况。 示例（MySQL）： 'CREATE TABLE foo(a INT, b INT, c INT);\n\nINSERT INTO foo VALUES (1,2,3,4)' 'foo' 表有三列，但在 INSERT INTO 语句中我们传递了四列。",
                  "markdown": "报告 VALUES 中的形参数目与目标表中的列数不匹配的情况。\n\n示例（MySQL）：\n\n    CREATE TABLE foo(a INT, b INT, c INT);\n\n    INSERT INTO foo VALUES (1,2,3,4)\n\n`foo` 表有三列，但在 INSERT INTO 语句中我们传递了四列。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlInsertValues",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlRedundantElseNullInspection",
                "shortDescription": {
                  "text": "冗余 ELSE NULL 子句"
                },
                "fullDescription": {
                  "text": "报告冗余的 ELSE NULL 子句。 示例（MySQL）： 'SELECT CASE WHEN 2 > 1 THEN 'OK' ELSE NULL END AS alias FROM foo;' 'ELSE NULL' 部分永远不会被执行，可以省略。",
                  "markdown": "报告冗余的 ELSE NULL 子句。\n\n示例（MySQL）：\n\n    SELECT CASE WHEN 2 > 1 THEN 'OK' ELSE NULL END AS alias FROM foo;\n\n`ELSE NULL` 部分永远不会被执行，可以省略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlRedundantElseNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlCallNotationInspection",
                "shortDescription": {
                  "text": "使用命名实参和位置实参"
                },
                "fullDescription": {
                  "text": "报告位置实参在命名实参之后的调用。 适用于 PostgreSQL、Oracle 和 Db2。 示例（PostgreSQL 中）： 'CREATE FUNCTION foo(a int, b int, c int) RETURNS int\n    LANGUAGE plpgsql AS\n$$\nBEGIN\n    RETURN a + b + c;\nEND\n$$;\nSELECT foo(a => 1, b => 2, c => 3);\n  -- `3` 在命名实参之后\nSELECT foo(1, b => 2, 3);\n  -- `1` 和 `3` 在命名实参之后\nSELECT foo(b => 2, 1, 3);'",
                  "markdown": "报告位置实参在命名实参之后的调用。 适用于 PostgreSQL、Oracle 和 Db2。\n\n示例（PostgreSQL 中）：\n\n    CREATE FUNCTION foo(a int, b int, c int) RETURNS int\n        LANGUAGE plpgsql AS\n    $$\n    BEGIN\n        RETURN a + b + c;\n    END\n    $$;\n    SELECT foo(a => 1, b => 2, c => 3);\n      -- `3` 在命名实参之后\n    SELECT foo(1, b => 2, 3);\n      -- `1` 和 `3` 在命名实参之后\n    SELECT foo(b => 2, 1, 3);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "SqlCallNotation",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MysqlParsingInspection",
                "shortDescription": {
                  "text": "8.0 以前的版本中不受支持的语法"
                },
                "fullDescription": {
                  "text": "报告查询中 UNION 的无效用法。 该检查适用于早于 8.0 的 MySQL 版本。 示例（MySQL）： 'SELECT * FROM (SELECT 1 UNION (SELECT 1 UNION SELECT 2)) a;'",
                  "markdown": "报告查询中 UNION 的无效用法。\n\n该检查适用于早于 8.0 的 MySQL 版本。\n\n示例（MySQL）：\n\n\n    SELECT * FROM (SELECT 1 UNION (SELECT 1 UNION SELECT 2)) a;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MysqlParsing",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MySQL",
                      "index": 15,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlShadowingAliasInspection",
                "shortDescription": {
                  "text": "列被别名隐藏"
                },
                "fullDescription": {
                  "text": "报告 SELECT 中别名名称与 FROM 子句中的列名称匹配。 示例（MySQL）： 'CREATE TABLE foo (a INT, b INT, c INT);\nSELECT a b, c FROM foo;' 'a' 列使用 'b' 别名，但 'b' 名称也被 'foo' 表中的列使用。",
                  "markdown": "报告 SELECT 中别名名称与 FROM 子句中的列名称匹配。\n\n示例（MySQL）：\n\n    CREATE TABLE foo (a INT, b INT, c INT);\n    SELECT a b, c FROM foo;\n\n`a` 列使用 `b` 别名，但 `b` 名称也被 `foo` 表中的列使用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlShadowingAlias",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlUnreachableCodeInspection",
                "shortDescription": {
                  "text": "不可到达的代码"
                },
                "fullDescription": {
                  "text": "报告 SQL 例程中不可到达的语句。 示例（Microsoft SQL 服务器）： 'CREATE FUNCTION foo() RETURNS INT AS\nBEGIN\n    THROW;\n    RETURN 1;\nEND;' 在 Microsoft SQL Server 中，'THROW' 语句会抛出异常并将执行转移到 TRY...CATCH 结构的 CATCH 块。 因此，'RETURN 1;' 部分将永远不会被执行。",
                  "markdown": "报告 SQL 例程中不可到达的语句。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE FUNCTION foo() RETURNS INT AS\n    BEGIN\n        THROW;\n        RETURN 1;\n    END;\n\n在 Microsoft SQL Server 中，`THROW` 语句会抛出异常并将执行转移到 TRY...CATCH 结构的 CATCH 块。 因此，`RETURN 1;` 部分将永远不会被执行。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlUnreachable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlResolveInspection",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告未解析的 SQL 引用。 示例（MySQL）： 'CREATE TABLE users(id INT, name VARCHAR(40));\nCREATE TABLE admins(id INT, col1 INT);\n\nSELECT users.id, admins.id FROM admins WHERE admins.id > 1;' 'users.id' 列未解析，因为 FROM 子句中缺少 'users' 表。",
                  "markdown": "报告未解析的 SQL 引用。\n\n示例（MySQL）：\n\n    CREATE TABLE users(id INT, name VARCHAR(40));\n    CREATE TABLE admins(id INT, col1 INT);\n\n    SELECT users.id, admins.id FROM admins WHERE admins.id > 1;\n\n`users.id` 列未解析，因为 FROM 子句中缺少 `users` 表。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "SqlResolve",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlCurrentSchemaInspection",
                "shortDescription": {
                  "text": "已内省当前控制台架构"
                },
                "fullDescription": {
                  "text": "报告当前会话中未自省的架构和数据库。 例如，当您尝试在未内省的架构中创建表时，可能会出现此警告。 内省是一种检查数据源的方法。 执行内省时，将从数据库中检索结构信息以检测各种对象及其特性。例如，可能是表、列、函数和其他元素。",
                  "markdown": "报告当前会话中未自省的架构和数据库。\n\n例如，当您尝试在未内省的架构中创建表时，可能会出现此警告。\n\n内省是一种检查数据源的方法。 执行内省时，将从数据库中检索结构信息以检测各种对象及其特性。例如，可能是表、列、函数和其他元素。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlCurrentSchemaInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlRedundantLimitInspection",
                "shortDescription": {
                  "text": "查询中的冗余行限制"
                },
                "fullDescription": {
                  "text": "报告查询中限制行的冗余子句，例如 FETCH 和 LIMIT。 示例（PostgreSQL）： 'CREATE TABLE foo(a INT);\n\nSELECT * FROM foo WHERE EXISTS(SELECT * FROM foo LIMIT 2);\nSELECT * FROM foo WHERE EXISTS(SELECT * FROM foo FETCH FIRST 2 ROWS ONLY);' 要修复警告，您可以将 OFFSET 添加到限制子句。 如果缺少 OFFSET，则 LIMIT 是多余的，因为 LIMIT 的用法不会影响 EXISTS 的运算结果。 在 OFFSET 的情况下，我们跳过前 'N' 行，这将影响输出。 'SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW LIMIT 2);\nSELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW FETCH FIRST 2 ROWS ONLY);'",
                  "markdown": "报告查询中限制行的冗余子句，例如 FETCH 和 LIMIT。\n\n示例（PostgreSQL）：\n\n    CREATE TABLE foo(a INT);\n\n    SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo LIMIT 2);\n    SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo FETCH FIRST 2 ROWS ONLY);\n\n要修复警告，您可以将 OFFSET 添加到限制子句。 如果缺少 OFFSET，则 LIMIT 是多余的，因为 LIMIT 的用法不会影响 EXISTS 的运算结果。 在 OFFSET 的情况下，我们跳过前 `N` 行，这将影响输出。\n\n    SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW LIMIT 2);\n    SELECT * FROM foo WHERE EXISTS(SELECT * FROM foo OFFSET 1 ROW FETCH FIRST 2 ROWS ONLY);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlRedundantLimit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlInsertNullIntoNotNullInspection",
                "shortDescription": {
                  "text": "将 NULL 插入 NOT NULL 列"
                },
                "fullDescription": {
                  "text": "报告将 NULL 值插入仅接受 NOT NULL 值的列的情况。 示例（Microsoft SQL 服务器）： 'CREATE TABLE br2 (\nid INT NOT NULL,\ncol1 NVARCHAR (20) NOT NULL,\ncol2 NVARCHAR (20) NOT NULL,\n);\n--\nINSERT INTO br2 (id, col1, col2)\nVALUES (1, NULL, NULL);' 您不能在 'col1' 和 'col2' 中插入 NULL 值，因为它们被定义为 NOT NULL。 如果按原样运行脚本，则会收到错误消息。 要修复此代码，请将 VALUES 部分中的 NULL 替换为值（例如，'42' 和 ''bird''）。 INSERT INTO br2 (id, col1, col2)\nVALUES (1, 42, 'bird');",
                  "markdown": "报告将 NULL 值插入仅接受 NOT NULL 值的列的情况。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE TABLE br2 (\n    id INT NOT NULL,\n    col1 NVARCHAR (20) NOT NULL,\n    col2 NVARCHAR (20) NOT NULL,\n    );\n    --\n    INSERT INTO br2 (id, col1, col2)\n    VALUES (1, NULL, NULL);\n\n您不能在 `col1` 和 `col2` 中插入 NULL 值，因为它们被定义为 NOT NULL。 如果按原样运行脚本，则会收到错误消息。 要修复此代码，请将 VALUES 部分中的 NULL 替换为值（例如，`42` 和 `'bird'`）。\n\n```\nINSERT INTO br2 (id, col1, col2)\nVALUES (1, 42, 'bird');\n```"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlInsertNullIntoNotNull",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlDerivedTableAliasInspection",
                "shortDescription": {
                  "text": "每个派生表都应具有别名"
                },
                "fullDescription": {
                  "text": "报告没有别名的派生表。 示例（MySQL）： 'CREATE TABLE table1 (id INT, name VARCHAR(20), cats FLOAT);\nCREATE TABLE table2 (id INT, age INTEGER);\n\nSELECT id AS ID, name, cats, age\nFROM (SELECT table1.id, name, cats, age\nFROM table1\nJOIN table2 ON table1.id = table2.id);' 根据 dev.mysql.com 上的 Derived Tables，别名是强制的。 您可以使用引入别名快速修复来添加别名。 在应用快速修复后： 'SELECT id AS ID, name, cats, age\nFROM (SELECT table1.id, name, cats, age\nFROM table1\nJOIN table2 ON table1.id = table2.id);'",
                  "markdown": "报告没有别名的派生表。\n\n示例（MySQL）：\n\n    CREATE TABLE table1 (id INT, name VARCHAR(20), cats FLOAT);\n    CREATE TABLE table2 (id INT, age INTEGER);\n\n    SELECT id AS ID, name, cats, age\n    FROM (SELECT table1.id, name, cats, age\n    FROM table1\n    JOIN table2 ON table1.id = table2.id);\n\n根据 [dev.mysql.com 上的 Derived Tables](https://dev.mysql.com/doc/refman/8.0/en/derived-tables.html)，别名是强制的。 您可以使用**引入别名**快速修复来添加别名。\n\n在应用快速修复后：\n\n    SELECT id AS ID, name, cats, age\n    FROM (SELECT table1.id, name, cats, age\n    FROM table1\n    JOIN table2 ON table1.id = table2.id);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlDerivedTableAlias",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlTriggerTransitionInspection",
                "shortDescription": {
                  "text": "触发器中的可疑代码"
                },
                "fullDescription": {
                  "text": "报告触发器中转换表变量的不正确用法。 示例 (HSQLDB)： 'CREATE TABLE foo(a INT);\n\nCREATE TRIGGER trg\n AFTER DELETE ON foo\nBEGIN\n   SELECT * FROM NEW;\nEND;\n\nCREATE TRIGGER trig AFTER INSERT ON foo\n   REFERENCING OLD ROW AS newrow\n   FOR EACH ROW WHEN (a > 1)\n   INSERT INTO foo VALUES (1)' 在 HSQLDB 中，DELETE 触发器只能用于 OLD 状态，而 INSERT 触发器只能用于 NEW 状态。 因此，在前面的示例中，'SELECT * FROM NEW;' 中的 NEW 和 'REFERENCING OLD ROW AS newrow' 中的 OLD 将被高亮显示。",
                  "markdown": "报告触发器中转换表变量的不正确用法。\n\n示例 (HSQLDB)：\n\n    CREATE TABLE foo(a INT);\n\n    CREATE TRIGGER trg\n     AFTER DELETE ON foo\n    BEGIN\n       SELECT * FROM NEW;\n    END;\n\n    CREATE TRIGGER trig AFTER INSERT ON foo\n       REFERENCING OLD ROW AS newrow\n       FOR EACH ROW WHEN (a > 1)\n       INSERT INTO foo VALUES (1)\n\n在 HSQLDB 中，DELETE 触发器只能用于 OLD 状态，而 INSERT 触发器只能用于 NEW 状态。 因此，在前面的示例中，`SELECT * FROM NEW;` 中的 NEW 和 `REFERENCING OLD ROW AS newrow` 中的 OLD 将被高亮显示。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlTriggerTransition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlNamedArgumentsInspection",
                "shortDescription": {
                  "text": "应使用命名实参"
                },
                "fullDescription": {
                  "text": "报告在例程调用中不带名称使用的实参。 默认情况下，此检查处于禁用状态。 有关命名形参和未命名形参之间差异的详细信息，请参阅 docs.microsoft.com 上的 Binding Parameters by Name (Named Parameters) 。 示例（Microsoft SQL 服务器）： 'CREATE FUNCTION foo(n INT, m INT) RETURNS INT AS\nBEGIN\n    RETURN n + m;\nEND;\n\nCREATE PROCEDURE test AS\nBEGIN\n    foo n = 1, m = 2;\n\n--- 以下调用缺少形参名称，会被高亮显示\n    foo 1, 2;\nEND;' 'foo 1, 2;' 调用中的形参 '1, 2' 突出显示，因为它们缺少名称。",
                  "markdown": "报告在例程调用中不带名称使用的实参。 默认情况下，此检查处于禁用状态。\n\n有关命名形参和未命名形参之间差异的详细信息，请参阅 [docs.microsoft.com 上的 Binding Parameters by Name (Named Parameters)](https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/binding-parameters-by-name-named-parameters)。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE FUNCTION foo(n INT, m INT) RETURNS INT AS\n    BEGIN\n        RETURN n + m;\n    END;\n\n    CREATE PROCEDURE test AS\n    BEGIN\n        foo n = 1, m = 2;\n\n    --- 以下调用缺少形参名称，会被高亮显示\n        foo 1, 2;\n    END;\n\n`foo 1, 2;` 调用中的形参 `1, 2` 突出显示，因为它们缺少名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlNamedArguments",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlCaseVsCoalesceInspection",
                "shortDescription": {
                  "text": "使用 CASE 代替 COALESCE 函数，反之亦然"
                },
                "fullDescription": {
                  "text": "报告 CASE 和 COALESCE 调用可以互换的情况。 此检查具有以下意图操作：替换为 'COALESCE' 调用和相反的 替换为 CASE 表达式。 示例（MySQL）： 'SELECT\n  -- this CASE may be replaced by COALESCE\n\tCASE\n\t\tWHEN C1 IS NOT NULL THEN C1\n\t\tELSE 0\n\t\tEND\nFROM dual;' 在该示例中，CASE 语句可以替换为 'SELECT COALESCE(C1, 0)'，这会产生相同的结果。 如果您更喜欢使用 CASE 表达式，请在检查页面上选择 CASE 表达式优先于 COALESCE 函数选项。",
                  "markdown": "报告 CASE 和 COALESCE 调用可以互换的情况。 此检查具有以下意图操作：**替换为 'COALESCE' 调用** 和相反的 **替换为 CASE 表达式** 。\n\n示例（MySQL）：\n\n    SELECT\n      -- this CASE may be replaced by COALESCE\n    \tCASE\n    \t\tWHEN C1 IS NOT NULL THEN C1\n    \t\tELSE 0\n    \t\tEND\n    FROM dual;\n\n在该示例中，CASE 语句可以替换为 `SELECT COALESCE(C1, 0)`，这会产生相同的结果。\n\n如果您更喜欢使用 CASE 表达式，请在检查页面上选择 **CASE 表达式优先于 COALESCE 函数**选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlCaseVsCoalesce",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlTransactionStatementInTriggerInspection",
                "shortDescription": {
                  "text": "在触发器中使用事务管理语句"
                },
                "fullDescription": {
                  "text": "报告触发器主体中事务管理语句（如 COMMIT 或 ROLLBACK）的用法。 在触发器主体中使用 COMMIT 或 ROLLBACK 语句时，触发器将不会编译。 发生错误是因为触发器在事务中间触发。 当触发器启动时，当前事务仍未完成。 因为 COMMIT 会终止事务，这两个语句（COMMIT 和 ROLLBACK）都会导致异常。 在触发器中执行的更改应该由启动触发器的所属事务提交（或回滚）。 示例（Oracle）： 'CREATE TABLE employee_audit\n(\n    id          INT  NOT NULL,\n    update_date DATE NOT NULL,\n    old_name    VARCHAR2(100),\n    new_name    VARCHAR2(100)\n);\n\nCREATE TABLE employees\n(\n    id   INT           NOT NULL,\n    name VARCHAR2(100) NOT NULL\n);\n\nCREATE OR REPLACE TRIGGER trig_commit\n    AFTER UPDATE OF name\n    ON employees\n    FOR EACH ROW\nBEGIN\n    INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);\n    COMMIT;\nEND;\n\nCREATE OR REPLACE TRIGGER trig_rollback\n    AFTER UPDATE OF name\n    ON employees\n    FOR EACH ROW\nBEGIN\n    INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);\n    ROLLBACK;\nEND;'",
                  "markdown": "报告触发器主体中事务管理语句（如 COMMIT 或 ROLLBACK）的用法。\n\n在触发器主体中使用 COMMIT 或 ROLLBACK 语句时，触发器将不会编译。\n发生错误是因为触发器在事务中间触发。 当触发器启动时，当前事务仍未完成。 因为 COMMIT 会终止事务，这两个语句（COMMIT 和 ROLLBACK）都会导致异常。\n在触发器中执行的更改应该由启动触发器的所属事务提交（或回滚）。\n\n示例（Oracle）：\n\n    CREATE TABLE employee_audit\n    (\n        id          INT  NOT NULL,\n        update_date DATE NOT NULL,\n        old_name    VARCHAR2(100),\n        new_name    VARCHAR2(100)\n    );\n\n    CREATE TABLE employees\n    (\n        id   INT           NOT NULL,\n        name VARCHAR2(100) NOT NULL\n    );\n\n    CREATE OR REPLACE TRIGGER trig_commit\n        AFTER UPDATE OF name\n        ON employees\n        FOR EACH ROW\n    BEGIN\n        INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);\n        COMMIT;\n    END;\n\n    CREATE OR REPLACE TRIGGER trig_rollback\n        AFTER UPDATE OF name\n        ON employees\n        FOR EACH ROW\n    BEGIN\n        INSERT INTO employee_audit VALUES (:old.id, SYSDATE, :old.name, :new.name);\n        ROLLBACK;\n    END;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlTransactionStatementInTrigger",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlRedundantCodeInCoalesceInspection",
                "shortDescription": {
                  "text": "COALESCE 调用中的冗余代码"
                },
                "fullDescription": {
                  "text": "报告除 COALESCE 函数中第一个不评估为 NULL 的表达式之外的所有实参。 示例（MySQL）： 'SELECT COALESCE(NULL, NULL, NULL, 42, NULL, 'string') as a;' 第一个 NOT NULL 实参是 '42'，所有其他实参将显示为灰色。",
                  "markdown": "报告除 COALESCE 函数中第一个不评估为 NULL 的表达式之外的所有实参。\n\n示例（MySQL）：\n\n    SELECT COALESCE(NULL, NULL, NULL, 42, NULL, 'string') as a;\n\n第一个 NOT NULL 实参是 `42`，所有其他实参将显示为灰色。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlRedundantCodeInCoalesce",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlAggregatesInspection",
                "shortDescription": {
                  "text": "与聚合相关的问题"
                },
                "fullDescription": {
                  "text": "报告 SQL 聚合函数的无效用法。 即以下情况： 在 HAVING 和 ORDER BY 子句中使用但在 GROUP BY 子句中遗漏的列。 'CREATE TABLE foo(id INT PRIMARY KEY, a INT, b INT);\nSELECT a, MAX(b) FROM foo GROUP BY a HAVING b > 0;\nSELECT * FROM foo GROUP BY a ORDER BY b;' 当按主键进行分组时，此规则不适用。 'SELECT * FROM foo GROUP BY id ORDER BY b;' 在错误的上下文中聚合函数。 通常，您可以在以下上下文中使用聚合函数： SELECT 中的表达式列表； 在 HAVING 和 ORDER BY 部分； 和其他特定于方言的案例。 以下查询将显示错误。 'SELECT a FROM foo WHERE MAX(b) > 0;\nSELECT a FROM foo GROUP BY MAX(a);' 聚合函数的嵌套调用。 'SELECT MAX(SUM(a)) FROM foo GROUP BY a;' 此规则不适用于解析函数。 以下查询有效且正确。 'SELECT MAX(SUM(a) OVER ()) FROM foo;' 没有聚合函数的 HAVING 的用法。 在这种情况下，请考虑使用 WHERE 部分重写您的代码。 'SELECT a, MAX(b) FROM foo GROUP BY a HAVING a > 0;'",
                  "markdown": "报告 SQL 聚合函数的无效用法。\n\n即以下情况：\n\n* 在 HAVING 和 ORDER BY 子句中使用但在 GROUP BY 子句中遗漏的列。\n\n      CREATE TABLE foo(id INT PRIMARY KEY, a INT, b INT);\n      SELECT a, MAX(b) FROM foo GROUP BY a HAVING b > 0;\n      SELECT * FROM foo GROUP BY a ORDER BY b;\n\n  当按主键进行分组时，此规则不适用。\n\n      SELECT * FROM foo GROUP BY id ORDER BY b;\n\n* 在错误的上下文中聚合函数。 通常，您可以在以下上下文中使用聚合函数： SELECT 中的表达式列表； 在 HAVING 和 ORDER BY 部分； 和其他特定于方言的案例。 以下查询将显示错误。\n\n      SELECT a FROM foo WHERE MAX(b) > 0;\n      SELECT a FROM foo GROUP BY MAX(a);\n\n* 聚合函数的嵌套调用。\n\n      SELECT MAX(SUM(a)) FROM foo GROUP BY a;\n\n  此规则不适用于解析函数。 以下查询有效且正确。\n\n      SELECT MAX(SUM(a) OVER ()) FROM foo;\n\n* 没有聚合函数的 HAVING 的用法。 在这种情况下，请考虑使用 WHERE 部分重写您的代码。\n\n      SELECT a, MAX(b) FROM foo GROUP BY a HAVING a > 0;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlAggregates",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlMissingColumnAliasesInspection",
                "shortDescription": {
                  "text": "缺少列别名"
                },
                "fullDescription": {
                  "text": "报告在输出表达式中没有显式别名的查询（例如，在 SELECT 语句中）。 示例（PostgreSQL）： 'CREATE TABLE foo(a INT, b INT);\n\nSELECT 1, a + 1 AS A2, MAX(b) AS M\nFROM foo;'",
                  "markdown": "报告在输出表达式中没有显式别名的查询（例如，在 SELECT 语句中）。\n\n示例（PostgreSQL）：\n\n    CREATE TABLE foo(a INT, b INT);\n\n    SELECT 1, a + 1 AS A2, MAX(b) AS M\n    FROM foo;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlMissingColumnAliases",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlAddNotNullColumnInspection",
                "shortDescription": {
                  "text": "添加没有默认值的非 null 列"
                },
                "fullDescription": {
                  "text": "报告创建没有 DEFAULT 值的 NOT NULL 列的尝试。 示例（Microsoft SQL 服务器）： 'CREATE TABLE foo (a INT, b  INT)\n\nALTER TABLE foo ADD c INT NOT NULL;' 默认情况下，列包含 NULL 值。 在示例中，我们使用 NOT NULL 约束强制列不接受 NULL 值。 如果我们禁止使用 NULL 值，则必须设置 SQL 在创建新记录时可以使用的 DEFAULT 值。 'ALTER TABLE foo ADD c INT NOT NULL DEFAULT 42;' 您可以使用添加 DEFAULT 值快速修复快速添加 DEFAULT 值。",
                  "markdown": "报告创建没有 DEFAULT 值的 NOT NULL 列的尝试。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE TABLE foo (a INT, b  INT)\n\n    ALTER TABLE foo ADD c INT NOT NULL;\n\n默认情况下，列包含 NULL 值。 在示例中，我们使用 NOT NULL 约束强制列不接受 NULL 值。\n如果我们禁止使用 NULL 值，则必须设置 SQL 在创建新记录时可以使用的 DEFAULT 值。\n\n    ALTER TABLE foo ADD c INT NOT NULL DEFAULT 42;\n\n您可以使用**添加 DEFAULT 值**快速修复快速添加 DEFAULT 值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlAddNotNullColumn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OraMissingBodyInspection",
                "shortDescription": {
                  "text": "缺少软件包/对象类型规范的主体"
                },
                "fullDescription": {
                  "text": "报告缺少主体声明的软件包和对象类型规范。 声明例程的软件包规范和对象类型以及带有光标的软件包规范必须具有实现这些例程和光标的主体声明。 在程序代码中调用例程或光标时，缺少主体会导致运行时错误。 示例（Oracle）： 'CREATE OR REPLACE PACKAGE ppp IS\n    FUNCTION foo(a INT) RETURN INT;\nEND;'",
                  "markdown": "报告缺少主体声明的软件包和对象类型规范。\n\n声明例程的软件包规范和对象类型以及带有光标的软件包规范必须具有实现这些例程和光标的主体声明。 在程序代码中调用例程或光标时，缺少主体会导致运行时错误。\n\n示例（Oracle）：\n\n    CREATE OR REPLACE PACKAGE ppp IS\n        FUNCTION foo(a INT) RETURN INT;\n    END;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlMissingBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Oracle",
                      "index": 123,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MongoJSExtResolveInspection",
                "shortDescription": {
                  "text": "解析问题"
                },
                "fullDescription": {
                  "text": "报告 MongoDB 和 JavaScript 代码中未解析的引用。",
                  "markdown": "报告 MongoDB 和 JavaScript 代码中未解析的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MongoJSResolve",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "MongoJS",
                      "index": 130,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlIllegalCursorStateInspection",
                "shortDescription": {
                  "text": "非法光标状态"
                },
                "fullDescription": {
                  "text": "报告 SQL 例程中的非法光标状态。 例程具有 CLOSE 或 FETCH 语句，但光标可能已被关闭。 例程具有 OPEN 语句，但光标可能已被打开。 示例（Microsoft SQL 服务器）： 'CREATE TABLE t(col INT);\n\nCREATE PROCEDURE foo() AS\nBEGIN\nDECLARE my_cursor CURSOR FOR SELECT * FROM t;\nDECLARE a INT;\nFETCH my_cursor INTO a;\nCLOSE my_cursor;\nEND;' 根据 docs.microsoft.com 上的 CLOSE (Transact-SQL)，必须为打开的光标执行 CLOSE，并且不允许对仅声明或已经关闭的光标执行 CLOSE。 因此，我们需要打开光标来修正警告。 'CREATE PROCEDURE foo() AS\nBEGIN\nDECLARE my_cursor CURSOR FOR SELECT * FROM t;\nDECLARE a INT;\nOPEN my_cursor;\nFETCH my_cursor INTO a;\nCLOSE my_cursor;\nEND;'",
                  "markdown": "报告 SQL 例程中的非法光标状态。\n\n* 例程具有 CLOSE 或 FETCH 语句，但光标可能已被关闭。\n* 例程具有 OPEN 语句，但光标可能已被打开。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE TABLE t(col INT);\n\n    CREATE PROCEDURE foo() AS\n    BEGIN\n    DECLARE my_cursor CURSOR FOR SELECT * FROM t;\n    DECLARE a INT;\n    FETCH my_cursor INTO a;\n    CLOSE my_cursor;\n    END;\n\n根据 [docs.microsoft.com 上的 CLOSE (Transact-SQL)](https://docs.microsoft.com/en-us/sql/t-sql/language-elements/close-transact-sql)，必须为打开的光标执行 CLOSE，并且不允许对仅声明或已经关闭的光标执行 CLOSE。 因此，我们需要打开光标来修正警告。\n\n    CREATE PROCEDURE foo() AS\n    BEGIN\n    DECLARE my_cursor CURSOR FOR SELECT * FROM t;\n    DECLARE a INT;\n    OPEN my_cursor;\n    FETCH my_cursor INTO a;\n    CLOSE my_cursor;\n    END;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlIllegalCursorState",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlCheckUsingColumnsInspection",
                "shortDescription": {
                  "text": "检查 using 子句列"
                },
                "fullDescription": {
                  "text": "报告两个表中都不存在的 USING 子句中的列。 示例（MySQL）： 'CREATE TABLE t1 (i INT, j INT);\nCREATE TABLE t2 (k INT, l INT);\nSELECT * FROM t1 JOIN t2 USING (j);' 在 USING 子句中，列名必须存在于两个表中，SELECT 查询将使用给定的列名自动连接这些表。 由于我们在 't2' 中没有 'j' 列，我们可以使用 ON 重写查询。 ON 子句可以连接两个表中列名不匹配的表。 'SELECT * FROM t1 JOIN t2 ON t1.j = t2.l;'",
                  "markdown": "报告两个表中都不存在的 USING 子句中的列。\n\n示例（MySQL）：\n\n    CREATE TABLE t1 (i INT, j INT);\n    CREATE TABLE t2 (k INT, l INT);\n    SELECT * FROM t1 JOIN t2 USING (j);\n\n在 USING 子句中，列名必须存在于两个表中，SELECT 查询将使用给定的列名自动连接这些表。 由于我们在 `t2` 中没有 `j` 列，我们可以使用 ON 重写查询。 ON 子句可以连接两个表中列名不匹配的表。\n\n    SELECT * FROM t1 JOIN t2 ON t1.j = t2.l;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlCheckUsingColumns",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlConstantConditionInspection",
                "shortDescription": {
                  "text": "恒定条件"
                },
                "fullDescription": {
                  "text": "报告 WHERE 或 JOIN 子句中始终为 TRUE 或始终为 FALSE 的条件。 示例（MySQL）： 'CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);\nSELECT a FROM t1 WHERE 'Cat' = 'Cat';' ''Cat' = 'Cat'' 始终为 true，将被报告。",
                  "markdown": "报告 WHERE 或 JOIN 子句中始终为 TRUE 或始终为 FALSE 的条件。\n\n示例（MySQL）：\n\n    CREATE TABLE t1 (a TEXT, b INT, c BOOLEAN);\n    SELECT a FROM t1 WHERE 'Cat' = 'Cat';\n\n`'Cat' = 'Cat'` 始终为 true，将被报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlConstantCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlDuplicateColumnInspection",
                "shortDescription": {
                  "text": "SELECT 中的重复列名"
                },
                "fullDescription": {
                  "text": "报告 SELECT 列表中列别名的重复名称。 示例（Sybase ASE）： 'CREATE TABLE t1 (a TEXT, b INT, c INT);\n\nSELECT a AS x, b AS x FROM t1;' 'x' 别名用于 'a' 和 'b' 列。 这些分配高亮显示为错误，因为您不能对 Sybase ASE 中的列使用相同的别名。",
                  "markdown": "报告 SELECT 列表中列别名的重复名称。\n\n示例（Sybase ASE）：\n\n    CREATE TABLE t1 (a TEXT, b INT, c INT);\n\n    SELECT a AS x, b AS x FROM t1;\n\n`x` 别名用于 `a` 和 `b` 列。 这些分配高亮显示为错误，因为您不能对 Sybase ASE 中的列使用相同的别名。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlDuplicateColumn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlInsertIntoGeneratedColumnInspection",
                "shortDescription": {
                  "text": "插入到生成的列中"
                },
                "fullDescription": {
                  "text": "报告将值赋给生成的列的 INSERT 语句。 可以读取生成的列，但不能直接写入其值。 示例（PostgreSQL）： 'CREATE TABLE foo\n(\n   col1 INT,\n   col2 INT GENERATED ALWAYS AS (col1 + 1) STORED\n);\nINSERT INTO foo(col1, col2) VALUES (1, 2);'\n 您不能将 '2' 插入到 'col2' 列中，因为此列已生成。 要使此脚本正常工作，您可以将 '2' 更改为 DEFAULT。 'INSERT INTO foo(col1, col2) VALUES (1, DEFAULT);'",
                  "markdown": "报告将值赋给生成的列的 INSERT 语句。 可以读取生成的列，但不能直接写入其值。\n\n示例（PostgreSQL）：\n\n    CREATE TABLE foo\n    (\n       col1 INT,\n       col2 INT GENERATED ALWAYS AS (col1 + 1) STORED\n    );\n    INSERT INTO foo(col1, col2) VALUES (1, 2);\n\n您不能将 `2` 插入到 `col2` 列中，因为此列已生成。\n要使此脚本正常工作，您可以将 `2` 更改为 DEFAULT。\n`INSERT INTO foo(col1, col2) VALUES (1, DEFAULT);`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlInsertIntoGeneratedColumn",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlIdentifierInspection",
                "shortDescription": {
                  "text": "标识符应加引号"
                },
                "fullDescription": {
                  "text": "报告在查询中使用 SQL 预留关键字作为标识符名称时的情况。 示例（Microsoft SQL 服务器）： 'CREATE TABLE select (identity INT IDENTITY NOT NULL, order INT NOT NULL);' 我们使用 'select'、'identity' 和'order' 作为表名和列名。 但它们也是 Microsoft SQL Server 中的保留关键字。 因此，为了将它们用作查询中的对象名称，您必须用引号引用这些标识符。 要用引号引用它们，您可以使用为标识符加引号 快速修复。 在应用快速修复后： 'CREATE TABLE [select] ([identity] INT IDENTITY NOT NULL, [order] INT NOT NULL);'",
                  "markdown": "报告在查询中使用 SQL 预留关键字作为标识符名称时的情况。\n\n示例（Microsoft SQL 服务器）：\n\n    CREATE TABLE select (identity INT IDENTITY NOT NULL, order INT NOT NULL);\n\n我们使用 `select`、`identity` 和`order` 作为表名和列名。\n但它们也是 Microsoft SQL Server 中的保留关键字。\n因此，为了将它们用作查询中的对象名称，您必须用引号引用这些标识符。 要用引号引用它们，您可以使用**为标识符加引号** 快速修复。\n\n在应用快速修复后：\n\n    CREATE TABLE [select] ([identity] INT IDENTITY NOT NULL, [order] INT NOT NULL);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlIdentifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MsOrderByInspection",
                "shortDescription": {
                  "text": "查询中的 ORDER BY"
                },
                "fullDescription": {
                  "text": "报告在视图、内联函数、派生表、子查询和通用表表达式中使用 'ORDER BY' 子句而不使用 'TOP'、'OFFSET' 或 'FOR XML' 的用法。 有关 'ORDER BY' 用法的详细信息，请参阅 docs.microsoft.com 上的 SELECT - ORDER BY 子句 (Transact-SQL)。 示例（Microsoft SQL Server）： 'CREATE TABLE foo (a INT NOT NULL, b  INT NOT NULL);\n\nSELECT *\nFROM (SELECT a, b\nFROM foo A\nWHERE a < 89\nORDER BY b) ALIAS;' 在子查询中，ORDER BY 将被高亮显示为错误。 您可以将 TOP、OFFSET 或 FOR XML 添加到子查询。 或者，使用删除元素快速修复来删除 ORDER BY 部分。 在应用快速修复后： 'SELECT *\nFROM (SELECT a, b\nFROM foo A\nWHERE a < 89) ALIAS;'",
                  "markdown": "报告在视图、内联函数、派生表、子查询和通用表表达式中使用 `ORDER BY` 子句而不使用 `TOP`、`OFFSET` 或 `FOR XML` 的用法。\n\n有关 `ORDER BY` 用法的详细信息，请参阅 [docs.microsoft.com 上的 SELECT - ORDER BY 子句 (Transact-SQL)](https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql)。\n\n示例（Microsoft SQL Server）：\n\n    CREATE TABLE foo (a INT NOT NULL, b  INT NOT NULL);\n\n    SELECT *\n    FROM (SELECT a, b\n    FROM foo A\n    WHERE a < 89\n    ORDER BY b) ALIAS;\n\n在子查询中，ORDER BY 将被高亮显示为错误。 您可以将 TOP、OFFSET 或 FOR XML 添加到子查询。\n或者，使用**删除元素**快速修复来删除 ORDER BY 部分。\n\n在应用快速修复后：\n\n    SELECT *\n    FROM (SELECT a, b\n    FROM foo A\n    WHERE a < 89) ALIAS;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "MsOrderBy",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL Server",
                      "index": 147,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlDeprecateTypeInspection",
                "shortDescription": {
                  "text": "弃用的类型"
                },
                "fullDescription": {
                  "text": "报告已弃用并且可能在 DBMS 的未来版本中消失的类型的用法。 报告的类型： Oracle 中的 LONG（请参阅 docs.oracle.com 上的 Deprecated and Desupported Features 页面）。 Microsoft SQL Server 中的 TEXT、NTEXT 和 IMAGE（请参阅 docs.microsoft.com 上的 Deprecated Database Engine Features in SQL Server 2016 页面）。 示例（Oracle）： 'CREATE TABLE ot.foo(\na NUMBER GENERATED BY DEFAULT AS IDENTITY,\nb LONG NOT NULL\n);'",
                  "markdown": "报告已弃用并且可能在 DBMS 的未来版本中消失的类型的用法。\n\n报告的类型：\n\n* Oracle 中的 LONG（请参阅 [docs.oracle.com 上的 Deprecated and Desupported Features](https://docs.oracle.com/cd/A91202_01/901_doc/server.901/a90120/ch4_dep.htm#6690) 页面）。\n* Microsoft SQL Server 中的 TEXT、NTEXT 和 IMAGE（请参阅 [docs.microsoft.com 上的 Deprecated Database Engine Features in SQL Server 2016](https://docs.microsoft.com/en-us/sql/database-engine/deprecated-database-engine-features-in-sql-server-2016?view=sql-server-ver15) 页面）。\n\n示例（Oracle）：\n\n    CREATE TABLE ot.foo(\n    a NUMBER GENERATED BY DEFAULT AS IDENTITY,\n    b LONG NOT NULL\n    );\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlDeprecateType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SqlGotoInspection",
                "shortDescription": {
                  "text": "使用 GOTO 语句"
                },
                "fullDescription": {
                  "text": "报告后向 GOTO 语句和用于退出循环的 GOTO 语句的用法。 通常不推荐大量使用 GOTO 语句。 有关详细信息，请参阅 ibm.com 上的 GOTO statement in SQL procedures。 考虑使用循环而不是使用 GOTO 返回到上一条语句。 考虑使用另一个流控制语句，例如 RETURN 或 BREAK，而不是使用 GOTO 退出 WHILE 循环。 示例（Oracle）： 'CREATE PROCEDURE test(n INT) AS\nDECLARE\n    x INT;\nBEGIN\n    x := 0;\n    GOTO a;\n    <<a>> x := 1;\n    IF (n = 0) THEN\n        GOTO a;\n    END IF;\n    WHILE TRUE\n        LOOP\n            GOTO b;\n        END LOOP;\n    <<b>> x := 3;\nEND;'",
                  "markdown": "报告后向 GOTO 语句和用于退出循环的 GOTO 语句的用法。\n\n通常不推荐大量使用 GOTO 语句。 有关详细信息，请参阅 [ibm.com 上的 GOTO statement in SQL procedures](https://www.ibm.com/docs/no/db2/11.5?topic=procedures-goto-statement-in-sql)。\n\n考虑使用循环而不是使用 GOTO 返回到上一条语句。\n\n考虑使用另一个流控制语句，例如 RETURN 或 BREAK，而不是使用 GOTO 退出 WHILE 循环。\n\n示例（Oracle）：\n\n    CREATE PROCEDURE test(n INT) AS\n    DECLARE\n        x INT;\n    BEGIN\n        x := 0;\n        GOTO a;\n        <<a>> x := 1;\n        IF (n = 0) THEN\n            GOTO a;\n        END IF;\n        WHILE TRUE\n            LOOP\n                GOTO b;\n            END LOOP;\n        <<b>> x := 3;\n    END;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SqlGoto",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "SQL",
                      "index": 45,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.sass",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "SassScssResolvedByNameOnly",
                "shortDescription": {
                  "text": "缺少 import"
                },
                "fullDescription": {
                  "text": "报告对另一个文件（但该文件未在当前文件中显式导入）中声明的变量、mixin 或函数的引用。 示例： '* {\n  margin: $var-in-other-file;\n}'",
                  "markdown": "报告对另一个文件（但该文件未在当前文件中显式[导入](https://sass-lang.com/documentation/at-rules/import)）中声明的变量、mixin 或函数的引用。\n\n**示例：**\n\n\n    * {\n      margin: $var-in-other-file;\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SassScssResolvedByNameOnly",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Sass_SCSS",
                      "index": 24,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SassScssUnresolvedVariable",
                "shortDescription": {
                  "text": "未解析的变量"
                },
                "fullDescription": {
                  "text": "报告未解析的 Sass/SCSS 变量引用。 示例： '* {\n  margin: $unknown-var;\n}'",
                  "markdown": "报告未解析的 [Sass/SCSS 变量](https://sass-lang.com/documentation/variables)引用。\n\n**示例：**\n\n\n    * {\n      margin: $unknown-var;\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SassScssUnresolvedVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Sass_SCSS",
                      "index": 24,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SassScssUnresolvedMixin",
                "shortDescription": {
                  "text": "未解析的 mixin"
                },
                "fullDescription": {
                  "text": "报告未解析的 Sass/SCSS mixin 引用。 示例： '* {\n  @include unknown-mixin;\n}'",
                  "markdown": "报告未解析的 [Sass/SCSS mixin](https://sass-lang.com/documentation/at-rules/mixin) 引用。\n\n**示例：**\n\n\n    * {\n      @include unknown-mixin;\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SassScssUnresolvedMixin",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Sass_SCSS",
                      "index": 24,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SassScssUnresolvedPlaceholderSelector",
                "shortDescription": {
                  "text": "未解析的占位符选择器"
                },
                "fullDescription": {
                  "text": "报告未解析的 Sass/SCSS 占位符选择器引用。 示例： '* {\n  @extend %unknown-placeholder-selector;\n}'",
                  "markdown": "报告未解析的 [Sass/SCSS 占位符选择器](https://sass-lang.com/documentation/variables)引用。\n\n**示例：**\n\n\n    * {\n      @extend %unknown-placeholder-selector;\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SassScssUnresolvedPlaceholderSelector",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Sass_SCSS",
                      "index": 24,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "HtmlUnknownBooleanAttribute",
                "shortDescription": {
                  "text": "不正确的布尔特性"
                },
                "fullDescription": {
                  "text": "报告不含值的 HTML 非布尔特性。 建议配置不应报告的特性。",
                  "markdown": "报告不含值的 HTML 非布尔特性。 建议配置不应报告的特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownBooleanAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicatedCode",
                "shortDescription": {
                  "text": "重复的代码段"
                },
                "fullDescription": {
                  "text": "Reports duplicated blocks of code from the selected scope: the same file, same module, dependent modules or the entire project. The inspection features quick-fixes that help you to set the size of detected duplicates, navigate to repetitive code fragments, and compare them in a tool window.When possible, the inspection provides a quick-fix to extract a method from the duplicated code. The inspection options allow you to select the scope of the reported duplicated fragments and set the initial size for the duplicated language constructs. You can also configure the constructs that you want to anonymize in 设置 | Editor | Duplicates.",
                  "markdown": "Reports duplicated blocks of code from the selected scope: the same file, same module, dependent modules or the entire project.\n\nThe inspection features quick-fixes that help you to set the size of detected duplicates, navigate to repetitive code fragments, and compare them in a tool window.When possible, the inspection provides a quick-fix to extract a method from the duplicated code.\n\nThe inspection options allow you to select the scope of the reported duplicated fragments and set the initial size for the duplicated language constructs.\n\nYou can also configure the constructs that you want to anonymize in [设置 \\| Editor \\| Duplicates](settings://duplicates.index)."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "DuplicatedCode",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSuppression",
                "shortDescription": {
                  "text": "冗余禁止"
                },
                "fullDescription": {
                  "text": "报告由于它们所影响的检查在此上下文中不再适用而可以安全移除的下列元素： '@SuppressWarning' 注解或 '// noinspection' 行注释，或 '/** noinspection */' JavaDoc 注释 示例： 'public class C {\n // 符号已经为 private，\n // 但周围仍有注解\n  @SuppressWarnings({\"WeakerAccess\"})\n private boolean CONST = true;\n void f() {\n    CONST = false;\n  }\n}'",
                  "markdown": "报告由于它们所影响的检查在此上下文中不再适用而可以安全移除的下列元素：\n\n* `@SuppressWarning` 注解或\n* `// noinspection` 行注释，或\n* `/** noinspection */` JavaDoc 注释\n\n示例：\n\n\n    public class C {\n     // 符号已经为 private，\n     // 但周围仍有注解\n      @SuppressWarnings({\"WeakerAccess\"})\n     private boolean CONST = true;\n     void f() {\n        CONST = false;\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSuppression",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CustomRegExpInspection",
                "shortDescription": {
                  "text": "自定义正则表达式检查"
                },
                "fullDescription": {
                  "text": "自定义正则表达式检查",
                  "markdown": "自定义正则表达式检查"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CustomRegExpInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncorrectFormatting",
                "shortDescription": {
                  "text": "格式设置不正确"
                },
                "fullDescription": {
                  "text": "报告代码不遵循项目代码样式设置时出现的格式问题。 此检查与需要第三方格式化程序进行代码格式设置的语言（例如启用了 CLangFormat 的 Go 或 C 语言）不兼容。",
                  "markdown": "报告代码不遵循项目代码样式设置时出现的格式问题。\n\n\n此检查与需要第三方格式化程序进行代码格式设置的语言（例如启用了 CLangFormat 的 Go 或 C 语言）不兼容。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "IncorrectFormatting",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpUnexpectedAnchor",
                "shortDescription": {
                  "text": "起始或结束定位点在意外位置"
                },
                "fullDescription": {
                  "text": "报告不在模式开头的 '^' 或 '\\A' 定位标记以及不在模式末尾的 '$'、'\\Z' 或 '\\z' 定位标记。 如果这些正则表达式定位标记位于错误的位置，则会阻止模式与任何对象匹配。 对于 '^' 和 '$' 定位标记，则很可能是指文字字符，并且忘记了转义。 示例： '(Price $10)' 2018.1 最新变化",
                  "markdown": "报告不在模式开头的 `^` 或 `\\A` 定位标记以及不在模式末尾的 `$`、`\\Z` 或 `\\z` 定位标记。 如果这些正则表达式定位标记位于错误的位置，则会阻止模式与任何对象匹配。 对于 `^` 和 `$` 定位标记，则很可能是指文字字符，并且忘记了转义。\n\n**示例：**\n\n\n      (Price $10)\n\n\n2018.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpUnexpectedAnchor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SpellCheckingInspection",
                "shortDescription": {
                  "text": "拼写错误"
                },
                "fullDescription": {
                  "text": "报告代码、注释和文字中的拼写错误并一键修正。",
                  "markdown": "报告代码、注释和文字中的拼写错误并一键修正。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "SpellCheckingInspection",
                    "ideaSeverity": "TYPO",
                    "qodanaSeverity": "Low"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "校对",
                      "index": 86,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckXmlFileWithXercesValidator",
                "shortDescription": {
                  "text": "外部验证失败"
                },
                "fullDescription": {
                  "text": "报告 Xerces 验证程序检测到的 XML 文件和指定 DTD 或架构的差异。",
                  "markdown": "报告 Xerces 验证程序检测到的 XML 文件和指定 DTD 或架构的差异。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckXmlFileWithXercesValidator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpEscapedMetaCharacter",
                "shortDescription": {
                  "text": "转义元字符"
                },
                "fullDescription": {
                  "text": "报告转义元字符。 某些正则表达式代码样式指定应将元字符放在字符类中，从而使正则表达式更易于理解。 此检查不会警告元字符 '[', ']' 和 '^'，因为这些字符可能需要在字符类中进行额外的转义。 示例： '\\d+\\.\\d+' 在应用快速修复后： '\\d+[.]\\d+' 2017.1 最新变化",
                  "markdown": "报告转义元字符。 某些正则表达式代码样式指定应将元字符放在字符类中，从而使正则表达式更易于理解。 此检查不会警告元字符 `[`, `]` 和 `^`，因为这些字符可能需要在字符类中进行额外的转义。\n\n**示例：**\n\n\n      \\d+\\.\\d+\n\n在应用快速修复后：\n\n\n      \\d+[.]\\d+\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpEscapedMetaCharacter",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnusedNamespaceDeclaration",
                "shortDescription": {
                  "text": "未使用的架构声明"
                },
                "fullDescription": {
                  "text": "报告 XML 中未使用的命名空间声明或位置提示。",
                  "markdown": "报告 XML 中未使用的命名空间声明或位置提示。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlUnusedNamespaceDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSimplifiable",
                "shortDescription": {
                  "text": "正则表达式可以简化"
                },
                "fullDescription": {
                  "text": "报告可以简化的正则表达式。 示例： '[a] xx* [ah-hz]' 在应用快速修复后： 'a x+ [ahz]' 2022.1 最新变化",
                  "markdown": "报告可以简化的正则表达式。\n\n**示例：**\n\n\n      [a] xx* [ah-hz]\n\n在应用快速修复后：\n\n\n      a x+ [ahz]\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpSimplifiable",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpEmptyAlternationBranch",
                "shortDescription": {
                  "text": "替代项中存在空分支"
                },
                "fullDescription": {
                  "text": "报告正则表达式替换中的空分支。 空分支只能匹配空字符串，在大多数情况下，这并不是我们的目的。 此检查不会报告位于替换开头或末尾的单个空分支。 示例： '(alpha||bravo)' 在应用快速修复后： '(alpha|bravo)' 2017.2 最新变化",
                  "markdown": "报告正则表达式替换中的空分支。 空分支只能匹配空字符串，在大多数情况下，这并不是我们的目的。 此检查不会报告位于替换开头或末尾的单个空分支。\n\n**示例：**\n\n\n      (alpha||bravo)\n\n在应用快速修复后：\n\n\n      (alpha|bravo)\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpEmptyAlternationBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpUnnecessaryNonCapturingGroup",
                "shortDescription": {
                  "text": "不必要的非捕获组"
                },
                "fullDescription": {
                  "text": "报告不必要的非捕获组（对匹配结果无影响）。 示例： 'Everybody be cool, (?:this) is a robbery!' 在应用快速修复后： 'Everybody be cool, this is a robbery!' 2021.1 最新变化",
                  "markdown": "报告不必要的非捕获组（对匹配结果无影响）。\n\n**示例：**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\n在应用快速修复后：\n\n\n      Everybody be cool, this is a robbery!\n\n2021.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpUnnecessaryNonCapturingGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TodoComment",
                "shortDescription": {
                  "text": "TODO 注释"
                },
                "fullDescription": {
                  "text": "报告代码中的 TODO 注释。 您可以在设置 | 编辑器 | TODO 中配置 TODO 注释的格式。 启用只对没有任何详细信息的 TODO 注释发出警告选项，以仅对不提供有关应完成任务的任何描述的空 TODO 注释发出警告。 禁用可报告所有 TODO 注释。",
                  "markdown": "报告代码中的 **TODO** 注释。\n\n您可以在[设置 \\| 编辑器 \\| TODO](settings://preferences.toDoOptions) 中配置 **TODO** 注释的格式。\n\n启用**只对没有任何详细信息的 TODO 注释发出警告**选项，以仅对不提供有关应完成任务的任何描述的空 TODO 注释发出警告。 禁用可报告所有 TODO 注释。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TodoComment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDefaultAttributeValue",
                "shortDescription": {
                  "text": "包含默认值的冗余特性"
                },
                "fullDescription": {
                  "text": "报告对 XML 特性默认值的冗余赋值。",
                  "markdown": "报告对 XML 特性默认值的冗余赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlDefaultAttributeValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaCompliance",
                "shortDescription": {
                  "text": "符合 JSON 架构"
                },
                "fullDescription": {
                  "text": "报告 JSON 文件与分配给它的 JSON 模式之间的不一致。",
                  "markdown": "报告 JSON 文件与分配给它的 [JSON 模式](https://json-schema.org)之间的不一致。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonSchemaCompliance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 115,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyDirectory",
                "shortDescription": {
                  "text": "空目录"
                },
                "fullDescription": {
                  "text": "报告空目录。 仅适用于代码 | 检查代码或代码 | 分析代码 | 通过名称运行检查，并且不会在编辑器中报告。 使用仅报告位于源文件夹下的空目录选项可以仅报告源根下的目录。",
                  "markdown": "报告空目录。\n\n仅适用于**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 通过名称运行检查**，并且不会在编辑器中报告。\n\n使用**仅报告位于源文件夹下的空目录**选项可以仅报告源根下的目录。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyDirectory",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckDtdRefs",
                "shortDescription": {
                  "text": "未解析的 DTD 引用"
                },
                "fullDescription": {
                  "text": "报告特定于 DTD 的引用（例如，对 XML 实体或 DTD 元素声明的引用）中的不一致。 适用于 DTD 和 XML 文件。",
                  "markdown": "报告特定于 DTD 的引用（例如，对 XML 实体或 DTD 元素声明的引用）中的不一致。 适用于 DTD 和 XML 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckDtdRefs",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonAsciiCharacters",
                "shortDescription": {
                  "text": "非 ASCII 字符"
                },
                "fullDescription": {
                  "text": "报告在异常上下文中使用非 ASCII 符号的代码元素。 示例： 标识符、字符串或注释中使用的非 ASCII 字符。 使用不同语言编写的标识符，例如带有使用西里尔文编写的字母 'C' 的 'myСollection'。 包含 Unicode 符号（如长划线和箭头）的注释或字符串。",
                  "markdown": "报告在异常上下文中使用非 ASCII 符号的代码元素。\n\n示例：\n\n* 标识符、字符串或注释中使用的非 ASCII 字符。\n* 使用不同语言编写的标识符，例如带有使用西里尔文编写的字母 **C** 的 `my`**С**`ollection`。\n* 包含 Unicode 符号（如长划线和箭头）的注释或字符串。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonAsciiCharacters",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "国际化",
                      "index": 124,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IgnoreFileDuplicateEntry",
                "shortDescription": {
                  "text": "忽略文件重复项"
                },
                "fullDescription": {
                  "text": "报告忽略文件（例如 .gitignore、.hgignore）中的重复条目（模式）。 这些文件中的重复条目冗余，可以移除。 示例： '# 输出目录\n    /out/\n    /target/\n    /out/'",
                  "markdown": "报告忽略文件（例如 .gitignore、.hgignore）中的重复条目（模式）。 这些文件中的重复条目冗余，可以移除。\n\n示例：\n\n\n        # 输出目录\n        /out/\n        /target/\n        /out/\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IgnoreFileDuplicateEntry",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "版本控制",
                      "index": 129,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonStandardCompliance",
                "shortDescription": {
                  "text": "符合 JSON 标准"
                },
                "fullDescription": {
                  "text": "报告 JSON 文件与语言规范的以下差异： 行或块注释（可配置）。 多个顶层值（用于 JSON Lines 文件，可针对其他文件配置）。 对象或数组中的尾随逗号（可配置）。 用单引号引用的字符串。 属性键不是由双引号引用的字符串。 用 NaN 或正无穷大/负无穷大数值作为浮点文字（可配置）。",
                  "markdown": "报告 JSON 文件与[语言规范](https://tools.ietf.org/html/rfc7159)的以下差异：\n\n* 行或块注释（可配置）。\n* 多个顶层值（用于 JSON Lines 文件，可针对其他文件配置）。\n* 对象或数组中的尾随逗号（可配置）。\n* 用单引号引用的字符串。\n* 属性键不是由双引号引用的字符串。\n* 用 NaN 或正无穷大/负无穷大数值作为浮点文字（可配置）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JsonStandardCompliance",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 115,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaRefReference",
                "shortDescription": {
                  "text": "未解析的 '$ref' 和 '$schema' 引用"
                },
                "fullDescription": {
                  "text": "报告 JSON 架构中未解析的 '$ref' 或 '$schema' 路径。",
                  "markdown": "报告 JSON 架构中未解析的 `$ref` 或 `$schema` 路径。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonSchemaRefReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 115,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SSBasedInspection",
                "shortDescription": {
                  "text": "结构搜索检查"
                },
                "fullDescription": {
                  "text": "允许配置可以应用于您正在编辑的文件的结构搜索/结构替换模板。 所有匹配项都将高亮显示并使用您配置的模板名称标记。 如果您还配置了结构替换模式，相应的替换选项将作为快速修复提供。",
                  "markdown": "允许配置可以应用于您正在编辑的文件的**结构搜索/结构替换**模板。\n\n所有匹配项都将高亮显示并使用您配置的模板名称标记。\n如果您还配置了**结构替换**模式，相应的替换选项将作为快速修复提供。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SSBasedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "结构搜索",
                      "index": 137,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSuspiciousBackref",
                "shortDescription": {
                  "text": "可疑的反向引用"
                },
                "fullDescription": {
                  "text": "报告在运行时无法解析的反向引用。 这意味着反向引用永远无法匹配任何内容。 如果组是在反向引用之后定义的，或者组是在替代项的不同分支中定义的，则反向引用将不可解析。 在其反向引用之后定义的组的示例： '\\1(abc)' 不同分支中的组和反向引用的示例： 'a(b)c|(xy)\\1z' 2022.1 最新变化",
                  "markdown": "报告在运行时无法解析的反向引用。 这意味着反向引用永远无法匹配任何内容。 如果组是在反向引用之后定义的，或者组是在替代项的不同分支中定义的，则反向引用将不可解析。\n\n**在其反向引用之后定义的组的示例：**\n\n\n      \\1(abc)\n\n**不同分支中的组和反向引用的示例：**\n\n\n      a(b)c|(xy)\\1z\n\n2022.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpSuspiciousBackref",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpSingleCharAlternation",
                "shortDescription": {
                  "text": "单字符替代项"
                },
                "fullDescription": {
                  "text": "报告正则表达式中的单一字符替换。 改用一个字符类更简单。 这还可能提高匹配性能。 示例： 'a|b|c|d' 在应用快速修复后： '[abcd]' 2017.1 最新变化",
                  "markdown": "报告正则表达式中的单一字符替换。 改用一个字符类更简单。 这还可能提高匹配性能。\n\n**示例：**\n\n\n      a|b|c|d\n\n在应用快速修复后：\n\n\n      [abcd]\n\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpSingleCharAlternation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckTagEmptyBody",
                "shortDescription": {
                  "text": "空元素内容"
                },
                "fullDescription": {
                  "text": "报告没有内容的 XML 元素。 示例： '<user>\n    <name></name>\n  </user>' 在应用快速修复后： '<user>\n    <name/>\n  </user>'",
                  "markdown": "报告没有内容的 XML 元素。\n\n**示例：**\n\n\n      <user>\n        <name></name>\n      </user>\n\n在应用快速修复后：\n\n\n      <user>\n        <name/>\n      </user>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckTagEmptyBody",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnresolvedReference",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告使用 XML 语法的 RELAX-NG 文件中对命名模式 ('define') 的未解析引用。 建议创建引用的 'define' 元素。",
                  "markdown": "报告使用 XML 语法的 RELAX-NG 文件中对命名模式 (`define`) 的未解析引用。 建议创建引用的 `define` 元素。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "UnresolvedReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "RELAX NG",
                      "index": 142,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlMissingClosingTag",
                "shortDescription": {
                  "text": "缺少结束标记"
                },
                "fullDescription": {
                  "text": "报告不含结束标记的 HTML 元素。 即便在可选的情况下，有些编码样式也要求 HTML 元素包含结束标记。 示例： '<html>\n    <body>\n      <p>Behold!\n    </body>\n  </html>' 在应用快速修复后： '<html>\n    <body>\n      <p>Behold!</p>\n    </body>\n  </html>'",
                  "markdown": "报告不含结束标记的 HTML 元素。 即便在可选的情况下，有些编码样式也要求 HTML 元素包含结束标记。\n\n**示例：**\n\n\n      <html>\n        <body>\n          <p>Behold!\n        </body>\n      </html>\n\n在应用快速修复后：\n\n\n      <html>\n        <body>\n          <p>Behold!</p>\n        </body>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "HtmlMissingClosingTag",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlInvalidId",
                "shortDescription": {
                  "text": "未解析的 'id' 引用"
                },
                "fullDescription": {
                  "text": "报告 XML 中未解析的 'id' 引用。",
                  "markdown": "报告 XML 中未解析的 `id` 引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlInvalidId",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReassignedToPlainText",
                "shortDescription": {
                  "text": "重新分配为纯文本"
                },
                "fullDescription": {
                  "text": "报告被显式重新分配为纯文本文件类型的文件。 这种关联是不必要的，因为平台会根据内容自动检测文本文件。 您可以通过在设置 | 编辑器 | 文件类型 | 文本中移除文件类型关联来关闭此警告。",
                  "markdown": "报告被显式重新分配为纯文本文件类型的文件。 这种关联是不必要的，因为平台会根据内容自动检测文本文件。\n\n您可以通过在**设置 \\| 编辑器 \\| 文件类型 \\| 文本**中移除文件类型关联来关闭此警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReassignedToPlainText",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDeprecatedElement",
                "shortDescription": {
                  "text": "弃用的符号"
                },
                "fullDescription": {
                  "text": "报告弃用的 XML 元素或特性。 可以通过 XML 注释或带有 'deprecated' 文本的文档标记来标记符号。",
                  "markdown": "报告弃用的 XML 元素或特性。\n\n可以通过 XML 注释或带有 'deprecated' 文本的文档标记来标记符号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlDeprecatedElement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpAnonymousGroup",
                "shortDescription": {
                  "text": "匿名捕获组或数字反向引用"
                },
                "fullDescription": {
                  "text": "报告正则表达式中的匿名捕获组和数字反向引用。 只有正则表达式方言支持命名组和命名组引用，才支持这些用法。 命名组和命名反向引用可改进代码可读性，建议改用。 无需捕获时，使用非捕获组，即使用 '(?:xxx)' 而不是 '(xxx)'，可以提高匹配效率和减少需要使用的内存。 示例： '(\\d\\d\\d\\d)\\1' 更好的正则表达式模式如下： '(?<quad>\\d\\d\\d\\d)\\k<quad>' 2017.2 最新变化",
                  "markdown": "报告正则表达式中的匿名捕获组和数字反向引用。 只有正则表达式方言支持命名组和命名组引用，才支持这些用法。 命名组和命名反向引用可改进代码可读性，建议改用。 无需捕获时，使用非捕获组，即使用 `(?:xxx)` 而不是 `(xxx)`，可以提高匹配效率和减少需要使用的内存。\n\n**示例：**\n\n\n      (\\d\\d\\d\\d)\\1\n\n更好的正则表达式模式如下：\n\n\n      (?<quad>\\d\\d\\d\\d)\\k<quad>\n\n2017.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpAnonymousGroup",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnresolvedReference",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告 XML 中的未解析引用。",
                  "markdown": "报告 XML 中的未解析引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlUnresolvedReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRepeatedSpace",
                "shortDescription": {
                  "text": "连续空格"
                },
                "fullDescription": {
                  "text": "报告正则表达式中的多个连续空格。 由于空格默认不可见，因此，很难了解需要的空格数量。 使用单个空格和计数量词来替换连续空格可以让正则表达式更清晰易懂。 示例： '(     )' 在应用快速修复后： '( {5})' 2017.1 最新变化",
                  "markdown": "报告正则表达式中的多个连续空格。 由于空格默认不可见，因此，很难了解需要的空格数量。 使用单个空格和计数量词来替换连续空格可以让正则表达式更清晰易懂。\n\n**示例：**\n\n\n      (     )\n\n在应用快速修复后：\n\n\n      ( {5})\n\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRepeatedSpace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckEmptyScriptTag",
                "shortDescription": {
                  "text": "空标记"
                },
                "fullDescription": {
                  "text": "报告在某些浏览器中无法正常运行的空标记。 示例： '<html>\n    <script/>\n  </html>' 在应用快速修复后： '<html>\n    <script></script>\n  </html>'",
                  "markdown": "报告在某些浏览器中无法正常运行的空标记。\n\n**示例：**\n\n\n      <html>\n        <script/>\n      </html>\n\n在应用快速修复后：\n\n\n      <html>\n        <script></script>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CheckEmptyScriptTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InconsistentLineSeparators",
                "shortDescription": {
                  "text": "行分隔符不一致"
                },
                "fullDescription": {
                  "text": "报告包含的行分隔符与项目设置中指定的行分隔符不同的文件。 例如，如果在设置 | 编辑器 | 代码样式 | 行分隔符中将行分隔符设置为 '\\n'，而您正在编辑的文件使用 '\\r\\n' 作为行分隔符，就会触发该检查。 该检查还会警告留意文件中的混合行分隔符。",
                  "markdown": "报告包含的行分隔符与项目设置中指定的行分隔符不同的文件。\n\n例如，如果在[设置 \\| 编辑器 \\| 代码样式 \\| 行分隔符](settings://preferences.sourceCode?Line%20separator)中将行分隔符设置为 `\\n`，而您正在编辑的文件使用 `\\r\\n` 作为行分隔符，就会触发该检查。\n\n该检查还会警告留意文件中的混合行分隔符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InconsistentLineSeparators",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ProblematicWhitespace",
                "shortDescription": {
                  "text": "有问题的空格"
                },
                "fullDescription": {
                  "text": "报告以下问题： 当代码样式配置为只使用空格时使用制表符进行缩进。 当代码样式配置为只使用制表符时使用空格进行缩进。 当代码样式配置为使用智能制表符时，使用空格进行缩进，以及使用制表符进行对齐。",
                  "markdown": "报告以下问题：\n\n* 当代码样式配置为只使用空格时使用制表符进行缩进。\n* 当代码样式配置为只使用制表符时使用空格进行缩进。\n* 当代码样式配置为使用智能制表符时，使用空格进行缩进，以及使用制表符进行对齐。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ProblematicWhitespace",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownTarget",
                "shortDescription": {
                  "text": "链接中未解析的文件"
                },
                "fullDescription": {
                  "text": "报告链接中未解析的文件。",
                  "markdown": "报告链接中未解析的文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownTarget",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LongLine",
                "shortDescription": {
                  "text": "行长度超出代码样式的允许范围"
                },
                "fullDescription": {
                  "text": "报告比在设置 | 编辑器 | 代码样式 | 常规中指定的强制换行位置参数长的行。",
                  "markdown": "报告比在[设置 \\| 编辑器 \\| 代码样式 \\| 常规](settings://preferences.sourceCode?Hard%20wrap%20at)中指定的**强制换行位置**参数长的行。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LongLine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlWrongRootElement",
                "shortDescription": {
                  "text": "错误的根元素"
                },
                "fullDescription": {
                  "text": "报告与 '<doctype>' 标记中指定的名称不同的根标记名称。",
                  "markdown": "报告与 `<doctype>` 标记中指定的名称不同的根标记名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlWrongRootElement",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownAttribute",
                "shortDescription": {
                  "text": "未知特性"
                },
                "fullDescription": {
                  "text": "报告未知的 HTML 特性。 建议配置不应报告的特性。",
                  "markdown": "报告未知的 HTML 特性。 建议配置不应报告的特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownAttribute",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantEscape",
                "shortDescription": {
                  "text": "冗余字符转义"
                },
                "fullDescription": {
                  "text": "报告可以替换为保留其含义的非转义字符的冗余字符转义序列。 许多在字符类外部必需的转义序列在字符类的方括号 '[]' 内部冗余。 尽管某些方言（JavaScript、Python 等）允许在字符类外部使用未转义的左大括号 '{'，但这样可能会导致混乱并降低模式的可移植性，因为某些方言要求将大括号作为字符进行转义。 因此，该检查不会报告转义的左大括号。 示例： '\\-\\;[\\.]' 在应用快速修复后： '-;[.]' 忽略转义的右括号 '}' 和 ']' 选项可以指定当 RegExp 方言允许在字符类外部使用未转义的 '\\}' 和 '\\]' 时是否报告它们。 2017.3 最新变化",
                  "markdown": "报告可以替换为保留其含义的非转义字符的冗余字符转义序列。 许多在字符类外部必需的转义序列在字符类的方括号 `[]` 内部冗余。\n\n\n尽管某些方言（JavaScript、Python 等）允许在字符类外部使用未转义的左大括号 `{`，但这样可能会导致混乱并降低模式的可移植性，因为某些方言要求将大括号作为字符进行转义。\n因此，该检查不会报告转义的左大括号。\n\n**示例：**\n\n\n      \\-\\;[\\.]\n\n在应用快速修复后：\n\n\n      -;[.]\n\n\n**忽略转义的右括号 '}' 和 '\\]'** 选项可以指定当 RegExp 方言允许在字符类外部使用未转义的 `\\}` 和 `\\]` 时是否报告它们。\n\n2017.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantEscape",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlExtraClosingTag",
                "shortDescription": {
                  "text": "冗余结束标记"
                },
                "fullDescription": {
                  "text": "报告空元素的冗余结束标记，例如 'img' 或 'br'。 示例： '<html>\n    <body>\n      <br></br>\n    </body>\n  </html>' 在应用快速修复后： '<html>\n    <body>\n      <br>\n    </body>\n  </html>'",
                  "markdown": "报告空元素的冗余结束标记，例如 `img` 或 `br`。\n\n**示例：**\n\n\n      <html>\n        <body>\n          <br></br>\n        </body>\n      </html>\n\n在应用快速修复后：\n\n\n      <html>\n        <body>\n          <br>\n        </body>\n      </html>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlExtraClosingTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownTag",
                "shortDescription": {
                  "text": "未知标记"
                },
                "fullDescription": {
                  "text": "报告未知的 HTML 标记。 建议配置不应报告的标记。",
                  "markdown": "报告未知的 HTML 标记。 建议配置不应报告的标记。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlHighlighting",
                "shortDescription": {
                  "text": "XML 高亮显示"
                },
                "fullDescription": {
                  "text": "报告批量代码检查结果中的 XML 验证问题。",
                  "markdown": "报告批量代码检查结果中的 XML 验证问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlHighlighting",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlDuplicatedId",
                "shortDescription": {
                  "text": "重复 'id' 特性"
                },
                "fullDescription": {
                  "text": "报告 XML 中重复的 'id' 特性。",
                  "markdown": "报告 XML 中重复的 `id` 特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlDuplicatedId",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpDuplicateCharacterInClass",
                "shortDescription": {
                  "text": "字符类中存在重复字符"
                },
                "fullDescription": {
                  "text": "报告正则表达式字符类中的重复字符。 重复字符是多余的，可将其移除而不改变正则表达式的语义。 示例： '[aabc]' 在应用快速修复后： '[abc]'",
                  "markdown": "报告正则表达式字符类中的重复字符。 重复字符是多余的，可将其移除而不改变正则表达式的语义。\n\n**示例：**\n\n\n      [aabc]\n\n在应用快速修复后：\n\n\n      [abc]\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpDuplicateCharacterInClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlUnboundNsPrefix",
                "shortDescription": {
                  "text": "未绑定的命名空间前缀"
                },
                "fullDescription": {
                  "text": "报告 XML 中未绑定的命名空间前缀。",
                  "markdown": "报告 XML 中未绑定的命名空间前缀。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XmlUnboundNsPrefix",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RequiredAttributes",
                "shortDescription": {
                  "text": "缺少必要的特性"
                },
                "fullDescription": {
                  "text": "报告 XML/HTML 标记中缺少的强制特性。 建议配置不应报告的特性。",
                  "markdown": "报告 XML/HTML 标记中缺少的强制特性。 建议配置不应报告的特性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RequiredAttributes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantClassElement",
                "shortDescription": {
                  "text": "冗余的 '\\d', '[:digit:]'，或 '\\D' 类元素"
                },
                "fullDescription": {
                  "text": "报告在同一个类中与 '\\w' 或 '[:word:]'（带 '\\W' 的 '\\D'）一起使用且可移除的冗余 '\\d' 或 '[:digit:]'。 示例： '[\\w\\d]' 在应用快速修复后： '[\\w]' 2022.2 最新变化",
                  "markdown": "报告在同一个类中与 `\\w` 或 `[:word:]`（带 `\\W` 的 `\\D`）一起使用且可移除的冗余 `\\d` 或 `[:digit:]`。\n\n**示例：**\n\n\n      [\\w\\d]\n\n在应用快速修复后：\n\n\n      [\\w]\n\n2022.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantClassElement",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XmlPathReference",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告 XML 中未解析的文件引用。",
                  "markdown": "报告 XML 中未解析的文件引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "XmlPathReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "XML",
                      "index": 88,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Json5StandardCompliance",
                "shortDescription": {
                  "text": "符合 JSON5 标准"
                },
                "fullDescription": {
                  "text": "报告 JSON5 文件中语言规范不一致的情况。",
                  "markdown": "报告 JSON5 文件中[语言规范](http://json5.org)不一致的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Json5StandardCompliance",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 115,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlWrongAttributeValue",
                "shortDescription": {
                  "text": "特性值错误"
                },
                "fullDescription": {
                  "text": "报告不正确的 HTML 特性值。",
                  "markdown": "报告不正确的 HTML 特性值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlWrongAttributeValue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LossyEncoding",
                "shortDescription": {
                  "text": "有损编码"
                },
                "fullDescription": {
                  "text": "报告由于当前文档编码而无法显示的字符。 示例： 如果在带有 US-ASCII 字符集的文档中键入国际字符，保存时会丢失某些字符。 如果加载使用 ISO-8859-1 一字节字符集的 UTF-8 编码文件，某些字符将无法正确显示。 要解决此问题，可以直接在文件中指定编码来更改文件编码，例如编辑 XML 文件的 XML prolog 中的 'encoding=' 特性，或者在设置 | 编辑器 | 文件编码中更改相应选项。",
                  "markdown": "报告由于当前文档编码而无法显示的字符。\n\n示例：\n\n* 如果在带有 **US-ASCII** 字符集的文档中键入国际字符，保存时会丢失某些字符。\n* 如果加载使用 **ISO-8859-1** 一字节字符集的 **UTF-8** 编码文件，某些字符将无法正确显示。\n\n要解决此问题，可以直接在文件中指定编码来更改文件编码，例如编辑 XML 文件的 XML prolog 中的 `encoding=` 特性，或者在**设置 \\| 编辑器 \\| 文件编码**中更改相应选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LossyEncoding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "国际化",
                      "index": 124,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonSchemaDeprecation",
                "shortDescription": {
                  "text": "弃用的 JSON 属性"
                },
                "fullDescription": {
                  "text": "报告 JSON 文件中弃用的属性。 请注意，JSON 架构规范中尚未定义弃用机制， 并且该检查使用了非标准的扩展 'deprecationMessage'。",
                  "markdown": "报告 JSON 文件中弃用的属性。  \n请注意，JSON 架构规范中尚未定义弃用机制， 并且该检查使用了非标准的扩展 'deprecationMessage'。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JsonSchemaDeprecation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 115,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CheckValidXmlInScriptTagBody",
                "shortDescription": {
                  "text": "'script' 标记的内容格式错误"
                },
                "fullDescription": {
                  "text": "报告是无效 XML 的 'script' 标记的内容。 示例： '<script type=\"text/javascript\">\n    console.log('<');\n  </script>' 在应用快速修复后： '<script type=\"text/javascript\">\n    console.log('&lt;');\n  </script>'",
                  "markdown": "报告是无效 XML 的 `script` 标记的内容。  \n\n**示例：**\n\n\n      <script type=\"text/javascript\">\n        console.log('<');\n      </script>\n\n在应用快速修复后：\n\n\n      <script type=\"text/javascript\">\n        console.log('&lt;');\n      </script>\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CheckValidXmlInScriptTagBody",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HtmlUnknownAnchorTarget",
                "shortDescription": {
                  "text": "链接中未解析的片段"
                },
                "fullDescription": {
                  "text": "报告 '#' 符号后面的 URL 中未解析的最后部分。",
                  "markdown": "报告 `#` 符号后面的 URL 中未解析的最后部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HtmlUnknownAnchorTarget",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "HTML",
                      "index": 25,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Annotator",
                "shortDescription": {
                  "text": "注解器"
                },
                "fullDescription": {
                  "text": "报告批处理代码检查运行结果中对此文件至关重要的问题（例如，语法错误）。 与检查不同，这些问题通常会在编辑器中高亮显示，并且无法配置。 这些选项控制此检查所执行检查的作用域： 选项报告语法错误：报告解析器相关问题。 选项报告来自语言特定注解器的问题：报告由为相关语言配置的注解器发现的问题 请参阅自定义语言支持：注解器以了解详情。 选项报告其他高亮显示问题：报告特定于当前文件语言的问题（例如，类型不匹配或未报告的异常）。 请参阅自定义语言支持：高亮显示以了解详情。",
                  "markdown": "报告批处理代码检查运行结果中对此文件至关重要的问题（例如，语法错误）。 与检查不同，这些问题通常会在编辑器中高亮显示，并且无法配置。 这些选项控制此检查所执行检查的作用域：\n\n* 选项**报告语法错误**：报告解析器相关问题。\n* 选项**报告来自语言特定注解器的问题** ：报告由为相关语言配置的注解器发现的问题 请参阅[自定义语言支持：注解器](https://plugins.jetbrains.com/docs/intellij/annotator.html)以了解详情。\n* 选项**报告其他高亮显示问题** ：报告特定于当前文件语言的问题（例如，类型不匹配或未报告的异常）。 请参阅[自定义语言支持：高亮显示](https://plugins.jetbrains.com/docs/intellij/syntax-highlighting-and-error-highlighting.html#semantic-highlighting)以了解详情。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Annotator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JsonDuplicatePropertyKeys",
                "shortDescription": {
                  "text": "对象文字中的重复键"
                },
                "fullDescription": {
                  "text": "报告对象文字中重复的键。",
                  "markdown": "报告对象文字中重复的键。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JsonDuplicatePropertyKeys",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JSON 和 JSON5",
                      "index": 115,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpRedundantNestedCharacterClass",
                "shortDescription": {
                  "text": "冗余嵌套字符类"
                },
                "fullDescription": {
                  "text": "报告非必要的嵌套字符类。 示例： '[a-c[x-z]]' 在应用快速修复后： '[a-cx-z]' 2020.2 最新变化",
                  "markdown": "报告非必要的嵌套字符类。\n\n**示例：**\n\n\n      [a-c[x-z]]\n\n在应用快速修复后：\n\n\n      [a-cx-z]\n\n2020.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpRedundantNestedCharacterClass",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpOctalEscape",
                "shortDescription": {
                  "text": "八进制转义"
                },
                "fullDescription": {
                  "text": "报告八进制转义（容易与反向引用混淆）。 使用十六进制转义可避免混淆。 示例： '\\07' 在应用快速修复后： '\\x07' 2017.1 最新变化",
                  "markdown": "报告八进制转义（容易与反向引用混淆）。 使用十六进制转义可避免混淆。\n\n**示例：**\n\n\n      \\07\n\n在应用快速修复后：\n\n\n      \\x07\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "RegExpOctalEscape",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedDefine",
                "shortDescription": {
                  "text": "未使用的定义"
                },
                "fullDescription": {
                  "text": "报告 RELAX-NG 文件 (XML 或 Compact 语法) 中未使用的命名模式 ('define')。 通过另一个文件中的 include 使用的 'define' 元素将被忽略。",
                  "markdown": "报告 RELAX-NG 文件 (XML 或 Compact 语法) 中未使用的命名模式 (`define`)。 通过另一个文件中的 include 使用的 `define` 元素将被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedDefine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "RELAX NG",
                      "index": 142,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RegExpDuplicateAlternationBranch",
                "shortDescription": {
                  "text": "替代项中存在重复分支"
                },
                "fullDescription": {
                  "text": "报告正则表达式替换中的重复分支。 重复分支会降低匹配速度并导致表达式意图不明。 示例： '(alpha|bravo|charlie|alpha)' 在应用快速修复后： '(alpha|bravo|charlie)' 2017.1 最新变化",
                  "markdown": "报告正则表达式替换中的重复分支。 重复分支会降低匹配速度并导致表达式意图不明。\n\n**示例：**\n\n\n      (alpha|bravo|charlie|alpha)\n\n在应用快速修复后：\n\n\n      (alpha|bravo|charlie)\n\n2017.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RegExpDuplicateAlternationBranch",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "正则表达式",
                      "index": 75,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "JavaScript",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "JSUnusedAssignment",
                "shortDescription": {
                  "text": "未使用的赋值"
                },
                "fullDescription": {
                  "text": "报告赋值后从未使用其值的变量。 建议移除未使用的变量以缩短代码并避免冗余分配。 将报告以下情况： 变量赋值后从未读取。 在下次读取变量前，变量的值总是被另一个赋值覆盖。 变量的初始值设定项冗余（出于上述原因之一）。",
                  "markdown": "报告赋值后从未使用其值的变量。  \n建议移除未使用的变量以缩短代码并避免冗余分配。\n\n将报告以下情况：\n\n* 变量赋值后从未读取。\n* 在下次读取变量前，变量的值总是被另一个赋值覆盖。\n* 变量的初始值设定项冗余（出于上述原因之一）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnusedAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/未使用的符号",
                      "index": 27,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FlowJSError",
                "shortDescription": {
                  "text": "Flow 类型检查器"
                },
                "fullDescription": {
                  "text": "报告 Flow 中的错误。",
                  "markdown": "报告 [Flow](https://flowtype.org/) 中的错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "FlowJSError",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Flow 类型检查器",
                      "index": 28,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ShiftOutOfRangeJS",
                "shortDescription": {
                  "text": "通过可能错误的常量进行移位运算"
                },
                "fullDescription": {
                  "text": "报告此类情况下的移位运算，即第二个操作数是合理范围外的常量，例如 '0..31' 范围外的整数移位运算，移位的值为负值或过大的值。",
                  "markdown": "报告此类情况下的移位运算，即第二个操作数是合理范围外的常量，例如 `0..31` 范围外的整数移位运算，移位的值为负值或过大的值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ShiftOutOfRangeJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/按位运算问题",
                      "index": 31,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSClosureCompilerSyntax",
                "shortDescription": {
                  "text": "JSDoc 标记不正确的用法"
                },
                "fullDescription": {
                  "text": "报告 Google Closure Compiler 注解隐含的警告，包括 '@abstract'、'@interface' 和 '@implement' 标记的正确使用情况。",
                  "markdown": "报告 *Google Closure Compiler* 注解隐含的警告，包括 `@abstract`、`@interface` 和 `@implement` 标记的正确使用情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSClosureCompilerSyntax",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BadExpressionStatementJS",
                "shortDescription": {
                  "text": "非赋值或调用的表达式语句"
                },
                "fullDescription": {
                  "text": "报告既非赋值也非调用的表达式语句。 此类语句通常表明有错误。",
                  "markdown": "报告既非赋值也非调用的表达式语句。 此类语句通常表明有错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "BadExpressionStatementJS",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/有效性问题",
                      "index": 42,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingFloatingPointLiteralJS",
                "shortDescription": {
                  "text": "浮点文字会引起混淆"
                },
                "fullDescription": {
                  "text": "报告任何没有小数点的浮点数或小数点前的任何数字 或小数点后的任何数字。 此类文字可能令人困惑，并且违反多种编码标准。",
                  "markdown": "报告任何没有小数点的浮点数或小数点前的任何数字 或小数点后的任何数字。 此类文字可能令人困惑，并且违反多种编码标准。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingFloatingPointLiteralJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueOrBreakFromFinallyBlockJS",
                "shortDescription": {
                  "text": "'continue' 或 'break' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'break' 或 'continue' 语句。 此类语句非常令人困惑，可能隐藏异常，并导致调试复杂化。",
                  "markdown": "报告 `finally` 块中的 `break` 或 `continue` 语句。 此类语句非常令人困惑，可能隐藏异常，并导致调试复杂化。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueOrBreakFromFinallyBlockJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSMethodCanBeStatic",
                "shortDescription": {
                  "text": "方法可以为 'static'"
                },
                "fullDescription": {
                  "text": "报告可以安全地设为 'static' 的类方法。 如果某个方法未引用其类的任何非 static 方法和非 static 字段，并且未在子类中被重写， 则该方法可以为 'static' 方法。 使用下面的第一个复选框只检查 'private' 方法。",
                  "markdown": "报告可以安全地设为 `static` 的类方法。 如果某个方法未引用其类的任何非 static 方法和非 static 字段，并且未在子类中被重写， 则该方法可以为 `static` 方法。\n\n\n使用下面的第一个复选框只检查 `private` 方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSMethodCanBeStatic",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatementJS",
                "shortDescription": {
                  "text": "'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告 'continue' 语句。",
                  "markdown": "报告 `continue` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUndeclaredVariable",
                "shortDescription": {
                  "text": "隐式声明的全局 JavaScript 变量"
                },
                "fullDescription": {
                  "text": "报告全局变量的隐式声明。 示例： 'var aaa = 1; // 优良\n  bbb = 2; // 不良，如果未在某处用 'var' 声明 bbb'",
                  "markdown": "报告全局变量的隐式声明。\n\n示例：\n\n\n      var aaa = 1; // 优良\n      bbb = 2; // 不良，如果未在某处用 'var' 声明 bbb\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSUndeclaredVariable",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SillyAssignmentJS",
                "shortDescription": {
                  "text": "变量被赋值给自己"
                },
                "fullDescription": {
                  "text": "报告 'x = x' 形式的赋值。",
                  "markdown": "报告 `x = x` 形式的赋值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SillyAssignmentJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/赋值问题",
                      "index": 73,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptCheckImport",
                "shortDescription": {
                  "text": "未解析的已导入名称"
                },
                "fullDescription": {
                  "text": "报告 TypeScript 代码的 'import' 声明中未解析的名称或绑定。",
                  "markdown": "报告 TypeScript 代码的 `import` 声明中未解析的名称或绑定。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "TypeScriptCheckImport",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSXSyntaxUsed",
                "shortDescription": {
                  "text": "已使用 JSX 语法"
                },
                "fullDescription": {
                  "text": "报告 JavaScript 代码中 JSX 标记的用法。",
                  "markdown": "报告 JavaScript 代码中 JSX 标记的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JSXSyntaxUsed",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSJoinVariableDeclarationAndAssignment",
                "shortDescription": {
                  "text": "变量声明可与变量的第一个赋值合并"
                },
                "fullDescription": {
                  "text": "报告在没有初始值设定项的情况下声明并且在代码或单个嵌套范围中使用多得多的变量。 建议将此变量移到更靠近其用法的位置，并将其与初始值设定项表达式联接起来。",
                  "markdown": "报告在没有初始值设定项的情况下声明并且在代码或单个嵌套范围中使用多得多的变量。 建议将此变量移到更靠近其用法的位置，并将其与初始值设定项表达式联接起来。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSJoinVariableDeclarationAndAssignment",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ConvertModuleExportToExport",
                "shortDescription": {
                  "text": "使用了 'module.exports' 而不是 'export'"
                },
                "fullDescription": {
                  "text": "报告 'module.export' 语句。 建议将其替换为 'export' 或 'export default' 语句。 请注意，用于将 'module.export' 转换为 'export' 的快速修复不适用于函数或语句内部的 'module.export'，因为 'export' 语句只能位于模块顶层。",
                  "markdown": "报告 `module.export` 语句。 建议将其替换为 `export` 或 `export default` 语句。   \n\n请注意，用于将 `module.export` 转换为 `export` 的快速修复不适用于函数或语句内部的 `module.export`，因为 `export` 语句只能位于模块顶层。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6ConvertModuleExportToExport",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DocumentWriteJS",
                "shortDescription": {
                  "text": "调用 'document.write()'"
                },
                "fullDescription": {
                  "text": "报告对 'document.write()' 或 'document.writeln()' 的方法调用。 在采用显式 DOM 调用（例如 'getElementByID()' 和 'createElement()'）时, 此类调用的大多数用法执行效果更好。 此外，'write()' 和 'writeln()' 调用不适用于 XML DOM，包括用于 XHTML 的 DOM（如果以 XML 格式查看）。 这会导致难以指出错误。",
                  "markdown": "报告对 `document.write()` 或 `document.writeln()` 的方法调用。 在采用显式 DOM 调用（例如 `getElementByID()` 和 `createElement()`）时, 此类调用的大多数用法执行效果更好。 此外，`write()` 和 `writeln()` 调用不适用于 XML DOM，包括用于 XHTML 的 DOM（如果以 XML 格式查看）。 这会导致难以指出错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DocumentWriteJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/DOM 问题",
                      "index": 84,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteRecursionJS",
                "shortDescription": {
                  "text": "无限递归"
                },
                "fullDescription": {
                  "text": "报告肯定会无限递归或 抛出异常的函数。 此类函数可能无法正常返回。",
                  "markdown": "报告肯定会无限递归或 抛出异常的函数。 此类函数可能无法正常返回。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteRecursionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncompatibleMaskJS",
                "shortDescription": {
                  "text": "不兼容的按位掩码运算"
                },
                "fullDescription": {
                  "text": "报告确定评估为 'true' 或 'false' 的按位掩码表达式。 表达式的形式为 '(var & constant1) == constant2' 或 '(var | constant1) == constant2'，其中 'constant1' 和 'constant2' 是不兼容的位掩码常量。 示例： '// 不兼容的掩码：由于掩码中的最后一个字节为零，\n// 0x1200 是可能的，但 0x1234 不可能\nif ((mask & 0xFF00) == 0x1234) {...}'",
                  "markdown": "报告确定评估为 `true` 或 `false` 的按位掩码表达式。 表达式的形式为 `(var & constant1) == constant2` 或 `(var | constant1) == constant2`，其中 `constant1` 和 `constant2` 是不兼容的位掩码常量。\n\n示例：\n\n\n    // 不兼容的掩码：由于掩码中的最后一个字节为零，\n    // 0x1200 是可能的，但 0x1234 不可能\n    if ((mask & 0xFF00) == 0x1234) {...}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncompatibleBitwiseMaskOperation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/按位运算问题",
                      "index": 31,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSDuplicatedDeclaration",
                "shortDescription": {
                  "text": "重复声明"
                },
                "fullDescription": {
                  "text": "报告一个范围中的多个声明。",
                  "markdown": "报告一个范围中的多个声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSDuplicatedDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptValidateGenericTypes",
                "shortDescription": {
                  "text": "不正确的泛型实参"
                },
                "fullDescription": {
                  "text": "报告函数、接口或类声明中的无效类型实参。",
                  "markdown": "报告函数、接口或类声明中的无效类型实参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "TypeScriptValidateGenericTypes",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSMismatchedCollectionQueryUpdate",
                "shortDescription": {
                  "text": "不匹配的集合查询和更新"
                },
                "fullDescription": {
                  "text": "报告查询了其内容但未更新或更新了其内容但未查询 的字段或变量的集合。 这种不匹配的查询和更新毫无意义， 并且可能表明有死码或排版错误。 根据查询方法是否返回某些内容或向其传递回调，来自动检测查询方法。 使用下表指定哪些方法是更新方法。",
                  "markdown": "报告查询了其内容但未更新或更新了其内容但未查询 的字段或变量的集合。 这种不匹配的查询和更新毫无意义， 并且可能表明有死码或排版错误。\n\n\n根据查询方法是否返回某些内容或向其传递回调，来自动检测查询方法。\n使用下表指定哪些方法是更新方法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSMismatchedCollectionQueryUpdate",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6PreferShortImport",
                "shortDescription": {
                  "text": "可以缩短导入"
                },
                "fullDescription": {
                  "text": "报告可缩短其 'from' 部分的 ES6 import。 建议导入父目录。",
                  "markdown": "报告可缩短其 `from` 部分的 ES6 import。 建议导入父目录。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ES6PreferShortImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBitwiseExpressionJS",
                "shortDescription": {
                  "text": "可以简化按位表达式"
                },
                "fullDescription": {
                  "text": "报告包含 'and' 零、 'or' 零或零移位的表达式。 此类表达式可能是由于没有完全完成自动化重构而造成。",
                  "markdown": "报告包含 `and` 零、 ` or` 零或零移位的表达式。 此类表达式可能是由于没有完全完成自动化重构而造成。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBitwiseExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/按位运算问题",
                      "index": 31,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSStringConcatenationToES6Template",
                "shortDescription": {
                  "text": "已使用字符串串联而不是模板文字"
                },
                "fullDescription": {
                  "text": "报告字符串串联。 建议将其替换为模板文字。 示例 '\"result: \" + a + \".\"' 应用快速修复后，代码如下所示： '`result: ${a}.`'",
                  "markdown": "报告字符串串联。 建议将其替换为[模板文字](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)。\n\n示例\n\n     \"result: \" + a + \".\" \n\n应用快速修复后，代码如下所示：\n\n     `result: ${a}.` \n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSStringConcatenationToES6Template",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReplaceAssignmentWithOperatorAssignmentJS",
                "shortDescription": {
                  "text": "赋值可被替换为运算符赋值"
                },
                "fullDescription": {
                  "text": "报告可由运算符赋值替换的赋值运算，以使代码更简洁、更清晰。 示例： 'x = x + 3;'\n  'x = x / 3;'\n 应用快速修复后，结果如下所示：   'x += 3;'\n  'x /= 3;'",
                  "markdown": "报告可由运算符赋值替换的赋值运算，以使代码更简洁、更清晰。\n\n\n示例：\n\n      x = x + 3;\n      x = x / 3;\n\n应用快速修复后，结果如下所示：\n\n      x += 3;\n      x /= 3;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentReplaceableWithOperatorAssignmentJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/赋值问题",
                      "index": 73,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSFileReferences",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告 JavaScript 文件中未解析的文件引用，包括 CommonJS 和 AMD 模块引用。",
                  "markdown": "报告 JavaScript 文件中未解析的文件引用，包括 CommonJS 和 AMD 模块引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSFileReferences",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionWithInconsistentReturnsJS",
                "shortDescription": {
                  "text": "函数的返回不一致"
                },
                "fullDescription": {
                  "text": "报告在某些情况下返回值但在其他情况下不返回值的函数。 这通常表明有错误。 示例： 'function foo() {\n  if (true)\n    return 3;\n  return;\n}'",
                  "markdown": "报告在某些情况下返回值但在其他情况下不返回值的函数。 这通常表明有错误。\n\n示例：\n\n\n    function foo() {\n      if (true)\n        return 3;\n      return;\n    }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionWithInconsistentReturnsJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/有效性问题",
                      "index": 42,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ClassMemberInitializationOrder",
                "shortDescription": {
                  "text": "在 static 初始值设定项中使用可能未分配的属性"
                },
                "fullDescription": {
                  "text": "报告引用另一个未提升的类成员，而被引用的这个类成员可能尚未初始化的类成员初始值设定项。 由于针对字段进行类成员初始化，所以一个字段不能引用后面声明的另一个字段。",
                  "markdown": "报告引用另一个未提升的类成员，而被引用的这个类成员可能尚未初始化的类成员初始值设定项。   \n\n由于针对字段进行类成员初始化，所以一个字段不能引用后面声明的另一个字段。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ES6ClassMemberInitializationOrder",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedFunctionJS",
                "shortDescription": {
                  "text": "嵌套函数"
                },
                "fullDescription": {
                  "text": "报告嵌套在另一个函数中的函数。 尽管 JavaScript 允许嵌套函数，但此类结构可能令人困惑。 使用下面的复选框以忽略匿名嵌套函数。",
                  "markdown": "报告嵌套在另一个函数中的函数。 尽管 JavaScript 允许嵌套函数，但此类结构可能令人困惑。\n\n\n使用下面的复选框以忽略匿名嵌套函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedFunctionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6DestructuringVariablesMerge",
                "shortDescription": {
                  "text": "正在析构具有相同键的属性"
                },
                "fullDescription": {
                  "text": "报告多个包含相同键的解构属性。 建议合并这些属性。",
                  "markdown": "报告多个包含相同键的解构属性。 建议合并这些属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6DestructuringVariablesMerge",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptRedundantGenericType",
                "shortDescription": {
                  "text": "冗余类型实参"
                },
                "fullDescription": {
                  "text": "报告其值等于默认值并且可以移除的类型实参。 示例： 'type Foo<T=number> = T;\nlet z: Foo<number>;'",
                  "markdown": "报告其值等于默认值并且可以移除的类型实参。\n\n\n示例：\n\n\n    type Foo<T=number> = T;\n    let z: Foo<number>;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TypeScriptRedundantGenericType",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptUMDGlobal",
                "shortDescription": {
                  "text": "已引用的 UMD 全局变量"
                },
                "fullDescription": {
                  "text": "如果当前文件是模块（ECMAScript 或 CommonJS），则报告 Universal Module Definition (UMD) 全局变量的用法。 如果没有隐式包含此库，那么在没有显式 import 的情况下引用 UMD 变量可能会导致运行时错误。",
                  "markdown": "如果当前文件是模块（ECMAScript 或 CommonJS），则报告 Universal Module Definition (UMD) 全局变量的用法。 如果没有隐式包含此库，那么在没有显式 import 的情况下引用 UMD 变量可能会导致运行时错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TypeScriptUMDGlobal",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryReturnJS",
                "shortDescription": {
                  "text": "不必要的 'return' 语句"
                },
                "fullDescription": {
                  "text": "报告不必要的 'return' 语句，即不返回值并且刚好在函数'贯穿'底部之前发生的 'return' 语句。 这些语句可以安全移除。",
                  "markdown": "报告不必要的 `return` 语句，即不返回值并且刚好在函数'贯穿'底部之前发生的 `return` 语句。 这些语句可以安全移除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryReturnStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSLastCommaInObjectLiteral",
                "shortDescription": {
                  "text": "对象文字中的最后一个逗号多余"
                },
                "fullDescription": {
                  "text": "报告对象文字中尾随逗号的用法。 只有将 JavaScript 语言版本设置为 ECMAScript 5.1 时才报告该警告。 此规范允许在对象文字中使用尾随逗号，但在使用尾随逗号时，某些浏览器可能会抛出错误。 您可以在代码样式 | JavaScript 或 TypeScript | 标点符号中配置尾随逗号的格式设置选项。",
                  "markdown": "报告对象文字中尾随逗号的用法。\n\n只有将 JavaScript 语言版本设置为 ECMAScript 5.1 时才报告该警告。\n\n此规范允许在对象文字中使用尾随逗号，但在使用尾随逗号时，某些浏览器可能会抛出错误。\n\n您可以在**代码样式** \\| **JavaScript** 或 **TypeScript** \\| **标点符号**中配置尾随逗号的格式设置选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSLastCommaInObjectLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StandardJS",
                "shortDescription": {
                  "text": "标准代码样式"
                },
                "fullDescription": {
                  "text": "报告 JavaScript Standard Style linter 检测到的差异。 编辑器中高亮显示的严重性基于 linter 报告的严重性级别。",
                  "markdown": "报告 [JavaScript Standard Style](https://standardjs.com/) linter 检测到的差异。   \n\n编辑器中高亮显示的严重性基于 linter 报告的严重性级别。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "StandardJS",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码质量工具",
                      "index": 102,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedAssignmentJS",
                "shortDescription": {
                  "text": "嵌套赋值"
                },
                "fullDescription": {
                  "text": "报告嵌套在另一个表达式中的赋值表达式，例如 'a=b=1'。 此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。",
                  "markdown": "报告嵌套在另一个表达式中的赋值表达式，例如 `a=b=1`。 此类表达式可能令人困惑，并违反一般设计原则，即给定结构只应发挥一种作用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedAssignmentJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/赋值问题",
                      "index": 73,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DefaultNotLastCaseInSwitchJS",
                "shortDescription": {
                  "text": "'default' 不是 'switch' 中的最后一个 case"
                },
                "fullDescription": {
                  "text": "报告其中的 'default' case 位于另一个 case 之前， 而不是作为最后一个 case，因而可能造成混淆的 'switch' 语句。",
                  "markdown": "报告其中的 `default` case 位于另一个 case 之前， 而不是作为最后一个 case，因而可能造成混淆的 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DefaultNotLastCaseInSwitchJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyFinallyBlockJS",
                "shortDescription": {
                  "text": "空 'finally' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'finally' 块，此类块通常表明有错误。",
                  "markdown": "报告空的 `finally` 块，此类块通常表明有错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyFinallyBlockJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSCommentMatchesSignature",
                "shortDescription": {
                  "text": "不匹配的 JSDoc 和函数签名"
                },
                "fullDescription": {
                  "text": "报告 JSDoc 注释中形参的名称和数量与函数的实际形参之间不匹配的情况。 建议更新 JSDoc 注释中的形参。 示例： '/**\n * @param height Height in pixels\n */\nfunction sq(height, width) {} // 宽度未记录' 在应用快速修复后： '/**\n * @param height Height in pixels\n * @param width\n */\nfunction sq(height, width) {}'",
                  "markdown": "报告 JSDoc 注释中形参的名称和数量与函数的实际形参之间不匹配的情况。 建议更新 JSDoc 注释中的形参。\n\n**示例：**\n\n\n    /**\n     * @param height Height in pixels\n     */\n    function sq(height, width) {} // 宽度未记录\n\n在应用快速修复后：\n\n\n    /**\n     * @param height Height in pixels\n     * @param width\n     */\n    function sq(height, width) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSCommentMatchesSignature",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopThatDoesntUseLoopVariableJS",
                "shortDescription": {
                  "text": "'for' 循环中的 update 或 condition 未使用循环变量"
                },
                "fullDescription": {
                  "text": "报告其中的条件或更新不使用 'for' 循环变量的 'for' 循环。",
                  "markdown": "报告其中的条件或更新不使用 `for` 循环变量的 `for` 循环。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopThatDoesntUseLoopVariableJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptAbstractClassConstructorCanBeMadeProtected",
                "shortDescription": {
                  "text": "抽象类构造函数可以设为 protected"
                },
                "fullDescription": {
                  "text": "报告 abstract 类的 public 构造函数，并建议将其设置为 protected（因为将其设置为 public 是无用的）。",
                  "markdown": "报告 abstract 类的 public 构造函数，并建议将其设置为 protected（因为将其设置为 public 是无用的）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TypeScriptAbstractClassConstructorCanBeMadeProtected",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionWithMultipleReturnPointsJS",
                "shortDescription": {
                  "text": "函数具有多个返回点"
                },
                "fullDescription": {
                  "text": "报告具有多个返回点的函数。 此类函数难以理解和维护。",
                  "markdown": "报告具有多个返回点的函数。 此类函数难以理解和维护。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionWithMultipleReturnPointsJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/函数指标",
                      "index": 111,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThreeNegationsPerFunctionJS",
                "shortDescription": {
                  "text": "函数包含三个以上的否定"
                },
                "fullDescription": {
                  "text": "报告具有三项或更多项否定运算（'!' 或 '!='）的函数。 此类函数可能造成不必要的混淆。",
                  "markdown": "报告具有三项或更多项否定运算（`!` 或 `!=`）的函数。 此类函数可能造成不必要的混淆。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionWithMoreThanThreeNegationsJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/函数指标",
                      "index": 111,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSRemoveUnnecessaryParentheses",
                "shortDescription": {
                  "text": "不必要的圆括号"
                },
                "fullDescription": {
                  "text": "报告冗余圆括号。 在表达式中： 'var x = ((1) + 2) + 3' 在箭头函数实参列表中： 'var incrementer = (x) => x + 1' 在 TypeScript 和 Flow 类型声明中： 'type Card = (Suit & Rank) | (Suit & Number)'",
                  "markdown": "报告冗余圆括号。\n\n在表达式中：\n\n    var x = ((1) + 2) + 3\n\n在箭头函数实参列表中：\n\n    var incrementer = (x) => x + 1\n\n在 TypeScript 和 Flow 类型声明中：\n\n    type Card = (Suit & Rank) | (Suit & Number)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSRemoveUnnecessaryParentheses",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialIfJS",
                "shortDescription": {
                  "text": "冗余的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告可以简化为单个赋值 或 'return' 语句的 'if' 语句。 示例： 'if(foo())\n {\n  return true;\n }\n else\n {\n   return false;\n }' 应用快速修复后，代码如下所示：  'return foo();'",
                  "markdown": "报告可以简化为单个赋值 或 `return` 语句的 `if` 语句。\n\n示例：\n\n\n    if(foo())\n     {\n      return true;\n     }\n     else\n     {\n       return false;\n     }\n\n应用快速修复后，代码如下所示：\n\n     return foo();\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantIfStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CommaExpressionJS",
                "shortDescription": {
                  "text": "逗号表达式"
                },
                "fullDescription": {
                  "text": "报告逗号表达式。 此类表达式通常表明代码过于巧妙，并且可能导致难以捉摸的错误。 初始值设定项中的逗号表达式或 'for' 循环的 update 部分中的逗号表达式 被忽略。",
                  "markdown": "报告逗号表达式。 此类表达式通常表明代码过于巧妙，并且可能导致难以捉摸的错误。 初始值设定项中的逗号表达式或 `for` 循环的 update 部分中的逗号表达式 被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CommaExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6BindWithArrowFunction",
                "shortDescription": {
                  "text": "箭头函数 'bind' 用法可疑"
                },
                "fullDescription": {
                  "text": "报告 'bind' 与箭头函数一起使用的情况。 由于箭头函数使用词法 'this'，所以 'bind' 调用对它们无效。 有关详细信息，请参阅此处。",
                  "markdown": "报告 `bind` 与箭头函数一起使用的情况。  \n由于箭头函数使用词法 `this`，所以 `bind` 调用对它们无效。  \n有关详细信息，请参阅[此处](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Lexical_this)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ES6BindWithArrowFunction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSBitwiseOperatorUsage",
                "shortDescription": {
                  "text": "按位运算符用法"
                },
                "fullDescription": {
                  "text": "报告按位 AND (\"'&'\") 或 OR (\"'|'\") 运算符的可疑用法。 通常这是拼写错误，应为应用布尔运算 AND (\"'&&'\") 和 OR (\"'||'\") 的结果。",
                  "markdown": "报告按位 AND (\"`&`\") 或 OR (\"`|`\") 运算符的可疑用法。 通常这是拼写错误，应为应用布尔运算 AND (\"`&&`\") 和 OR (\"`||`\") 的结果。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSBitwiseOperatorUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/按位运算问题",
                      "index": 31,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnterminatedStatementJS",
                "shortDescription": {
                  "text": "未终止的语句"
                },
                "fullDescription": {
                  "text": "报告结尾不带分号或换行符的语句。 在编辑器 | 代码样式 | JavaScript 或 TypeScript - 标点符号中选择“用分号结束语句”选项，报告任何不以分号结尾的语句，即使末尾使用了换行符时也报告。 根据某些编码样式，为了与其他语言相一致，分号比换行符更可取。",
                  "markdown": "报告结尾不带分号或换行符的语句。\n\n在*编辑器 \\| 代码样式 \\| JavaScript 或 TypeScript - 标点符号*中选择\"用分号结束语句\"选项，报告任何不以分号结尾的语句，即使末尾使用了换行符时也报告。\n根据某些编码样式，为了与其他语言相一致，分号比换行符更可取。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnterminatedStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithIdenticalBranchesJS",
                "shortDescription": {
                  "text": "'if' 语句的分支相同"
                },
                "fullDescription": {
                  "text": "报告具有相同的 'then' 和 'else' 分支的 'if' 语句。 此类语句几乎 肯定有错误。",
                  "markdown": "报告具有相同的 `then` 和 `else` 分支的 `if` 语句。 此类语句几乎 肯定有错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithIdenticalBranchesJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSConsecutiveCommasInArrayLiteral",
                "shortDescription": {
                  "text": "数组文字中的连续逗号"
                },
                "fullDescription": {
                  "text": "报告数组文字中的连续逗号。 跳过的元素接受 'undefined' 值， 但这可能是无意为之，例如，当逗号位于一行的末尾和下一行的开头时。",
                  "markdown": "报告数组文字中的连续逗号。 跳过的元素接受 `undefined` 值， 但这可能是无意为之，例如，当逗号位于一行的末尾和下一行的开头时。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSConsecutiveCommasInArrayLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnreachableSwitchBranches",
                "shortDescription": {
                  "text": "不可到达 'switch' 语句的 'case' 分支"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句不可到达的 'case' 分支。 示例： '/**\n * @param {('foo' | 'bar')} p\n */\nfunction foo(p) {\n    switch (p) {\n        case 'foo': break;\n        case 'bar': break;\n        case 'baz': break; // 不可到达\n    }\n}'",
                  "markdown": "报告 `switch` 语句不可到达的 `case` 分支。\n\n示例：\n\n\n    /**\n     * @param {('foo' | 'bar')} p\n     */\n    function foo(p) {\n        switch (p) {\n            case 'foo': break;\n            case 'bar': break;\n            case 'baz': break; // 不可到达\n        }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnreachableSwitchBranches",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrivialConditionalJS",
                "shortDescription": {
                  "text": "冗余条件表达式"
                },
                "fullDescription": {
                  "text": "报告如下格式的条件表达式 'condition ? true : false\ncondition ? false : true' 这些表达式可以安全地转换为 'condition\n!condition'",
                  "markdown": "报告如下格式的条件表达式\n\n\n    condition ? true : false\n    condition ? false : true\n\n\n这些表达式可以安全地转换为\n\n\n    condition\n    !condition\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantConditionalExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSValidateTypes",
                "shortDescription": {
                  "text": "类型不匹配"
                },
                "fullDescription": {
                  "text": "报告类型不正确的以下对象： 函数调用中的形参 返回值 赋值表达式 将忽略 TypeScript 代码。",
                  "markdown": "报告类型不正确的以下对象：\n\n* 函数调用中的形参\n* 返回值\n* 赋值表达式\n\n将忽略 TypeScript 代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSValidateTypes",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSTestFailedLine",
                "shortDescription": {
                  "text": "在测试代码中高亮显示失败的行"
                },
                "fullDescription": {
                  "text": "报告失败的方法调用或测试中的断言。",
                  "markdown": "报告失败的方法调用或测试中的断言。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSTestFailedLine",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/单元测试",
                      "index": 132,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IfStatementWithTooManyBranchesJS",
                "shortDescription": {
                  "text": "'if' 语句的分支过多"
                },
                "fullDescription": {
                  "text": "报告分支过多的 'if' 语句。 此类语句可能令人困惑，并且通常表明设计抽象级别不足。 使用下面的字段可指定预期的最大分支数。",
                  "markdown": "报告分支过多的 `if` 语句。 此类语句可能令人困惑，并且通常表明设计抽象级别不足。\n\n\n使用下面的字段可指定预期的最大分支数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IfStatementWithTooManyBranchesJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatementJS",
                "shortDescription": {
                  "text": "'break' 语句"
                },
                "fullDescription": {
                  "text": "报告 'break' 语句。 忽略结束 case 块的 'break' 语句。",
                  "markdown": "报告 `break` 语句。 忽略结束 case 块的 `break` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSPotentiallyInvalidUsageOfClassThis",
                "shortDescription": {
                  "text": "从闭包对类中 'this' 的引用可能无效"
                },
                "fullDescription": {
                  "text": "报告试图通过不是 lambda 的嵌套函数中的 'this.' 限定符，来引用 ECMAScript 类成员的情况。 不是 lambda 的嵌套函数中的 'this' 是函数自身的 'this'，与外部类无关。",
                  "markdown": "报告试图通过不是 lambda 的嵌套函数中的 `this.` 限定符，来引用 ECMAScript 类成员的情况。  \n不是 lambda 的嵌套函数中的 `this` 是函数自身的 ` this`，与外部类无关。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSPotentiallyInvalidUsageOfClassThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DebuggerStatementJS",
                "shortDescription": {
                  "text": "'debugger' 语句"
                },
                "fullDescription": {
                  "text": "报告用于与 Javascript 调试器交互的 'debugger' 语句。 此类语句不应出现在生产代码中。",
                  "markdown": "报告用于与 Javascript 调试器交互的 `debugger` 语句。 此类语句不应出现在生产代码中。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DebuggerStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryContinueJS",
                "shortDescription": {
                  "text": "不必要的 'continue' 语句"
                },
                "fullDescription": {
                  "text": "报告循环末尾不必要的 'continue' 语句。 建议移除这些语句。",
                  "markdown": "报告循环末尾不必要的 ` continue` 语句。 建议移除这些语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryContinueJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BreakStatementWithLabelJS",
                "shortDescription": {
                  "text": "带标签的 'break' 语句"
                },
                "fullDescription": {
                  "text": "报告 'break' 标签语句。",
                  "markdown": "报告 `break` 标签语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BreakStatementWithLabelJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSDeclarationsAtScopeStart",
                "shortDescription": {
                  "text": "'var' 未在函数开头声明"
                },
                "fullDescription": {
                  "text": "检查使用 var 声明的局部变量的声明是否位于函数范围的顶部。 默认情况下，在执行代码时，变量声明总是被隐形地移动（“提升”）到它所包含的范围的顶部。 因此，在范围顶部声明有助于在代码中表现出这种行为。",
                  "markdown": "检查使用 **var** 声明的局部变量的声明是否位于函数范围的顶部。   \n\n默认情况下，在执行代码时，变量声明总是被隐形地移动（\"提升\"）到它所包含的范围的顶部。 因此，在范围顶部声明有助于在代码中表现出这种行为。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSDeclarationsAtScopeStart",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToForLoopParameterJS",
                "shortDescription": {
                  "text": "赋值给 'for' 循环形参"
                },
                "fullDescription": {
                  "text": "报告对声明为 'for' 循环形参的变量的赋值。 虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由错误所致。",
                  "markdown": "报告对声明为 ` for` 循环形参的变量的赋值。 虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由错误所致。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToForLoopParameterJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/赋值问题",
                      "index": 73,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ConvertIndexedForToForOf",
                "shortDescription": {
                  "text": "已使用索引的 'for' 而不是 'for..of'"
                },
                "fullDescription": {
                  "text": "报告对数组使用的 'for' 索引循环。 建议将其替换为 'for..of' 循环。 'for..of' 循环 (在 ECMAScript 6 中引入) 对 'iterable' 对象进行迭代。",
                  "markdown": "报告对数组使用的 [for](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for) 索引循环。 建议将其替换为 [for..of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) 循环。   \n`for..of` 循环 (在 ECMAScript 6 中引入) 对 `iterable` 对象进行迭代。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6ConvertIndexedForToForOf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpressionJS",
                "shortDescription": {
                  "text": "条件表达式"
                },
                "fullDescription": {
                  "text": "报告三元条件表达式。 有些编码标准禁止此类表达式， 而是支持显式的 'if' 语句。",
                  "markdown": "报告三元条件表达式。 有些编码标准禁止此类表达式， 而是支持显式的 `if` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ConvertVarToLetConst",
                "shortDescription": {
                  "text": "已使用 'var' 而不是 'let' 或 'const'"
                },
                "fullDescription": {
                  "text": "报告使用 'var' 而不是 'let' 或 'const' 的声明。 'let' 和 'const' 的作用范围都为块，行为更为严格。 建议将所有 'var' 声明替换为 'let' 或 'const' 声明，具体取决于特定值的语义。 为避免引用错误，可将声明移至函数顶部，或放在变量的第一个用法前。 选择'通过‘全部修复’操作保守地转换变量'选项，以防止使用“全部修复”操作时在这些复杂情况下出现任何更改。",
                  "markdown": "报告使用 `var` 而不是 `let` 或 `const` 的声明。  \n`let` 和 `const` 的作用范围都为块，行为更为严格。   \n\n建议将所有 `var` 声明替换为 `let` 或 `const` 声明，具体取决于特定值的语义。 为避免引用错误，可将声明移至函数顶部，或放在变量的第一个用法前。   \n选择'通过'全部修复'操作保守地转换变量'选项，以防止使用\"全部修复\"操作时在这些复杂情况下出现任何更改。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6ConvertVarToLetConst",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessBooleanExpressionJS",
                "shortDescription": {
                  "text": "无意义的语句或布尔表达式"
                },
                "fullDescription": {
                  "text": "报告无意义或复杂的没有意义的布尔表达式或语句。 示例： 'let a = !(false && x);\n  let b = false || x;' 应用快速修复后，结果如下所示： 'let a = true;\n  let b = x;'",
                  "markdown": "报告无意义或复杂的没有意义的布尔表达式或语句。\n\n示例：\n\n\n      let a = !(false && x);\n      let b = false || x;\n\n应用快速修复后，结果如下所示：\n\n\n      let a = true;\n      let b = x;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessBooleanExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DynamicallyGeneratedCodeJS",
                "shortDescription": {
                  "text": "执行动态生成的代码"
                },
                "fullDescription": {
                  "text": "报告 'eval()'、'setTimeout()' 或 'setInterval()' 函数的调用或 'Function' 对象的分配。 这些函数用于执行通常动态生成的 任意 JavaScript 文本字符串。 这可能非常令人困惑，并且可能存在安全风险。 忽略静态地向这些方法提供回调函数而不生成代码的情况。",
                  "markdown": "报告 `eval()`、`setTimeout()` 或 `setInterval()` 函数的调用或 `Function` 对象的分配。 这些函数用于执行通常动态生成的 任意 JavaScript 文本字符串。 这可能非常令人困惑，并且可能存在安全风险。   \n\n忽略静态地向这些方法提供回调函数而不生成代码的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DynamicallyGeneratedCodeJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUrlImportUsage",
                "shortDescription": {
                  "text": "使用了 URL 导入"
                },
                "fullDescription": {
                  "text": "检查 JavaScript 语言中使用过的 URL import。 建议下载指定的远程 URL 的模块。 此类关联使 IDE 可以提供正确的代码补全和导航。 只有 JavaScript 语言中的 ECMAScript 模块支持 import 说明符中的 URL。",
                  "markdown": "检查 JavaScript 语言中使用过的 URL import。 建议下载指定的远程 URL 的模块。 此类关联使 IDE 可以提供正确的代码补全和导航。   \n\n只有 JavaScript 语言中的 ECMAScript 模块支持 import 说明符中的 URL。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSUrlImportUsage",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Import 和依赖项",
                      "index": 140,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnContinueStatementJS",
                "shortDescription": {
                  "text": "'continue' 语句上的不必要标签"
                },
                "fullDescription": {
                  "text": "报告可以在不更改控制流的情况下移除其标签的 'continue' 标签语句。",
                  "markdown": "报告可以在不更改控制流的情况下移除其标签的 `continue` 标签语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnContinueStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSPotentiallyInvalidTargetOfIndexedPropertyAccess",
                "shortDescription": {
                  "text": "索引的属性访问的目标可能不正确"
                },
                "fullDescription": {
                  "text": "报告可能无效的索引属性访问，例如 'Array[1]'。",
                  "markdown": "报告可能无效的索引属性访问，例如 `Array[1]`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSPotentiallyInvalidTargetOfIndexedPropertyAccess",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedCatchParameterJS",
                "shortDescription": {
                  "text": "未使用的 'catch' 形参"
                },
                "fullDescription": {
                  "text": "报告未在相应的块中使用的 'catch' 形参。 将忽略名称为 'ignore' 或 'ignored' 的 'catch' 形参。 使用下面的复选框对包含注释的 'catch' 块禁用此检查。",
                  "markdown": "报告未在相应的块中使用的 `catch` 形参。 将忽略名称为 `ignore` 或 `ignored` 的 `catch` 形参。\n\n\n使用下面的复选框对包含注释的\n`catch` 块禁用此检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedCatchParameterJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnonymousFunctionJS",
                "shortDescription": {
                  "text": "匿名函数"
                },
                "fullDescription": {
                  "text": "报告匿名函数。 函数表达式的显式名称可能有助于调试。 如果 ECMAScript 6 标准中指定了 'name' 属性，则忽略没有名称的函数表达式。 例如，不会报告 'var bar = function() {};'。",
                  "markdown": "报告匿名函数。 函数表达式的显式名称可能有助于调试。 如果 ECMAScript 6 标准中指定了 `name` 属性，则忽略没有名称的函数表达式。 例如，不会报告 `var bar = function() {};`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnonymousFunctionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSTypeOfValues",
                "shortDescription": {
                  "text": "包含非标准值的 'typeof' 比较"
                },
                "fullDescription": {
                  "text": "报告 'typeof' 表达式与不是以下标准类型之一的文字字符串的比较：'undefined'、'object'、'boolean'、'number'、'string'、'function' 或 'symbol'。 此类比较始终返回 'false'。",
                  "markdown": "报告 `typeof` 表达式与不是以下标准类型之一的文字字符串的比较：`undefined`、`object`、`boolean`、`number`、`string`、`function` 或 `symbol`。 此类比较始终返回 `false`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSTypeOfValues",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyCatchBlockJS",
                "shortDescription": {
                  "text": "空 'catch' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'catch' 块。 这表明错误未加处理就被直接忽略。 'catch' 块中的任何注释都会禁止该检查。",
                  "markdown": "报告空的 `catch` 块。 这表明错误未加处理就被直接忽略。   \n\n`catch` 块中的任何注释都会禁止该检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyCatchBlockJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThrowFromFinallyBlockJS",
                "shortDescription": {
                  "text": "'throw' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'throw' 语句。 此类 'throw' 语句可能会掩盖抛出的异常，并导致调试复杂化。",
                  "markdown": "报告 `finally` 块中的 `throw` 语句。 此类 `throw` 语句可能会掩盖抛出的异常，并导致调试复杂化。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThrowInsideFinallyBlockJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSPotentiallyInvalidUsageOfThis",
                "shortDescription": {
                  "text": "从闭包对 'this' 的引用可能无效"
                },
                "fullDescription": {
                  "text": "报告闭包中的用于引用外部上下文属性的 'this'。 示例： 'function Outer() {\n  this.outerProp = 1;\n  function inner() {\n    // 不良，因为 Outer 的 'outerProp' \n    // 不会如预期的那样\n    // 在调用 'new Outer()' 时在此处进行更新\n    this.outerProp = 2;\n  }\n  inner();\n}'",
                  "markdown": "报告闭包中的用于引用外部上下文属性的 `this`。\n\n示例：\n\n\n    function Outer() {\n      this.outerProp = 1;\n      function inner() {\n        // 不良，因为 Outer 的 'outerProp' \n        // 不会如预期的那样\n        // 在调用 'new Outer()' 时在此处进行更新\n        this.outerProp = 2;\n      }\n      inner();\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSPotentiallyInvalidUsageOfThis",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnresolvedLibraryURL",
                "shortDescription": {
                  "text": "HTTP 链接缺少本地存储的库"
                },
                "fullDescription": {
                  "text": "报告未与任何本地存储文件关联的外部 JavaScript 库的 URL。 建议下载此库。 此类关联使 IDE 可以提供正确的代码补全和导航。",
                  "markdown": "报告未与任何本地存储文件关联的外部 JavaScript 库的 URL。 建议下载此库。 此类关联使 IDE 可以提供正确的代码补全和导航。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnresolvedLibraryURL",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "XHTMLIncompatabilitiesJS",
                "shortDescription": {
                  "text": "不兼容的 XHTML 用法"
                },
                "fullDescription": {
                  "text": "报告可能会导致 XHTML 文档出现问题的 常见 JavaScript DOM 模式。 特别是，根据文档是作为 XML 还是 HTML 加载， 所检测到的模式的行为将完全不同。 这可能导致难以捉摸的错误，即脚本行为依赖于文档的 MIME 类型而不是依赖于其内容。 检测到的模式包括 document.body、 document.images、 document.applets、 document.links、 document.forms 和 document.anchors。",
                  "markdown": "报告可能会导致 XHTML 文档出现问题的 常见 JavaScript DOM 模式。 特别是，根据文档是作为 XML 还是 HTML 加载， 所检测到的模式的行为将完全不同。 这可能导致难以捉摸的错误，即脚本行为依赖于文档的 MIME 类型而不是依赖于其内容。 检测到的模式包括 **document.body** 、 **document.images** 、 **document.applets** 、 **document.links** 、 **document.forms** 和 **document.anchors**。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "XHTMLIncompatabilitiesJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/DOM 问题",
                      "index": 84,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptFieldCanBeMadeReadonly",
                "shortDescription": {
                  "text": "可以为只读字段"
                },
                "fullDescription": {
                  "text": "报告可设为 readonly 的 private 字段（例如，如果该字段仅在构造函数中赋值）。",
                  "markdown": "报告可设为 readonly 的 private 字段（例如，如果该字段仅在构造函数中赋值）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TypeScriptFieldCanBeMadeReadonly",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedIfStatementJS",
                "shortDescription": {
                  "text": "否定的 'if' 语句"
                },
                "fullDescription": {
                  "text": "报告具有 else 分支和否定条件的 if 语句。 翻转 if 和 else 分支的顺序通常会改进此类语句的清晰度。",
                  "markdown": "报告具有 **else** 分支和否定条件的 **if** 语句。 翻转 **if** 和 **else** 分支的顺序通常会改进此类语句的清晰度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedIfStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConditionalExpressionWithIdenticalBranchesJS",
                "shortDescription": {
                  "text": "具有相同分支的条件表达式"
                },
                "fullDescription": {
                  "text": "报告具有相同的 'then' 和 'else' 分支的三元条件表达式。",
                  "markdown": "报告具有相同的 `then` 和 `else` 分支的三元条件表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConditionalExpressionWithIdenticalBranchesJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSIncompatibleTypesComparison",
                "shortDescription": {
                  "text": "类型不兼容的表达式的比较"
                },
                "fullDescription": {
                  "text": "报告与不兼容类型的操作数或不含可能公共值的类型的操作数的比较。",
                  "markdown": "报告与不兼容类型的操作数或不含可能公共值的类型的操作数的比较。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSIncompatibleTypesComparison",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSAnnotator",
                "shortDescription": {
                  "text": "未遵循 ECMAScript 规范"
                },
                "fullDescription": {
                  "text": "报告基本语法问题以及与语言规范不一致的情况，例如关键字的无效用法、不兼容的数字格式的用法或 getter/setter 的多个形参。 通常必须报告此类错误，并且不应禁用这些错误。 但在某些情况下，例如由于 JavaScript 的动态性质而导致问题、使用尚未支持的语言功能或 IDE 检查器中有错误时，禁止报告这些很基本的错误可能会很方便。",
                  "markdown": "报告基本语法问题以及与语言规范不一致的情况，例如关键字的无效用法、不兼容的数字格式的用法或 getter/setter 的多个形参。   \n通常必须报告此类错误，并且不应禁用这些错误。 但在某些情况下，例如由于 JavaScript 的动态性质而导致问题、使用尚未支持的语言功能或 IDE 检查器中有错误时，禁止报告这些很基本的错误可能会很方便。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JSAnnotator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6TopLevelAwaitExpression",
                "shortDescription": {
                  "text": "顶层 'await' 表达式"
                },
                "fullDescription": {
                  "text": "报告顶层 'await' 表达式的用法。 虽然有人在提出新的 'top-level async' 建议，但不允许在 async 函数之外使用 'await'。",
                  "markdown": "报告顶层 `await` 表达式的用法。 虽然有人在提出新的 'top-level async' 建议，但不允许在 async 函数之外使用 `await`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ES6TopLevelAwaitExpression",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Async 代码和 promise",
                      "index": 148,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ConvertToForOf",
                "shortDescription": {
                  "text": "使用了 'for..in' 而不是 'for..of'"
                },
                "fullDescription": {
                  "text": "报告对数组的 'for..in' 循环的用法。 建议将其替换为 'for..of' 循环。 'for..of' 循环 (在 ECMAScript 6 中引入) 对 'iterable' 对象进行迭代。 对于数组，此结构比 'for..in' 更可取，因为它只处理数组值，不处理数组对象的属性。",
                  "markdown": "报告对数组的 [for..in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in) 循环的用法。 建议将其替换为 [for..of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) 循环。   \n`for..of` 循环 (在 ECMAScript 6 中引入) 对 `iterable` 对象进行迭代。 对于数组，此结构比 `for..in` 更可取，因为它只处理数组值，不处理数组对象的属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6ConvertToForOf",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParameterNamingConventionJS",
                "shortDescription": {
                  "text": "函数形参命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合 指定正则表达式模式的函数形参。 使用下面提供的字段来指定局部变量名称的最小长度、 最大长度以及预期的正则表达式。 使用标准 'java.util.regex' 格式的正则表达式。",
                  "markdown": "报告名称太短、太长或不符合 指定正则表达式模式的函数形参。\n\n\n使用下面提供的字段来指定局部变量名称的最小长度、\n最大长度以及预期的正则表达式。 使用标准 `java.util.regex` 格式的正则表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ParameterNamingConventionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/命名约定",
                      "index": 149,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ParametersPerFunctionJS",
                "shortDescription": {
                  "text": "函数的形参过多"
                },
                "fullDescription": {
                  "text": "报告形参过多的函数。 此类函数通常表明设计有问题。 使用下面的字段可指定函数的最大可接受形参数量。",
                  "markdown": "报告形参过多的函数。 此类函数通常表明设计有问题。\n\n\n使用下面的字段可指定函数的最大可接受形参数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexFunctionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/函数指标",
                      "index": 111,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ThisExpressionReferencesGlobalObjectJS",
                "shortDescription": {
                  "text": "引用全局对象的 'this' 表达式"
                },
                "fullDescription": {
                  "text": "报告对象文字或构造函数体之外的 'this' 表达式。 此类 'this' 表达式引用顶级“全局”JavaScript 对象，但大多是无用的。",
                  "markdown": "报告对象文字或构造函数体之外的 ` this` 表达式。 此类 `this` 表达式引用顶级\"全局\"JavaScript 对象，但大多是无用的。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ThisExpressionReferencesGlobalObjectJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/有效性问题",
                      "index": 42,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSSuspiciousNameCombination",
                "shortDescription": {
                  "text": "可疑的变量/形参名称组合"
                },
                "fullDescription": {
                  "text": "报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值或函数调用。 示例： 'var x = 0;\n  var y = x;' 或 'var x = 0, y = 0;\n  var rc = new Rectangle(y, x, 20, 20);' 此处，检查猜测 'x' 和 'y' 混淆了。 指定不应一起使用的名称。 如果形参名称或赋值目标名称包含一个组中的词语，而赋值或传递的变量的名称包含另一个组中的词语，则会报告错误。",
                  "markdown": "报告目标变量或函数形参的名称与分配给它的值的名称不匹配的赋值或函数调用。\n\n示例：\n\n\n      var x = 0;\n      var y = x;\n\n或\n\n\n      var x = 0, y = 0;\n      var rc = new Rectangle(y, x, 20, 20);\n\n此处，检查猜测 `x` 和 `y` 混淆了。\n\n指定不应一起使用的名称。 如果形参名称或赋值目标名称包含一个组中的词语，而赋值或传递的变量的名称包含另一个组中的词语，则会报告错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSSuspiciousNameCombination",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedFunctionCallJS",
                "shortDescription": {
                  "text": "链式函数调用"
                },
                "fullDescription": {
                  "text": "报告目标为另一个函数调用的函数调用，例如 'foo().bar()'",
                  "markdown": "报告目标为另一个函数调用的函数调用，例如 `foo().bar()`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedFunctionCallJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedFunctionCallJS",
                "shortDescription": {
                  "text": "嵌套函数调用"
                },
                "fullDescription": {
                  "text": "报告在另一个函数调用中用作实参的函数调用，例如 'foo(bar())'",
                  "markdown": "报告在另一个函数调用中用作实参的函数调用，例如 `foo(bar())`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedFunctionCallJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSEqualityComparisonWithCoercion",
                "shortDescription": {
                  "text": "相等运算符可能导致类型强制"
                },
                "fullDescription": {
                  "text": "报告可能导致意外类型强制的相等运算符的用法。 建议将 '==' 和 '!=' 替换为类型安全的相等运算符 '===' 和 '!=='。 根据所选的选项，将报告下面的一种情况： '==' 和 '!=' 运算符的所有用法。 除了与 null 比较之外的所有用法。 某些代码样式允许使用 'x == null' 替代 'x === null || x === undefined'。 仅可疑的表达式，例如：'==' 或 '!=' 与 '0'、''''、 'null'、'true'、 'false' 或 'undefined' 比较。",
                  "markdown": "报告可能导致意外类型强制的相等运算符的用法。 建议将 `==` 和 `!=` 替换为类型安全的相等运算符 `===` 和 `!==`。\n\n根据所选的选项，将报告下面的一种情况：\n\n* `==` 和 `!=` 运算符的所有用法。\n* 除了与 null 比较之外的所有用法。 某些代码样式允许使用 `x == null` 替代 `x === null || x === undefined`。\n* 仅可疑的表达式，例如：`==` 或 `!=` 与 `0`、`''`、 `null`、`true`、 `false` 或 `undefined` 比较。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualityComparisonWithCoercionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantOnLHSOfComparisonJS",
                "shortDescription": {
                  "text": "常量位于比较的左侧"
                },
                "fullDescription": {
                  "text": "报告左侧有常量的比较运算。 根据 编码约定，常量应当位于比较的右侧。",
                  "markdown": "报告左侧有常量的比较运算。 根据 编码约定，常量应当位于比较的右侧。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantOnLefSideOfComparisonJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSCheckFunctionSignatures",
                "shortDescription": {
                  "text": "签名不匹配"
                },
                "fullDescription": {
                  "text": "报告其中的实参与所引用函数的签名不匹配的 JavaScript 调用表达式，包括实参的类型及其数量。 也报告在形参和返回类型方面与被重载函数不匹配的重载函数。 将忽略 TypeScript 代码。",
                  "markdown": "报告其中的实参与所引用函数的签名不匹配的 JavaScript 调用表达式，包括实参的类型及其数量。 也报告在形参和返回类型方面与被重载函数不匹配的重载函数。\n\n将忽略 TypeScript 代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSCheckFunctionSignatures",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptUnresolvedReference",
                "shortDescription": {
                  "text": "未解析的 TypeScript 引用"
                },
                "fullDescription": {
                  "text": "报告 TypeScript 代码中的未解析引用。",
                  "markdown": "报告 TypeScript 代码中的未解析引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "TypeScriptUnresolvedReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSNonStrictModeUsed",
                "shortDescription": {
                  "text": "使用了非严格模式"
                },
                "fullDescription": {
                  "text": "报告不处于 'strict' 模式的 JavaScript 文件。",
                  "markdown": "报告不处于 ` strict` 模式的 JavaScript 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSNonStrictModeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6RedundantAwait",
                "shortDescription": {
                  "text": "冗余 'await' 表达式"
                },
                "fullDescription": {
                  "text": "报告 'await' 的冗余用法，例如 'await await' 或等待非 promise 结果。 选择“报告 promise”选项时，建议在适用时（在 'return' 语句中以及包含 'Promise.resolve/reject' 时）移除 promise 前面的 'await'。 在此类上下文中移除 'await' 会导致两个问题。 用 'try-catch' 环绕代码并且忘记添加 'await' 会改变代码语义，而您可能没有注意到这一点。 采用显式的 'await' 可能会阻止 V8 运行时提供异步堆栈跟踪。",
                  "markdown": "报告 `await` 的冗余用法，例如 `await await` 或等待非 promise 结果。\n\n\n选择\"报告 promise\"选项时，建议在适用时（在 `return` 语句中以及包含 `Promise.resolve/reject` 时）移除 promise 前面的 `await`。\n\n在此类上下文中移除 `await` 会导致两个问题。\n\n* 用 `try-catch ` 环绕代码并且忘记添加 `await` 会改变代码语义，而您可能没有注意到这一点。\n* 采用显式的 `await` 可能会阻止 V8 运行时提供[异步堆栈跟踪](http://bit.ly/v8-zero-cost-async-stack-traces)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6RedundantAwait",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Async 代码和 promise",
                      "index": 148,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentToFunctionParameterJS",
                "shortDescription": {
                  "text": "赋值给函数形参"
                },
                "fullDescription": {
                  "text": "报告对函数形参的赋值，包括递增和递减运算。 虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由错误所致。",
                  "markdown": "报告对函数形参的赋值，包括递增和递减运算。 虽然偶尔是有意为之，但此结构可能格外令人困惑，并且通常是由错误所致。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentToFunctionParameterJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/赋值问题",
                      "index": 73,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FallThroughInSwitchStatementJS",
                "shortDescription": {
                  "text": "'switch' 语句中的直落"
                },
                "fullDescription": {
                  "text": "报告可以将控制从一个分支转到下一个分支的 'switch' 语句。 这种“贯穿”通常表示有错误， 例如，缺少 'break' 或 'return'。",
                  "markdown": "报告可以将控制从一个分支转到下一个分支的 `switch` 语句。 这种\"贯穿\"通常表示有错误， 例如，缺少 `break` 或 `return`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FallThroughInSwitchStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallerJS",
                "shortDescription": {
                  "text": "使用 'caller' 属性"
                },
                "fullDescription": {
                  "text": "报告 JavaScript 函数中 'caller' 属性的用法。 使用此属性访问调用方法的堆栈帧可能格外令人困惑，并导致难以捉摸的错误。",
                  "markdown": "报告 JavaScript 函数中 `caller` 属性的用法。 使用此属性访问调用方法的堆栈帧可能格外令人困惑，并导致难以捉摸的错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallerJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptExplicitMemberType",
                "shortDescription": {
                  "text": "显式类型"
                },
                "fullDescription": {
                  "text": "报告与显式类型的当前代码样式不匹配的类型注解。 从上下文推断出的类型与类型注解完全匹配时，不需要类型声明，例如： 'var pi: number = 3.14' 在某些情况下，最好始终采用显式类型 – 这可以防止意外更改类型，并使代码更明确。",
                  "markdown": "报告与显式类型的当前代码样式不匹配的类型注解。\n\n\n从上下文推断出的类型与类型注解完全匹配时，不需要类型声明，例如：\n\n\n        var pi: number = 3.14\n\n在某些情况下，最好始终采用显式类型 -- 这可以防止意外更改类型，并使代码更明确。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TypeScriptExplicitMemberType",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSDuplicateCaseLabel",
                "shortDescription": {
                  "text": "重复的 'case' 标签"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句中重复的 'case' 标签，这通常表示有错误。",
                  "markdown": "报告 `switch` 语句中重复的 `case` 标签，这通常表示有错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSDuplicateCaseLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSSwitchVariableDeclarationIssue",
                "shortDescription": {
                  "text": "声明了变量并在不同的 'case' 子句中使用"
                },
                "fullDescription": {
                  "text": "报告在 'switch' 语句的一个 'case' 子句中声明但在同一语句的另一个 'case' 子句中使用的变量。 对于块范围的变量，这将导致抛出 'ReferenceError'。 对于 'var' 变量，它表示可能有错误。 如果有意使用此模式，请禁用 'var' 变量检查。",
                  "markdown": "报告在 `switch` 语句的一个 `case` 子句中声明但在同一语句的另一个 `case` 子句中使用的变量。 对于块范围的变量，这将导致抛出 `ReferenceError`。 对于 `var` 变量，它表示可能有错误。\n\n如果有意使用此模式，请禁用 `var` 变量检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSSwitchVariableDeclarationIssue",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReuseOfLocalVariableJS",
                "shortDescription": {
                  "text": "局部变量的重用"
                },
                "fullDescription": {
                  "text": "报告重用局部变量并使用无关 初始变量用法的新值覆盖其值的情况。 以这种方式重用局部变量可能会造成混淆， 因为局部变量的预期语义可能随每种用法而变化。 如果代码更改导致预期被覆盖的值任然存在，那么也可能导致错误。 优良的作法是保持变量生命周期尽可能短，而不要为了简洁重用局部变量。",
                  "markdown": "报告重用局部变量并使用无关 初始变量用法的新值覆盖其值的情况。 以这种方式重用局部变量可能会造成混淆， 因为局部变量的预期语义可能随每种用法而变化。 如果代码更改导致预期被覆盖的值任然存在，那么也可能导致错误。 优良的作法是保持变量生命周期尽可能短，而不要为了简洁重用局部变量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReuseOfLocalVariableJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/数据流",
                      "index": 155,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ConvertLetToConst",
                "shortDescription": {
                  "text": "已使用 'let' 而不是 'const'"
                },
                "fullDescription": {
                  "text": "报告可以设为 'const' 的 'let' 声明。",
                  "markdown": "报告可以设为 `const` 的 `let` 声明。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6ConvertLetToConst",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSXDomNesting",
                "shortDescription": {
                  "text": "无效的 DOM 元素嵌套"
                },
                "fullDescription": {
                  "text": "检测 JSX 文件中未根据 DOM 规范正确嵌套的 HTML 元素。 React 会对不正确嵌套的元素报告运行时警告。",
                  "markdown": "检测 JSX 文件中未根据 DOM 规范正确嵌套的 HTML 元素。 React 会对不正确嵌套的元素报告运行时警告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSXDomNesting",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/React",
                      "index": 156,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLocalVariableJS",
                "shortDescription": {
                  "text": "冗余局部变量"
                },
                "fullDescription": {
                  "text": "报告不会让函数更易于理解的不必要局部变量： 立刻返回的局部变量 立刻赋值给另一个变量并且不再使用的局部变量 总是与另一个局部变量或形参的值相同的局部变量。 使用下面的复选框以使该检查忽略立刻返回或抛出的变量。 为清晰起见和易于调试，某些编码样式建议使用此类变量。",
                  "markdown": "报告不会让函数更易于理解的不必要局部变量：\n\n* 立刻返回的局部变量\n* 立刻赋值给另一个变量并且不再使用的局部变量\n* 总是与另一个局部变量或形参的值相同的局部变量。\n\n\n使用下面的复选框以使该检查忽略立刻返回或抛出的变量。 为清晰起见和易于调试，某些编码样式建议使用此类变量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLocalVariableJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/数据流",
                      "index": 155,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSXUnresolvedComponent",
                "shortDescription": {
                  "text": "未解析的 JSX 组件"
                },
                "fullDescription": {
                  "text": "报告对 JSX 组件的未解析引用。 如果引用的组件在此项目或其依赖项中定义，则建议添加缺少的 import 语句，或创建采用此名称的新组件。 新组件的模板可以在“编辑器 | 文件和代码模板”中修改。",
                  "markdown": "报告对 JSX 组件的未解析引用。 如果引用的组件在此项目或其依赖项中定义，则建议添加缺少的 import 语句，或创建采用此名称的新组件。\n\n新组件的模板可以在\"编辑器 \\| 文件和代码模板\"中修改。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSXUnresolvedComponent",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelOnBreakStatementJS",
                "shortDescription": {
                  "text": "'break' 语句上的标签不必要"
                },
                "fullDescription": {
                  "text": "报告可以在不更改控制流的情况下移除其标签的 'break' 标签语句。",
                  "markdown": "报告可以在不更改控制流的情况下移除其标签的 `break` 标签语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelOnBreakStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DivideByZeroJS",
                "shortDescription": {
                  "text": "除以零"
                },
                "fullDescription": {
                  "text": "报告除以 0 或对 0 取余。",
                  "markdown": "报告除以 0 或对 0 取余。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DivideByZeroJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSReferencingMutableVariableFromClosure",
                "shortDescription": {
                  "text": "从闭包中引用可变变量"
                },
                "fullDescription": {
                  "text": "报告函数中对外部可变变量的访问。 示例： 'for (var i = 1; i <= 3; i++) {\n    setTimeout(function() {\n        console.log(i); // 不良\n    }, 0);\n  }'",
                  "markdown": "报告函数中对外部可变变量的访问。\n\n示例：\n\n\n      for (var i = 1; i <= 3; i++) {\n        setTimeout(function() {\n            console.log(i); // 不良\n        }, 0);\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSReferencingMutableVariableFromClosure",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ChainedEqualityJS",
                "shortDescription": {
                  "text": "链式相等"
                },
                "fullDescription": {
                  "text": "报告链式相等比较（即 'a==b==c'）。 此类比较令人困惑。",
                  "markdown": "报告链式相等比较（即 `a==b==c`）。 此类比较令人困惑。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ChainedEqualityComparisonsJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ConvertRequireIntoImport",
                "shortDescription": {
                  "text": "使用了 'require()' 而不是 'import'"
                },
                "fullDescription": {
                  "text": "报告 'require()' 语句。 建议使用 'import' 语句将其转换为 'require()' 调用。 启用“使用‘全部修复’操作转换内部范围中的 require()”， 在使用“全部修复”操作时转换嵌套函数和语句内部的所有 'require()' 调用。 请注意，将内部范围中的 'require()' 语句转换为 'import' 语句 可能会导致代码语义更改。 Import 语句是 static 模块依赖项，它们获得了提升， 这表明它们被移至当前模块的顶部。 'require()' 调用动态加载模块。 它们可以有条件地执行，其范围由使用它们的表达式来定义。 清除“使用‘全部修复’操作转换内部范围中的 require()”复选框，以防止在使用“全部修复”操作时对这些复杂情况进行任何更改。",
                  "markdown": "报告 `require()` 语句。 建议使用 `import` 语句将其转换为 `require()` 调用。   \n\n启用\"使用'全部修复'操作转换内部范围中的 require()\"， 在使用\"全部修复\"操作时转换嵌套函数和语句内部的所有 `require()` 调用。   \n\n请注意，将内部范围中的 `require()` 语句转换为 `import` 语句 可能会导致代码语义更改。 Import 语句是 static 模块依赖项，它们获得了提升， 这表明它们被移至当前模块的顶部。 `require()` 调用动态加载模块。 它们可以有条件地执行，其范围由使用它们的表达式来定义。   \n清除\"使用'全部修复'操作转换内部范围中的 require()\"复选框，以防止在使用\"全部修复\"操作时对这些复杂情况进行任何更改。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6ConvertRequireIntoImport",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSRedundantSwitchStatement",
                "shortDescription": {
                  "text": "'switch' 语句冗余，可以替换"
                },
                "fullDescription": {
                  "text": "报告语句体为空或仅有一个 'case' 分支或仅有一个 'default' 分支的 'switch' 语句。",
                  "markdown": "报告语句体为空或仅有一个 `case` 分支或仅有一个 `default` 分支的 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSRedundantSwitchStatement",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnusedGlobalSymbols",
                "shortDescription": {
                  "text": "未使用的全局符号"
                },
                "fullDescription": {
                  "text": "报告未使用的可以全局访问的 public 函数、变量、类或属性。",
                  "markdown": "报告未使用的可以全局访问的 public 函数、变量、类或属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnusedGlobalSymbols",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/未使用的符号",
                      "index": 27,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BlockStatementJS",
                "shortDescription": {
                  "text": "不必要的块语句"
                },
                "fullDescription": {
                  "text": "报告不用作 'if' 、'for' 、'while' 、'do' 、 'with' 或 'try' 语句体，也不用作函数声明体的块语句。 从 ECMAScript 6 开始，JavaScript 块为 'let' 和 'const' 变量引入了新的范围， 但独立的块语句在与 'var' 变量一起使用时仍然会引起混淆，并导致难以捉摸的错误。",
                  "markdown": "报告不用作 `if` 、`for` 、`while` 、`do` 、 `with` 或 `try` 语句体，也不用作函数声明体的块语句。 从 ECMAScript 6 开始，JavaScript 块为 `let` 和 `const` 变量引入了新的范围， 但独立的块语句在与 `var` 变量一起使用时仍然会引起混淆，并导致难以捉摸的错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BlockStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedConditionalExpressionJS",
                "shortDescription": {
                  "text": "嵌套条件表达式"
                },
                "fullDescription": {
                  "text": "报告另一个三元条件中的三元条件表达式。 此类嵌套条件可能极其令人困惑，最好替换为更显式的条件逻辑。",
                  "markdown": "报告另一个三元条件中的三元条件表达式。 此类嵌套条件可能极其令人困惑，最好替换为更显式的条件逻辑。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedConditionalExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6PossiblyAsyncFunction",
                "shortDescription": {
                  "text": "非异步函数中的 'await'"
                },
                "fullDescription": {
                  "text": "报告可能想要异步但其实缺少 'async' 修饰符的函数中的 'await' 用法。 虽然 'await' 可以用作标识符，但很可能是打算将其用作运算符， 因此应将包含函数设为 'async' 。",
                  "markdown": "报告可能想要异步但其实缺少 `async` 修饰符的函数中的 `await` 用法。 虽然 `await` 可以用作标识符，但很可能是打算将其用作运算符， 因此应将包含函数设为 `async` 。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6PossiblyAsyncFunction",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Async 代码和 promise",
                      "index": 148,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TextLabelInSwitchStatementJS",
                "shortDescription": {
                  "text": "'switch' 语句中的文本标签"
                },
                "fullDescription": {
                  "text": "报告 'switch' 语句内部的标签语句， 这通常是由于拼写错误所致。 示例： 'switch(x)\n    {\n        case 1:\n        case2:   //拼写错误！\n        case 3:\n            break;\n    }'",
                  "markdown": "报告 `switch` 语句内部的标签语句， 这通常是由于拼写错误所致。\n\n示例：\n\n\n        switch(x)\n        {\n            case 1:\n            case2:   //拼写错误！\n            case 3:\n                break;\n        }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TextLabelInSwitchStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FlowJSFlagCommentPlacement",
                "shortDescription": {
                  "text": "位置错误的 @flow 标记"
                },
                "fullDescription": {
                  "text": "报告不位于文件顶部的 '@flow' 标志注释。",
                  "markdown": "报告不位于文件顶部的 `@flow` 标志注释。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FlowJSFlagCommentPlacement",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Flow 类型检查器",
                      "index": 28,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSOctalInteger",
                "shortDescription": {
                  "text": "八进制整数"
                },
                "fullDescription": {
                  "text": "报告已弃用的前缀为 '0' 而不是 '0o' 的八进制整数文字。 现代 ECMAScript 代码中不允许使用此类文字，在 strict 模式下使用它们会导致错误。 要针对 ES5 和 ES3 语言级别强制执行此检查，请选中下面的“对 ES5 代码中过时的八进制文字发出警告”复选框。",
                  "markdown": "报告已弃用的前缀为 `0` 而不是 `0o` 的八进制整数文字。  \n现代 ECMAScript 代码中不允许使用此类文字，在 strict 模式下使用它们会导致错误。  \n要针对 ES5 和 ES3 语言级别强制执行此检查，请选中下面的\"对 ES5 代码中过时的八进制文字发出警告\"复选框。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JSOctalInteger",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/有效性问题",
                      "index": 42,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSMissingSwitchDefault",
                "shortDescription": {
                  "text": "'switch' 语句没有 'default' 分支"
                },
                "fullDescription": {
                  "text": "报告在未枚举某些可能值的情况下不含 'default' 子句的 'switch' 语句。",
                  "markdown": "报告在未枚举某些可能值的情况下不含 `default` 子句的 `switch` 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSMissingSwitchDefault",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSXNamespaceValidation",
                "shortDescription": {
                  "text": "缺少 JSX 命名空间"
                },
                "fullDescription": {
                  "text": "报告未导入命名空间的 JSX 构造的用法。 将命名空间置于文件范围中可以确保正确编译代码。",
                  "markdown": "报告未导入命名空间的 JSX 构造的用法。 将命名空间置于文件范围中可以确保正确编译代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSXNamespaceValidation",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Import 和依赖项",
                      "index": 140,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyTryBlockJS",
                "shortDescription": {
                  "text": "空 'try' 块"
                },
                "fullDescription": {
                  "text": "报告空的 'try' 块，此类块通常表示有错误。",
                  "markdown": "报告空的 `try` 块，此类块通常表示有错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EmptyTryBlockJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReservedWordUsedAsNameJS",
                "shortDescription": {
                  "text": "保留词用作名称"
                },
                "fullDescription": {
                  "text": "报告用作名称的 JavaScript 保留字。 JavaScript 规范 保留了许多当前未用作关键字的词语。 如果后续版本的 JavaScript 开始使用这些词语作为关键字， 使用这些词语作为标识符可能会破坏代码。",
                  "markdown": "报告用作名称的 JavaScript 保留字。 JavaScript 规范 保留了许多当前未用作关键字的词语。 如果后续版本的 JavaScript 开始使用这些词语作为关键字， 使用这些词语作为标识符可能会破坏代码。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReservedWordAsName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/有效性问题",
                      "index": 42,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "IncrementDecrementResultUsedJS",
                "shortDescription": {
                  "text": "使用增量或减量的结果"
                },
                "fullDescription": {
                  "text": "报告赋值结果在包含其的表达式中 使用的递增 ('++') 或递减 ('--') 表达式。 此类赋值可能会由于运算顺序而导致困惑，因为赋值的评估可能会以意想不到的方式影响外部表达式。 示例：'var a = b++'",
                  "markdown": "报告赋值结果在包含其的表达式中 使用的递增 (`++`) 或递减 (`--`) 表达式。 此类赋值可能会由于运算顺序而导致困惑，因为赋值的评估可能会以意想不到的方式影响外部表达式。 示例：`var a = b++`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "IncrementDecrementResultUsedJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SuspiciousTypeOfGuard",
                "shortDescription": {
                  "text": "类型防护检查不健全"
                },
                "fullDescription": {
                  "text": "报告 'typeof' 或 'instanceof' 不健全的类型防护检查。 在以下两种情况下，'typeof x' 类型防护可能不健全： 'typeof x' 不对应于指定的值（例如，当 'x' 为 'string | boolean' 类型时，'typeof x === 'number''） 'typeof x' 始终对应于指定的值（例如，当 'x' 为 'string' 类型时，'typeof x === 'string''） 在以下两种情况下，'x instanceof A' 类型防护可能不健全： 'x' 的类型与 'A' 不相关 'x' 的类型是 'A' 或 'A' 的子类型",
                  "markdown": "报告 `typeof` 或 `instanceof` 不健全的类型防护检查。 在以下两种情况下，`typeof x` 类型防护可能不健全：\n\n* `typeof x` 不对应于指定的值（例如，当 `x` 为 'string \\| boolean' 类型时，`typeof x === 'number'`）\n* `typeof x` 始终对应于指定的值（例如，当 `x` 为 'string' 类型时，`typeof x === 'string'`）\n\n在以下两种情况下，`x instanceof A` 类型防护可能不健全：\n\n* `x` 的类型与 `A` 不相关\n* `x` 的类型是 `A` 或 `A` 的子类型"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SuspiciousTypeOfGuard",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LoopStatementThatDoesntLoopJS",
                "shortDescription": {
                  "text": "不循环的循环语句"
                },
                "fullDescription": {
                  "text": "报告语句体最多可以执行一次的 'for' 、 'while' 或 'do' 语句。 这通常表示有错误。",
                  "markdown": "报告语句体最多可以执行一次的 `for` 、 `while` 或 `do` 语句。 这通常表示有错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LoopStatementThatDoesntLoopJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSNonASCIINames",
                "shortDescription": {
                  "text": "包含非 ASCII 符号的标识符"
                },
                "fullDescription": {
                  "text": "报告名称中的非 ASCII 符号。 如果选择“仅允许 ASCII 名称”选项，则报告所有包含非 ASCII 符号的名称。 否则，报告所有同时包含 ASCII 和非 ASCII 符号的名称。",
                  "markdown": "报告名称中的非 ASCII 符号。  \n\n如果选择\"仅允许 ASCII 名称\"选项，则报告所有包含非 ASCII 符号的名称。  \n否则，报告所有同时包含 ASCII 和非 ASCII 符号的名称。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSNonASCIINames",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/命名约定",
                      "index": 149,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6MissingAwait",
                "shortDescription": {
                  "text": "异步函数调用缺少 await"
                },
                "fullDescription": {
                  "text": "报告 'async' 函数中没有预期的 'await' 前缀的 'async' 函数调用。 此类调用返回 'Promise'，并且控制流会立即继续。 示例： 'async function bar() { /* ... */ }\nasync function foo() {\n    bar(); // 不良\n}' 应用快速修复后，将添加 'await' 前缀： 'async function bar() { /* ... */ }\nasync function foo() {\n    await bar(); // 优良\n}' 在选中“报告 return 语句中的 promise”复选框的情况下，还建议在 return 语句中添加 'await'。 虽然一般不必这样做，但它有两大好处。 使用 'try-catch' 环绕代码时，您不会忘记去添加 'await'。 显式的 'await' 有助于 V8 运行时提供异步堆栈跟踪。",
                  "markdown": "报告 `async` 函数中没有预期的 `await` 前缀的 ` async` 函数调用。 此类调用返回 `Promise`，并且控制流会立即继续。\n\n示例：\n\n\n    async function bar() { /* ... */ }\n    async function foo() {\n        bar(); // 不良\n    }\n\n\n应用快速修复后，将添加 `await` 前缀：\n\n\n    async function bar() { /* ... */ }\n    async function foo() {\n        await bar(); // 优良\n    }\n\n在选中\"报告 return 语句中的 promise\"复选框的情况下，还建议在 return 语句中添加 `await`。  \n虽然一般不必这样做，但它有两大好处。  \n\n* 使用 `try-catch` 环绕代码时，您不会忘记去添加 `await`。\n* 显式的 `await` 有助于 V8 运行时提供[异步堆栈跟踪](https://bit.ly/v8-zero-cost-async-stack-traces)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6MissingAwait",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Async 代码和 promise",
                      "index": 148,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TailRecursionJS",
                "shortDescription": {
                  "text": "尾递归"
                },
                "fullDescription": {
                  "text": "报告尾递归，即报告函数在返回之前 调用自身作为最后操作的情况。 尾递归总是可以替换为循环，循环的速度快得多。 一些 JavaScript 引擎执行这种优化，而另一些则不执行。 因此，尾递归解决方案在不同环境下 可能具有截然不同的性能特点。",
                  "markdown": "报告尾递归，即报告函数在返回之前 调用自身作为最后操作的情况。 尾递归总是可以替换为循环，循环的速度快得多。 一些 JavaScript 引擎执行这种优化，而另一些则不执行。 因此，尾递归解决方案在不同环境下 可能具有截然不同的性能特点。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TailRecursionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FlowJSCoverage",
                "shortDescription": {
                  "text": "Flow 不涵盖代码"
                },
                "fullDescription": {
                  "text": "报告 Flow 类型检查器未覆盖的 JavaScript 代码段。 要使用此检查，请在设置 | 语言和框架 | JavaScript 中配置 Flow 可执行文件。",
                  "markdown": "报告 Flow 类型检查器未覆盖的 JavaScript 代码段。 要使用此检查，请在[设置 \\| 语言和框架 \\| JavaScript](settings://Settings.JavaScript) 中配置 Flow 可执行文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "FlowJSCoverage",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Flow 类型检查器",
                      "index": 28,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConfusingPlusesOrMinusesJS",
                "shortDescription": {
                  "text": "'+' 或 '-' 的序列会引起混淆"
                },
                "fullDescription": {
                  "text": "报告 JavaScript 代码中 '+' 或 '-' 字符的可疑组合 (例如 'a+++b') 。 此类序列令人困惑，并且它们的语义可能会因为空格的变化而变化。",
                  "markdown": "报告 JavaScript 代码中 `+` 或 `-` 字符的可疑组合 (例如 `a+++b`) 。 此类序列令人困惑，并且它们的语义可能会因为空格的变化而变化。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConfusingPlusesOrMinusesJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptConfig",
                "shortDescription": {
                  "text": "不一致的 Tsconfig.json 属性"
                },
                "fullDescription": {
                  "text": "报告 tsconfig.json 文件中的 'paths' 、'checkJs' 或 'extends' 属性不一致的情况。 'checkJs' 属性必须具备 'allowJs'。 'extends' 属性应为有效的文件引用。",
                  "markdown": "报告 tsconfig.json 文件中的 `paths` 、`checkJs` 或 `extends` 属性不一致的情况。   \n`checkJs` 属性必须具备 `allowJs`。   \n`extends` 属性应为有效的文件引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeScriptConfig",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSIgnoredPromiseFromCall",
                "shortDescription": {
                  "text": "返回 promise 的方法调用结果被忽略"
                },
                "fullDescription": {
                  "text": "报告返回日后不使用的 'Promise' 的函数调用。 此类调用通常是无意为之，表明有错误。",
                  "markdown": "报告返回日后不使用的 `Promise` 的函数调用。 此类调用通常是无意为之，表明有错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSIgnoredPromiseFromCall",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Async 代码和 promise",
                      "index": 148,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexBooleanExpressionJS",
                "shortDescription": {
                  "text": "过度复杂的布尔表达式"
                },
                "fullDescription": {
                  "text": "报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。 使用下面的字段可指定算术表达式中允许的最大项数。",
                  "markdown": "报告包含太多项的布尔表达式。 此类表达方式可能令人困惑，并且容易出错。\n\n\n使用下面的字段可指定算术表达式中允许的最大项数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexBooleanExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "OverlyComplexArithmeticExpressionJS",
                "shortDescription": {
                  "text": "过于复杂的算术表达式"
                },
                "fullDescription": {
                  "text": "报告包含太多项的算术表达式。 此类表达方式可能令人困惑，并且容易出错。 使用下面的字段可指定算术表达式中允许的最大项数。",
                  "markdown": "报告包含太多项的算术表达式。 此类表达方式可能令人困惑，并且容易出错。\n\n\n使用下面的字段可指定算术表达式中允许的最大项数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexArithmeticExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StringLiteralBreaksHTMLJS",
                "shortDescription": {
                  "text": "中断 HTML 解析的字符串文字"
                },
                "fullDescription": {
                  "text": "报告包含 '</' 序列的字符串文字。 此类字符串可能会导致错误解析在其中嵌入 JavaScript 代码的任何 HTML。",
                  "markdown": "报告包含 `</` 序列的字符串文字。 此类字符串可能会导致错误解析在其中嵌入 JavaScript 代码的任何 HTML。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StringLiteralBreaksHTMLJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/有效性问题",
                      "index": 42,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicateConditionJS",
                "shortDescription": {
                  "text": "'if' 语句中的重复条件"
                },
                "fullDescription": {
                  "text": "报告 'if' 语句的不同分支中的重复条件。 重复条件通常因程序员疏忽大意所致。 示例： 'if (a) {\n    ...\n  } else if (a) {\n    ...\n  }'",
                  "markdown": "报告 `if` 语句的不同分支中的重复条件。 重复条件通常因程序员疏忽大意所致。\n\n示例：\n\n\n      if (a) {\n        ...\n      } else if (a) {\n        ...\n      }\n\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicateConditionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSComparisonWithNaN",
                "shortDescription": {
                  "text": "与 NaN 比较"
                },
                "fullDescription": {
                  "text": "报告与 NaN 的比较。 类似于 'expr == NaN' 或 'expr === NaN' 的比较总是评估为 'false'。",
                  "markdown": "报告与 NaN 的比较。 类似于 `expr == NaN` 或 `expr === NaN` 的比较总是评估为 `false`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSComparisonWithNaN",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnnecessaryLabelJS",
                "shortDescription": {
                  "text": "不必要的标签"
                },
                "fullDescription": {
                  "text": "报告未使用的标签。",
                  "markdown": "报告未使用的标签。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnnecessaryLabelJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnresolvedReference",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告 JavaScript 代码中的未解析引用。",
                  "markdown": "报告 JavaScript 代码中的未解析引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSUnresolvedReference",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PlatformDetectionJS",
                "shortDescription": {
                  "text": "平台检测不准确"
                },
                "fullDescription": {
                  "text": "报告用于检测从中运行脚本的浏览器或 操作系统的通用 JavaScript 模式。 除了指出不可移植的结构外，这些平台检测模式通常不完整并且容易被愚弄。 在大多数情况下，检测单个环境的功能 比尝试检测整个平台更可取。 检测到的模式包括： 'document.all' 'document.layers' 'navigator.userAgent' 'navigator.oscpu' 'navigator.appName' 'navigator.appCodeName' 'navigator.platform'",
                  "markdown": "报告用于检测从中运行脚本的浏览器或 操作系统的通用 JavaScript 模式。 除了指出不可移植的结构外，这些平台检测模式通常不完整并且容易被愚弄。 在大多数情况下，检测单个环境的功能 比尝试检测整个平台更可取。\n\n检测到的模式包括：\n\n* `document.all`\n* `document.layers`\n* `navigator.userAgent`\n* `navigator.oscpu`\n* `navigator.appName`\n* `navigator.appCodeName`\n* `navigator.platform`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PlatformDetectionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/DOM 问题",
                      "index": 84,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptDuplicateUnionOrIntersectionType",
                "shortDescription": {
                  "text": "联合或相交类型组件重复"
                },
                "fullDescription": {
                  "text": "报告合集或交集中的重复类型。",
                  "markdown": "报告合集或交集中的重复类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeScriptDuplicateUnionOrIntersectionType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6UnusedImports",
                "shortDescription": {
                  "text": "未使用的 import"
                },
                "fullDescription": {
                  "text": "报告冗余的 'import' 语句。 如果源文件中没有使用导入的符号，通常就会出现这种情况。 为避免副作用，可以考虑使用 bare import 'import 'packageName'' 来代替常规 import。",
                  "markdown": "报告冗余的 `import` 语句。 如果源文件中没有使用导入的符号，通常就会出现这种情况。 为避免副作用，可以考虑使用 bare import `import 'packageName'` 来代替常规 import。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ES6UnusedImports",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Import 和依赖项",
                      "index": 140,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InnerHTMLJS",
                "shortDescription": {
                  "text": "使用 'innerHTML' 属性"
                },
                "fullDescription": {
                  "text": "报告使用 'innerHTML' 属性以文本形式对 DOM 节点的 JavaScript 访问。 在采用显式 DOM 调用（例如 'getElementByID()' 和 'createElement()'）时, 'innerHTML' 的大多数用法执行效果更好。 此外，'innerHTML' 不适用于 XML DOM，包括用于 XHTML 的 DOM（如果以 XML 格式查看）。 这可能会导致 难以诊断错误。",
                  "markdown": "报告使用 `innerHTML` 属性以文本形式对 DOM 节点的 JavaScript 访问。 在采用显式 DOM 调用（例如 `getElementByID()` 和 `createElement()`）时, `innerHTML` 的大多数用法执行效果更好。 此外，`innerHTML` 不适用于 XML DOM，包括用于 XHTML 的 DOM（如果以 XML 格式查看）。 这可能会导致 难以诊断错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InnerHTMLJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/DOM 问题",
                      "index": 84,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VoidExpressionJS",
                "shortDescription": {
                  "text": "'void' 表达式"
                },
                "fullDescription": {
                  "text": "报告 'void' 表达式。",
                  "markdown": "报告 `void` 表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VoidExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSAssignmentUsedAsCondition",
                "shortDescription": {
                  "text": "用作条件的赋值"
                },
                "fullDescription": {
                  "text": "报告用作 'if'、'while'、'for' 或 'do' 语句的条件的赋值。 虽然偶尔是有意为之，但此用法令人困惑，而且通常表明存在拼写错误（例如，应使用 '=' 而不是 '=='）。",
                  "markdown": "报告用作 `if`、`while`、`for` 或 `do` 语句的条件的赋值。 虽然偶尔是有意为之，但此用法令人困惑，而且通常表明存在拼写错误（例如，应使用 `=` 而不是 `==`）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSAssignmentUsedAsCondition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/赋值问题",
                      "index": 73,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ForLoopReplaceableByWhileJS",
                "shortDescription": {
                  "text": "'for' 循环可被替换为 'while' 循环"
                },
                "fullDescription": {
                  "text": "报告既不包含初始化也不包含更新组件的 'for' 循环。 建议将该循环替换为更简单的 'while' 语句。 示例： 'for(; exitCondition(); ) {\n    process();\n  }' 应用快速修复后，结果如下所示： 'while(exitCondition()) {\n    process();\n  }' 如果希望此检查忽略包含普通条件或不存在条件的 for 循环，请使用下面的复选框。",
                  "markdown": "报告既不包含初始化也不包含更新组件的 `for` 循环。 建议将该循环替换为更简单的 `while` 语句。\n\n示例：\n\n\n      for(; exitCondition(); ) {\n        process();\n      }\n\n应用快速修复后，结果如下所示：\n\n\n      while(exitCondition()) {\n        process();\n      }\n\n如果希望此检查忽略包含普通条件或不存在条件的 **for** 循环，请使用下面的复选框。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ForLoopReplaceableByWhile",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSVoidFunctionReturnValueUsed",
                "shortDescription": {
                  "text": "使用了 void 函数返回值"
                },
                "fullDescription": {
                  "text": "报告不返回任何内容的函数的返回值。 调用此类函数总是生成 'undefined' 值，此类赋值可能表明有错误。 示例： 'let a = console.log('foo');' 以下用法将被忽略： 在 return 语句内部 在某些二进制运算中 对于覆盖的非 void 函数",
                  "markdown": "报告不返回任何内容的函数的返回值。 调用此类函数总是生成 `undefined` 值，此类赋值可能表明有错误。\n\n示例：\n\n\n    let a = console.log('foo');\n\n以下用法将被忽略：\n\n* 在 return 语句内部\n* 在某些二进制运算中\n* 对于覆盖的非 void 函数"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSVoidFunctionReturnValueUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReturnFromFinallyBlockJS",
                "shortDescription": {
                  "text": "'return' 位于 'finally' 块内"
                },
                "fullDescription": {
                  "text": "报告 'finally' 块中的 'return' 语句。 此类 'return' 语句可能会掩盖抛出的异常，并导致调试复杂化。",
                  "markdown": "报告 `finally` 块中的 `return` 语句。 此类 `return` 语句可能会掩盖抛出的异常，并导致调试复杂化。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReturnInsideFinallyBlockJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantConditionalExpressionJS",
                "shortDescription": {
                  "text": "常量条件表达式"
                },
                "fullDescription": {
                  "text": "报告格式为 'true? 的条件表达式 result1: result2' 或 'false? result1: result2。 建议简化该表达式。'",
                  "markdown": "报告格式为 `true? 的条件表达式 result1: result2` 或 `false? result1: result2``。\n建议简化该表达式。\n`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantConditionalExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NonBlockStatementBodyJS",
                "shortDescription": {
                  "text": "没有大括号的语句体"
                },
                "fullDescription": {
                  "text": "报告其语句体不是块语句的 'if'、'while'、'for' 或 'with' 语句。 在语句体中使用代码块通常对下游维护更安全。",
                  "markdown": "报告其语句体不是块语句的 `if`、`while`、`for` 或 `with` 语句。 在语句体中使用代码块通常对下游维护更安全。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NonBlockStatementBodyJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSValidateJSDoc",
                "shortDescription": {
                  "text": "JSDoc 中的语法错误和未解析的引用"
                },
                "fullDescription": {
                  "text": "报告文档注释中的语法差异。",
                  "markdown": "报告文档注释中的语法差异。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSValidateJSDoc",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FlowJSConfig",
                "shortDescription": {
                  "text": "缺少 .flowconfig"
                },
                "fullDescription": {
                  "text": "报告在项目中没有关联的 '.flowconfig' 文件且带有 '@flow' 标志的 JavaScript 文件。",
                  "markdown": "报告在项目中没有关联的 `.flowconfig` 文件且带有 `@flow` 标志的 JavaScript 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FlowJSConfig",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Flow 类型检查器",
                      "index": 28,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptValidateTypes",
                "shortDescription": {
                  "text": "类型不匹配"
                },
                "fullDescription": {
                  "text": "报告类型不正确的形参、返回值或赋值表达式。",
                  "markdown": "报告类型不正确的形参、返回值或赋值表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "TypeScriptValidateTypes",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StatementsPerFunctionJS",
                "shortDescription": {
                  "text": "函数过长"
                },
                "fullDescription": {
                  "text": "报告过长的函数。 函数长度通过函数中非空语句的数量来计算。 太长的函数容易出错，而且难以测试。 使用下面的字段可指定函数中的可接受最大语句数量。",
                  "markdown": "报告过长的函数。 函数长度通过函数中非空语句的数量来计算。 太长的函数容易出错，而且难以测试。\n\n\n使用下面的字段可指定函数中的可接受最大语句数量。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionTooLongJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/函数指标",
                      "index": 111,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ContinueStatementWithLabelJS",
                "shortDescription": {
                  "text": "带标签的 'continue' 语句"
                },
                "fullDescription": {
                  "text": "添加 'continue' 标签语句。",
                  "markdown": "添加 `continue` 标签语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ContinueStatementWithLabelJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptMissingConfigOption",
                "shortDescription": {
                  "text": "缺少 tsconfig.json 选项 "
                },
                "fullDescription": {
                  "text": "报告 'tsconfig.json' 中需要显式选项的用法。 例如，要在 '.tsx' 文件中使用 JSX，'tsconfig.json' 必须包含 '\"jsx\"' 属性。",
                  "markdown": "报告 `tsconfig.json` 中需要显式选项的用法。 例如，要在 `.tsx` 文件中使用 JSX，`tsconfig.json` 必须包含 `\"jsx\"` 属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeScriptMissingConfigOption",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSObjectNullOrUndefined",
                "shortDescription": {
                  "text": "对象为 'null' 或 'undefined'"
                },
                "fullDescription": {
                  "text": "报告对 'undefined' 或 'null' 对象调用方法、访问属性或调用函数所导致的错误。",
                  "markdown": "报告对 `undefined` 或 `null` 对象调用方法、访问属性或调用函数所导致的错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSObjectNullOrUndefined",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6ShorthandObjectProperty",
                "shortDescription": {
                  "text": "属性可被替换为速记形式"
                },
                "fullDescription": {
                  "text": "报告可以转换为 ES6 速记样式的对象属性，并提供快速修复来执行此操作。 示例： 'var obj = {foo:foo}' 应用快速修复后，代码如下所示： 'var obj = {foo}'",
                  "markdown": "报告可以转换为 ES6 速记样式的对象属性，并提供快速修复来执行此操作。\n\n示例：\n\n\n    var obj = {foo:foo}\n\n应用快速修复后，代码如下所示：\n\n\n    var obj = {foo}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6ShorthandObjectProperty",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSPotentiallyInvalidConstructorUsage",
                "shortDescription": {
                  "text": "可能无效的构造函数用法"
                },
                "fullDescription": {
                  "text": "报告可能无效的构造函数的用法，例如：'new' 后面不是构造函数的函数，使用 构造函数的原型或调用构造函数但没有使用 'new' 。 假定构造函数的名称采用大写（可选）或有显式的 JSDoc '@constructor' 标记。",
                  "markdown": "报告可能无效的构造函数的用法，例如：`new` 后面不是构造函数的函数，使用 构造函数的原型或调用构造函数但没有使用 `new` 。 假定构造函数的名称采用大写（可选）或有显式的 JSDoc `@constructor` 标记。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSPotentiallyInvalidConstructorUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PointlessArithmeticExpressionJS",
                "shortDescription": {
                  "text": "无意义的算术表达式"
                },
                "fullDescription": {
                  "text": "报告包括加零或减零、乘零或一、除一和零移位的算术表达式。 此类表达式可能是由于没有完全完成自动化重构而造成。",
                  "markdown": "报告包括加零或减零、乘零或一、除一和零移位的算术表达式。 此类表达式可能是由于没有完全完成自动化重构而造成。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PointlessArithmeticExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NodeCoreCodingAssistance",
                "shortDescription": {
                  "text": "未解析的 Node.js API"
                },
                "fullDescription": {
                  "text": "建议为 Node.js 配置编码辅助，例如 'require' 和/或核心模块（'path'、'http'、'fs' 等）。 有关完整列表，请参阅 https://nodejs.org/api/。",
                  "markdown": "建议为 Node.js 配置编码辅助，例如 `require` 和/或核心模块（'path'、'http'、'fs' 等）。\n\n\n有关完整列表，请参阅 <https://nodejs.org/api/>。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NodeCoreCodingAssistance",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Node.js",
                      "index": 164,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSPrimitiveTypeWrapperUsage",
                "shortDescription": {
                  "text": "使用了基元类型对象包装器"
                },
                "fullDescription": {
                  "text": "报告基元类型包装器使用不当或基元类型属性被修改的情况，因为在后一种情况下，所赋之值将丢失。",
                  "markdown": "报告基元类型包装器使用不当或基元类型属性被修改的情况，因为在后一种情况下，所赋之值将丢失。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSPrimitiveTypeWrapperUsage",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptSmartCast",
                "shortDescription": {
                  "text": "范围缩小的类型"
                },
                "fullDescription": {
                  "text": "报告通过类型防护缩小变量类型范围时的变量用法。 请注意，严重性级别不影响此检查。",
                  "markdown": "报告通过类型防护缩小变量类型范围时的变量用法。 请注意，严重性级别不影响此检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeScriptSmartCast",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSLastCommaInArrayLiteral",
                "shortDescription": {
                  "text": "数组文字中的最后一个逗号多余"
                },
                "fullDescription": {
                  "text": "报告数组文字中尾随逗号的用法。 只有将 JavaScript 语言版本设置为 ECMAScript 5.1 时才报告该警告。 尽管此规范允许在数组中使用尾随逗号，但在使用尾随逗号时，某些浏览器可能会抛出错误。 您可以在代码样式 | JavaScript 或 TypeScript | 标点符号中配置尾随逗号的格式设置选项。",
                  "markdown": "报告数组文字中尾随逗号的用法。\n\n只有将 JavaScript 语言版本设置为 ECMAScript 5.1 时才报告该警告。\n\n尽管此规范允许在数组中使用尾随逗号，但在使用尾随逗号时，某些浏览器可能会抛出错误。\n\n您可以在**代码样式** \\| **JavaScript** 或 **TypeScript** \\| **标点符号**中配置尾随逗号的格式设置选项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSLastCommaInArrayLiteral",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NegatedConditionalExpressionJS",
                "shortDescription": {
                  "text": "否定条件表达式"
                },
                "fullDescription": {
                  "text": "报告条件被否定的条件表达式。 建议翻转条件表达式中分支的顺序以增加语句的清晰度。 示例：'!condition ? 2 : 1'",
                  "markdown": "报告条件被否定的条件表达式。 建议翻转条件表达式中分支的顺序以增加语句的清晰度。 示例：`!condition ? 2 : 1`"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NegatedConditionalExpressionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSAccessibilityCheck",
                "shortDescription": {
                  "text": "已引用无法访问的 @private 和 @protected 成员"
                },
                "fullDescription": {
                  "text": "报告对使用 '@private' 或 '@protected' 标记进行标记，但不符合这些标记所隐含的可见性规则的 JavaScript 成员的引用。",
                  "markdown": "报告对使用 `@private` 或 `@protected` 标记进行标记，但不符合这些标记所隐含的可见性规则的 JavaScript 成员的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSAccessibilityCheck",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionWithMultipleLoopsJS",
                "shortDescription": {
                  "text": "函数具有多个循环"
                },
                "fullDescription": {
                  "text": "报告具有多个循环语句的函数。",
                  "markdown": "报告具有多个循环语句的函数。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionWithMultipleLoopsJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/函数指标",
                      "index": 111,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LabeledStatementJS",
                "shortDescription": {
                  "text": "标记语句"
                },
                "fullDescription": {
                  "text": "报告标签语句。",
                  "markdown": "报告标签语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LabeledStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NpmUsedModulesInstalled",
                "shortDescription": {
                  "text": "缺少模块依赖关系"
                },
                "fullDescription": {
                  "text": "报告未安装或未在 package.json 依赖项中列出的 'require()' 调用或 'import' 语句中的模块。 建议安装此模块和/或将其包含到 package.json 中。 对于 'require()' 调用，仅在Node.js Core JavaScript 库范围内的文件中起作用。",
                  "markdown": "报告未安装或未在 package.json 依赖项中列出的 `require()` 调用或 `import` 语句中的模块。\n\n建议安装此模块和/或将其包含到 package.json 中。\n\n对于 `require()` 调用，仅在*Node.js Core* JavaScript 库范围内的文件中起作用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "NpmUsedModulesInstalled",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Import 和依赖项",
                      "index": 140,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WithStatementJS",
                "shortDescription": {
                  "text": "'with' 语句"
                },
                "fullDescription": {
                  "text": "报告 'with' 语句。 此类语句会导致可能令人困惑的隐式绑定，并且在设置新变量时可能会表现出奇怪的行为。",
                  "markdown": "报告 `with` 语句。 此类语句会导致可能令人困惑的隐式绑定，并且在设置新变量时可能会表现出奇怪的行为。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WithStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能不合需要的代码结构",
                      "index": 55,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSConstantReassignment",
                "shortDescription": {
                  "text": "尝试分配给常量或只读变量"
                },
                "fullDescription": {
                  "text": "报告将值重新赋给常量或只读变量的情况。",
                  "markdown": "报告将值重新赋给常量或只读变量的情况。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JSConstantReassignment",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/有效性问题",
                      "index": 42,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MagicNumberJS",
                "shortDescription": {
                  "text": "幻数"
                },
                "fullDescription": {
                  "text": "报告使用数值文字但未通过常量声明来命名的“幻数”。 幻数可能导致生成意图不明确的代码，如果一个代码位置中的幻数被更改，但在另一个代码位置未被更改，则可能导致错误。 数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、 0.0 和 1.0 将被忽略。",
                  "markdown": "报告使用数值文字但未通过常量声明来命名的\"幻数\"。 幻数可能导致生成意图不明确的代码，如果一个代码位置中的幻数被更改，但在另一个代码位置未被更改，则可能导致错误。 数字 0、1、2、3、4、5、6、7、8、9、10、100、1000、 0.0 和 1.0 将被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MagicNumberJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FunctionNamingConventionJS",
                "shortDescription": {
                  "text": "函数命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合 指定正则表达式模式的函数。 使用下面提供的字段来指定函数名称的最小长度、 最大长度以及正则表达式。 对正则表达式使用标准的 'java.util.regex' 格式。",
                  "markdown": "报告名称太短、太长或不符合 指定正则表达式模式的函数。\n\n\n使用下面提供的字段来指定函数名称的最小长度、\n最大长度以及正则表达式。 对正则表达式使用标准的 `java.util.regex` 格式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FunctionNamingConventionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/命名约定",
                      "index": 149,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptLibrary",
                "shortDescription": {
                  "text": "缺少全局库"
                },
                "fullDescription": {
                  "text": "报告符号必须具备但未在 'tsconfig.json' 中的 'lib' 编译器选项下列出的 TypeScript 库文件。",
                  "markdown": "报告符号必须具备但未在 `tsconfig.json` 中的 `lib` 编译器选项下列出的 TypeScript 库文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "TypeScriptLibrary",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptMissingAugmentationImport",
                "shortDescription": {
                  "text": "缺少扩大导入"
                },
                "fullDescription": {
                  "text": "报告没有显式 import 的 增强模块的用法。",
                  "markdown": "报告没有显式 import 的 [增强模块](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TypeScriptMissingAugmentationImport",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ObjectAllocationIgnoredJS",
                "shortDescription": {
                  "text": "对象分配的结果已忽略"
                },
                "fullDescription": {
                  "text": "报告所分配对象的结果被忽略的对象分配，例如 'new Error();' 作为不带任何赋值的语句。 此类分配表达式可以指示奇怪的对象初始化策略。",
                  "markdown": "报告所分配对象的结果被忽略的对象分配，例如 `new Error();` 作为不带任何赋值的语句。 此类分配表达式可以指示奇怪的对象初始化策略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ObjectAllocationIgnored",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSHint",
                "shortDescription": {
                  "text": "JSHint"
                },
                "fullDescription": {
                  "text": "报告 JSHint linter 检测到的问题。",
                  "markdown": "报告 [JSHint](https://jshint.com/) linter 检测到的问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JSHint",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码质量工具",
                      "index": 102,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Eslint",
                "shortDescription": {
                  "text": "ESLint"
                },
                "fullDescription": {
                  "text": "报告 ESLint linter 检测到的差异。 高亮显示基于 ESLint 配置文件中为每条规则指定的规则严重性。 清除“使用配置文件中的规则严重性”复选框，对所有 ESLint 规则使用该项检查中配置的严重性。",
                  "markdown": "报告 [ESLint](https://eslint.org) linter 检测到的差异。   \n\n高亮显示基于 [ESLint 配置文件](https://eslint.org/docs/user-guide/configuring)中为每条规则指定的规则严重性。   \n\n清除\"使用配置文件中的规则严重性\"复选框，对所有 ESLint 规则使用该项检查中配置的严重性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Eslint",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码质量工具",
                      "index": 102,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSEqualityComparisonWithCoercion.TS",
                "shortDescription": {
                  "text": "相等运算符可能导致类型强制"
                },
                "fullDescription": {
                  "text": "报告可能导致意外类型强制的相等运算符的用法。 建议将 '==' 或 '!=' 相等运算符替换为类型安全的 '===' 或 '!==' 运算符。 根据所选的选项，将报告下面的一种情况： '==' 和 '!=' 运算符的所有用法。 除了与 null 比较之外的所有用法。 某些代码样式允许使用 'x == null' 替代 'x === null || x === undefined'。 仅可疑的表达式，例如：'==' 或 '!=' 与 '0'、''''、 'null'、'true'、 'false' 或 'undefined' 比较。",
                  "markdown": "报告可能导致意外类型强制的相等运算符的用法。 建议将 `==` 或 `!=` 相等运算符替换为类型安全的 `===` 或 `!==` 运算符。\n\n根据所选的选项，将报告下面的一种情况：\n\n* `==` 和 `!=` 运算符的所有用法。\n* 除了与 null 比较之外的所有用法。 某些代码样式允许使用 `x == null` 替代 `x === null || x === undefined`。\n* 仅可疑的表达式，例如：`==` 或 `!=` 与 `0`、`''`、 `null`、`true`、 `false` 或 `undefined` 比较。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EqualityComparisonWithCoercionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ExceptionCaughtLocallyJS",
                "shortDescription": {
                  "text": "将异常用于本地控制流"
                },
                "fullDescription": {
                  "text": "报告异常始终可以通过包含 'try' 语句捕获的 'throw' 语句。 使用 'throw' 语句作为 'goto' 来更改局部控制流令人困惑。",
                  "markdown": "报告异常始终可以通过包含 `try` 语句捕获的 `throw` 语句。 使用 `throw` 语句作为 `goto` 来更改局部控制流令人困惑。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ExceptionCaughtLocallyJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Try 语句问题",
                      "index": 47,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CyclomaticComplexityJS",
                "shortDescription": {
                  "text": "函数过于复杂"
                },
                "fullDescription": {
                  "text": "报告函数中分支点太多的函数（循环复杂度太高）。 此类函数可能令人困惑，也难以测试。 使用下面提供的字段可指定函数的最大可接受循环复杂度。",
                  "markdown": "报告函数中分支点太多的函数（循环复杂度太高）。 此类函数可能令人困惑，也难以测试。\n\n\n使用下面提供的字段可指定函数的最大可接受循环复杂度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyComplexFunctionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/函数指标",
                      "index": 111,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PackageJsonMismatchedDependency",
                "shortDescription": {
                  "text": "package.json 中的依赖关系不匹配"
                },
                "fullDescription": {
                  "text": "报告未安装或与指定的版本范围不匹配的 package.json 中的依赖项。",
                  "markdown": "报告未安装或与指定的[版本范围](https://docs.npmjs.com/about-semantic-versioning)不匹配的 package.json 中的依赖项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PackageJsonMismatchedDependency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Import 和依赖项",
                      "index": 140,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "InfiniteLoopJS",
                "shortDescription": {
                  "text": "无限循环语句"
                },
                "fullDescription": {
                  "text": "报告只能通过抛出异常来退出的 'for' 、 'while' 或 'do' 语句。 此类语句通常表示编码错误。",
                  "markdown": "报告只能通过抛出异常来退出的 `for` 、 `while` 或 `do` 语句。 此类语句通常表示编码错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "InfiniteLoopJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSArrowFunctionBracesCanBeRemoved",
                "shortDescription": {
                  "text": "箭头函数体周围的大括号冗余"
                },
                "fullDescription": {
                  "text": "报告其函数体仅由大括号和恰好一条语句组成的箭头函数。 建议转换为不带大括号的简洁语法。 'let incrementer = (x) => {return x + 1};' 应用快速修复后，代码段如下所示： 'let incrementer = (x) => x + 1;'",
                  "markdown": "报告其函数体仅由大括号和恰好一条语句组成的箭头函数。 建议转换为不带大括号的简洁语法。\n\n\n        let incrementer = (x) => {return x + 1};\n\n应用快速修复后，代码段如下所示：\n\n\n        let incrementer = (x) => x + 1;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSArrowFunctionBracesCanBeRemoved",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSClassNamingConvention",
                "shortDescription": {
                  "text": "类命名约定"
                },
                "fullDescription": {
                  "text": "报告用 JSDoc '@constructor' 或 '@class' 标记进行注解， 并且其名称太短、太长或不符合指定正则表达式模式的类或函数。 使用下面提供的字段来指定类名称的最小长度、 最大长度以及预期的正则表达式。 对正则表达式使用标准的 'java.util.regex' 格式。",
                  "markdown": "报告用 JSDoc `@constructor` 或 `@class` 标记进行注解， 并且其名称太短、太长或不符合指定正则表达式模式的类或函数。\n\n\n使用下面提供的字段来指定类名称的最小长度、\n最大长度以及预期的正则表达式。 对正则表达式使用标准的 `java.util.regex` 格式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSClassNamingConvention",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/命名约定",
                      "index": 149,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptJSXUnresolvedComponent",
                "shortDescription": {
                  "text": "未解析的 JSX 组件"
                },
                "fullDescription": {
                  "text": "报告对 JSX 组件的未解析引用。 如果引用的组件在此项目或其依赖项中定义，则建议添加 import 语句，或使用指定名称创建新组件。 新组件的模板可以在“编辑器 | 文件和代码模板”中修改。",
                  "markdown": "报告对 JSX 组件的未解析引用。 如果引用的组件在此项目或其依赖项中定义，则建议添加 import 语句，或使用指定名称创建新组件。\n\n新组件的模板可以在\"编辑器 \\| 文件和代码模板\"中修改。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "TypeScriptJSXUnresolvedComponent",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnfilteredForInLoop",
                "shortDescription": {
                  "text": "未过滤 for..in 循环"
                },
                "fullDescription": {
                  "text": "报告未筛选的 'for-in' 循环。 使用此结构不仅会处理对象自身的属性，还会处理对象原型的属性。 在某些特定情况下可能出人意料，例如，在复制或修改所有属性的实用程序方法中 或者 'Object' 的原型可能被错误修改时。 例如，以下代码将打印 42 和 myMethod： 'Object.prototype.myMethod = function myMethod() {};\nlet a = { foo: 42 };\nfor (let i in a) {\n  console.log(a[i]);\n}' 建议将整个循环替换为 'Object.keys()' 方法，或添加 'hasOwnProperty()' 检查。 应用快速修复后，代码如下所示： 'for (let i in a) {\n  if (a.hasOwnProperty(i)) {\n    console.log(a[i]);\n  }\n}'",
                  "markdown": "报告未筛选的 `for-in` 循环。   \n\n使用此结构不仅会处理对象自身的属性，还会处理对象原型的属性。 在某些特定情况下可能出人意料，例如，在复制或修改所有属性的实用程序方法中 或者 `Object` 的原型可能被错误修改时。 例如，以下代码将打印 **42** 和 **myMethod** ：   \n\n\n    Object.prototype.myMethod = function myMethod() {};\n    let a = { foo: 42 };\n    for (let i in a) {\n      console.log(a[i]);\n    }\n\n建议将整个循环替换为 `Object.keys()` 方法，或添加 `hasOwnProperty()` 检查。 应用快速修复后，代码如下所示：\n\n\n    for (let i in a) {\n      if (a.hasOwnProperty(i)) {\n        console.log(a[i]);\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnfilteredForInLoop",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSFunctionExpressionToArrowFunction",
                "shortDescription": {
                  "text": "使用了函数表达式而不是箭头函数"
                },
                "fullDescription": {
                  "text": "报告函数表达式。 建议将其转换为箭头函数。 示例： 'arr.map(function(el) {return el + 1})' 应用快速修复后，代码如下所示： 'arr.map(el => el + 1)'",
                  "markdown": "报告[函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function)表达式。 建议将其转换为[箭头函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。\n\n示例：\n\n    arr.map(function(el) {return el + 1})\n\n应用快速修复后，代码如下所示：\n\n    arr.map(el => el + 1)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSFunctionExpressionToArrowFunction",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/ES2015 迁移协助",
                      "index": 82,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUndefinedPropertyAssignment",
                "shortDescription": {
                  "text": "未定义的属性赋值"
                },
                "fullDescription": {
                  "text": "报告对未在变量类型中定义的属性的赋值。 示例： '/**\n * @type {{ property1: string, property2: number }}\n */\nlet myVariable = create();\n\nmyVariable.newProperty = 3; // 不良'",
                  "markdown": "报告对未在变量类型中定义的属性的赋值。\n\n示例：\n\n\n    /**\n     * @type {{ property1: string, property2: number }}\n     */\n    let myVariable = create();\n\n    myVariable.newProperty = 3; // 不良\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSUndefinedPropertyAssignment",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSDeprecatedSymbols",
                "shortDescription": {
                  "text": "已使用弃用的符号"
                },
                "fullDescription": {
                  "text": "报告弃用的函数变量的用法。",
                  "markdown": "报告弃用的函数变量的用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSDeprecatedSymbols",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LocalVariableNamingConventionJS",
                "shortDescription": {
                  "text": "局部变量命名约定"
                },
                "fullDescription": {
                  "text": "报告名称太短、太长或不符合 指定正则表达式模式的局部变量。 使用下面提供的字段来指定局部变量名称的最小长度、 最大长度以及预期的正则表达式。 使用标准 'java.util.regex' 格式的正则表达式。",
                  "markdown": "报告名称太短、太长或不符合 指定正则表达式模式的局部变量。\n\n\n使用下面提供的字段来指定局部变量名称的最小长度、\n最大长度以及预期的正则表达式。 使用标准 `java.util.regex` 格式的正则表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LocalVariableNamingConventionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/命名约定",
                      "index": 149,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UpdateDependencyToLatestVersion",
                "shortDescription": {
                  "text": "将 package.json 依赖项更新为最新版本"
                },
                "fullDescription": {
                  "text": "建议将 package.json 依赖项升级到最新版本，并忽略指定的版本。",
                  "markdown": "建议将 package.json 依赖项升级到最新版本，并忽略指定的版本。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "UpdateDependencyToLatestVersion",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/Import 和依赖项",
                      "index": 140,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnresolvedExtXType",
                "shortDescription": {
                  "text": "未解析的 Ext JS xtype"
                },
                "fullDescription": {
                  "text": "报告没有相应类的 Ext JS 'xtype' 引用。",
                  "markdown": "报告没有相应类的 Ext JS `xtype` 引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnresolvedExtXType",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ES6RedundantNestingInTemplateLiteral",
                "shortDescription": {
                  "text": "模板文字中的冗余嵌套"
                },
                "fullDescription": {
                  "text": "报告字符串或模板文字的嵌套实例。 建议将嵌套的实例内联到包含其的模板字符串中。 示例： 'let a = `Hello, ${`Brave ${\"New\"}`} ${\"World\"}!`' 应用快速修复后，代码如下所示： 'let a = `Hello, Brave New World!`'",
                  "markdown": "报告字符串或模板文字的嵌套实例。 建议将嵌套的实例内联到包含其的模板字符串中。\n\n示例：\n\n\n    let a = `Hello, ${`Brave ${\"New\"}`} ${\"World\"}!`\n\n应用快速修复后，代码如下所示：\n\n\n    let a = `Hello, Brave New World!`\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ES6RedundantNestingInTemplateLiteral",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestingDepthJS",
                "shortDescription": {
                  "text": "函数过度嵌套"
                },
                "fullDescription": {
                  "text": "报告其函数体中包含的语句在其他语句中嵌套过深的函数。 此类函数可能令人困惑，并且表明可能有必要重构。 使用下面提供的字段指定函数中可接受的最大嵌套深度。",
                  "markdown": "报告其函数体中包含的语句在其他语句中嵌套过深的函数。 此类函数可能令人困惑，并且表明可能有必要重构。\n\n\n使用下面提供的字段指定函数中可接受的最大嵌套深度。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "OverlyNestedFunctionJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/函数指标",
                      "index": 111,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TypeScriptSuspiciousConstructorParameterAssignment",
                "shortDescription": {
                  "text": "已分配构造函数字段形参"
                },
                "fullDescription": {
                  "text": "在类字段声明为构造函数形参，然后为此形参赋值时，报告 TypeScript 代码中的常见错误。 在这种情况下，不会赋值给相应的字段，而只是修改局部形参值。 'class Foo {\n  constructor(private p: number) {\n    p = 1; //必须为 this.p = 1；\n  }\n}'",
                  "markdown": "在类字段声明为构造函数形参，然后为此形参赋值时，报告 TypeScript 代码中的常见错误。  \n在这种情况下，*不会* 赋值给相应的字段，而只是修改局部形参值。\n\n\n    class Foo {\n      constructor(private p: number) {\n        p = 1; //必须为 this.p = 1；\n      }\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TypeScriptSuspiciousConstructorParameterAssignment",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/TypeScript",
                      "index": 78,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AssignmentResultUsedJS",
                "shortDescription": {
                  "text": "使用的赋值的结果"
                },
                "fullDescription": {
                  "text": "报告赋值结果在包含其的表达式中使用的赋值表达式。 此类赋值通常表明有编码错误，例如，应是 '=' 而不是 '=='。 此外，它们可能会由于运算顺序而导致混淆， 因为赋值的求值可能会以意想不到的方式影响外部表达式。 将忽略圆括号中的表达式。",
                  "markdown": "报告赋值结果在包含其的表达式中使用的赋值表达式。 此类赋值通常表明有编码错误，例如，应是 `=` 而不是 `==`。 此外，它们可能会由于运算顺序而导致混淆， 因为赋值的求值可能会以意想不到的方式影响外部表达式。\n\n将忽略圆括号中的表达式。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AssignmentResultUsedJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/赋值问题",
                      "index": 73,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ConstantOnRHSOfComparisonJS",
                "shortDescription": {
                  "text": "常量位于比较的右侧"
                },
                "fullDescription": {
                  "text": "报告右侧有常量的比较运算。 根据 编码约定，常量应当只位于比较的左侧。",
                  "markdown": "报告右侧有常量的比较运算。 根据 编码约定，常量应当只位于比较的左侧。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ConstantOnRightSideOfComparisonJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码样式问题",
                      "index": 112,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnnecessarySemicolon",
                "shortDescription": {
                  "text": "不必要的分号"
                },
                "fullDescription": {
                  "text": "报告不必要的分号。",
                  "markdown": "报告不必要的分号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnnecessarySemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NestedSwitchStatementJS",
                "shortDescription": {
                  "text": "嵌套 'switch' 语句"
                },
                "fullDescription": {
                  "text": "报告嵌套在另一个 'switch' 语句中的 'switch' 语句。 嵌套的 'switch' 语句可能非常令人困惑，尤其在缩进不一致的情况下。",
                  "markdown": "报告嵌套在另一个 `switch` 语句中的 `switch` 语句。 嵌套的 `switch` 语句可能非常令人困惑，尤其在缩进不一致的情况下。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NestedSwitchStatementJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSMissingSwitchBranches",
                "shortDescription": {
                  "text": "'switch' 语句缺少分支"
                },
                "fullDescription": {
                  "text": "当 'switch' 语句不包含 'enum' 或 'union' 类型的某些值选项时，报告该类型变量的 switch 语句。",
                  "markdown": "当 `switch` 语句不包含 `enum` 或 `union` 类型的某些值选项时，报告该类型变量的 switch 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "JSMissingSwitchBranches",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/switch 语句问题",
                      "index": 107,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSJQueryEfficiency",
                "shortDescription": {
                  "text": "可以优化 JQuery 选择器"
                },
                "fullDescription": {
                  "text": "报告可以缓存的重复 jQuery 选择器，或报告特性或伪选择器的用法（可选）。",
                  "markdown": "报告可以缓存的重复 jQuery 选择器，或报告特性或伪选择器的用法（可选）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSJQueryEfficiency",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnreachableCodeJS",
                "shortDescription": {
                  "text": "不可到达的代码"
                },
                "fullDescription": {
                  "text": "报告永远无法执行的代码，这几乎肯定表明有错误",
                  "markdown": "报告永远无法执行的代码，这几乎肯定表明有错误"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnreachableCodeJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/控制流问题",
                      "index": 97,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSSuspiciousEqPlus",
                "shortDescription": {
                  "text": "可疑的 '=+' 赋值"
                },
                "fullDescription": {
                  "text": "报告 'a =+ b' 形式的赋值。 建议替换为 'a += b'。",
                  "markdown": "报告 `a =+ b` 形式的赋值。 建议替换为 `a += b`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSSuspiciousEqPlus",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能的 bug",
                      "index": 85,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EmptyStatementBodyJS",
                "shortDescription": {
                  "text": "带空体的语句"
                },
                "fullDescription": {
                  "text": "报告语句体为空的 'if' 、'while' 、'for' 或 'with' 语句。 此类语句通常是由拼写错误所致，可能会引起混淆。 使用下面的复选框指定是否应报告以空块语句为主体的语句。",
                  "markdown": "报告语句体为空的 `if` 、`while` 、`for` 或 `with` 语句。 此类语句通常是由拼写错误所致，可能会引起混淆。\n\n\n使用下面的复选框指定是否应报告以空块语句为主体的语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StatementWithEmptyBodyJS",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/可能引起混淆的代码结构",
                      "index": 44,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JSUnusedLocalSymbols",
                "shortDescription": {
                  "text": "未使用的局部符号"
                },
                "fullDescription": {
                  "text": "报告本地可以访问的并且未使用的形参、局部变量、函数、类或 private 成员声明。",
                  "markdown": "报告本地可以访问的并且未使用的形参、局部变量、函数、类或 private 成员声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JSUnusedLocalSymbols",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/未使用的符号",
                      "index": 27,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.plugins.postcss",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "PostCssUnresolvedModuleValueReference",
                "shortDescription": {
                  "text": "未解析的 CSS 模块值"
                },
                "fullDescription": {
                  "text": "报告对 CSS Module Value（'@value' 声明）的未解析引用。 示例： '@value foo from unknown;'",
                  "markdown": "报告对 [CSS Module Value](https://github.com/css-modules/postcss-modules-values)（`@value` 声明）的未解析引用。\n\n示例：\n\n\n    @value foo from unknown;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PostCssUnresolvedModuleValueReference",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PostCSS",
                      "index": 30,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PostCssNesting",
                "shortDescription": {
                  "text": "无效的嵌套规则"
                },
                "fullDescription": {
                  "text": "报告语法不符合 PostCSS Nested 或 PostCSS Nesting 规范的嵌套样式规则。 示例： '.phone {\n  &_title {}\n}'",
                  "markdown": "报告语法不符合 [PostCSS Nested](https://github.com/postcss/postcss-nested) 或 [PostCSS Nesting](https://github.com/csstools/postcss-nesting) 规范的嵌套样式规则。\n\n示例：\n\n\n    .phone {\n      &_title {}\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PostCssNesting",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PostCSS",
                      "index": 30,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PostCssCustomMedia",
                "shortDescription": {
                  "text": "自定义媒体无效"
                },
                "fullDescription": {
                  "text": "报告 PostCSS 自定义媒体查询中的语法错误。 示例： '@custom-media --small-viewport (max-width: 30em);'",
                  "markdown": "报告 [PostCSS 自定义媒体](https://github.com/postcss/postcss-custom-media)查询中的语法错误。\n\n示例：\n\n\n    @custom-media --small-viewport (max-width: 30em);\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PostCssCustomMedia",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PostCSS",
                      "index": 30,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PostCssCustomSelector",
                "shortDescription": {
                  "text": "自定义选择器无效"
                },
                "fullDescription": {
                  "text": "报告 PostCSS 自定义选择器中的语法错误。 示例： '@custom-selector :--heading h1, h2, h3;'",
                  "markdown": "报告 [PostCSS 自定义选择器](https://github.com/postcss/postcss-custom-selectors)中的语法错误。\n\n示例：\n\n\n    @custom-selector :--heading h1, h2, h3;\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PostCssCustomSelector",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PostCSS",
                      "index": 30,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PostCssMediaRange",
                "shortDescription": {
                  "text": "媒体查询范围无效"
                },
                "fullDescription": {
                  "text": "检查范围上下文语法，该语法可替代性地用于 'range' 类型的媒体特性。 示例： '@media screen and (500px <= width <= 1200px) {}'",
                  "markdown": "检查[范围上下文](https://github.com/postcss/postcss-media-minmax)语法，该语法可替代性地用于 'range' 类型的媒体特性。\n\n示例：\n\n\n    @media screen and (500px <= width <= 1200px) {}\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "PostCssMediaRange",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PostCSS",
                      "index": 30,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.reactivestreams",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "ReactiveStreamsUnusedPublisher",
                "shortDescription": {
                  "text": "未使用的发布者"
                },
                "fullDescription": {
                  "text": "报告未使用的 'Publisher' 实例。 要使用生成新的 'Publisher' 实例的运算符（返回 Mono/Flux/Flowable 的 Mono/Flux/Flowable 对象的方法），您必须通过 'subscribe()' 订阅创建的 'Publisher'。 使用工厂（例如，'Mono.just()'）而不订阅返回的 'Publisher'，会创建一个从未使用的对象，并被视为不必要的内存分配。 例如，'Mono.just(1, 2, 3).map(i -> i + 3)' 不会被执行，除非您订阅了此 'Publisher'，或者除非您通过应用运算符生成新的 'Publisher' 并订阅它。 示例： 未使用的 'Flux' 实例： 'Flux.just(1, 2, 3);' 使用者使用的 'Flux' 实例： 'Flux.just(1, 2, 3).subscribe(System.out::println);' 不会报告对使用 Error Prone 或 AssertJ 的 '@CanIgnoreReturnValue' 注解进行注解的方法的调用。 2019.3 最新变化",
                  "markdown": "报告未使用的 `Publisher` 实例。\n\n\n要使用生成新的 `Publisher` 实例的运算符（返回 Mono/Flux/Flowable 的 Mono/Flux/Flowable 对象的方法），您必须通过 `subscribe()` 订阅创建的 `Publisher`。\n\n\n使用工厂（例如，`Mono.just()`）而不订阅返回的 `Publisher`，会创建一个从未使用的对象，并被视为不必要的内存分配。\n\n\n例如，`Mono.just(1, 2, 3).map(i -> i + 3)` 不会被执行，除非您订阅了此 `Publisher`，或者除非您通过应用运算符生成新的 `Publisher` 并订阅它。\n\n**示例：**\n\n未使用的 `Flux` 实例：\n\n\n    Flux.just(1, 2, 3);\n\n使用者使用的 `Flux` 实例：\n\n\n    Flux.just(1, 2, 3).subscribe(System.out::println);\n\n不会报告对使用 Error Prone 或 AssertJ 的 `@CanIgnoreReturnValue` 注解进行注解的方法的调用。\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReactiveStreamsUnusedPublisher",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/通用",
                      "index": 35,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactiveStreamsThrowInOperator",
                "shortDescription": {
                  "text": "Throw 语句位于 Reactive 运算符中"
                },
                "fullDescription": {
                  "text": "报告 Reactor/RxJava 运算符代码中的 'throw' 表达式。 从 Reactor/RxJava 运算符抛出异常表明可能存在问题，因为您可以返回“类似于 Reactive”的错误：从 'flatMap()' 的 'Mono.error()' 或 'Flowable.error()'，或者从 Reactor 的 'handle()' 运算符调用 'sink.error()'。 此外，Reactor 工厂方法允许在没有任何错误的情况下返回已检查的异常，而在没有 'Exceptions' 类的情况下抛出此类异常会导致编译错误。 示例： 'Flux.just(1, 2, 3).flatMap(i -> {\n            throw new RuntimeException();\n        })' 在应用快速修复后： 'Flux.just(1, 2, 3).flatMap(i -> {\n            return Flux.error(new RuntimeException());\n        })' 2019.3 最新变化",
                  "markdown": "报告 Reactor/RxJava 运算符代码中的 `throw` 表达式。\n\n从 Reactor/RxJava 运算符抛出异常表明可能存在问题，因为您可以返回\"类似于 Reactive\"的错误：从 `flatMap()` 的 `Mono.error()` 或 `Flowable.error()`，或者从 Reactor 的 `handle()` 运算符调用 `sink.error()`。\n\n\n此外，Reactor 工厂方法允许在没有任何错误的情况下返回已检查的异常，而在没有 `Exceptions` 类的情况下抛出此类异常会导致编译错误。\n\n**示例：**\n\n\n    Flux.just(1, 2, 3).flatMap(i -> {\n                throw new RuntimeException();\n            })\n\n在应用快速修复后：\n\n\n    Flux.just(1, 2, 3).flatMap(i -> {\n                return Flux.error(new RuntimeException());\n            })\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReactiveStreamsThrowInOperator",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/通用",
                      "index": 35,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactiveStreamsPublisherImplementation",
                "shortDescription": {
                  "text": "类实现发布者"
                },
                "fullDescription": {
                  "text": "报告直接实现 'Publisher' 接口的类。 考虑使用来自 RxJava、Reactor 或 Mutiny 的 static 生成器，例如 'Flux.just()'、'Flux.create()'、'Flux.generate()'、'Flux.from()' 'Mono.create()'、'Mono.from()'、'Mono.just()' 'Flowable.just()'、'Flowable.from()' 'Maybe.just()'、'Maybe.from()' 'Multi.createFrom()', 'Multi.createBy()' 'Uni.createFrom()'",
                  "markdown": "报告直接实现 `Publisher` 接口的类。\n\n考虑使用来自 RxJava、Reactor 或 Mutiny 的 static 生成器，例如\n\n* `Flux.just()`、`Flux.create()`、`Flux.generate()`、`Flux.from()`\n* `Mono.create()`、`Mono.from()`、`Mono.just()`\n* `Flowable.just()`、`Flowable.from()`\n* `Maybe.just()`、`Maybe.from()`\n* `Multi.createFrom()`, `Multi.createBy()`\n* `Uni.createFrom()`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReactiveStreamsPublisherImplementation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/通用",
                      "index": 35,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactiveStreamsNullableInLambdaInTransform",
                "shortDescription": {
                  "text": "在转换方法中从 lambda 返回 null 或可为 null 的内容"
                },
                "fullDescription": {
                  "text": "报告可能在 Reactive Streams 链中返回 'null' 的转换操作。 Reactive Streams 不支持可 null 值，因为这些值会导致此类代码失败。 该快速修复会建议将 'map()' 替换为 'mapNotNull'，从而忽略异常。 示例： 'repository.findWithTailableCursorBy()\n    .map(e -> (Person)null)\n    .doOnNext(System.out::println)' 在应用快速修复后： 'repository.findWithTailableCursorBy()\n    .mapNotNull(e -> (Person)null)\n    .doOnNext(System.out::println)' 2019.3 最新变化",
                  "markdown": "报告可能在 Reactive Streams 链中返回 `null` 的转换操作。\n\n\nReactive Streams 不支持可 null 值，因为这些值会导致此类代码失败。\n该快速修复会建议将 `map()` 替换为 `mapNotNull`，从而忽略异常。\n\n**示例：**\n\n    repository.findWithTailableCursorBy()\n        .map(e -> (Person)null)\n        .doOnNext(System.out::println)\n\n在应用快速修复后：\n\n    repository.findWithTailableCursorBy()\n        .mapNotNull(e -> (Person)null)\n        .doOnNext(System.out::println)\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReactiveStreamsNullableInLambdaInTransform",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/通用",
                      "index": 35,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactorZipWithMonoVoid",
                "shortDescription": {
                  "text": "Zip 包含 Mono<Void> 类型的形参"
                },
                "fullDescription": {
                  "text": "报告包含在 Reactor 链内具有 'Mono<Void>' 返回值的实参的 zip 操作 。 'Zip' 会在传入 'Mono<Void>' 完成后立即完成空操作。 该快速修复会建议将 'zip()'、'zipWhen()' 和 'zipWith()' 替换为 'when'。 示例： 'Mono.zip(Mono.just(1), Mono.fromRunnable(() -> System.out.println(\"value\")))\n                .map(v -> \"New value\")\n                .doFinally(System.out::println);' 在应用快速修复后： 'Mono.when(Mono.just(1), Mono.fromRunnable(() -> System.out.println(\"value\")))\n                .then(Mono.fromCallable(() -> \"New value\"))\n                .doFinally(System.out::println);' 2023.1 最新变化",
                  "markdown": "报告包含在 Reactor 链内具有 `Mono<Void>` 返回值的实参的 zip 操作 。\n\n\n`Zip` 会在传入 `Mono<Void>` 完成后立即完成空操作。\n该快速修复会建议将 `zip()`、`zipWhen()` 和 `zipWith()` 替换为 `when`。\n\n**示例：**\n\n    Mono.zip(Mono.just(1), Mono.fromRunnable(() -> System.out.println(\"value\")))\n                    .map(v -> \"New value\")\n                    .doFinally(System.out::println);\n\n在应用快速修复后：\n\n    Mono.when(Mono.just(1), Mono.fromRunnable(() -> System.out.println(\"value\")))\n                    .then(Mono.fromCallable(() -> \"New value\"))\n                    .doFinally(System.out::println);\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReactorZipWithMonoVoid",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/Reactor",
                      "index": 122,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactiveStreamsTooLongSameOperatorsChain",
                "shortDescription": {
                  "text": "相同方法链过长"
                },
                "fullDescription": {
                  "text": "报告长的 Reactive Streams 转换链。 每个运算符方法调用，例如 'map()' 或 'filter()'，都会为这些运算符创建一些对象。 在每个订阅上对每个流元素调用长运算符链可能会导致性能开销。 为避免这种情况，请尽可能将长运算符链合并为一个运算符调用。 示例： 'Flux.just(1, 2, 3)\n        .map(it -> it + 1)\n        .map(it -> it + 2)\n        .map(it -> it + 3)' 在应用快速修复后： 'Flux.just(1, 2, 3)\n        .map(it -> it + 1 + 2 + 3)' 2019.3 最新变化",
                  "markdown": "报告长的 Reactive Streams 转换链。\n\n每个运算符方法调用，例如 `map()` 或 `filter()`，都会为这些运算符创建一些对象。\n在每个订阅上对每个流元素调用长运算符链可能会导致性能开销。\n为避免这种情况，请尽可能将长运算符链合并为一个运算符调用。\n\n**示例：**\n\n\n    Flux.just(1, 2, 3)\n            .map(it -> it + 1)\n            .map(it -> it + 2)\n            .map(it -> it + 3)\n\n在应用快速修复后：\n\n\n    Flux.just(1, 2, 3)\n            .map(it -> it + 1 + 2 + 3)\n\n2019.3 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReactiveStreamsTooLongSameOperatorsChain",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/通用",
                      "index": 35,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CallingSubscribeInNonBlockingScope",
                "shortDescription": {
                  "text": "在 \"reactive\" 方法中调用 'subscribe'"
                },
                "fullDescription": {
                  "text": "报告 \"reactive\" 方法中的 'subscribe()' 调用。 返回 'Publisher' 类型（包括 'Flux' 和 'Mono'）的方法不应直接调用 'subscribe()' 方法，因为它可能破坏反应式调用链。 不要使用 'subscribe()'，而是考虑使用组合运算符，例如 'flatMap()'、'zip()'、'then()' > 等。 示例： 'Flux<String> stringFlux(){\n    Flux<String> flux = Flux.just(\"abc\");\n    flux.subscribe(); // <- 在非阻塞上下文中阻塞 'subscribe' 调用\n    return flux;\n  }'",
                  "markdown": "报告 \"reactive\" 方法中的 `subscribe()` 调用。\n\n返回 `Publisher` 类型（包括 `Flux` 和 `Mono`）的方法不应直接调用 `subscribe()` 方法，因为它可能破坏反应式调用链。\n\n不要使用 `subscribe()`，而是考虑使用组合运算符，例如 `flatMap()`、`zip()`、`then()` \\> 等。\n\n**示例：**\n\n\n      Flux<String> stringFlux(){\n        Flux<String> flux = Flux.just(\"abc\");\n        flux.subscribe(); // <- 在非阻塞上下文中阻塞 'subscribe' 调用\n        return flux;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CallingSubscribeInNonBlockingScope",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/Reactor",
                      "index": 122,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactorTransformationOnMonoVoid",
                "shortDescription": {
                  "text": "在 Mono<Void> 类型的接收器上调用转换函数"
                },
                "fullDescription": {
                  "text": "报告对 Reactor 链内的 'Mono<Void>' 值调用的转换操作。 'Mono<Void>' 会在没有任何值的情况下完成，这就是不会在转换函数上调用任何内容的原因。 该快速修复会建议将 'map()' 和 'flatMap()' 替换为 'then()'。 示例： 'Mono.when(Mono.just(1), Mono.just(2))\n                .map(v -> \"New value\")\n                .doFinally(System.out::println);' 在应用快速修复后： 'Mono.when(Mono.just(1), Mono.just(2))\n                .then(Mono.fromCallable(() -> \"New value\"))\n                .doFinally(System.out::println);' 2023.1 最新变化",
                  "markdown": "报告对 Reactor 链内的 `Mono<Void>` 值调用的转换操作。\n\n\n`Mono<Void>` 会在没有任何值的情况下完成，这就是不会在转换函数上调用任何内容的原因。\n该快速修复会建议将 `map()` 和 `flatMap()` 替换为 `then()`。\n\n**示例：**\n\n    Mono.when(Mono.just(1), Mono.just(2))\n                    .map(v -> \"New value\")\n                    .doFinally(System.out::println);\n\n在应用快速修复后：\n\n    Mono.when(Mono.just(1), Mono.just(2))\n                    .then(Mono.fromCallable(() -> \"New value\"))\n                    .doFinally(System.out::println);\n\n2023.1 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReactorTransformationOnMonoVoid",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/Reactor",
                      "index": 122,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MutinyCallingSubscribeInNonBlockingScope",
                "shortDescription": {
                  "text": "在 \"reactive\" 方法中调用 'subscribe'"
                },
                "fullDescription": {
                  "text": "报告 \"reactive\" 方法中的 'subscribe()' 调用。 返回 Publisher（包括 'Uni' 和 'Multi'）的方法不应直接调用 'subscribe()' 方法，因为它可能破坏反应式调用链。 不要使用 'subscribe()'，而应考虑使用组合运算符，例如 'flatMap()'、'merge()' 等。 示例： 'Multi<String> stringMulti(){\n    Multi<String> multi = Multi.createFrom().item(\"abc\");\n    multi.subscribe(); // <- 在非阻塞上下文中阻塞 'subscribe' 调用\n    return multi;\n  }'",
                  "markdown": "报告 \"reactive\" 方法中的 `subscribe()` 调用。\n\n返回 Publisher（包括 `Uni` 和 `Multi`）的方法不应直接调用 `subscribe()` 方法，因为它可能破坏反应式调用链。\n\n不要使用 `subscribe()`，而应考虑使用组合运算符，例如 `flatMap()`、`merge()` 等。\n\n**示例：**\n\n\n      Multi<String> stringMulti(){\n        Multi<String> multi = Multi.createFrom().item(\"abc\");\n        multi.subscribe(); // <- 在非阻塞上下文中阻塞 'subscribe' 调用\n        return multi;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MutinyCallingSubscribeInNonBlockingScope",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/Mutiny",
                      "index": 161,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactiveStreamsSubscriberImplementation",
                "shortDescription": {
                  "text": "类实现订阅者"
                },
                "fullDescription": {
                  "text": "报告直接实现 'Subscriber' 接口的类。 考虑使用来自 RxJava、Reactor 或 Mutiny 的 static 生成器，例如 'Flux.just()'、'Flux.create()'、'Flux.generate()'、'Flux.from()' 'Mono.create()'、'Mono.from()'、'Mono.just()' 'Flowable.just()'、'Flowable.from()' 'Maybe.just()'、'Maybe.from()' 'Multi.createFrom()', 'Multi.createBy()' 'Uni.createFrom()'",
                  "markdown": "报告直接实现 `Subscriber` 接口的类。\n\n考虑使用来自 RxJava、Reactor 或 Mutiny 的 static 生成器，例如\n\n* `Flux.just()`、`Flux.create()`、`Flux.generate()`、`Flux.from()`\n* `Mono.create()`、`Mono.from()`、`Mono.just()`\n* `Flowable.just()`、`Flowable.from()`\n* `Maybe.just()`、`Maybe.from()`\n* `Multi.createFrom()`, `Multi.createBy()`\n* `Uni.createFrom()`"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "ReactiveStreamsSubscriberImplementation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/通用",
                      "index": 35,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnfinishedStepVerifier",
                "shortDescription": {
                  "text": "未完成的 StepVerifier"
                },
                "fullDescription": {
                  "text": "报告缺失的 'StepVerifier' 终端调用。 启动 'Publisher' 订阅和断言需要调用终端验证方法，例如'verify()'、'verifyComplete()' 等。 示例： 'StepVerifier.create(Flux.just(1,2,3)).expectNext(1);' 在应用快速修复后： 'StepVerifier.create(Flux.just(1,2,3)).expectNext(1).verifyComplete();'",
                  "markdown": "报告缺失的 `StepVerifier` 终端调用。\n\n\n启动 `Publisher` 订阅和断言需要调用终端验证方法，例如`verify()`、`verifyComplete()` 等。\n\n**示例：**\n\n\n    StepVerifier.create(Flux.just(1,2,3)).expectNext(1);\n\n在应用快速修复后：\n\n\n    StepVerifier.create(Flux.just(1,2,3)).expectNext(1).verifyComplete();\n"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnfinishedStepVerifier",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/Reactor",
                      "index": 122,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ReactorAutomaticDebugger",
                "shortDescription": {
                  "text": "不必要的调试初始化"
                },
                "fullDescription": {
                  "text": "报告冗余的 'ReactorDebugAgent.init()' 调用。 IDE 可以自动初始化 Reactor Debug 模式，因此用户不需要显式调用 'ReactorDebugAgent.init()' 或 'Hooks.onOperatorDebug()'。 此外，同时调用 'ReactorDebugAgent.init()' 和 'Hooks.onOperatorDebug()' 会导致 Reactor 生成双倍的调试堆栈帧。",
                  "markdown": "报告冗余的 `ReactorDebugAgent.init()` 调用。\n\n\nIDE 可以自动初始化 Reactor Debug 模式，因此用户不需要显式调用 `ReactorDebugAgent.init()` 或 `Hooks.onOperatorDebug()`。\n\n此外，同时调用 `ReactorDebugAgent.init()` 和 `Hooks.onOperatorDebug()` 会导致 Reactor 生成双倍的调试堆栈帧。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ReactorAutomaticDebugger",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Reactive Streams/Reactor",
                      "index": 122,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.freemarker",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "FtlFileReferencesInspection",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告 '#include' 和 '#import' 指令中的未解析 FreeMarker 文件引用。",
                  "markdown": "报告 `#include` 和 `#import` 指令中的未解析 FreeMarker 文件引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "FtlFileReferencesInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FtlImportCallInspection",
                "shortDescription": {
                  "text": "未解析的外部调用"
                },
                "fullDescription": {
                  "text": "报告位于其他文件中的未解析 '#macro' 和 '#function' 指令。 该快速修复会建议对所需文件使用 '#import' 或 '#include'。",
                  "markdown": "报告位于其他文件中的未解析 `#macro` 和 `#function` 指令。\n\n该快速修复会建议对所需文件使用 `#import` 或 `#include`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "FtlImportCallInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FtlCallsInspection",
                "shortDescription": {
                  "text": "无效的调用指令"
                },
                "fullDescription": {
                  "text": "报告与宏声明不匹配的 FreeMarker 调用（例如，缺少形参、错误类型等）。",
                  "markdown": "报告与宏声明不匹配的 FreeMarker 调用（例如，缺少形参、错误类型等）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "FtlCallsInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FtlTypesInspection",
                "shortDescription": {
                  "text": "不正确的表达式类型"
                },
                "fullDescription": {
                  "text": "报告不正确的 FreeMarker 表达式类型。",
                  "markdown": "报告不正确的 FreeMarker 表达式类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FtlTypesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FtlLanguageInspection",
                "shortDescription": {
                  "text": "内置错误"
                },
                "fullDescription": {
                  "text": "报告 FreeMarker 语言错误。",
                  "markdown": "报告 FreeMarker 语言错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "FtlLanguageInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FtlReferencesInspection",
                "shortDescription": {
                  "text": "未解析的引用"
                },
                "fullDescription": {
                  "text": "报告未解析的 FreeMarker 引用。",
                  "markdown": "报告未解析的 FreeMarker 引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FtlReferencesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FtlDeprecatedBuiltInsInspection",
                "shortDescription": {
                  "text": "内置已弃用"
                },
                "fullDescription": {
                  "text": "报告已弃用的内置对象（例如，'default'、'exists'、'if_exists'、'web_safe'）。",
                  "markdown": "报告已弃用的内置对象（例如，`default`、`exists`、`if_exists`、`web_safe`）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "FtlDeprecatedBuiltInsInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "FtlWellformednessInspection",
                "shortDescription": {
                  "text": "指令格式不正确"
                },
                "fullDescription": {
                  "text": "报告格式错误的 FreeMarker 指令（例如，错误的嵌套、缺少结束标记等）。",
                  "markdown": "报告格式错误的 FreeMarker 指令（例如，错误的嵌套、缺少结束标记等）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "FtlWellformednessInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "FreeMarker",
                      "index": 39,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.editorconfig.editorconfigjetbrains",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "EditorConfigNumerousWildcards",
                "shortDescription": {
                  "text": "过多通配符"
                },
                "fullDescription": {
                  "text": "报告包含过多通配符的部分。 使用大量通配符可能会导致性能问题。",
                  "markdown": "报告包含过多通配符的部分。 使用大量通配符可能会导致性能问题。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigNumerousWildcards",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigKeyCorrectness",
                "shortDescription": {
                  "text": "未知属性"
                },
                "fullDescription": {
                  "text": "报告 IDE 不支持的属性。 注意：一些 “ij” 域属性可能需要特定的语言插件。",
                  "markdown": "报告 IDE 不支持的属性。 注意：一些 \"ij\" 域属性可能需要特定的语言插件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigKeyCorrectness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEncoding",
                "shortDescription": {
                  "text": "文件编码与 EditorConfig 字符集不匹配"
                },
                "fullDescription": {
                  "text": "检查当前文件编码是否与 .editorconfig 文件 \"charset\" 属性中定义的编码匹配。",
                  "markdown": "检查当前文件编码是否与 .editorconfig 文件 \"charset\" 属性中定义的编码匹配。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigEncoding",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEmptyHeader",
                "shortDescription": {
                  "text": "空标头"
                },
                "fullDescription": {
                  "text": "报告带有空标题的部分。 部分标题必须包含格式类似于 'gitignore' 支持的格式的文件路径 glob。",
                  "markdown": "报告带有空标题的部分。 部分标题必须包含格式类似于 `gitignore` 支持的格式的文件路径 glob。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigEmptyHeader",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigMissingRequiredDeclaration",
                "shortDescription": {
                  "text": "缺少必需声明"
                },
                "fullDescription": {
                  "text": "报告缺少所需声明的属性。 有关更多信息，请参阅文档。",
                  "markdown": "报告缺少所需声明的属性。 有关更多信息，请参阅文档。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigMissingRequiredDeclaration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigSpaceInHeader",
                "shortDescription": {
                  "text": "文件模式中的空格"
                },
                "fullDescription": {
                  "text": "报告影响模式匹配的通配符模式中的空格字符。 如果这些字符不是故意的，则应将其删除。",
                  "markdown": "报告影响模式匹配的通配符模式中的空格字符。 如果这些字符不是故意的，则应将其删除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigSpaceInHeader",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigOptionRedundancy",
                "shortDescription": {
                  "text": "冗余属性"
                },
                "fullDescription": {
                  "text": "报告另一个适用的部分已经包含相同的属性和值的冗余的属性。 示例： '[*]\nindent_size=4\n[*.java]\nindent_size=4' 都适用于 '*.java' 文件并定义相同的 'indent_size' 值。",
                  "markdown": "报告另一个适用的部分已经包含相同的属性和值的冗余的属性。\n\n\n示例：\n\n\n    [*]\n    indent_size=4\n    [*.java]\n    indent_size=4\n\n都适用于 `*.java` 文件并定义相同的 `indent_size` 值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigOptionRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPartialOverride",
                "shortDescription": {
                  "text": "重叠的部分"
                },
                "fullDescription": {
                  "text": "报告当前部分中指定的文件子集与其他部分中的其他子集重叠。 例如：'[{foo,bar}]' 和 '[{foo,bas}]' 都包含 “foo”。",
                  "markdown": "报告当前部分中指定的文件子集与其他部分中的其他子集重叠。 例如：`[{foo,bar}]` 和 `[{foo,bas}]` 都包含 \"foo\"。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "EditorConfigPartialOverride",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigListAcceptability",
                "shortDescription": {
                  "text": "意外的值列表"
                },
                "fullDescription": {
                  "text": "报告在不支持列表的属性中使用的值列表。 在这种情况下，只能指定一个值。",
                  "markdown": "报告在不支持列表的属性中使用的值列表。 在这种情况下，只能指定一个值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigListAcceptability",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPatternEnumerationRedundancy",
                "shortDescription": {
                  "text": "不必要的大括号"
                },
                "fullDescription": {
                  "text": "报告要么为空 '{}'，要么只包含一个模式（例如 '{foo}'）而非包含多个模式的列表（例如 '{foo,bar}'）的模式列表。 在这种情况下，大括号会被作为名称的一部分进行处理。 例如，模式 '*.{a}' 将匹配 'my.{a}' 文件而非 'my.a' 文件。",
                  "markdown": "报告要么为空 `{}`，要么只包含一个模式（例如 `{foo}`）而非包含多个模式的列表（例如 `{foo,bar}`）的模式列表。 在这种情况下，大括号会被作为名称的一部分进行处理。 例如，模式 `*.{a}` 将匹配 `my.{a}` 文件而非 `my.a` 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigPatternEnumerationRedundancy",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPairAcceptability",
                "shortDescription": {
                  "text": "意外的键值对"
                },
                "fullDescription": {
                  "text": "报告当前上下文中不允许的键值对。",
                  "markdown": "报告当前上下文中不允许的键值对。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigPairAcceptability",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigNoMatchingFiles",
                "shortDescription": {
                  "text": "无匹配文件"
                },
                "fullDescription": {
                  "text": "报告通配符模式与 '.editorconfig' 文件所在目录下的任何文件都不匹配的部分。",
                  "markdown": "报告通配符模式与 `.editorconfig` 文件所在目录下的任何文件都不匹配的部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigNoMatchingFiles",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigWildcardRedundancy",
                "shortDescription": {
                  "text": "冗余通配符"
                },
                "fullDescription": {
                  "text": "报告在同一部分中使用 “**” 通配符时变得冗余的通配符。 “**” 通配符定义了比其他通配符更广泛的文件集。 因此，同一部分中使用的任何其他通配符都是无效的，可以删除。",
                  "markdown": "报告在同一部分中使用 \"\\*\\*\" 通配符时变得冗余的通配符。\n\n\n\"\\*\\*\" 通配符定义了比其他通配符更广泛的文件集。\n因此，同一部分中使用的任何其他通配符都是无效的，可以删除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigWildcardRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigHeaderUniqueness",
                "shortDescription": {
                  "text": "EditorConfig 部分不唯一"
                },
                "fullDescription": {
                  "text": "报告定义与其他部分相同的文件模式的部分。",
                  "markdown": "报告定义与其他部分相同的文件模式的部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigHeaderUniqueness",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigValueCorrectness",
                "shortDescription": {
                  "text": "无效属性值"
                },
                "fullDescription": {
                  "text": "报告不符合值限制的属性值。 例如，某些属性可能只能为 “true” 或 “false”、其他属性仅包含整数等。 如果一个值的变体集合有限，请使用代码完成来查看所有变体。",
                  "markdown": "报告不符合值限制的属性值。 例如，某些属性可能只能为 \"true\" 或 \"false\"、其他属性仅包含整数等。 如果一个值的变体集合有限，请使用代码完成来查看所有变体。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigValueCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigUnusedDeclaration",
                "shortDescription": {
                  "text": "未使用的声明"
                },
                "fullDescription": {
                  "text": "报告未使用的声明。 可以删除此类声明。",
                  "markdown": "报告未使用的声明。 可以删除此类声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigUnusedDeclaration",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigRootDeclarationUniqueness",
                "shortDescription": {
                  "text": "额外顶层声明"
                },
                "fullDescription": {
                  "text": "报告多个顶层声明。 EditorConfig 文件中只能有一个可选的 “root=true” 顶级声明。 不允许使用多个顶级声明。",
                  "markdown": "报告多个顶层声明。 EditorConfig 文件中只能有一个可选的 \"root=true\" 顶级声明。 不允许使用多个顶级声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigRootDeclarationUniqueness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigRootDeclarationCorrectness",
                "shortDescription": {
                  "text": "意外的顶层声明"
                },
                "fullDescription": {
                  "text": "报告非预期的顶层声明。 EditorConfig 文件中不允许使用除 “root=true” 之外的顶级声明。",
                  "markdown": "报告非预期的顶层声明。 EditorConfig 文件中不允许使用除 \"root=true\" 之外的顶级声明。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigRootDeclarationCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigPatternRedundancy",
                "shortDescription": {
                  "text": "重复或冗余模式"
                },
                "fullDescription": {
                  "text": "报告已经有另一个模式定义了具有相同或更广泛文件范围的冗余的文件模式。 例如，在 '[{*.java,*}]' 中，第一个 '*.java' 模式定义了比 '*' 更窄的范围。 这使得第一个模式变得多余并且可以被移除。",
                  "markdown": "报告已经有另一个模式定义了具有相同或更广泛文件范围的冗余的文件模式。 例如，在 `[{*.java,*}]` 中，第一个 `*.java` 模式定义了比 `*` 更窄的范围。 这使得第一个模式变得多余并且可以被移除。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigPatternRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigDeprecatedDescriptor",
                "shortDescription": {
                  "text": "弃用的属性"
                },
                "fullDescription": {
                  "text": "报告不再支持的 EditorConfig 属性。",
                  "markdown": "报告不再支持的 EditorConfig 属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigDeprecatedDescriptor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigShadowedOption",
                "shortDescription": {
                  "text": "被重写的属性"
                },
                "fullDescription": {
                  "text": "报告已在其他部分中定义的属性。 示例： '[*.java]\nindent_size=4\n[{*.java,*.js}]\nindent_size=2' 第二部分也包括所有 '*.java' 文件，但它也重新定义了 indent_size。 因此，值 \"2\" 将用于匹配 '*.java' 的文件。",
                  "markdown": "报告已在其他部分中定义的属性。\n\n示例：\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\n第二部分也包括所有 `*.java` 文件，但它也重新定义了 indent_size。 因此，值 \"2\" 将用于匹配 `*.java` 的文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigShadowedOption",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigValueUniqueness",
                "shortDescription": {
                  "text": "非唯一列表值"
                },
                "fullDescription": {
                  "text": "报告值列表中的重复项。",
                  "markdown": "报告值列表中的重复项。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigValueUniqueness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigUnexpectedComma",
                "shortDescription": {
                  "text": "意外逗号"
                },
                "fullDescription": {
                  "text": "报告不能在当前上下文中使用的逗号。 逗号只能用作分隔符来分隔列表中的值。",
                  "markdown": "报告不能在当前上下文中使用的逗号。 逗号只能用作分隔符来分隔列表中的值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigUnexpectedComma",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigCharClassRedundancy",
                "shortDescription": {
                  "text": "不必要的字符类"
                },
                "fullDescription": {
                  "text": "报告由单个字符组成的字符类。 这种类可以简化为一个字符，例如 '[a]'→'a'。",
                  "markdown": "报告由单个字符组成的字符类。 这种类可以简化为一个字符，例如 `[a]`→`a`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigCharClassRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigEmptySection",
                "shortDescription": {
                  "text": "空部分"
                },
                "fullDescription": {
                  "text": "报告不包含任何 EditorConfig 属性的部分。",
                  "markdown": "报告不包含任何 EditorConfig 属性的部分。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigEmptySection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigShadowingOption",
                "shortDescription": {
                  "text": "重写属性"
                },
                "fullDescription": {
                  "text": "报告覆盖文件中先前定义的相同属性的属性。 示例： '[*.java]\nindent_size=4\n[{*.java,*.js}]\nindent_size=2' 第二部分同样包含 '[*.java]' 文件，但还将 indent_size 设置为值 2。 因此第一个声明 'indent_size=4' 将被忽略。",
                  "markdown": "报告覆盖文件中先前定义的相同属性的属性。\n\n示例：\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\n第二部分同样包含 `[*.java]` 文件，但还将 indent_size 设置为值 2。 因此第一个声明 `indent_size=4` 将被忽略。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigShadowingOption",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigReferenceCorrectness",
                "shortDescription": {
                  "text": "无效引用"
                },
                "fullDescription": {
                  "text": "报告未知或类型错误的标识符。",
                  "markdown": "报告未知或类型错误的标识符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigReferenceCorrectness",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigVerifyByCore",
                "shortDescription": {
                  "text": "无效的 .editorconfig 文件"
                },
                "fullDescription": {
                  "text": "使用备份 EditorConfig 核心库验证整个文件，并报告任何失败。 任何此类失败都会阻止 EditorConfig 属性的正确应用。",
                  "markdown": "使用备份 EditorConfig 核心库验证整个文件，并报告任何失败。 任何此类失败都会阻止 EditorConfig 属性的正确应用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "EditorConfigVerifyByCore",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "EditorConfigCharClassLetterRedundancy",
                "shortDescription": {
                  "text": "重复的字符类字母"
                },
                "fullDescription": {
                  "text": "报告 EditorConfig 部分中在字符类中包含重复字符的通配符模式，例如 '[aa]'。",
                  "markdown": "报告 EditorConfig 部分中在字符类中包含重复字符的通配符模式，例如 `[aa]`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "EditorConfigCharClassLetterRedundancy",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "EditorConfig",
                      "index": 41,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.velocity",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "VtlInterpolationsInspection",
                "shortDescription": {
                  "text": "合式性检查"
                },
                "fullDescription": {
                  "text": "报告 '#macro' 和 '#set' 指令中正式符号的非法用法。",
                  "markdown": "报告 `#macro` 和 `#set` 指令中正式符号的非法用法。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "VtlInterpolationsInspection",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Velocity",
                      "index": 50,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VtlReferencesInspection",
                "shortDescription": {
                  "text": "引用检查"
                },
                "fullDescription": {
                  "text": "如果 Velocity 参考被错误解析，则报告。",
                  "markdown": "如果 Velocity 参考被错误解析，则报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VtlReferencesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Velocity",
                      "index": 50,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VtlDirectiveArgsInspection",
                "shortDescription": {
                  "text": "指令实参检查"
                },
                "fullDescription": {
                  "text": "报告 Velocity 指令的非法值或实参类型。",
                  "markdown": "报告 Velocity 指令的非法值或实参类型。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VtlDirectiveArgsInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Velocity",
                      "index": 50,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VtlFileReferencesInspection",
                "shortDescription": {
                  "text": "文件引用检查"
                },
                "fullDescription": {
                  "text": "如果 '#include' 和 '#parse' 指令中的 Velocity 文件引用被错误解析，则报告。",
                  "markdown": "如果 `#include` 和 `#parse` 指令中的 Velocity 文件引用被错误解析，则报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VtlFileReferencesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Velocity",
                      "index": 50,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VtlTypesInspection",
                "shortDescription": {
                  "text": "类型检查"
                },
                "fullDescription": {
                  "text": "如果二元和一元表达式具有类型不正确的操作数，则报告。",
                  "markdown": "如果二元和一元表达式具有类型不正确的操作数，则报告。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VtlTypesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Velocity",
                      "index": 50,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.css",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "CssInvalidFunction",
                "shortDescription": {
                  "text": "无效函数"
                },
                "fullDescription": {
                  "text": "报告未知的 CSS 函数或不正确的函数形参。",
                  "markdown": "报告未知的 [CSS 函数](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions)或不正确的函数形参。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssInvalidFunction",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssMissingComma",
                "shortDescription": {
                  "text": "选择器列表中缺少逗号"
                },
                "fullDescription": {
                  "text": "报告多行选择器。 这很可能表明实际上要使用多个单行选择器，但有一行或几行的末尾缺少逗号。 示例： 'input /* comma has probably been forgotten */\n.button {\n  margin: 1px;\n}'",
                  "markdown": "报告多行选择器。 这很可能表明实际上要使用多个单行选择器，但有一行或几行的末尾缺少逗号。\n\n**示例：**\n\n\n    input /* comma has probably been forgotten */\n    .button {\n      margin: 1px;\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssMissingComma",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/可能的 bug",
                      "index": 77,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssConvertColorToRgbInspection",
                "shortDescription": {
                  "text": "颜色可被替换为 rgb()"
                },
                "fullDescription": {
                  "text": "报告 'hsl()' 或 'hwb()' 颜色函数或十六进制的颜色表示法。 建议将此类颜色值替换为等效的 'rgb()' 或 'rgba()' 颜色函数。 示例： '#0c0fff' 在应用快速修复后： 'rgb(12, 15, 255)'.",
                  "markdown": "报告 `hsl()` 或 `hwb()` 颜色函数或十六进制的颜色表示法。\n\n建议将此类颜色值替换为等效的 `rgb()` 或 `rgba()` 颜色函数。\n\n**示例：**\n\n    #0c0fff\n\n在应用快速修复后：\n\n    rgb(12, 15, 255).\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssConvertColorToRgbInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssUnusedSymbol",
                "shortDescription": {
                  "text": "未使用的选择器"
                },
                "fullDescription": {
                  "text": "报告出现在选择器中但未在 HTML 中使用的 CSS 类或元素 ID。 请注意，只有通过代码 | 检查代码或代码 | 分析代码 | 按名称运行检查运行时，才能获得完整的检查结果。 由于性能原因，不实时检查样式表文件。",
                  "markdown": "报告出现在选择器中但未在 HTML 中使用的 CSS 类或元素 ID。\n\n\n请注意，只有通过**代码 \\| 检查代码** 或**代码 \\| 分析代码 \\| 按名称运行检查**运行时，才能获得完整的检查结果。\n由于性能原因，不实时检查样式表文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssUnusedSymbol",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssDeprecatedValue",
                "shortDescription": {
                  "text": "弃用的值"
                },
                "fullDescription": {
                  "text": "报告已弃用的 CSS 值。 建议将已弃用的值替换为其有效的等效值。",
                  "markdown": "报告已弃用的 CSS 值。 建议将已弃用的值替换为其有效的等效值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssDeprecatedValue",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssNonIntegerLengthInPixels",
                "shortDescription": {
                  "text": "非整数长度(像素)"
                },
                "fullDescription": {
                  "text": "报告以像素为单位的非整数长度。 示例： 'width: 3.14px'",
                  "markdown": "报告以像素为单位的非整数长度。\n\n**示例：**\n\n     width: 3.14px\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CssNonIntegerLengthInPixels",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/可能的 bug",
                      "index": 77,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssOverwrittenProperties",
                "shortDescription": {
                  "text": "覆盖的属性"
                },
                "fullDescription": {
                  "text": "报告规则集中重复的 CSS 属性。 遵循速记属性。 示例： '.foo {\n  margin-bottom: 1px;\n  margin-bottom: 1px; /* duplicates margin-bottom */\n  margin: 0; /* overrides margin-bottom */\n}'",
                  "markdown": "报告规则集中重复的 CSS 属性。 遵循速记属性。\n\n**示例：**\n\n\n    .foo {\n      margin-bottom: 1px;\n      margin-bottom: 1px; /* duplicates margin-bottom */\n      margin: 0; /* overrides margin-bottom */\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssOverwrittenProperties",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidNestedSelector",
                "shortDescription": {
                  "text": "嵌套选择器无效"
                },
                "fullDescription": {
                  "text": "报告以标识符或函数表示法开头的嵌套选择器。",
                  "markdown": "报告以标识符或函数表示法开头的嵌套选择器。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssInvalidNestedSelector",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidHtmlTagReference",
                "shortDescription": {
                  "text": "无效类型选择器"
                },
                "fullDescription": {
                  "text": "报告与未知 HTML 元素匹配的 CSS 类型选择器。",
                  "markdown": "报告与未知 HTML 元素匹配的 CSS [类型选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssInvalidHtmlTagReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssMissingSemicolon",
                "shortDescription": {
                  "text": "缺少分号"
                },
                "fullDescription": {
                  "text": "报告声明末尾处缺少的分号。",
                  "markdown": "报告声明末尾处缺少的分号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssMissingSemicolon",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/代码样式问题",
                      "index": 158,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidCustomPropertyAtRuleName",
                "shortDescription": {
                  "text": "@property 名称无效"
                },
                "fullDescription": {
                  "text": "报告无效的自定义属性名称。 自定义属性名称应以两个短划线作为前缀。 示例： '@property invalid-property-name {\n  ...\n}\n\n@property --valid-property-name {\n  ...\n}'",
                  "markdown": "报告无效的自定义属性名称。 自定义属性名称应以两个短划线作为前缀。\n\n**示例：**\n\n\n    @property invalid-property-name {\n      ...\n    }\n\n    @property --valid-property-name {\n      ...\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssInvalidCustomPropertyAtRuleName",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssConvertColorToHexInspection",
                "shortDescription": {
                  "text": "颜色可被替换为 #-hex"
                },
                "fullDescription": {
                  "text": "报告 'rgb()'、'hsl()' 或其他颜色函数。 建议用等效的十六进制表示法代替颜色函数。 示例： 'rgb(12, 15, 255)' 在应用快速修复后： '#0c0fff'.",
                  "markdown": "报告 `rgb()`、`hsl()` 或其他颜色函数。\n\n建议用等效的十六进制表示法代替颜色函数。\n\n**示例：**\n\n    rgb(12, 15, 255)\n\n在应用快速修复后：\n\n    #0c0fff.\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssConvertColorToHexInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidAtRule",
                "shortDescription": {
                  "text": "未知 @ 规则"
                },
                "fullDescription": {
                  "text": "报告未知的 CSS @ 规则。",
                  "markdown": "报告未知的 [CSS @ 规则](https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssInvalidAtRule",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssUnknownTarget",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告未解析的文件引用，例如 '@import' 语句中的不正确路径。",
                  "markdown": "报告未解析的文件引用，例如 `@import` 语句中的不正确路径。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssUnknownTarget",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssNegativeValue",
                "shortDescription": {
                  "text": "负属性值"
                },
                "fullDescription": {
                  "text": "报告应不小于零的 CSS 负值属性（例如对象的宽度或高度）。",
                  "markdown": "报告应不小于零的 CSS 负值属性（例如对象的宽度或高度）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssNegativeValue",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssNoGenericFontName",
                "shortDescription": {
                  "text": "缺少通用字体系列名称"
                },
                "fullDescription": {
                  "text": "验证 'font-family' 属性是否包含通用的字体系列名称作为回退备选项。 通用字体系列名称包括：'serif'、'sans-serif'、'cursive'、'fantasy' 和 'monospace'。",
                  "markdown": "验证 [font-family](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family) 属性是否包含通用的字体系列名称作为回退备选项。\n\n\n通用字体系列名称包括：`serif`、`sans-serif`、`cursive`、`fantasy` 和 `monospace`。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssNoGenericFontName",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/可能的 bug",
                      "index": 77,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidCharsetRule",
                "shortDescription": {
                  "text": "@charset 位置错误或不正确"
                },
                "fullDescription": {
                  "text": "报告位置错误的 '@charset' @ 规则或不正确的字符集值。",
                  "markdown": "报告位置错误的 `@charset` @ 规则或不正确的字符集值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssInvalidCharsetRule",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidPseudoSelector",
                "shortDescription": {
                  "text": "无效的伪选择器"
                },
                "fullDescription": {
                  "text": "报告不正确的 CSS pseudo-class pseudo-element。",
                  "markdown": "报告不正确的 CSS [pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes) [pseudo-element](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssInvalidPseudoSelector",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidCustomPropertyAtRuleDeclaration",
                "shortDescription": {
                  "text": "@property 声明无效"
                },
                "fullDescription": {
                  "text": "报告自定义属性的声明中缺少的必需语法、继承或 initial-value 属性。",
                  "markdown": "报告自定义属性的声明中缺少的必需[语法](https://developer.mozilla.org/en-US/docs/web/css/@property/syntax)、[继承](https://developer.mozilla.org/en-US/docs/web/css/@property/inherits)或 [initial-value](https://developer.mozilla.org/en-US/docs/web/css/@property/initial-value) 属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssInvalidCustomPropertyAtRuleDeclaration",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssRedundantUnit",
                "shortDescription": {
                  "text": "冗余度量单位"
                },
                "fullDescription": {
                  "text": "在规范不要求提供单位的情况下，报告值为零的度量单位。 示例： 'width: 0px'",
                  "markdown": "在规范不要求提供单位的情况下，报告值为零的度量单位。\n\n**示例：**\n\n    width: 0px\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssRedundantUnit",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/代码样式问题",
                      "index": 158,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidPropertyValue",
                "shortDescription": {
                  "text": "无效的属性值"
                },
                "fullDescription": {
                  "text": "报告不正确的 CSS 属性值。",
                  "markdown": "报告不正确的 CSS 属性值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssInvalidPropertyValue",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssBrowserCompatibilityForProperties",
                "shortDescription": {
                  "text": "属性与所选浏览器不兼容"
                },
                "fullDescription": {
                  "text": "报告不受指定浏览器支持的 CSS 属性。 基于 MDN 兼容性数据。",
                  "markdown": "报告不受指定浏览器支持的 CSS 属性。 基于 [MDN 兼容性数据](https://github.com/mdn/browser-compat-data)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssBrowserCompatibilityForProperties",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssReplaceWithShorthandUnsafely",
                "shortDescription": {
                  "text": "属性或许可被替换为速记形式"
                },
                "fullDescription": {
                  "text": "报告一组 CSS 常规属性，并建议将不完整的一组 CSS 常规属性替换为速记形式，但在本例中，速记形式并非 100% 等效。 例如，'outline-color' 和 'outline-style' 这 2 个属性可以替换为单个 'outline'。 此类替换不是 100% 等效，因为速记形式会将所有忽略的子值重置为其初始状态。 在本例中，切换到 'outling' 简写形式意味着 'outling-width' 也将设置为其初始值，即 'medium'。 此检查不会处理整组常规属性（在切换到速记形式 100% 安全时）。 对于此类情况，请参阅“属性可以安全替换为速记形式”检查。",
                  "markdown": "报告一组 CSS 常规属性，并建议将不完整的一组 CSS 常规属性替换为速记形式，但在本例中，速记形式并非 100% 等效。\n\n\n例如，`outline-color` 和 `outline-style` 这 2 个属性可以替换为单个 `outline`。\n此类替换不是 100% 等效，因为速记形式会将所有忽略的子值重置为其初始状态。\n在本例中，切换到 `outling` 简写形式意味着 `outling-width` 也将设置为其初始值，即 `medium`。\n\n\n此检查不会处理整组常规属性（在切换到速记形式 100% 安全时）。\n对于此类情况，请参阅\"属性可以安全替换为速记形式\"检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CssReplaceWithShorthandUnsafely",
                    "ideaSeverity": "INFORMATION",
                    "qodanaSeverity": "Info"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssUnknownUnit",
                "shortDescription": {
                  "text": "未知单位"
                },
                "fullDescription": {
                  "text": "报告未知单元.",
                  "markdown": "报告未知单元."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssUnknownUnit",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidMediaFeature",
                "shortDescription": {
                  "text": "无效媒体特性"
                },
                "fullDescription": {
                  "text": "报告未知 CSS 媒体特性或不正确的媒体特性值。",
                  "markdown": "报告未知 [CSS 媒体特性](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)或不正确的媒体特性值。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssInvalidMediaFeature",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssInvalidImport",
                "shortDescription": {
                  "text": "@import 位置错误"
                },
                "fullDescription": {
                  "text": "报告位置错误的 '@import' 语句。 根据规范， '@import' 规则必须优先于其他所有类型的规则，但 '@charset' 规则除外。",
                  "markdown": "报告位置错误的 `@import` 语句。\n\n\n根据[规范](https://developer.mozilla.org/en-US/docs/Web/CSS/@import)，\n`@import` 规则必须优先于其他所有类型的规则，但 `@charset` 规则除外。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssInvalidImport",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssUnresolvedCustomProperty",
                "shortDescription": {
                  "text": "未解析的自定义属性"
                },
                "fullDescription": {
                  "text": "报告对 'var()' 函数实参中的自定义属性的未解析引用。",
                  "markdown": "报告对 `var()` 函数实参中的[自定义属性](https://developer.mozilla.org/en-US/docs/Web/CSS/--*)的未解析引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssUnresolvedCustomProperty",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssUnresolvedClassInComposesRule",
                "shortDescription": {
                  "text": "'composes' 规则中的未解析类"
                },
                "fullDescription": {
                  "text": "报告 'composes' 规则中无法解析为任何有效目标的 CSS 类引用。 示例： '.className {/* ... */}\n\n  .otherClassName {\n    composes: className;\n  }'",
                  "markdown": "报告 ['composes'](https://github.com/css-modules/css-modules#composition) 规则中无法解析为任何有效目标的 CSS 类引用。\n\n**示例：**\n\n\n      .className {/* ... */}\n\n      .otherClassName {\n        composes: className;\n      }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "CssUnresolvedClassInComposesRule",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssReplaceWithShorthandSafely",
                "shortDescription": {
                  "text": "属性可以安全地替换为速记形式"
                },
                "fullDescription": {
                  "text": "报告一组普通属性。 建议将整组 CSS 常规属性替换为等效的速记形式。 例如，'padding-top'、'padding-right'、'padding-bottom' 和 'padding-left' 这 4 个属性可以安全地替换为单个 'padding' 属性。 注意，如果这组常规属性不完整（例如，规则集中只有 3 个 'padding-xxx' 属性），则不会显示此检查，因为切换到速记形式可能会改变结果。 对于此类情况，可以考虑执行“属性可能已被替换为速记形式”检查。",
                  "markdown": "报告一组普通属性。 建议将整组 CSS 常规属性替换为等效的速记形式。\n\n\n例如，`padding-top`、`padding-right`、`padding-bottom` 和 `padding-left`\n这 4 个属性可以安全地替换为单个 `padding` 属性。\n\n\n注意，如果这组常规属性不完整（例如，规则集中只有 3 个 `padding-xxx` 属性），则不会显示此检查，因为切换到速记形式可能会改变结果。\n对于此类情况，可以考虑执行\"属性可能已被替换为速记形式\"检查。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "CssReplaceWithShorthandSafely",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS",
                      "index": 52,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "CssUnknownProperty",
                "shortDescription": {
                  "text": "未知属性"
                },
                "fullDescription": {
                  "text": "报告未知的 CSS 属性或在错误的上下文中使用的属性。 将未知属性添加到“自定义 CSS 属性”列表以跳过验证。",
                  "markdown": "报告未知的 CSS 属性或在错误的上下文中使用的属性。\n\n将未知属性添加到\"自定义 CSS 属性\"列表以跳过验证。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "CssUnknownProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/无效元素",
                      "index": 53,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.kubernetes",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "HelmChartMissingKeys",
                "shortDescription": {
                  "text": "缺少 Chart.yaml 键"
                },
                "fullDescription": {
                  "text": "报告 Chart.yaml 中缺少所需的键。",
                  "markdown": "报告 Chart.yaml 中缺少所需的键。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "HelmChartMissingKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesDeprecatedResources",
                "shortDescription": {
                  "text": "弃用的 Kubernetes 资源"
                },
                "fullDescription": {
                  "text": "报告弃用的 Kubernetes 资源类型。",
                  "markdown": "报告弃用的 Kubernetes 资源类型。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KubernetesDeprecatedResources",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesUnknownValues",
                "shortDescription": {
                  "text": "未知 Kubernetes YAML 值"
                },
                "fullDescription": {
                  "text": "报告 Kubernetes 资源文件中的无效值。",
                  "markdown": "报告 Kubernetes 资源文件中的无效值。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KubernetesUnknownValues",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesUnknownKeys",
                "shortDescription": {
                  "text": "未知 Kubernetes YAML 键"
                },
                "fullDescription": {
                  "text": "报告 Kubernetes 资源文件中无法识别的键。",
                  "markdown": "报告 Kubernetes 资源文件中无法识别的键。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KubernetesUnknownKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesNonEditableResources",
                "shortDescription": {
                  "text": "不可编辑的 Kubernetes 资源"
                },
                "fullDescription": {
                  "text": "报告不可编辑（只读）的 Kubernetes 资源类型。",
                  "markdown": "报告不可编辑（只读）的 Kubernetes 资源类型。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KubernetesNonEditableResources",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HelmChartUnknownValues",
                "shortDescription": {
                  "text": "Chart.yaml 值无效"
                },
                "fullDescription": {
                  "text": "报告 Chart.yaml 和 requirements.yaml 中无法识别的值。",
                  "markdown": "报告 Chart.yaml 和 requirements.yaml 中无法识别的值。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "HelmChartUnknownValues",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesMissingKeys",
                "shortDescription": {
                  "text": "缺少 Kubernetes YAML 键"
                },
                "fullDescription": {
                  "text": "报告 Kubernetes 资源文件中缺少所需的键。",
                  "markdown": "报告 Kubernetes 资源文件中缺少所需的键。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KubernetesMissingKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesUnknownResourcesInspection",
                "shortDescription": {
                  "text": "未知 Kubernetes 资源"
                },
                "fullDescription": {
                  "text": "报告无法识别的 Kubernetes 资源类型。",
                  "markdown": "报告无法识别的 Kubernetes 资源类型。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KubernetesUnknownResourcesInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "HelmChartUnknownKeys",
                "shortDescription": {
                  "text": "未知 Chart.yaml 键"
                },
                "fullDescription": {
                  "text": "报告 Chart.yaml 中无法识别的键。",
                  "markdown": "报告 Chart.yaml 中无法识别的键。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "HelmChartUnknownKeys",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesDeprecatedKeys",
                "shortDescription": {
                  "text": "弃用的 Kubernetes 资源属性"
                },
                "fullDescription": {
                  "text": "报告 Kubernetes 资源文件中已弃用的键。",
                  "markdown": "报告 Kubernetes 资源文件中已弃用的键。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KubernetesDeprecatedKeys",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesDuplicatedEnvVars",
                "shortDescription": {
                  "text": "重复的 EnvVar 定义"
                },
                "fullDescription": {
                  "text": "报告 Kubernetes 容器定义中的重复 EnvVars。",
                  "markdown": "报告 Kubernetes 容器定义中的重复 EnvVars。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "KubernetesDuplicatedEnvVars",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "KubernetesNonEditableKeys",
                "shortDescription": {
                  "text": "不可编辑的 Kubernetes 资源属性"
                },
                "fullDescription": {
                  "text": "报告 Kubernetes 资源文件中的不可编辑（只读）的键。",
                  "markdown": "报告 Kubernetes 资源文件中的不可编辑（只读）的键。   "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "KubernetesNonEditableKeys",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Kubernetes",
                      "index": 62,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.properties",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "UseEllipsisInPropertyInspection",
                "shortDescription": {
                  "text": "使用三点字符而不是省略号"
                },
                "fullDescription": {
                  "text": "报告 UTF-8 属性文件中用于代替省略号字符的三个“点”字符。",
                  "markdown": "报告 UTF-8 属性文件中用于代替省略号字符的三个\"点\"字符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UseEllipsisInPropertyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 64,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AlphaUnsortedPropertiesFile",
                "shortDescription": {
                  "text": "属性文件或资源包未按字母顺序排序"
                },
                "fullDescription": {
                  "text": "报告未按字母顺序排序的资源包或 .properties 文件。",
                  "markdown": "报告未按字母顺序排序的资源包或 .properties 文件。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "AlphaUnsortedPropertiesFile",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 64,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "TrailingSpacesInProperty",
                "shortDescription": {
                  "text": "属性中有尾随空格"
                },
                "fullDescription": {
                  "text": "报告键或值以空格结尾的所有属性。",
                  "markdown": "报告键或值以空格结尾的所有属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TrailingSpacesInProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 64,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "WrongPropertyKeyValueDelimiter",
                "shortDescription": {
                  "text": "属性键/值分隔符与代码样式设置不匹配"
                },
                "fullDescription": {
                  "text": "报告键或值分隔符与代码样式设置不匹配的属性。",
                  "markdown": "报告键或值分隔符与代码样式设置不匹配的属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "WrongPropertyKeyValueDelimiter",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 64,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DuplicatePropertyInspection",
                "shortDescription": {
                  "text": "重复属性"
                },
                "fullDescription": {
                  "text": "报告具有不同值的重复属性键、重复键或重复属性值。 示例： 'property1=value;\nproperty2=value;' 选项 列表允许选择检查应搜索重复项的区域。",
                  "markdown": "报告具有不同值的重复属性键、重复键或重复属性值。\n\n示例：\n\n\n    property1=value;\n    property2=value;\n\n**选项** 列表允许选择检查应搜索重复项的区域。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DuplicatePropertyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 64,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnusedProperty",
                "shortDescription": {
                  "text": "未使用的属性"
                },
                "fullDescription": {
                  "text": "报告未在包含它们的 .properties 文件外部引用的属性。",
                  "markdown": "报告未在包含它们的 .properties 文件外部引用的属性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnusedProperty",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "属性文件",
                      "index": 64,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "Docker",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "DockerFileAddOrCopyPaths",
                "shortDescription": {
                  "text": "'ADD'/'COPY' 命令的无效目标"
                },
                "fullDescription": {
                  "text": "报告 'ADD' 和 'COPY' 命令中无效的目标目录。 根据 Dockerfile 规范，如果指定了多个源，则目标必须是目录，并且必须以斜杠 '/' 结尾。 否则，Docker 构建会失败。 示例： '# 下面的所有命令都将失败\n  ADD textA.txt textB.txt relativeDir\n  ADD [\"binaryA.jar\", \"binary2.jar\", \"destination\"]\n  COPY text3.txt text4.txt /absolute/path' 在应用快速修复后： 'ADD textA.txt textB.txt relativeDir/\n  ADD [\"binaryA.jar\", \"binary2.jar\", \"destination/\"]\n  COPY text3.txt text4.txt /absolute/path/'",
                  "markdown": "报告 `ADD` 和 `COPY` 命令中无效的目标目录。\n\n\n根据 [Dockerfile 规范](https://docs.docker.com/engine/reference/builder/#add)，如果指定了多个源，则目标必须是目录，并且必须以斜杠 '/' 结尾。\n否则，Docker 构建会失败。\n\n**示例：**\n\n\n      # 下面的所有命令都将失败\n      ADD textA.txt textB.txt relativeDir\n      ADD [\"binaryA.jar\", \"binary2.jar\", \"destination\"]\n      COPY text3.txt text4.txt /absolute/path\n\n在应用快速修复后：\n\n\n      ADD textA.txt textB.txt relativeDir/\n      ADD [\"binaryA.jar\", \"binary2.jar\", \"destination/\"]\n      COPY text3.txt text4.txt /absolute/path/\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DockerFileAddOrCopyPaths",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Dockerfile",
                      "index": 71,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DockerFileRunCommandMissingContinuation",
                "shortDescription": {
                  "text": "'RUN' 命令缺少连续字符"
                },
                "fullDescription": {
                  "text": "报告 'RUN' 命令中的缺失继续符。 在 shell 形式的 'RUN' 命令中，应使用 '\\'（反斜杠）将单条 'RUN' 指令延续到下一行。 否则，Docker 构建会失败。 示例： '# the command below will fail\n  RUN /bin/bash -c 'source $HOME/.bashrc;\n      echo $HOME'' 在应用快速修复后： 'RUN /bin/bash -c 'source $HOME/.bashrc; \\\n      echo $HOME''",
                  "markdown": "报告 `RUN` 命令中的缺失继续符。\n\n\n在 *shell* 形式的 `RUN` 命令中，应使用 '\\\\'（反斜杠）将单条 `RUN` 指令延续到下一行。\n否则，Docker 构建会失败。\n\n**示例：**\n\n\n      # the command below will fail\n      RUN /bin/bash -c 'source $HOME/.bashrc;\n          echo $HOME'\n\n在应用快速修复后：\n\n\n      RUN /bin/bash -c 'source $HOME/.bashrc; \\\n          echo $HOME'\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "DockerFileRunCommandMissingContinuation",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Dockerfile",
                      "index": 71,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComposeMissingKeys",
                "shortDescription": {
                  "text": "缺少 docker-compose YAML 键"
                },
                "fullDescription": {
                  "text": "报告 Docker Compose 文件中缺少必需键。",
                  "markdown": "报告 Docker Compose 文件中缺少必需键。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ComposeMissingKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Docker-compose",
                      "index": 136,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComposeUnquotedPorts",
                "shortDescription": {
                  "text": "未加引号的端口映射"
                },
                "fullDescription": {
                  "text": "报告 Docker Compose 文件中未加引号的端口映射。 根据 Compose 文件规范，'HOST:CONTAINER' 格式的映射端口在使用小于 60 的容器端口时可能会导致错误的结果，因为 YAML 会将格式为 'xx:yy' 的数字解析为六十进制值。 因此，我们建议始终将端口映射明确指定为字符串。 示例： 'ports:\n    - 3000\n    - 3000-3005\n    - 22:22\n    - 8080:8080' 在应用快速修复后： 'ports:\n    - \"3000\"\n    - \"3000-3005\"\n    - \"22:22\"\n    - \"8080:8080\"'",
                  "markdown": "报告 Docker Compose 文件中未加引号的端口映射。\n\n\n根据 [Compose 文件规范](https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-1)，`HOST:CONTAINER` 格式的映射端口在使用小于 60 的容器端口时可能会导致错误的结果，因为 YAML 会将格式为 `xx:yy` 的数字解析为六十进制值。\n因此，我们建议始终将端口映射明确指定为字符串。\n\n**示例：**\n\n\n      ports:\n        - 3000\n        - 3000-3005\n        - 22:22\n        - 8080:8080\n\n在应用快速修复后：\n\n\n      ports:\n        - \"3000\"\n        - \"3000-3005\"\n        - \"22:22\"\n        - \"8080:8080\"\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "ComposeUnquotedPorts",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Docker-compose",
                      "index": 136,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DockerJsonFormStringLiterals",
                "shortDescription": {
                  "text": "JSON 数组格式的带单引号的字符串"
                },
                "fullDescription": {
                  "text": "报告 JSON 数组格式的带单引号的字符串。 JSON 数组形式，必须在单词周围使用双引号 (\")，而不是单引号 (')。 否则，Docker 构建会失败。 示例： '# 下面的所有命令都将失败\n  RUN ['/bin/bash', '-c', 'echo hello']\n  ADD ['binaryA.jar', 'binary2.jar', 'destination/']\n  COPY ['binaryA.jar', 'binary2.jar', 'destination/']' 在应用快速修复后： 'RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n  ADD [\"binaryA.jar\", \"binary2.jar\", \"destination/\"]\n  COPY [\"binaryA.jar\", \"binary2.jar\", \"destination/\"]'",
                  "markdown": "报告 JSON 数组格式的带单引号的字符串。\n\n\nJSON 数组形式，必须在单词周围使用双引号 (\")，而不是单引号 (')。 否则，Docker 构建会失败。\n\n**示例：**\n\n\n      # 下面的所有命令都将失败\n      RUN ['/bin/bash', '-c', 'echo hello']\n      ADD ['binaryA.jar', 'binary2.jar', 'destination/']\n      COPY ['binaryA.jar', 'binary2.jar', 'destination/']\n\n在应用快速修复后：\n\n\n      RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n      ADD [\"binaryA.jar\", \"binary2.jar\", \"destination/\"]\n      COPY [\"binaryA.jar\", \"binary2.jar\", \"destination/\"]\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DockerJsonFormStringLiterals",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Dockerfile",
                      "index": 71,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComposeUnknownKeys",
                "shortDescription": {
                  "text": "未知 docker-compose YAML 键"
                },
                "fullDescription": {
                  "text": "报告 Docker Compose 文件中无法识别的键。",
                  "markdown": "报告 Docker Compose 文件中无法识别的键。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ComposeUnknownKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Docker-compose",
                      "index": 136,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DockerFileArgumentCount",
                "shortDescription": {
                  "text": "实参数量错误"
                },
                "fullDescription": {
                  "text": "报告 Dockerfile 命令的无效实参数量。 到达带有无效实参数量的指令后，Docker 构建将失败。",
                  "markdown": "报告 Dockerfile 命令的无效实参数量。\n\n\n到达带有无效实参数量的指令后，Docker 构建将失败。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "DockerFileArgumentCount",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Dockerfile",
                      "index": 71,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DockerFileAssignments",
                "shortDescription": {
                  "text": "'key=value' 对中无效的空格"
                },
                "fullDescription": {
                  "text": "报告 'ARG'、'ENV' 和 'LABEL' 命令中键值对的不正确间距。 尽管 Dockerfile 规范中没有明确指定，但不允许使用键值对的某些间距组合。 到达问题指令后，Docker 构建将失败。 示例： 'ARG' 命令不允许在 '=' 周围有任何空格 'ENV' 和 'LABEL' 在 '=' 后不允许有空格 '# 下面的所有命令都将失败\n  ARG answer = 42\n  ARG version= \"1.0.0\"\n  LABEL \"maintained.by\"= someone@gmail.com\n  ENV JAVA_HOME= \"/docker-java-home\"' 在应用快速修复后： 'ARG answer=2\n  ARG version=\"1.0.0\"\n  LABEL \"maintained.by\"=someone@gmail.com\n  ENV JAVA_HOME=\"/docker-java-home\"'",
                  "markdown": "报告 `ARG`、`ENV` 和 `LABEL` 命令中键值对的不正确间距。\n\n\n尽管 [Dockerfile 规范](https://docs.docker.com/engine/reference/builder/#arg)中没有明确指定，但不允许使用键值对的某些间距组合。\n到达问题指令后，Docker 构建将失败。\n\n**示例：**\n\n* `ARG` 命令不允许在 '=' 周围有任何空格\n* `ENV` 和 `LABEL` 在 '=' 后不允许有空格\n\n\n      # 下面的所有命令都将失败\n      ARG answer = 42\n      ARG version= \"1.0.0\"\n      LABEL \"maintained.by\"= someone@gmail.com\n      ENV JAVA_HOME= \"/docker-java-home\"\n\n在应用快速修复后：\n\n\n      ARG answer=2\n      ARG version=\"1.0.0\"\n      LABEL \"maintained.by\"=someone@gmail.com\n      ENV JAVA_HOME=\"/docker-java-home\"\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "DockerFileAssignments",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Dockerfile",
                      "index": 71,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "ComposeUnknownValues",
                "shortDescription": {
                  "text": "未知 docker-compose YAML 值"
                },
                "fullDescription": {
                  "text": "报告 Docker Compose 文件中无法识别的值。",
                  "markdown": "报告 Docker Compose 文件中无法识别的值。  "
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ComposeUnknownValues",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Docker-compose",
                      "index": 136,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "Lombook Plugin",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "RedundantModifiersUtilityClassLombok",
                "shortDescription": {
                  "text": "@UtilityClass 修饰符"
                },
                "fullDescription": {
                  "text": "报告使用 '@UtilityClass' 注解的类中不需要的修饰符。",
                  "markdown": "报告使用 `@UtilityClass` 注解的类中不需要的修饰符。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantModifiersUtilityClassLombok",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok/冗余修饰符",
                      "index": 80,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "SpringQualifierCopyableLombok",
                "shortDescription": {
                  "text": "@Qualifier 不可通过 lombok 复制"
                },
                "fullDescription": {
                  "text": "报告类字段上被相应的 Lombok '@RequiredArgsConstructor' 和 '@AllArgsConstructor' 注解忽略的 Spring '@Qualifier' 注解。 如果 'lombok.config' 文件中没有 'lombok.copyableAnnotations' 定义，生成的构造函数将不会收到 '@Qualifier' 注解。",
                  "markdown": "报告类字段上被相应的 Lombok `@RequiredArgsConstructor` 和 `@AllArgsConstructor` 注解忽略的 Spring `@Qualifier` 注解。 如果 `lombok.config` 文件中没有 `lombok.copyableAnnotations` 定义，生成的构造函数将不会收到 `@Qualifier` 注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "SpringQualifierCopyableLombok",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok",
                      "index": 79,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantModifiersValLombok",
                "shortDescription": {
                  "text": "'val' 前的不必要 final"
                },
                "fullDescription": {
                  "text": "报告在 'val' 之前的不需要 'final' 修饰符。",
                  "markdown": "报告在 `val` 之前的不需要 `final` 修饰符。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantModifiersValLombok",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok/冗余修饰符",
                      "index": 80,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LombokGetterMayBeUsed",
                "shortDescription": {
                  "text": "可以使用 Lombok @Getter"
                },
                "fullDescription": {
                  "text": "报告可由 lombok '@Getter' 注解替换的标准 getter 方法。 示例： 'import java.util.Date;\n\n  public class MyClass {\n    /**\n     * 处理日期。\n     */\n    private Date processDate;\n\n    /**\n     * 返回日期。\n     *\n     * @return The date\n     */\n    public Date getProcessDate() {\n      return processDate;\n    }\n  }' 在应用快速修复/清理后： 'import lombok.Getter;\n  import java.util.Date;\n\n  @Getter\n  public class MyClass {\n    /**\n     * 处理日期。\n     * -- GETTER --\n     * 返回日期。\n     *\n     * @return The date\n     */\n    private Date processDate;\n  }' 它仅在配置 lombok 库时报告。 要移除 lombok，请参阅 lombok 网站。 2023.2 最新变化",
                  "markdown": "报告可由 lombok `@Getter` 注解替换的标准 getter 方法。\n\n示例：\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * 处理日期。\n         */\n        private Date processDate;\n\n        /**\n         * 返回日期。\n         *\n         * @return The date\n         */\n        public Date getProcessDate() {\n          return processDate;\n        }\n      }\n\n在应用快速修复/清理后：\n\n\n      import lombok.Getter;\n      import java.util.Date;\n\n      @Getter\n      public class MyClass {\n        /**\n         * 处理日期。\n         * -- GETTER --\n         * 返回日期。\n         *\n         * @return The date\n         */\n        private Date processDate;\n      }\n\n它仅在配置 lombok 库时报告。 要移除 lombok，请参阅 lombok 网站。\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LombokGetterMayBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantSlf4jDefinition",
                "shortDescription": {
                  "text": "@Slf4j"
                },
                "fullDescription": {
                  "text": "报告明确定义的 Slf4j 记录器。 可以改用 '@Slf4j' 注解。",
                  "markdown": "报告明确定义的 *Slf4j* 记录器。 可以改用 `@Slf4j` 注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantSlf4jDefinition",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok/冗余定义",
                      "index": 157,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RedundantModifiersValueLombok",
                "shortDescription": {
                  "text": "@Value 修饰符"
                },
                "fullDescription": {
                  "text": "报告使用 '@Value' 注解的类中不需要的修饰符。",
                  "markdown": "报告使用 `@Value` 注解的类中不需要的修饰符。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RedundantModifiersValueLombok",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok/冗余修饰符",
                      "index": 80,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "StaticMethodImportLombok",
                "shortDescription": {
                  "text": "对 lombok 生成的方法使用 static import"
                },
                "fullDescription": {
                  "text": "报告 Lombok 的生成方法的静态 import 用法。 这将在使用 javac 进行编译时失败。 原因是在 lombok 注解处理器启动之前解析了 static 方法。 此时，javac 在注解处理器应该生成的代码之前使用原始代码，然后 javac 当然会报告缺失的符号（生成的方法）。 参阅更多详细信息",
                  "markdown": "报告 Lombok 的生成方法的静态 import 用法。  \n\n\n这将在使用 javac 进行编译时失败。 原因是在 lombok 注解处理器启动之前解析了 static 方法。\n此时，javac 在注解处理器应该生成的代码之前使用原始代码，然后 javac 当然会报告缺失的符号（生成的方法）。\n参阅更多[详细信息](https://github.com/projectlombok/lombok/issues/2044)"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "StaticMethodImportLombok",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok",
                      "index": 79,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LombokSetterMayBeUsed",
                "shortDescription": {
                  "text": "可以使用 Lombok @Setter"
                },
                "fullDescription": {
                  "text": "报告可由 lombok '@Setter' 注解替换的标准 setter 方法。 示例： 'import java.util.Date;\n\n  public class MyClass {\n    /**\n     * 处理日期。\n     */\n    private Date processDate;\n\n    /**\n     * 设置日期。\n     *\n     * @param The date\n     */\n    public void setProcessDate(Date param) {\n      processDate = param;\n    }\n  }' 在应用快速修复/清理后： 'import lombok.Setter;\n  import java.util.Date;\n\n  @Setter\n  public class MyClass {\n    /**\n     * 处理日期。\n     * -- SETTER --\n     * 设置日期。\n     *\n     * @param The date\n     */\n    private Date processDate;\n  }' 它仅在配置 lombok 库时报告。 要移除 lombok，请参阅 lombok 网站。 2023.2 最新变化",
                  "markdown": "报告可由 lombok `@Setter` 注解替换的标准 setter 方法。\n\n示例：\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * 处理日期。\n         */\n        private Date processDate;\n\n        /**\n         * 设置日期。\n         *\n         * @param The date\n         */\n        public void setProcessDate(Date param) {\n          processDate = param;\n        }\n      }\n\n在应用快速修复/清理后：\n\n\n      import lombok.Setter;\n      import java.util.Date;\n\n      @Setter\n      public class MyClass {\n        /**\n         * 处理日期。\n         * -- SETTER --\n         * 设置日期。\n         *\n         * @param The date\n         */\n        private Date processDate;\n      }\n\n它仅在配置 lombok 库时报告。 要移除 lombok，请参阅 lombok 网站。\n\n2023.2 最新变化"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LombokSetterMayBeUsed",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/详细或冗余的代码结构",
                      "index": 37,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "Lombok",
                "shortDescription": {
                  "text": "Lombok 注解"
                },
                "fullDescription": {
                  "text": "提供 Lombok 注解的一般检查。",
                  "markdown": "提供 Lombok 注解的一般检查。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "Lombok",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok",
                      "index": 79,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DeprecatedLombok",
                "shortDescription": {
                  "text": "已弃用的 Lombok 注解"
                },
                "fullDescription": {
                  "text": "报告已弃用的 Lombok 注解并建议快速修复以将它们替换为提升到主软件包的注解。",
                  "markdown": "报告已弃用的 Lombok 注解并建议快速修复以将它们替换为提升到主软件包的注解。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DeprecatedLombok",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Java/Lombok",
                      "index": 79,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "ru.adelf.idea.dotenv",
            "version": "2024.2.1",
            "rules": [
              {
                "id": "DotEnvDuplicateKeyInspection",
                "shortDescription": {
                  "text": "Duplicate keys"
                },
                "fullDescription": {
                  "text": "Reports duplicate keys in .env files.",
                  "markdown": "Reports duplicate keys in .env files."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvDuplicateKeyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DotEnvExtraBlankLineInspection",
                "shortDescription": {
                  "text": "Extra blank line"
                },
                "fullDescription": {
                  "text": "Reports extra blank lines in .env files.",
                  "markdown": "Reports extra blank lines in .env files."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvExtraBlankLineInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DotEnvLeadingCharacterInspection",
                "shortDescription": {
                  "text": "Invalid leading character"
                },
                "fullDescription": {
                  "text": "Reports keys with invalid leading character in .env files. Only A-Z and '_' are allowed as first char of a key.",
                  "markdown": "Reports keys with invalid leading character in .env files. Only A-Z and '_' are allowed as first char of a key."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvLeadingCharacterInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DotEnvTrailingWhitespaceInspection",
                "shortDescription": {
                  "text": "Value has trailing whitespace"
                },
                "fullDescription": {
                  "text": "Reports trailing whitespaces.",
                  "markdown": "Reports trailing whitespaces."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvTrailingWhitespaceInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DotEnvIncorrectDelimiterInspection",
                "shortDescription": {
                  "text": "Incorrect delimiter"
                },
                "fullDescription": {
                  "text": "Reports incorrect delimiter in .env files ('-' instead of'_').",
                  "markdown": "Reports incorrect delimiter in .env files ('-' instead of'_')."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvIncorrectDelimiterInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DotEnvSpaceInsideNonQuotedInspection",
                "shortDescription": {
                  "text": "Space inside non-quoted value"
                },
                "fullDescription": {
                  "text": "Reports spaces inside non-quoted values. Some .env libraries ignore everything after first space.",
                  "markdown": "Reports spaces inside non-quoted values. Some .env libraries ignore everything after first space."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvSpaceInsideNonQuotedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DotEnvSpaceAroundSeparatorInspection",
                "shortDescription": {
                  "text": "Extra spaces surrounding '='"
                },
                "fullDescription": {
                  "text": "Reports spaces surrounding separator.",
                  "markdown": "Reports spaces surrounding separator."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvSpaceAroundSeparatorInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DotEnvLowercaseKeyInspection",
                "shortDescription": {
                  "text": "Key uses lowercase chars"
                },
                "fullDescription": {
                  "text": "Reports keys, which use lowercase chars. Keys should be written in uppercase.",
                  "markdown": "Reports keys, which use lowercase chars. Keys should be written in uppercase."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DotEnvLowercaseKeyInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "DotEnv",
                      "index": 81,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "de.espend.idea.php.annotation",
            "version": "10.0.0",
            "rules": [
              {
                "id": "AnnotationDeprecatedInspection",
                "shortDescription": {
                  "text": "[Annotations] Annotation is deprecated"
                },
                "fullDescription": {
                  "text": "Doc block annotation class found, but it is deprecated You should migrate to a current alternative annotation",
                  "markdown": "Doc block annotation class found, but it is deprecated\n\nYou should migrate to a current alternative annotation"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnnotationDeprecatedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Annotation",
                      "index": 87,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnnotationDocBlockClassConstantNotFound",
                "shortDescription": {
                  "text": "[Annotations] Class not found"
                },
                "fullDescription": {
                  "text": "Class in class constant of DocBlock context not found",
                  "markdown": "Class in class constant of DocBlock context not found"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnnotationDocBlockClassConstantNotFound",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Annotation",
                      "index": 87,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnnotationDocBlockConstantDeprecated",
                "shortDescription": {
                  "text": "[Annotations] Deprecated usage"
                },
                "fullDescription": {
                  "text": "Constant in class found, but it is deprecated You should migrate to a current alternative annotation",
                  "markdown": "Constant in class found, but it is deprecated\n\nYou should migrate to a current alternative annotation"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnnotationDocBlockConstantDeprecated",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Annotation",
                      "index": 87,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "DoctrineTypeDeprecatedInspection",
                "shortDescription": {
                  "text": "[Annotations] Doctrine column type deprecated"
                },
                "fullDescription": {
                  "text": "Reports deprecations of the type Doctrine\\ORM\\Mapping\\Column::type based on the underlying type class [Annotation]Reports deprecations of Doctrine\\ORM\\Mapping\\Column::type",
                  "markdown": "Reports deprecations of the type Doctrine\\\\ORM\\\\Mapping\\\\Column::type based on the underlying type class\n\n\\[Annotation\\]Reports deprecations of Doctrine\\\\ORM\\\\Mapping\\\\Column::type"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "DoctrineTypeDeprecatedInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Annotation",
                      "index": 87,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "AnnotationMissingUseInspection",
                "shortDescription": {
                  "text": "[Annotations] Missing import"
                },
                "fullDescription": {
                  "text": "Doc block annotation class found, but its missing in use statement You should import the class as use statement",
                  "markdown": "Doc block annotation class found, but its missing in use statement   \nYou should import the class as *use* statement"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "AnnotationMissingUseInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Annotation",
                      "index": 87,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "RepositoryClassInspection",
                "shortDescription": {
                  "text": "[Annotations] Missing repository class"
                },
                "fullDescription": {
                  "text": "No repository class was found. Please create a PHP class see for more details",
                  "markdown": "No repository class was found. Please create a PHP class [see for more details](https://symfony.com/doc/current/doctrine/repository.html?phpstorm)"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "RepositoryClassInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Annotation",
                      "index": 87,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.qodana",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "JavaAnnotator",
                "shortDescription": {
                  "text": "Java 注解器"
                },
                "fullDescription": {
                  "text": "允许查看 Java 注解器报告的问题：编译问题、IDEA 引用未解析等。",
                  "markdown": "允许查看 Java 注解器报告的问题：编译问题、IDEA 引用未解析等。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "JavaAnnotator",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "JvmCoverageInspection",
                "shortDescription": {
                  "text": "检查 Kotlin 和 Java 源代码覆盖率"
                },
                "fullDescription": {
                  "text": "报告覆盖率低于某个阈值的方法和类。",
                  "markdown": "报告覆盖率低于某个阈值的方法和类。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "JvmCoverageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "代码覆盖率",
                      "index": 101,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QodanaSanity",
                "shortDescription": {
                  "text": "健全性"
                },
                "fullDescription": {
                  "text": "报告对此文件至关重要的问题，如语法错误、未解析的方法和变量等…",
                  "markdown": "报告对此文件至关重要的问题，如语法错误、未解析的方法和变量等..."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "QodanaSanity",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Qodana",
                      "index": 150,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "QodanaJavaSanity",
                "shortDescription": {
                  "text": "Java 健全性"
                },
                "fullDescription": {
                  "text": "报告 Java 代码中未解析的引用。",
                  "markdown": "报告 Java 代码中未解析的引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "QodanaJavaSanity",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "常规",
                      "index": 38,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "PhpCoverageInspection",
                "shortDescription": {
                  "text": "检查 PHP 源代码覆盖率"
                },
                "fullDescription": {
                  "text": "报告覆盖率低于某个阈值的方法、类和文件。",
                  "markdown": "报告覆盖率低于某个阈值的方法、类和文件。"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PhpCoverageInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "代码覆盖率",
                      "index": 101,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.intellij.plugins.markdown",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "MarkdownLinkDestinationWithSpaces",
                "shortDescription": {
                  "text": "链接不应包含空格"
                },
                "fullDescription": {
                  "text": "为确保不同工具之间的一致性，文件链接不应包含空格。 示例： '[Some file link](some file.md)' 快速修复会将空格替换为它们的 URL 编码等效项： '[Some file link](some%20file.md)'",
                  "markdown": "为确保不同工具之间的一致性，文件链接不应包含空格。\n\n**示例：**\n\n\n      [Some file link](some file.md)\n\n快速修复会将空格替换为它们的 URL 编码等效项：\n\n\n      [Some file link](some%20file.md)\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownLinkDestinationWithSpaces",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownOutdatedTableOfContents",
                "shortDescription": {
                  "text": "过期的目录部分"
                },
                "fullDescription": {
                  "text": "检查特定目录部分是否与文档的实际结构相对应。",
                  "markdown": "检查特定目录部分是否与文档的实际结构相对应。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownOutdatedTableOfContents",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedLinkLabel",
                "shortDescription": {
                  "text": "未解析的链接标签"
                },
                "fullDescription": {
                  "text": "报告 Markdown 文件中的未解析链接标签。",
                  "markdown": "报告 Markdown 文件中的未解析链接标签。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedLinkLabel",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownIncorrectTableFormatting",
                "shortDescription": {
                  "text": "表格式设置不正确"
                },
                "fullDescription": {
                  "text": "检查表的格式是否正确。",
                  "markdown": "检查表的格式是否正确。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "MarkdownIncorrectTableFormatting",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownNoTableBorders",
                "shortDescription": {
                  "text": "表没有边框"
                },
                "fullDescription": {
                  "text": "检查表是否有正确的边框。 出于兼容性原因，所有表行的开头和结尾都应该有边框（管道符号）。",
                  "markdown": "检查表是否有正确的边框。 出于兼容性原因，所有表行的开头和结尾都应该有边框（管道符号）。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownNoTableBorders",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownIncorrectlyNumberedListItem",
                "shortDescription": {
                  "text": "列表项编号错误"
                },
                "fullDescription": {
                  "text": "排序列表项应从 1 开始连续编号。 这背后的动机是，大多数 Markdown 处理器会忽略有序列表的编号。 处理器将为此类列表生成 '<ol>' 元素，该元素将从 1 开始对条目进行连续编号。",
                  "markdown": "排序列表项应从 1 开始连续编号。\n\n这背后的动机是，大多数 Markdown 处理器会忽略有序列表的编号。 处理器将为此类列表生成 `<ol>` 元素，该元素将从 1 开始对条目进行连续编号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownIncorrectlyNumberedListItem",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedFileReference",
                "shortDescription": {
                  "text": "未解析的文件引用"
                },
                "fullDescription": {
                  "text": "报告 Markdown 文件中的未解析文件引用。",
                  "markdown": "报告 Markdown 文件中的未解析文件引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedFileReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "MarkdownUnresolvedHeaderReference",
                "shortDescription": {
                  "text": "未解析的头引用"
                },
                "fullDescription": {
                  "text": "报告 Markdown 文件中的未解析头引用。",
                  "markdown": "报告 Markdown 文件中的未解析头引用。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "MarkdownUnresolvedHeaderReference",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Markdown",
                      "index": 91,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "tslint",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "TsLint",
                "shortDescription": {
                  "text": "TSLint"
                },
                "fullDescription": {
                  "text": "报告 TSLint linter 检测到的差异。 高亮显示基于 TSLint 配置文件中为每条规则指定的规则严重性。 清除“使用配置文件中的规则严重性”复选框，对所有 TSLint 规则使用该项检查中配置的严重性。",
                  "markdown": "报告 [TSLint](https://github.com/palantir/tslint) linter 检测到的差异。   \n\n高亮显示基于 [TSLint 配置文件](https://palantir.github.io/tslint/usage/configuration/)中为每条规则指定的规则严重性。   \n\n清除\"使用配置文件中的规则严重性\"复选框，对所有 TSLint 规则使用该项检查中配置的严重性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "TsLint",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/代码质量工具",
                      "index": 102,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.jetbrains.php.blade",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "BladeUnpairedParenthesesInStringLiteral",
                "shortDescription": {
                  "text": "由于字符串文字中的圆括号不成对而导致的解析错误"
                },
                "fullDescription": {
                  "text": "报告生成 Blade 解析器错误的字符串文字中未配对的圆括号。 有关详细信息，请参阅 laravel issue (github.com)。",
                  "markdown": "报告生成 Blade 解析器错误的字符串文字中未配对的圆括号。\n\n\n有关详细信息，请参阅 [laravel issue (github.com)](https://github.com/laravel/framework/issues/18317)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "BladeUnpairedParenthesesInStringLiteral",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Blade 文件",
                      "index": 105,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "BladeControlDirectives",
                "shortDescription": {
                  "text": "缺少控制指令"
                },
                "fullDescription": {
                  "text": "报告未通过相应 '@end...' 指令结束的 Blade 控制指令。 有关详细信息，请参阅 Blade 指令 (laravel.com)。",
                  "markdown": "报告未通过相应 `@end...` 指令结束的 Blade 控制指令。\n\n\n有关详细信息，请参阅 [Blade 指令 (laravel.com)](https://laravel.com/docs/blade#blade-directives)。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BladeControlDirectives",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Blade 文件",
                      "index": 105,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.security.package-checker",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "VulnerableCodeUsages",
                "shortDescription": {
                  "text": "易受攻击的 API 用法"
                },
                "fullDescription": {
                  "text": "报告导入依赖项的脆弱 API 的用法。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。 由 Checkmarx (c) 提供的脆弱性数据。",
                  "markdown": "报告导入依赖项的脆弱 API 的用法。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。\n\n由 [Checkmarx](https://checkmarx.com/) (c) 提供的脆弱性数据。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableCodeUsages",
                    "cweIds": [
                      1395
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "安全性",
                      "index": 118,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "NpmVulnerableApiCode",
                "shortDescription": {
                  "text": "易受攻击的 API 用法"
                },
                "fullDescription": {
                  "text": "报告导入依赖项的脆弱 API 的用法。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。 由 Checkmarx (c) 提供的脆弱性数据。",
                  "markdown": "报告导入依赖项的脆弱 API 的用法。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。\n\n由 [Checkmarx](https://checkmarx.com/) (c) 提供的脆弱性数据。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "NpmVulnerableApiCode",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript and TypeScript/安全性",
                      "index": 120,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableLibrariesLocal",
                "shortDescription": {
                  "text": "易受攻击的声明依赖项"
                },
                "fullDescription": {
                  "text": "报告在项目中声明的 Gradle、Maven、NPM 和 PyPI 依赖项中的漏洞。 Gradle 和 Maven 依赖项的完整列表显示在“项目”工具窗口的“外部库”下。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。 可用的快速修复可能会建议更新到安全版本或访问 Checkmarx 网站以详细了解特定漏洞。 由 Checkmarx (c) 提供的脆弱性数据。",
                  "markdown": "报告在项目中声明的 Gradle、Maven、NPM 和 PyPI 依赖项中的漏洞。\nGradle 和 Maven 依赖项的完整列表显示在\"项目\"工具窗口的\"外部库\"下。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。\n\n可用的快速修复可能会建议更新到安全版本或访问 Checkmarx 网站以详细了解特定漏洞。\n\n由 [Checkmarx](https://checkmarx.com/) (c) 提供的脆弱性数据。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableLibrariesLocal",
                    "cweIds": [
                      1395
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "安全性",
                      "index": 118,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VulnerableLibrariesGlobal",
                "shortDescription": {
                  "text": "易受攻击的导入依赖项"
                },
                "fullDescription": {
                  "text": "报告导入到项目中的 Gradle 和 Maven 依赖项中的漏洞。 Gradle 和 Maven 依赖项的完整列表显示在“项目”工具窗口的“外部库”下。 修正报告的问题有助于防止您的软件受到攻击者的破坏。 要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。 可用的快速修复可能会建议更新到安全版本或访问 Checkmarx 网站以详细了解特定漏洞。 由 Checkmarx (c) 提供的脆弱性数据。",
                  "markdown": "报告导入到项目中的 Gradle 和 Maven 依赖项中的漏洞。\nGradle 和 Maven 依赖项的完整列表显示在\"项目\"工具窗口的\"外部库\"下。\n\n修正报告的问题有助于防止您的软件受到攻击者的破坏。\n\n要解决问题，您可以更新到漏洞已修正的版本（如果可用）或切换到没有漏洞的依赖项。\n\n可用的快速修复可能会建议更新到安全版本或访问 Checkmarx 网站以详细了解特定漏洞。\n\n由 [Checkmarx](https://checkmarx.com/) (c) 提供的脆弱性数据。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VulnerableLibrariesGlobal",
                    "cweIds": [
                      1395
                    ],
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "安全性",
                      "index": 118,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.vue",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "VueMissingComponentImportInspection",
                "shortDescription": {
                  "text": "缺少组件导入"
                },
                "fullDescription": {
                  "text": "报告需要在 Vue 模板中导入的 Vue 组件。 它提供了一个快速修复来添加缺失的导入。",
                  "markdown": "报告需要在 Vue 模板中导入的 Vue 组件。 它提供了一个快速修复来添加缺失的导入。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VueMissingComponentImportInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Vue",
                      "index": 125,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VueDuplicateTag",
                "shortDescription": {
                  "text": "重复的模板/脚本标记"
                },
                "fullDescription": {
                  "text": "报告 Vue 文件中 'template' 或 'script' 标记的多次用法。 Vue 组件规范指示每个 '*.vue' 文件一次最多只能包含一个 'template' 或 'script' 块。",
                  "markdown": "报告 Vue 文件中 `template` 或 `script` 标记的多次用法。\n\n[Vue 组件规范](https://vue-loader.vuejs.org/spec.html)指示每个 `*.vue` 文件一次最多只能包含一个 `template` 或 `script` 块。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VueDuplicateTag",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Vue",
                      "index": 125,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VueDeprecatedSymbol",
                "shortDescription": {
                  "text": "已弃用的符号"
                },
                "fullDescription": {
                  "text": "报告已弃用的 Vue 符号。",
                  "markdown": "报告已弃用的 Vue 符号。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VueDeprecatedSymbol",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Vue",
                      "index": 125,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VueDataFunction",
                "shortDescription": {
                  "text": "数据函数"
                },
                "fullDescription": {
                  "text": "报告并非函数的 Vue 组件 data 属性。 建议用函数包装对象文字。 在定义组件时，'data' 必须声明为返回初始数据对象的函数，因为将使用相同的定义创建多个实例。 如果 'data' 仍然使用普通对象，那么该对象将通过引用来在创建的所有实例中共享！ 有了 'data' 函数，每次创建新实例时，都可以直接调用它以返回初始数据的新副本。",
                  "markdown": "报告并非函数的 Vue 组件 [data](https://vuejs.org/v2/api/#data) 属性。 建议用函数包装对象文字。\n\n在定义组件时，`data` 必须声明为返回初始数据对象的函数，因为将使用相同的定义创建多个实例。 如果 `data` 仍然使用普通对象，那么该对象将通过引用来在创建的所有实例中共享！ 有了 `data` 函数，每次创建新实例时，都可以直接调用它以返回初始数据的新副本。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VueDataFunction",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Vue",
                      "index": 125,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VueUnrecognizedDirective",
                "shortDescription": {
                  "text": "无法识别的指令"
                },
                "fullDescription": {
                  "text": "报告无法识别的 Vue 指令。",
                  "markdown": "报告无法识别的 Vue 指令。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "VueUnrecognizedDirective",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Vue",
                      "index": 125,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "VueUnrecognizedSlot",
                "shortDescription": {
                  "text": "无法识别的插槽"
                },
                "fullDescription": {
                  "text": "报告无法识别的 Vue 插槽。",
                  "markdown": "报告无法识别的 Vue 插槽。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "VueUnrecognizedSlot",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Vue",
                      "index": 125,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "dev.ekvedaras.laravelquery",
            "version": "4.0.4",
            "rules": [
              {
                "id": "UnknownTableOrViewInspection",
                "shortDescription": {
                  "text": "Unknown table or view"
                },
                "fullDescription": {
                  "text": "Title Database table or view not found.",
                  "markdown": "Database table or view not found."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnknownTableOrViewInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Database",
                      "index": 135,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "UnknownColumnInspection",
                "shortDescription": {
                  "text": "Unknown column"
                },
                "fullDescription": {
                  "text": "Title Database column not found.",
                  "markdown": "Database column not found."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "UnknownColumnInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "PHP/Database",
                      "index": 135,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.yaml",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "YAMLIncompatibleTypes",
                "shortDescription": {
                  "text": "可疑的类型不匹配"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中的标量值类型与相似位置中的值类型不匹配。 示例： 'myElements:\n  - value1\n  - value2\n  - false # <- 已报告，因为它是布尔值，而其他值是字符串'",
                  "markdown": "报告 YAML 文件中的标量值类型与相似位置中的值类型不匹配。\n\n**示例：**\n\n\n    myElements:\n      - value1\n      - value2\n      - false # <- 已报告，因为它是布尔值，而其他值是字符串\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLIncompatibleTypes",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 138,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLDuplicatedKeys",
                "shortDescription": {
                  "text": "重复的 YAML 键"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中的重复键。 示例： 'same_key: some value\n  same_key: another value'",
                  "markdown": "报告 YAML 文件中的重复键。\n\n**示例：**\n\n\n      same_key: some value\n      same_key: another value\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLDuplicatedKeys",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 138,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLSchemaValidation",
                "shortDescription": {
                  "text": "由 JSON 架构验证"
                },
                "fullDescription": {
                  "text": "如果指定了架构，则报告 YAML 文件和 JSON 架构之间的不一致。 方案示例： '{\n    \"properties\": {\n      \"SomeNumberProperty\": {\n        \"type\": \"number\"\n      }\n    }\n  }' 以下是带有相应警告的示例： 'SomeNumberProperty: hello world'",
                  "markdown": "如果指定了架构，则报告 YAML 文件和 JSON 架构之间的不一致。\n\n**方案示例：**\n\n\n      {\n        \"properties\": {\n          \"SomeNumberProperty\": {\n            \"type\": \"number\"\n          }\n        }\n      }\n\n**以下是带有相应警告的示例：**\n\n\n      SomeNumberProperty: hello world\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLSchemaValidation",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 138,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLUnresolvedAlias",
                "shortDescription": {
                  "text": "未解析的别名"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中的未解析别名。 示例： 'some_key: *unknown_alias'",
                  "markdown": "报告 YAML 文件中的未解析别名。\n\n**示例：**\n\n\n      some_key: *unknown_alias\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLUnresolvedAlias",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 138,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLSchemaDeprecation",
                "shortDescription": {
                  "text": "弃用的 YAML 键"
                },
                "fullDescription": {
                  "text": "报告 YAML 文件中已弃用的键。 仅当存在与相应 YAML 文件关联的 JSON 架构时，才会检查是否弃用。 请注意，JSON 架构规范中尚未定义弃用机制，并且此检查使用非标准的 'deprecationMessage' 扩展。 方案弃用示例： '{\n    \"properties\": {\n      \"SomeDeprecatedProperty\": {\n        \"deprecationMessage\": \"Baz\",\n        \"description\": \"Foo bar\"\n      }\n    }\n  }' 以下是带有相应警告的示例： 'SomeDeprecatedProperty: some value'",
                  "markdown": "报告 YAML 文件中已弃用的键。\n\n仅当存在与相应 YAML 文件关联的 JSON 架构时，才会检查是否弃用。\n\n请注意，JSON 架构规范中尚未定义弃用机制，并且此检查使用非标准的 `deprecationMessage` 扩展。\n\n**方案弃用示例：**\n\n\n      {\n        \"properties\": {\n          \"SomeDeprecatedProperty\": {\n            \"deprecationMessage\": \"Baz\",\n            \"description\": \"Foo bar\"\n          }\n        }\n      }\n\n**以下是带有相应警告的示例：**\n\n\n      SomeDeprecatedProperty: some value\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "YAMLSchemaDeprecation",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 138,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLRecursiveAlias",
                "shortDescription": {
                  "text": "递归别名"
                },
                "fullDescription": {
                  "text": "报告 YAML 别名中的递归。 别名不能递归并在相应定位标记引用的数据中使用。 示例： 'some_key: &some_anchor\n    sub_key1: value1\n    sub_key2: *some_anchor'",
                  "markdown": "报告 YAML 别名中的递归。\n\n别名不能递归并在相应定位标记引用的数据中使用。\n\n**示例：**\n\n\n      some_key: &some_anchor\n        sub_key1: value1\n        sub_key2: *some_anchor\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "YAMLRecursiveAlias",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 138,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "YAMLUnusedAnchor",
                "shortDescription": {
                  "text": "未使用的定位标记"
                },
                "fullDescription": {
                  "text": "报告未使用的定位标记。 示例： 'some_key: &some_anchor\n    key1: value1'",
                  "markdown": "报告未使用的定位标记。\n\n**示例：**\n\n\n      some_key: &some_anchor\n        key1: value1\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "YAMLUnusedAnchor",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "YAML",
                      "index": 138,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.laravel_idea.plugin",
            "version": "8.2.4.241",
            "rules": [
              {
                "id": "BladeUnknownComponentInspection",
                "shortDescription": {
                  "text": "Unknown Blade component"
                },
                "fullDescription": {
                  "text": "Reports unknown Blade components and suggests to create it.",
                  "markdown": "Reports unknown Blade components and suggests to create it."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "BladeUnknownComponentInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Laravel Idea",
                      "index": 143,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LaravelFunctionsInspection",
                "shortDescription": {
                  "text": "Laravel functions"
                },
                "fullDescription": {
                  "text": "Reports issues with Laravel function calls, like env() function outside of config files.",
                  "markdown": "Reports issues with Laravel function calls, like env() function outside of config files."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LaravelFunctionsInspection",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Laravel Idea",
                      "index": 143,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LaravelDeprecatedRoutesInspection",
                "shortDescription": {
                  "text": "Deprecated routes"
                },
                "fullDescription": {
                  "text": "Reports deprecated or abstract controllers and methods in route files.",
                  "markdown": "Reports deprecated or abstract controllers and methods in route files."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LaravelDeprecatedRoutesInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Laravel Idea",
                      "index": 143,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LaravelUnknownEloquentFactoryInspection",
                "shortDescription": {
                  "text": "Unknown factories"
                },
                "fullDescription": {
                  "text": "Reports HasFactory calls for models without factories. Allows creating factory.",
                  "markdown": "Reports HasFactory calls for models without factories. Allows creating factory."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LaravelUnknownEloquentFactoryInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Laravel Idea",
                      "index": 143,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LaravelUnknownViewInspection",
                "shortDescription": {
                  "text": "Unknown views"
                },
                "fullDescription": {
                  "text": "Reports unknown view calls.",
                  "markdown": "Reports unknown view calls."
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LaravelUnknownViewInspection",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Laravel Idea",
                      "index": 143,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "intellij.webpack",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "WebpackConfigHighlighting",
                "shortDescription": {
                  "text": "Webpack 配置符合 JSON 架构"
                },
                "fullDescription": {
                  "text": "根据 webpack 选项架构验证 webpack 配置文件中的选项（名称应以 `webpack` 开头，例如 `webpack.config.js`）。 禁用此检查以关闭配置对象内部的验证和代码补全。",
                  "markdown": "根据 [webpack 选项架构](https://github.com/webpack/webpack/blob/master/schemas/WebpackOptions.json)验证 webpack 配置文件中的选项（名称应以 \\`webpack\\` 开头，例如 \\`webpack.config.js\\`）。   \n\n禁用此检查以关闭配置对象内部的验证和代码补全。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "WebpackConfigHighlighting",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "JavaScript 和 TypeScript/常规",
                      "index": 32,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.jetbrains.sh",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "ShellCheck",
                "shortDescription": {
                  "text": "ShellCheck"
                },
                "fullDescription": {
                  "text": "报告由集成的 ShellCheck 静态分析工具检测到的 shell 脚本错误。",
                  "markdown": "报告由集成的 [ShellCheck](https://github.com/koalaman/shellcheck) 静态分析工具检测到的 shell 脚本错误。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "ShellCheck",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Shell 脚本",
                      "index": 154,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "org.jetbrains.plugins.less",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "LessUnresolvedVariable",
                "shortDescription": {
                  "text": "未解析的变量"
                },
                "fullDescription": {
                  "text": "报告对未解析的 Less 变量的引用。 示例： '* {\n  margin: @unknown-var;\n}'",
                  "markdown": "报告对未解析的 [Less 变量](http://lesscss.org/features/#variables-feature)的引用。\n\n**示例：**\n\n\n    * {\n      margin: @unknown-var;\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LessUnresolvedVariable",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Less",
                      "index": 160,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LessResolvedByNameOnly",
                "shortDescription": {
                  "text": "缺少 import"
                },
                "fullDescription": {
                  "text": "报告对在另一个文件中已声明但未在当前文件中显式导入的变量或 mixin 的引用。 示例： '* {\n  margin: @var-in-other-file;\n}'",
                  "markdown": "报告对在另一个文件中已声明但未在当前文件中显式[导入](http://lesscss.org/features/#import-atrules-feature)的变量或 mixin 的引用。\n\n**示例：**\n\n\n    * {\n      margin: @var-in-other-file;\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "note",
                  "parameters": {
                    "suppressToolId": "LessResolvedByNameOnly",
                    "ideaSeverity": "WEAK WARNING",
                    "qodanaSeverity": "Moderate"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Less",
                      "index": 160,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              },
              {
                "id": "LessUnresolvedMixin",
                "shortDescription": {
                  "text": "未解析的 mixin"
                },
                "fullDescription": {
                  "text": "报告对未解析的 Less mixin 的引用。 示例： '* {\n  .unknown-mixin();\n}'",
                  "markdown": "报告对未解析的 [Less mixin](http://lesscss.org/features/#mixins-feature) 的引用。\n\n**示例：**\n\n\n    * {\n      .unknown-mixin();\n    }\n"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "LessUnresolvedMixin",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "Less",
                      "index": 160,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "idea.plugin.protoeditor",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "PbDuplicatedImports",
                "shortDescription": {
                  "text": "重复的 import 语句"
                },
                "fullDescription": {
                  "text": "报告有效对等的 import 语句。",
                  "markdown": "报告有效对等的 import 语句。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "warning",
                  "parameters": {
                    "suppressToolId": "PbDuplicatedImports",
                    "ideaSeverity": "WARNING",
                    "qodanaSeverity": "High"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "协议缓冲区",
                      "index": 163,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          },
          {
            "name": "com.intellij.stylelint",
            "version": "241.17890.1",
            "rules": [
              {
                "id": "Stylelint",
                "shortDescription": {
                  "text": "Stylelint"
                },
                "fullDescription": {
                  "text": "报告 Stylelint linter 检测到的差异。 高亮显示基于 Stylelint 配置文件中为每条规则指定的规则严重性。",
                  "markdown": "报告 [Stylelint](http://stylelint.io) linter 检测到的差异。   \n\n高亮显示基于 [Stylelint 配置文件](https://stylelint.io/user-guide/configure)中为每条规则指定的规则严重性。"
                },
                "defaultConfiguration": {
                  "enabled": false,
                  "level": "error",
                  "parameters": {
                    "suppressToolId": "Stylelint",
                    "ideaSeverity": "ERROR",
                    "qodanaSeverity": "Critical"
                  }
                },
                "relationships": [
                  {
                    "target": {
                      "id": "CSS/代码质量工具",
                      "index": 167,
                      "toolComponent": {
                        "name": "IU"
                      }
                    },
                    "kinds": [
                      "superset"
                    ]
                  }
                ]
              }
            ],
            "language": "en-US",
            "contents": [
              "localizedData",
              "nonLocalizedData"
            ],
            "isComprehensive": false
          }
        ]
      },
      "invocations": [
        {
          "startTimeUtc": "2024-09-02T14:04:04.650784Z",
          "exitCode": 0,
          "executionSuccessful": true
        }
      ],
      "language": "en-US",
      "versionControlProvenance": [
        {
          "repositoryUri": "ssh://github-cclilshy/cloudtay/p-ripple-core",
          "revisionId": "86f074b832906c6e1071d5c45a2f577f837d592c",
          "branch": "main",
          "properties": {
            "repoUrl": "",
            "lastAuthorName": "cclilshy",
            "vcsType": "Git",
            "lastAuthorEmail": "jingnigg@gmail.com"
          }
        }
      ],
      "results": [],
      "automationDetails": {
        "id": "p-ripple-core/qodana/2024-09-02",
        "guid": "23e7d7e5-baaf-47ec-8592-f706198ec260",
        "properties": {
          "jobUrl": ""
        }
      },
      "newlineSequences": [
        "\r\n",
        "\n"
      ],
      "properties": {
        "configProfile": "starter",
        "deviceId": "120624294f34615-4e1e-45bc-8e5f-4e9b815a76ac",
        "qodanaNewResultSummary": {
          "moderate": 33,
          "total": 33
        }
      }
    }
  ],
  "properties": {
    "runTimestamp": "1725285847541"
  }
}